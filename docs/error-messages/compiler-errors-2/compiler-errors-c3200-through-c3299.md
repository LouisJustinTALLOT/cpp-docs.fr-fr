---
description: 'En savoir plus sur les éléments suivants : Erreurs du compilateur C3200 à C3299'
title: Erreurs du compilateur C3200 à C3299
ms.date: 04/21/2019
f1_keywords:
- C3220
- C3221
- C3245
- C3249
- C3250
- C3256
- C3257
- C3258
- C3259
- C3260
- C3261
- C3263
- C3267
- C3281
- C3294
helpviewer_keywords:
- C3220
- C3221
- C3245
- C3249
- C3250
- C3256
- C3257
- C3258
- C3259
- C3260
- C3261
- C3263
- C3267
- C3281
- C3294
ms.assetid: 6b3104f6-63bc-4823-b6f3-b8a16be4b87f
ms.openlocfilehash: e54d980634372099d76d9f30020f68f3f4affb59
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/11/2020
ms.locfileid: "97238659"
---
# <a name="compiler-errors-c3200-through-c3299"></a>Erreurs du compilateur C3200 à C3299

Les Articles de cette section de la documentation expliquent un sous-ensemble des messages d’erreur générés par le compilateur.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Messages d’erreur

|Error|Message|
|-----------|-------------|
|[Erreur du compilateur C3200](compiler-error-c3200.md)|'*type*' : argument template non valide pour le paramètre de modèle'*paramètre*', modèle de classe ATTENDU|
|[Erreur du compilateur C3201](compiler-error-c3201.md)|la liste de paramètres de modèle pour le modèle de classe'*template*'ne correspond pas à la liste de paramètres de modèle pour le paramètre de modèle'*paramètre*'|
|[Erreur du compilateur C3202](compiler-error-c3202.md)|'*identificateur*' : argument par défaut non valide, modèle de classe ATTENDU|
|[Erreur du compilateur C3203](compiler-error-c3203.md)|'*identificateur*' : le modèle de classe/générique non spécialisé ne peut pas être utilisé comme argument modèle/générique pour le paramètre modèle/générique'*paramètre*', type réel ATTENDU|
|[Erreur du compilateur C3204](compiler-error-c3204.md)|'*Function*'ne peut pas être appelé à partir d’un bloc catch|
|[Erreur du compilateur C3205](compiler-error-c3205.md)|la liste d’arguments pour le paramètre de modèle de modèle'*identifier*'est manquante|
|[Erreur du compilateur C3206](compiler-error-c3206.md)|'*fonction*' : argument générique/template non valide pour'*template*', liste d’arguments template/Generic manquante dans le modèle de classe/générique'*type*'|
|[Erreur du compilateur C3207](compiler-error-c3207.md)|'*fonction*' : argument template non valide pour'*paramètre*', modèle de classe ATTENDU|
|[Erreur du compilateur C3208](compiler-error-c3208.md)|'*fonction*' : la liste de paramètres de modèle pour le modèle de classe'*template*'ne correspond pas à la liste de paramètres de modèle pour le paramètre de modèle de modèle'*paramètre*'|
|[Erreur du compilateur C3209](compiler-error-c3209.md)|'*type*' : la classe générique doit être une classe managée/WinRT|
|[Erreur du compilateur C3210](compiler-error-c3210.md)|'*identificateur*' : la déclaration d’accès ne peut être appliquée qu’à un membre de classe de base|
|[Erreur du compilateur C3211](compiler-error-c3211.md)|'*fonction*' : une spécialisation explicite utilise une syntaxe de spécialisation partielle, utilisez le modèle <> à la place|
|[Erreur du compilateur C3212](compiler-error-c3212.md)|'*fonction*' : une spécialisation explicite d’un membre de modèle doit être membre d’une spécialisation explicite|
|[Erreur du compilateur C3213](compiler-error-c3213.md)|la classe de base'*classe*'est moins accessible que'*Derived_Class*'|
|[Erreur du compilateur C3214](compiler-error-c3214.md)|'*argument*' : argument de type non valide pour le paramètre générique'*paramètre*'du générique'*type*', ne satisfait pas la contrainte'*contrainte*'|
|[Erreur du compilateur C3215](compiler-error-c3215.md)|'*contrainte1*' : paramètre de type générique déjà restreint par'*contrainte2*'|
|[Erreur du compilateur C3216](compiler-error-c3216.md)|la contrainte doit être un paramètre générique et non'*type*'|
|[Erreur du compilateur C3217](compiler-error-c3217.md)|'*paramètre*' : le paramètre générique ne peut pas être restreint dans cette déclaration|
|[Erreur du compilateur C3218](compiler-error-c3218.md)|'*type*' : type non autorisé en tant que contrainte|
|[Erreur du compilateur C3219](compiler-error-c3219.md)|'*paramètre*' : le paramètre générique ne peut pas être imposé par plusieurs interfaces non- : '*type*'|
|Erreur du compilateur C3220|'*interface*' : l’interface ne peut pas avoir de ProgID|
|Erreur du compilateur C3221|'*membre*' : plusieurs attributs’default’et’case’ne sont pas autorisés sur un membre|
|[Erreur du compilateur C3222](compiler-error-c3222.md)|'*fonction*' : impossible de déclarer des arguments par défaut pour les fonctions membres d’un type managé/WinRT ou des fonctions génériques|
|[Erreur du compilateur C3223](compiler-error-c3223.md)|'*Property*' : vous ne pouvez pas appliquer’typeid’à une propriété|
|[Erreur du compilateur C3224](compiler-error-c3224.md)|'*type*' : aucune classe générique surchargée n’accepte'*nombre*'arguments de type générique|
|[Erreur du compilateur C3225](compiler-error-c3225.md)|l’argument de type générique pour'*argument*'ne peut pas être'*type*', il doit s’agir d’un type valeur ou d’un handle d’un type référence|
|[Erreur du compilateur C3226](compiler-error-c3226.md)|Une déclaration de modèle n'est pas autorisée dans une déclaration générique|
|[Erreur du compilateur C3227](compiler-error-c3227.md)|'*type*' : impossible d’utiliser'*Operator*'pour allouer un type générique|
|[Erreur du compilateur C3228](compiler-error-c3228.md)|'*fonction*' : l’argument de type générique pour'*argument*'ne peut pas être'*type*', il doit s’agir d’un type valeur ou d’un type de handle|
|[Erreur du compilateur C3229](compiler-error-c3229.md)|'*type*' : les indirections sur un paramètre de type générique ne sont pas autorisées|
|[Erreur du compilateur C3230](compiler-error-c3230.md)|'*fonction*' : l’argument de type de modèle pour'*argument*'ne peut pas contenir un paramètre de type générique : '*type*'|
|[Erreur du compilateur C3231](compiler-error-c3231.md)|'*type*' : l’argument de type de modèle ne peut pas utiliser de paramètre de type générique|
|[Erreur du compilateur C3232](compiler-error-c3232.md)|'*paramètre*' : un paramètre de type générique ne peut pas être utilisé dans un nom qualifié|
|[Erreur du compilateur C3233](compiler-error-c3233.md)|'*type*' : paramètre de type générique déjà restreint|
|[Erreur du compilateur C3234](compiler-error-c3234.md)|une classe générique ne peut pas dériver d'un paramètre de type générique|
|[Erreur du compilateur C3235](compiler-error-c3235.md)|'*spécialisation*' : la spécialisation explicite ou partielle d’une classe générique n’est pas autorisée|
|[Erreur du compilateur C3236](compiler-error-c3236.md)|l'instanciation explicite d'un générique n'est pas autorisée|
|[Erreur du compilateur C3237](compiler-error-c3237.md)|'*classe*' : une classe générique ne peut pas être un attribut personnalisé|
|[Erreur du compilateur C3238](compiler-error-c3238.md)|'*type*' : un type portant ce nom a déjà été transféré à l’assembly'*assembly*'|
|[Erreur du compilateur C3239](compiler-error-c3239.md)|'*type*' : un pointeur vers un pointeur intérieur/épinglé est interdit par le Common Language Runtime|
|[Erreur du compilateur C3240](compiler-error-c3240.md)|'*identificateur*' : doit être une fonction membre abstraite non surchargée de'*type*'|
|[Erreur du compilateur C3241](compiler-error-c3241.md)|'*membre*' : cette méthode n’a pas été introduite par'*interface*'|
|[Erreur du compilateur C3242](compiler-error-c3242.md)|'*fonction*' : vous ne pouvez substituer explicitement que des fonctions virtuelles|
|[Erreur du compilateur C3243](compiler-error-c3243.md)|aucune des fonctions de surcharge n’a été introduite par'*interface*'|
|[Erreur du compilateur C3244](compiler-error-c3244.md)|'*membre*' : cette méthode a été introduite par'*Interface1*'et non par'*interface2*'|
|Erreur du compilateur C3245|'*fonction*' : l’utilisation d’un modèle de variable nécessite une liste d’arguments template|
|[Erreur du compilateur C3246](compiler-error-c3246.md)|'*Class*' : ne peut pas hériter de'*BASE_CLASS*', car il a été déclaré comme'*héritage*'|
|[Erreur du compilateur C3247](compiler-error-c3247.md)|'*coclasse*' : une coclasse ne peut pas hériter d’une autre coclasse'*BASE_CLASS*'|
|[Erreur du compilateur C3248](compiler-error-c3248.md)|Obsolète. '*fonction*' : la fonction déclarée en tant que’sealed’ne peut pas être substituée par'*Function*'|
|Erreur du compilateur C3249|instruction ou sous-expression non conforme pour la fonction’constexpr'|
|Erreur du compilateur C3250|'*DECLARATION*' : la déclaration n’est pas autorisée dans le corps de la fonction’constexpr'|
|[Erreur du compilateur C3251](compiler-error-c3251.md)|impossible d'appeler une méthode de classe de base sur une instance de type valeur|
|[Erreur du compilateur C3252](compiler-error-c3252.md)|'*fonction*' : impossible de réduire l’accessibilité d’une méthode virtuelle dans un type managé/WinRT|
|[Erreur du compilateur C3253](compiler-error-c3253.md)|'*fonction*' : erreur de substitution explicite|
|[Erreur du compilateur C3254](compiler-error-c3254.md)|'*fonction*' : la classe contient une substitution explicite'*fonction*', mais ne dérive pas d’une interface qui contient la déclaration de fonction|
|[Erreur du compilateur C3255](compiler-error-c3255.md)|'*type*' : impossible d’allouer dynamiquement cet objet de type valeur sur un tas natif|
|Erreur du compilateur C3256|'*fonction*' : l’utilisation de la variable ne produit pas d’expression constante|
|Erreur du compilateur C3257|Obsolète.|
|Erreur du compilateur C3258|Obsolète.|
|Erreur du compilateur C3259|les fonctions’constexpr’ne peuvent avoir qu’une seule instruction return|
|Erreur du compilateur C3260|'*Token*' : le ou les jetons inattendus sont ignorés avant le corps lambda|
|Erreur du compilateur C3261|une fonction qui retourne un tableau managé/WinRT doit comporter des crochets à la fin de la déclaration : '*identifier*(...) []'|
|[Erreur du compilateur C3262](compiler-error-c3262.md)|indexation de tableau non valide : dimension (s) de *nombre* spécifiée pour le *nombre*-dimensionnel'*type*'|
|Erreur du compilateur C3263|Obsolète.|
|[Erreur du compilateur C3264](compiler-error-c3264.md)|'*identificateur*' : un constructeur de classe ne peut pas avoir de type de retour|
|[Erreur du compilateur C3265](compiler-error-c3265.md)|Impossible de déclarer un'*managed_construct*'managé dans un'*unmanaged_construct*'non managé|
|[Erreur du compilateur C3266](compiler-error-c3266.md)|'*fonction*' : un constructeur de classe doit avoir une liste de paramètres’void'|
|Erreur du compilateur C3267|Obsolète.|
|[Erreur du compilateur C3268](compiler-error-c3268.md)|'*fonction*' : une fonction générique ou une fonction membre d’une classe générique ne peut pas avoir de liste de paramètres de variables|
|[Erreur du compilateur C3269](compiler-error-c3269.md)|'*fonction*' : une fonction membre d’un type managé/WinRT ne peut pas être déclarée avec'... '|
|[Erreur du compilateur C3270](compiler-error-c3270.md)|'*Field*' : l’attribut FieldOffset ne peut être utilisé que dans le contexte de StructLayout (LayoutKind :: Explicit)|
|[Erreur du compilateur C3271](compiler-error-c3271.md)|'*Field*' : valeur'*Number*'non valide pour l’attribut FieldOffset|
|[Erreur du compilateur C3272](compiler-error-c3272.md)|'*symbol*' : le symbole requiert FieldOffset, car il est membre du struct/class *Type_name* défini avec StructLayout (LayoutKind :: Explicit)|
|[Erreur du compilateur C3273](compiler-error-c3273.md)|'*Keyword*' : non autorisé sur un bloc try C++|
|[Erreur du compilateur C3274](compiler-error-c3274.md)|finally/&#95;&#95;finally sans try correspondant|
|[Erreur du compilateur C3275](compiler-error-c3275.md)|'*identificateur*' : impossible d’utiliser ce symbole sans qualificateur|
|[Erreur du compilateur C3276](compiler-error-c3276.md)|'*Keyword*' : le saut hors du bloc finally/&#95;&#95;a un comportement indéfini lors de la gestion des arrêts|
|[Erreur du compilateur C3277](compiler-error-c3277.md)|Impossible de définir une énumération'*Enumeration*'non managée dans'*type*'managé|
|[Erreur du compilateur C3278](compiler-error-c3278.md)|l’appel direct de l’interface ou de la méthode pure'*Function*'échoue au moment de l’exécution|
|[Erreur du compilateur C3279](compiler-error-c3279.md)|les spécialisations partielles et explicites, ainsi que les instanciations explicites des modèles de classe déclarés dans l'espace de noms cli sont interdites|
|[Erreur du compilateur C3280](compiler-error-c3280.md)|'*fonction*' : une fonction membre d’un type managé ne peut pas être compilée comme fonction non managée|
|Erreur du compilateur C3281|'*fonction*' : l’opérateur global ne peut pas avoir un type managé/WinRT'*type*'dans la signature|
|[Erreur du compilateur C3282](compiler-error-c3282.md)|les listes de paramètres génériques ne peuvent apparaître que sur les classes, structures ou fonctions managées/WinRT|
|[Erreur du compilateur C3283](compiler-error-c3283.md)|'*interface*' : une interface ne peut pas avoir de constructeur d’instance|
|[Erreur du compilateur C3284](compiler-error-c3284.md)|les contraintes pour le paramètre générique'*paramètre*'de la fonction'*déclarateur*'doivent correspondre aux contraintes du paramètre générique'*paramètre*'de la fonction'*déclarateur*'|
|[Erreur du compilateur C3285](compiler-error-c3285.md)|une instruction for each ne peut pas fonctionner sur des variables de type'*type*'|
|[Erreur du compilateur C3286](compiler-error-c3286.md)|'*specifier*' : une variable d’itération ne peut pas avoir de spécificateurs de classe de stockage|
|[Erreur du compilateur C3287](compiler-error-c3287.md)|le type'*type*' (type de retour de GetEnumerator) doit avoir une fonction membre publique appropriée MoveNext et une propriété Current publique|
|[Erreur du compilateur C3288](compiler-error-c3288.md)|'*type*' : déréférencement non conforme d’un type de handle|
|[Erreur du compilateur C3289](compiler-error-c3289.md)|'*identificateur*' : une propriété triviale ne peut pas être indexée|
|[Erreur du compilateur C3290](compiler-error-c3290.md)|'*type*' : une propriété triviale ne peut pas avoir de type référence|
|[Erreur du compilateur C3291](compiler-error-c3291.md)|'default' : ne peut pas être le nom d’une propriété triviale|
|[Erreur du compilateur C3292](compiler-error-c3292.md)|impossible de rouvrir l'espace de noms cli|
|[Erreur du compilateur C3293](compiler-error-c3293.md)|'*identifier*' : utilisez’default’pour accéder à la propriété par défaut (indexeur) de la classe'*Class*'|
|Erreur du compilateur C3294|Obsolète.|
|[Erreur du compilateur C3295](compiler-error-c3295.md)|' #pragma *specifier*'ne peut être utilisé qu’au niveau global ou de la portée espace de noms|
|[Erreur du compilateur C3296](compiler-error-c3296.md)|'*identificateur*' : une propriété portant ce nom existe déjà|
|[Erreur du compilateur C3297](compiler-error-c3297.md)|' *contrainte2*' : impossible d’utiliser' *contrainte1*'en tant que contrainte, car' *contrainte1*'a la contrainte de valeur|
|[Erreur du compilateur C3298](compiler-error-c3298.md)|' *contrainte1*' : impossible d’utiliser' *contrainte2*'en tant que contrainte, car' *contrainte2*'a la contrainte REF et' *contrainte1*'a la contrainte de valeur|
|[Erreur du compilateur C3299](compiler-error-c3299.md)|' *fonction*' : impossible de spécifier des contraintes, elles sont héritées de la méthode de base|

## <a name="see-also"></a>Voir aussi

[Erreurs et avertissements du compilateur C/C++ et des outils de génération](../compiler-errors-1/c-cpp-build-errors.md) \
[Erreurs du compilateur C2000 - C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
