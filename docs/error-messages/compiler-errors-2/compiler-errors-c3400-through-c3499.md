---
title: Erreurs du compilateur C3400 à C3499
ms.date: 04/21/2019
f1_keywords:
- C3401
- C3402
- C3403
- C3404
- C3405
- C3406
- C3407
- C3410
- C3411
- C3416
- C3419
- C3422
- C3424
- C3425
- C3426
- C3427
- C3428
- C3429
- C3430
- C3431
- C3432
- C3433
- C3434
- C3435
- C3436
- C3437
- C3438
- C3439
- C3440
- C3441
- C3442
- C3443
- C3444
- C3445
- C3446
- C3471
- C3472
- C3473
- C3474
- C3475
- C3476
- C3477
- C3478
- C3479
- C3486
- C3494
- C3497
helpviewer_keywords:
- C3401
- C3402
- C3403
- C3404
- C3405
- C3406
- C3407
- C3410
- C3411
- C3416
- C3419
- C3422
- C3424
- C3425
- C3426
- C3427
- C3428
- C3429
- C3430
- C3431
- C3432
- C3433
- C3434
- C3435
- C3436
- C3437
- C3438
- C3439
- C3440
- C3441
- C3442
- C3443
- C3444
- C3445
- C3446
- C3471
- C3472
- C3473
- C3474
- C3475
- C3476
- C3477
- C3478
- C3479
- C3486
- C3494
- C3497
ms.assetid: a5651dfb-c402-4e01-b3ae-28f371e51d6a
ms.openlocfilehash: 587b28cedb0ab8b11c244be4278c7dc17d1f4247
ms.sourcegitcommit: 283cb64fd7958a6b7fbf0cd8534de99ac8d408eb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/28/2019
ms.locfileid: "64857381"
---
# <a name="compiler-errors-c3400-through-c3499"></a>Erreurs du compilateur C3400 à C3499

Les articles de cette section de la documentation expliquent un sous-ensemble des messages d’erreur qui sont générés par le compilateur.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Messages d’erreur

|Error|Message|
|-----------|-------------|
|[Erreur du compilateur C3400](compiler-error-c3400.md)|impliquant de dépendance de contrainte circulaire '*contrainte1*'et'*contrainte2*'|
|Erreur du compilateur C3401|«*spécificateur*' : spécificateur d’accès d’assembly non valide - seul 'private' n’est autorisée sur les modèles de classe|
|Erreur du compilateur C3402|«*fonction*' : ne peut pas résoudre la surcharge sauf dans la portée actuelle|
|Erreur du compilateur C3403|thread_local ne peut pas être utilisé avec/clr : pure ou/CLR : safe|
|Erreur du compilateur C3404|«*construire*' : erreur de syntaxe inattendue|
|Erreur du compilateur C3405|«*fonction*' : Impossible de résoudre la surcharge sans un descripteur complet|
|Erreur du compilateur C3406|«*mot clé*' : ne peut pas être utilisé dans un spécificateur de type élaboré|
|Erreur du compilateur C3407|«*type*' ne peut pas être utilisé dans ce contexte|
|[Erreur du compilateur C3408](compiler-error-c3408.md)|«*attribut*' : attribut n’est pas autorisé sur les définitions de modèle|
|[Erreur du compilateur C3409](compiler-error-c3409.md)|bloc d’attributs vide n’est pas autorisée.|
|Erreur du compilateur C3410|«*identificateur*' : le type de l’instanciation explicite '*type*'ne correspond pas au type du modèle de variable'*type*»|
|Erreur du compilateur C3411|«*type*' n’est pas valide en tant que la taille d’un tableau comme il n’est pas un type entier|
|[Erreur du compilateur C3412](compiler-error-c3412.md)|«*spécialisation*' : Impossible de spécialiser le modèle dans la portée actuelle|
|[Erreur du compilateur C3413](compiler-error-c3413.md)|«*modèle*' : instanciation explicite non valide|
|[Erreur du compilateur C3414](compiler-error-c3414.md)|«*fonction*' : fonction membre importée ne peut pas être définie.|
|[Erreur du compilateur C3415](compiler-error-c3415.md)|plusieurs '*section*' sections trouvées avec différents attributs ('0 x*valeur*')|
|Erreur du compilateur C3416|Obsolète.|
|[Erreur du compilateur C3417](compiler-error-c3417.md)|«*déclarateur*' : les types valeur ne peut pas contenir de fonctions membres spéciales définies par l’utilisateur|
|[Erreur du compilateur C3418](compiler-error-c3418.md)|spécificateur d’accès '*spécificateur*' n’est pas pris en charge|
|Erreur du compilateur C3419|Obsolète.|
|[Erreur du compilateur C3420](compiler-error-c3420.md)|«*fonction*' : un finaliseur ne peut pas être virtuel|
|[Erreur du compilateur C3421](compiler-error-c3421.md)|«*fonction*' : vous ne pouvez pas appeler le finaliseur pour cette classe car il est soit inaccessible ou il n’existe pas|
|Erreur du compilateur C3422|«*déclaration*' : incompatibilité de types'*type*'et'*type*»|
|Erreur du compilateur C3423|Obsolète.|
|Erreur du compilateur C3424|«*type*' : un cast de style fonction à un type de tableau n’est pas autorisé.|
|Erreur du compilateur C3425|ne peut pas lever le pointeur à l’objet de type incomplet '*type*'|
|Erreur du compilateur C3426|Impossible de lever l’objet de type incomplet '*type*'|
|Erreur du compilateur C3427|«*contexte*' : '*mot clé*' ne peut pas être utilisé avec layout_version (*nombre*)|
|Erreur du compilateur C3428|«*contexte*' : '*mot clé*' peut uniquement être appliqué aux définitions ou déclarations de classe|
|Erreur du compilateur C3429|«*contexte*' : '*mot clé*' ne peut pas être appliqué à une union|
|Erreur du compilateur C3430|une énumération délimitée doit avoir un nom|
|Erreur du compilateur C3431|«*identificateur*' : *type1* ne peut pas être redéclaré comme *type2*|
|Erreur du compilateur C3432|«*identificateur*' : une déclaration anticipée d’une énumération non délimitée doit avoir un type sous-jacent|
|Erreur du compilateur C3433|«*identificateur*' : toutes les déclarations d’énumération doit avoir le même type sous-jacent, était '*type1*« maintenant »*type2*»|
|Erreur du compilateur C3434|«*contexte*' : valeur de l’énumérateur '*nombre*« ne peut pas être représentée en tant que »*type*«, la valeur est »*nombre*»|
|Erreur du compilateur C3435|jeu de caractères '*nom*' n’est pas pris en charge|
|Erreur du compilateur C3436|#pragma setlocale n’est pas pris en charge quand/source-CharSet, / Execution-CharSet ou/UTF-8 a été spécifié.|
|Erreur du compilateur C3437|#pragma execution_character_set n’est pas pris en charge quand/source-CharSet, / Execution-CharSet ou/UTF-8 a été spécifié.|
|Erreur du compilateur C3438|«*contexte*' : '*valeur*' ne peut pas être appliqué à une classe gérée/WinRT|
|Erreur du compilateur C3439|layout_version (*nombre*) : numéro de version non valide|
|Erreur du compilateur C3440|«*déclaration*' : layout_version (*nombre*) incompatible avec une déclaration antérieure|
|Erreur du compilateur C3441|«*déclaration*' : '*mot clé*' ne peut pas être appliqué une fois que la classe a été définie.|
|Erreur du compilateur C3442|Initialisation de plusieurs membres d’union : '*member1*'et'*member2*'|
|Erreur du compilateur C3443|L’initialiseur de membre par défaut pour '*classe*' est récursif|
|Erreur du compilateur C3444|Vide la classe d’agrégation*classe*'doit être initialisée avec'{}'|
|[Erreur du compilateur C3445](compiler-error-c3445.md)|Copy-list-initialization de «*type*' ne peut pas utiliser un constructeur explicite|
|[Erreur du compilateur C3446](compiler-error-c3446.md)|«*classe*' : un initialiseur de membre par défaut n’est pas autorisé pour un membre d’une classe value|
|Erreur du compilateur C3447|Obsolète.|
|Erreur du compilateur C3448|Obsolète.|
|Erreur du compilateur C3449|Obsolète.|
|[Erreur du compilateur C3450](compiler-error-c3450.md)|«*type*' : pas un attribut ; Impossible de spécifier [System::AttributeUsageAttribute] / [Windows::Foundation::Metadata::AttributeUsageAttribute]|
|[Erreur du compilateur C3451](compiler-error-c3451.md)|«*attribut*' : Impossible d’appliquer l’attribut non managé à '*type*»|
|[Erreur du compilateur C3452](compiler-error-c3452.md)|le membre argument de la liste n'est pas une constante|
|[Erreur du compilateur C3453](compiler-error-c3453.md)|'*attribut*' : attribut non appliqué, car un qualificateur '*qualificateur*' ne correspond pas à|
|[Erreur du compilateur C3454](compiler-error-c3454.md)|[attribute] non autorisé dans une déclaration de classe|
|[Erreur du compilateur C3455](compiler-error-c3455.md)|«*attribut*' : aucun des constructeurs d’attribut correspond aux arguments|
|[Erreur du compilateur C3456](compiler-error-c3456.md)|[source\_annotation_attribute] ne pas autorisé dans une déclaration de classe de gérés/WinRT|
|[Erreur du compilateur C3457](compiler-error-c3457.md)|«*attribut*' : attribut ne prend pas en charge les arguments sans nom|
|[Erreur du compilateur C3458](compiler-error-c3458.md)|'[*attribute*]': attribute '[*attribute*]' already specified for '*identifier*'|
|[Erreur du compilateur C3459](compiler-error-c3459.md)|' [*attribut*]': attribut autorisé uniquement sur un indexeur de classe (la propriété indexée par défaut)|
|[Erreur du compilateur C3460](compiler-error-c3460.md)|«*type*' : seul un type défini par l’utilisateur peut être transféré.|
|[Erreur du compilateur C3461](compiler-error-c3461.md)|«*type*' : seul un type géré/WinRT peut être transféré.|
|[Erreur du compilateur C3462](compiler-error-c3462.md)|«*type*' : seul un type importé peut être transféré.|
|[Erreur du compilateur C3463](compiler-error-c3463.md)|«*type*' : type non autorisé dans l’attribut 'implements'|
|[Erreur du compilateur C3464](compiler-error-c3464.md)|«*type*» un type imbriqué ne peut pas être transféré.|
|[Erreur du compilateur C3465](compiler-error-c3465.md)|utilisation de type «*type*'vous devez référencer l’assembly'*assembly*'|
|[Erreur du compilateur C3466](compiler-error-c3466.md)|«*type*' : une spécialisation d’une classe générique ne peut pas être transférée.|
|[Erreur du compilateur C3467](compiler-error-c3467.md)|«*type*' : ce type a déjà été transféré|
|[Erreur du compilateur C3468](compiler-error-c3468.md)|«*type*' : vous ne pouvez transférer un type à un assembly : '*identificateur*' n’est pas un assembly|
|[Erreur du compilateur C3469](compiler-error-c3469.md)|«*type*' : une classe générique ne peut pas être transmise.|
|[Erreur du compilateur C3470](compiler-error-c3470.md)|«*classe*' : une classe ne peut pas avoir à la fois un indexeur (la propriété indexée par défaut) et operator]|
|Erreur du compilateur C3471|nouveau nom de module *nom* (défini sur la ligne de commande) des conflits avec le nom précédent *nom*|
|Erreur du compilateur C3472|nouveau nom de fichier de sortie *filename* (défini sur la ligne de commande) des conflits avec le nom de fichier précédent *nom de fichier*|
|Erreur du compilateur C3473|Aucun nom chemin d’accès ou le module de sortie spécifié.|
|Erreur du compilateur C3474|Impossible d’ouvrir le fichier de sortie '*filename*'|
|Erreur du compilateur C3475|Erreur de syntaxe dans le fichier d’entrée '*filename*'|
|Erreur du compilateur C3476|pas pu ouvrir le fichier '*filename*» pour l’entrée|
|Erreur du compilateur C3477|une expression lambda ne peut pas apparaître dans un contexte non évalué|
|Erreur du compilateur C3478|«*identificateur*' : un tableau ne peut pas être capturé par copie|
|Erreur du compilateur C3479|Annotations SAL sur les expressions lambda ne sont pas pris en charge.|
|[Erreur du compilateur C3480](compiler-error-c3480.md)|«*variable*' : une variable de capture lambda doit provenir d’une portée englobante de la fonction|
|[Erreur du compilateur C3481](compiler-error-c3481.md)|«*identificateur*' : variable de capture lambda introuvable|
|[Erreur du compilateur C3482](compiler-error-c3482.md)|'this' peut uniquement être utilisé en tant que capture lambda dans une fonction membre non statique|
|[Erreur du compilateur C3483](compiler-error-c3483.md)|«*identificateur*' fait déjà partie de la liste de capture lambda|
|[Erreur du compilateur C3484](compiler-error-c3484.md)|Erreur de syntaxe : '-> » avant le type de retour attendu|
|[Erreur du compilateur C3485](compiler-error-c3485.md)|une définition d'expression lambda ne peut pas contenir de qualificateurs cv|
|Erreur du compilateur C3486|Obsolète.|
|[Erreur du compilateur C3487](compiler-error-c3487.md)|'*type*' : toutes les expressions de retour doivent déduire le même type : il s’agissait auparavant «*type*'|
|[Erreur du compilateur C3488](compiler-error-c3488.md)|' &*identificateur*' n’est pas autorisée lorsque le mode de capture par défaut est par référence|
|[Erreur du compilateur C3489](compiler-error-c3489.md)|' &*identificateur*' est requis lorsque le mode de capture par défaut est par copie|
|[Erreur du compilateur C3490](compiler-error-c3490.md)|«*identificateur*' ne peut pas être modifié car il est accessible via un objet const|
|[Erreur du compilateur C3491](compiler-error-c3491.md)|«*identificateur*' : un par copie capture ne peut pas être modifiée dans une expression lambda non mutable|
|[Erreur du compilateur C3492](compiler-error-c3492.md)|«*identificateur*' : vous ne pouvez pas capturer un membre d’une union anonyme|
|[Erreur du compilateur C3493](compiler-error-c3493.md)|«*identificateur*' ne peuvent pas être capturés implicitement, car aucun mode de capture par défaut n’a été spécifié.|
|Erreur du compilateur C3494|'this' ne peut pas être capturé explicitement, car un mode de capture englobant ne le permet pas|
|[Erreur du compilateur C3495](compiler-error-c3495.md)|«*identificateur*' : identificateur dans la capture doit être une variable avec une durée de stockage automatique déclarée dans la portée d’atteinte de l’expression lambda|
|[Erreur du compilateur C3496](compiler-error-c3496.md)|'this' est toujours capturé par valeur : '&' ignoré|
|Erreur du compilateur C3497|Vous ne pouvez pas construire une instance d’une expression lambda|
|[Erreur du compilateur C3498](compiler-error-c3498.md)|«*identificateur*' : vous ne pouvez pas capturer une variable qui a un type géré/WinRT|
|[Erreur du compilateur C3499](compiler-error-c3499.md)|une expression lambda dont le type de retour spécifié est void ne peut pas retourner de valeur|

## <a name="see-also"></a>Voir aussi

[C /C++ compilateur et build erreurs et avertissements des outils](../compiler-errors-1/c-cpp-build-errors.md) \
[Erreurs du compilateur C2000 - C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
