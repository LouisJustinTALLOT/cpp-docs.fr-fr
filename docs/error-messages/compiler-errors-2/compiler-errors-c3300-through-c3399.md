---
description: 'En savoir plus sur : Erreurs du compilateur C3300 à C3399'
title: Erreurs du compilateur C3300 à C3399
ms.date: 04/21/2019
f1_keywords:
- C3300
- C3301
- C3302
- C3304
- C3305
- C3306
- C3307
- C3308
- C3310
- C3311
- C3312
- C3313
- C3314
- C3315
- C3316
- C3317
- C3318
- C3319
- C3321
- C3323
- C3324
- C3325
- C3326
- C3327
- C3328
- C3329
- C3330
- C3331
- C3332
- C3335
- C3336
- C3337
- C3338
- C3339
- C3341
- C3343
- C3344
- C3346
- C3348
- C3349
- C3355
- C3357
- C3359
- C3361
- C3362
- C3376
- C3377
- C3378
helpviewer_keywords:
- C3300
- C3301
- C3302
- C3304
- C3305
- C3306
- C3307
- C3308
- C3310
- C3311
- C3312
- C3313
- C3314
- C3315
- C3316
- C3317
- C3318
- C3319
- C3321
- C3323
- C3324
- C3325
- C3326
- C3327
- C3328
- C3329
- C3330
- C3331
- C3332
- C3335
- C3336
- C3337
- C3338
- C3339
- C3341
- C3343
- C3344
- C3346
- C3348
- C3349
- C3355
- C3357
- C3359
- C3361
- C3362
- C3376
- C3377
- C3378
ms.assetid: 190b7d29-ffe6-4261-921d-140da1935d00
ms.openlocfilehash: 7c3a2f00edd5bee55ba623125c65590584751c39
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/11/2020
ms.locfileid: "97238646"
---
# <a name="compiler-errors-c3300-through-c3399"></a>Erreurs du compilateur C3300 à C3399

Les Articles de cette section de la documentation expliquent un sous-ensemble des messages d’erreur générés par le compilateur.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Messages d’erreur

|Error|Message|
|-----------|-------------|
|Erreur du compilateur C3300|'*symbol*' : format incorrect pour IDL'*valeur*'|
|Erreur du compilateur C3301|'*coclasse*' : la coclasse ne peut pas être une interface'*symbol*'|
|Erreur du compilateur C3302|'*identificateur*' : l’identificateur contient plus de caractères que le *nombre*|
|[Erreur du compilateur C3303](compiler-error-c3303.md)|'*attribute*' : l’attribut ne peut être utilisé que sur'*type*'|
|Erreur du compilateur C3304|Obsolète.|
|Erreur du compilateur C3305|Obsolète.|
|Erreur du compilateur C3306|'*modèle*' : modèle de classe/générique sans nom n’est pas autorisé|
|Erreur du compilateur C3307|'*module*' : impossible de créer le module IDL|
|Erreur du compilateur C3308|' *fonction*' : l’appel direct via une classe importée n’est pas pris en charge|
|[Erreur du compilateur C3309](compiler-error-c3309.md)|'*macro* / *Keyword*' : le nom du module ne peut pas être une macro ou un mot clé|
|Erreur du compilateur C3310|'*identificateur*' : conflit de nom de module|
|Erreur du compilateur C3311|l’attribut module doit être défini au niveau de la portée globale|
|Erreur du compilateur C3312|fonction'*identifier*'introuvable pour le type'*type*'|
|Erreur du compilateur C3313|'*identificateur*' : une variable ne peut pas avoir le type'*type*'|
|Erreur du compilateur C3314|'*symbol*' : type de module IDL non pris en charge|
|Erreur du compilateur C3315|' *fonction*' : doit être une fonction membre|
|Erreur du compilateur C3316|'*type*' : un tableau de taille inconnue ne peut pas être utilisé dans une instruction for basée sur une plage|
|Erreur du compilateur C3317|'*identificateur*' : une fonction de surcharge ne peut pas être utilisée en tant qu’expression dans une instruction for basée sur une plage|
|Erreur du compilateur C3318|'*type*' : un tableau ne peut pas avoir un type d’élément qui contient’auto'|
|Erreur du compilateur C3319|Obsolète.|
|[Erreur du compilateur C3320](compiler-error-c3320.md)|'*type*' : le type ne peut pas avoir le même nom que la propriété’name’du module|
|Erreur du compilateur C3321|une liste d’initialiseurs est inattendue dans ce contexte|
|[Erreur du compilateur C3322](compiler-error-c3322.md)|'*Property*' : propriété non valide pour l’attribut'*attribute*'|
|Erreur du compilateur C3323|'alignas’et' __declspec (Align) 'ne sont pas autorisés dans les déclarations de fonction|
|Erreur du compilateur C3324|'*Property*' : la propriété apparaît plusieurs fois dans l’attribut'*attribute*'|
|Erreur du compilateur C3325|'*attribute*' : l’attribut a trop d’arguments|
|Erreur du compilateur C3326|'*valeur*' : n’est pas une valeur valide pour la propriété'*Property*'de l’attribut'*attribute*'|
|Erreur du compilateur C3327|'*Property*' : la valeur doit être spécifiée pour la propriété de l’attribut'*attribute*'|
|Erreur du compilateur C3328|'*attribute*' : l’attribut n’a pas assez d’arguments|
|Erreur du compilateur C3329|erreur de syntaxe : '*TOKEN1*'attendu non'*Token2*'|
|Erreur du compilateur C3330|' *fonction*' : une fonction ne peut pas retourner un tableau'*type*'|
|Erreur du compilateur C3331|'*identificateur*' : les attributs sur les paramètres sont autorisés uniquement sur les coclasses et les interfaces com|
|Erreur du compilateur C3332|'*Property*' : syntaxe non cohérente, la propriété'*Property*'est obligatoire et a une valeur par défaut|
|[Erreur du compilateur C3333](compiler-error-c3333.md)|'*bibliothèque*' : impossible de #import bibliothèque de types endommagée|
|[Erreur du compilateur C3334](compiler-error-c3334.md)|#import de bibliothèque de types endommagée impossible|
|Erreur du compilateur C3335|'*identificateur*' : il peut y avoir au plus une interface par défaut pour une coclasse'*classe*'|
|Erreur du compilateur C3336|Cette opération doit être effectuée au niveau de la portée de la classe|
|Erreur du compilateur C3337|'*identificateur*' : defaultvtable doit être une source d’événements pour une coclasse'*Class*'|
|Erreur du compilateur C3338|'*identifier*' : il peut y avoir au plus une interface par défaut qui est également une source d’événements pour une coclasse'*Class*'|
|Erreur du compilateur C3339|le paramètre de modèle de modèle nécessite’class’ou’TypeName’après la liste de paramètres|
|[Erreur du compilateur C3340](compiler-error-c3340.md)|'*identificateur*' : l’interface ne peut pas être à la fois’Restricted’et’default’dans la coclasse'*Class*'|
|Erreur du compilateur C3341|'*interface*' : une interface defaultvtable doit être’Dual’ou’Custom'|
|[Erreur du compilateur C3342](compiler-error-c3342.md)|'*identificateur*' : attribut ambigu|
|Erreur du compilateur C3343|'*Class*::*Name*' : l’identificateur d’attribut a trop de caractères|
|Erreur du compilateur C3344|vous ne pouvez pas définir une spécialisation explicite ni une spécialisation partielle de'*symbol*'|
|[Erreur du compilateur C3345](compiler-error-c3345.md)|'*Name*' : identificateur non valide pour le nom de module|
|Erreur du compilateur C3346|Déclaration exportée à la portée d’espace de noms non|
|[Erreur du compilateur C3347](compiler-error-c3347.md)|'*argument*' : l’argument requis n’est pas spécifié dans l’attribut *asttribute*|
|Erreur du compilateur C3348|les modèles exportés ne font pas partie des normes C++ actuelles|
|Erreur du compilateur C3349|'*Class*::*member*' : l’attribut multicast a déjà été implémenté par le *fournisseur fournisseur*|
|[Erreur du compilateur C3350](compiler-error-c3350.md)|' *fonction*' : un constructeur délégué attend un ou plusieurs arguments de *nombre*|
|[Erreur du compilateur C3351](compiler-error-c3351.md)|' *fonction*' : Si vous transmettez une instance d’objet null à un constructeur délégué, vous devez également passer l’adresse d’une fonction membre statique|
|[Erreur du compilateur C3352](compiler-error-c3352.md)|'*fonction*' : la fonction spécifiée ne correspond pas au type délégué'*type*'|
|[Erreur du compilateur C3353](compiler-error-c3353.md)|'*identificateur*' : un délégué ne peut être créé qu’à partir d’une fonction globale ou d’une fonction membre d’un type managé/WinRT|
|[Erreur du compilateur C3354](compiler-error-c3354.md)|'*identificateur*' : la fonction utilisée pour créer un délégué ne peut pas avoir le type de retour'*type*'|
|Erreur du compilateur C3355|'*Class*::*member*' : l’attribut multicast écoute le fournisseur'*Fournisseur1*', mais il est implémenté par le fournisseur'*FOURNISSEUR2*'|
|[Erreur du compilateur C3356](compiler-error-c3356.md)|'*identificateur*' : impossible d’appeler un attribut multicast avec un nom qualifié complet|
|Erreur du compilateur C3357|'*attribute*' : l’attribut est ambigu, doit utiliser un nom qualifié complet|
|[Erreur du compilateur C3358](compiler-error-c3358.md)|'*symbol*' : symbole introuvable|
|Erreur du compilateur C3359|'*spécialisation*' : impossible de spécialiser le modèle|
|[Erreur du compilateur C3360](compiler-error-c3360.md)|'*String*' : impossible de créer le *nom*|
|Erreur du compilateur C3361|Il n’y a aucun contexte dans lequel *agir*|
|Erreur du compilateur C3362|'*Class*::*member*' : l’attribut multicast n’a pas été implémenté|
|[Erreur du compilateur C3363](compiler-error-c3363.md)|'*identificateur*' : 'typeid’ne peut être appliqué qu’à un type|
|[Erreur du compilateur C3364](compiler-error-c3364.md)|' *fonction*' : argument non valide pour le constructeur délégué ; la cible du délégué doit être un pointeur vers une fonction membre|
|[Erreur du compilateur C3365](compiler-error-c3365.md)|opérateur'*opérateur*' : opérandes différents de type'*type*'et'*type*'|
|[Erreur du compilateur C3366](compiler-error-c3366.md)|'*membre*' : les données membres static des types managés/WinRT doivent être définies dans la définition de classe|
|[Erreur du compilateur C3367](compiler-error-c3367.md)|' *fonction*' : impossible d’utiliser une fonction static pour créer un délégué indépendant|
|[Erreur du compilateur C3368](compiler-error-c3368.md)|'*déclarateur*' : Convention d’appel non valide pour IDL|
|[Erreur du compilateur C3369](compiler-error-c3369.md)|'*module*' : idl_module déjà défini|
|[Erreur du compilateur C3370](compiler-error-c3370.md)|'*module*' : idl_module pas encore défini|
|[Erreur du compilateur C3371](compiler-error-c3371.md)|'idl_module' : seule la propriété 'name' est autorisée ici|
|[Erreur du compilateur C3372](compiler-error-c3372.md)|vous devez spécifier au moins 1 interface pour l’attribut'*attribut*'sur une coclasse|
|[Erreur du compilateur C3373](compiler-error-c3373.md)|l’attribut'*attribute*'n’accepte aucun argument sauf sur une coclasse|
|[Erreur du compilateur C3374](compiler-error-c3374.md)|Impossible de prendre l’adresse de' *Function*'à moins de créer une instance de délégué|
|[Erreur du compilateur C3375](compiler-error-c3375.md)|'*fonction*' : fonction déléguée ambiguë|
|Erreur du compilateur C3376|'*template*' : seuls les modèles de membres de données statiques sont autorisés|
|Erreur du compilateur C3377|'decltype (auto) 'n’est pas autorisé dans une expression New|
|Erreur du compilateur C3378|une déclaration peut être exportée uniquement à partir d’une unité d’interface de module|
|[Erreur du compilateur C3379](compiler-error-c3379.md)|'*classe*' : une classe imbriquée ne peut pas avoir de spécificateur d’accès à l’assembly dans le cadre de sa déclaration|
|[Erreur du compilateur C3380](compiler-error-c3380.md)|'*specifier*' : spécificateur d’accès à l’assembly non valide-seuls’public’ou’Private’sont autorisés|
|[Erreur du compilateur C3381](compiler-error-c3381.md)|'*specifier*' : les spécificateurs d’accès à l’assembly ne sont disponibles que dans le code compilé avec une option/clr|
|[Erreur du compilateur C3382](compiler-error-c3382.md)|'sizeof' n'est pas pris en charge avec /clr:safe|
|[Erreur du compilateur C3383](compiler-error-c3383.md)|'operator new' n'est pas pris en charge avec /clr:safe|
|[Erreur du compilateur C3384](compiler-error-c3384.md)|'*type*' : la contrainte de valeur et la contrainte Ref s’excluent mutuellement|
|[Erreur du compilateur C3385](compiler-error-c3385.md)|' *fonction*' : une fonction qui a un attribut personnalisé DllImport ne peut pas retourner une instance d’une classe|
|[Erreur du compilateur C3386](compiler-error-c3386.md)|'*type*' : __declspec (dllexport)/__declspec (dllimport) ne peut pas être appliqué à un type managé/WinRT|
|[Erreur du compilateur C3387](compiler-error-c3387.md)|'*membre*' : __declspec (dllexport)/__declspec (dllimport) ne peut pas être appliqué à un membre d’un type managé/WinRT|
|[Erreur du compilateur C3388](compiler-error-c3388.md)|'*Token*' : non autorisé en tant que contrainte, '*value*'supposé continuer l’analyse|
|[Erreur du compilateur C3389](compiler-error-c3389.md)|__declspec (*specifier*) ne peut pas être utilisé avec/clr : pure ou/CLR : safe|
|[Erreur du compilateur C3390](compiler-error-c3390.md)|'*type*' : argument de type non valide pour le paramètre générique'*paramètre*'du générique'*generic_type*', doit être un type référence|
|[Erreur du compilateur C3391](compiler-error-c3391.md)|'*type*' : argument de type non valide pour le paramètre générique'*paramètre*'du générique'*generic_type*', doit être un type valeur n’acceptant pas les valeurs null|
|[Erreur du compilateur C3392](compiler-error-c3392.md)|'*type*' : argument de type non valide pour le paramètre générique'*paramètre*'du générique'*generic_type*', doit avoir un constructeur sans paramètre public|
|[Erreur du compilateur C3393](compiler-error-c3393.md)|erreur de syntaxe dans la clause de contrainte : '*identifier*'n’est pas un type|
|[Erreur du compilateur C3394](compiler-error-c3394.md)|erreur de syntaxe dans la clause de contrainte : '*symbol*'trouvé, type attendu|
|[Erreur du compilateur C3395](compiler-error-c3395.md)|' *fonction*' : __declspec (dllexport) ne peut pas être appliqué à une fonction avec la Convention d’appel __clrcall|
|[Erreur du compilateur C3396](compiler-error-c3396.md)|'*classe*. *membre*' : attribut personnalisé introuvable dans'*namespace*'|
|[Erreur du compilateur C3397](compiler-error-c3397.md)|L'initialisation d'agrégats n'est pas autorisée dans les arguments par défaut|
|[Erreur du compilateur C3398](compiler-error-c3398.md)|'*Operator*' : impossible de convertir'*type*'en'*type*'. L'expression source doit être un symbole de fonction|
|[Erreur du compilateur C3399](compiler-error-c3399.md)|'*type*' : impossible de fournir des arguments lors de la création d’une instance d’un paramètre générique|

## <a name="see-also"></a>Voir aussi

[Erreurs et avertissements du compilateur C/C++ et des outils de génération](../compiler-errors-1/c-cpp-build-errors.md) \
[Erreurs du compilateur C2000 - C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
