---
title: Erreurs du compilateur C3500 à C3999
ms.date: 04/21/2019
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
ms.openlocfilehash: eddadeeeb014c6b64376554f7ff025a06e8935c9
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/17/2020
ms.locfileid: "79446938"
---
# <a name="compiler-errors-c3500-through-c3999"></a>Erreurs du compilateur C3500 à C3999

Les Articles de cette section de la documentation expliquent un sous-ensemble des messages d’erreur générés par le compilateur.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Messages d’erreur

|Error|Message|
|-----------|-------------|
|[Erreur du compilateur C3500](compiler-error-c3500.md)|ProgID'*ProgID*'non valide|
|[Erreur du compilateur C3501](compiler-error-c3501.md)|aucune TypeLib inscrite pour ProgID'*ProgID*'|
|Erreur du compilateur C3502|Impossible d’obtenir LIBID pour le ProgID'*ProgID*'|
|Erreur du compilateur C3503|le caractère' 0x*value*'n’est pas autorisé dans un littéral de chaîne brut|
|Erreur du compilateur C3504|Impossible de créer le GUID à partir de la chaîne'*String*'|
|[Erreur du compilateur C3505](compiler-error-c3505.md)|Impossible de charger la bibliothèque de types'*Library*'|
|[Erreur du compilateur C3506](compiler-error-c3506.md)|aucune TypeLib inscrite pour LIBID'*Library*'|
|[Erreur du compilateur C3507](compiler-error-c3507.md)|un ProgID ne peut pas comporter plus de 39 caractères'*ProgID*'; et ne contiennent pas de signes de ponctuation séparés de'. '; ni commencer par un chiffre|
|[Erreur du compilateur C3508](compiler-error-c3508.md)|'*type*' : n’est pas un type Automation valide|
|[Erreur du compilateur C3509](compiler-error-c3509.md)|'*type*' : type de retour Automation non valide ; Quand un paramètre est marqué comme’retval', le type de retour doit être’void', 'HRESULT’ou’SCODE'|
|[Erreur du compilateur C3510](compiler-error-c3510.md)|*bibliothèque* de bibliothèque de types dépendante introuvable|
|Erreur du compilateur C3511|'*identificateur*' : un appel à un constructeur de délégation sera le seul initialiseur de membre|
|Erreur du compilateur C3512|la séquence de caractères de délimitation pour un littéral de chaîne brut ne doit pas comporter plus de 16 caractères|
|Erreur du compilateur C3513|'*String*' : caractère délimiteur de littéral de chaîne brute non pris en charge|
|Erreur du compilateur C3514|'*caractère*' (*valeur*) : caractère délimiteur de littéral de chaîne brute non pris en charge|
|Erreur du compilateur C3515|Si un argument pour une spécialisation partielle de modèle de classe est une expansion de package, il s’agit du dernier argument|
|Erreur du compilateur C3516|fin de fichier inattendue détectée lors du traitement du littéral de chaîne brut ; la séquence de délimiteur'*chaîne*'n’a pas été mise en correspondance|
|Erreur du compilateur C3517|'*identificateur*'une déclaration d’alias ne peut pas avoir un type contenant’auto'|
|Erreur du compilateur C3518|'*identificateur*' : dans un contexte d’initialisation de liste directe, le type de'*type*'ne peut être déduit qu’à partir d’une seule expression d’initialiseur|
|[Erreur du compilateur C3519](compiler-error-c3519.md)|'*paramètre*' : paramètre non valide pour embedded_idl attribut|
|Erreur du compilateur C3520|'*identificateur*' : le package de paramètres doit être développé dans ce contexte|
|Erreur du compilateur C3521|'*identifier*'n’est pas un package de paramètres|
|Erreur du compilateur C3522|'*type*' : le package de paramètres ne peut pas être développé dans ce contexte|
|Erreur du compilateur C3523|'sizeof... ' nécessite comme argument un pack de paramètres non développé|
|Erreur du compilateur C3524|'*identificateur*' : 'sizeof’ne peut pas être appliqué à un package de paramètres. Souhaitiez-vous utiliser’sizeof... ' ?|
|Erreur du compilateur C3525|'*paramètre*' : si un modèle de classe possède un package de paramètres de modèle, il doit apparaître à la fin de la liste de paramètres de modèle|
|Erreur du compilateur C3526|'...' ne peut pas être appliqué à’This'|
|Erreur du compilateur C3527|'*identifier*'n’est pas un opérande valide pour’sizeof... '. Souhaitiez-vous utiliser’sizeof' ?|
|Erreur du compilateur C3528|'*identificateur1*' : le nombre d’éléments dans cette expansion de package ne correspond pas au nombre d’éléments dans'*identificateur2*'|
|Erreur du compilateur C3529|'*paramètre*' : un package de paramètres de modèle ne peut pas avoir d’argument par défaut|
|[Erreur du compilateur C3530](compiler-error-c3530.md)|'*type*'ne peut pas être combiné avec un autre spécificateur de type|
|[Erreur du compilateur C3531](compiler-error-c3531.md)|'*identificateur*' : un symbole dont le type contient'*type*'doit avoir un initialiseur|
|[Erreur du compilateur C3532](compiler-error-c3532.md)|le type d’élément d’un tableau ne peut pas être un type contenant'*type*'|
|[Erreur du compilateur C3533](compiler-error-c3533.md)|un paramètre ne peut pas avoir un type contenant'*type*'|
|Erreur du compilateur C3534|Obsolète.|
|[Erreur du compilateur C3535](compiler-error-c3535.md)|Impossible de déduire le type de'*type1*'à partir de'*type2*'|
|[Erreur du compilateur C3536](compiler-error-c3536.md)|'*identificateur*' : ne peut pas être utilisé avant d’être initialisé|
|[Erreur du compilateur C3537](compiler-error-c3537.md)|vous ne pouvez pas effectuer un cast en un type qui contient'*type*'|
|[Erreur du compilateur C3538](compiler-error-c3538.md)|dans un déclarateur, la liste'*type*'doit toujours déduire le même type|
|[Erreur du compilateur C3539](compiler-error-c3539.md)|un argument template ne peut pas être un type contenant'*type*'|
|[Erreur du compilateur C3540](compiler-error-c3540.md)|sizeof ne peut pas être appliqué à un type qui contient'*type*'|
|[Erreur du compilateur C3541](compiler-error-c3541.md)|TypeId ne peut pas être appliqué à un type qui contient'*type*'|
|Erreur du compilateur C3542|'*identificateur*' : une fonction membre virtuelle ne doit pas avoir de type de retour contenant'*type*'|
|Erreur du compilateur C3543|'*type*' : ne contient pas de package de paramètres|
|Erreur du compilateur C3544|'*paramètre*' : le package de paramètres attend un argument de modèle de type|
|Erreur du compilateur C3545|'*paramètre*' : le package de paramètres attend un argument de modèle sans type|
|Erreur du compilateur C3546|'... ' : il n’y a aucun Pack de paramètres disponible pour le développement|
|Erreur du compilateur C3547|Impossible d’utiliser le paramètre de modèle'*paramètre*', car il suit un package de paramètres de modèle et ne peut pas être déduit des paramètres de fonction de'*Function*'|
|Erreur du compilateur C3548|'*identificateur*' : le package de paramètres ne peut pas être utilisé dans ce contexte|
|Erreur du compilateur C3549|'*valeur*' : un package de paramètres de fonction ne peut pas avoir d’argument par défaut|
|[Erreur du compilateur C3550](compiler-error-c3550.md)|'decltype(auto)' simple est le seul autorisé dans ce contexte|
|[Erreur du compilateur C3551](compiler-error-c3551.md)|Si un type de retour de fin est utilisé, le type de retour de début doit être le spécificateur de type unique’auto' (et non'*type*')|
|[Erreur du compilateur C3552](compiler-error-c3552.md)|expected 'decltype(auto)'|
|[Erreur du compilateur C3553](compiler-error-c3553.md)|decltype attend une expression et non un type|
|[Erreur du compilateur C3554](compiler-error-c3554.md)|'*type*'ne peut pas être combiné avec un autre spécificateur de type|
|[Erreur du compilateur C3555](compiler-error-c3555.md)|argument incorrect de 'decltype'|
|[Erreur du compilateur C3556](compiler-error-c3556.md)|'*expression*' : argument incorrect pour’decltype'|
|Erreur du compilateur C3557|Obsolète.|
|Erreur du compilateur C3558|Obsolète.|
|Erreur du compilateur C3559|appel récursif à'*Function*' : la récursivité est détectée lors de la compilation du graphique des appels pour l’accès concurrentiel ::p arallel_for_each à : '*Function*'|
|Erreur du compilateur C3560|'*fonction*' : il n’est pas disponible lors de la compilation du graphique des appels pour l’accès concurrentiel ::p arallel_for_each à : '*Function*'|
|Erreur du compilateur C3561|opération de barrière de vignette trouvée dans le workflow de contrôle qui n’est pas uniforme en mosaïque lors de la compilation du graphique des appels pour l’accès concurrentiel ::p arallel_for_each à l’adresse'*Function*'|
|Erreur du compilateur C3562|la fonction intrinsèque'*Function*'ne doit pas comporter plus de paramètres *Number*|
|Erreur du compilateur C3563|Boucle infinie détectée lors de la compilation du graphique des appels pour l’accès concurrentiel ::p arallel_for_each à : '*Function*'|
|Erreur du compilateur C3564|lecture de la valeur non initialisée lors de la compilation du graphique des appels pour l’accès concurrentiel ::p arallel_for_each à : '*Function*'|
|Erreur du compilateur C3565|La quantité totale de mémoire tile_static (*nombre* d’octets) dépasse la limite du *nombre* d’octets lors de la compilation du graphique des appels pour l’accès concurrentiel ::p arallel_for_each|
|Erreur du compilateur C3566|les blocs avec des effets secondaires sont imbriqués trop profondément lors de la compilation du graphique des appels pour l’accès concurrentiel ::p arallel_for_each à : '*Function*'|
|Erreur du compilateur C3567|Division ou modulo par zéro détecté lors de la compilation du graphique des appels pour l’accès concurrentiel ::p arallel_for_each à : '*Function*'|
|Erreur du compilateur C3568|la somme des registres dépasse la limite de *nombre* lors de la compilation du graphique des appels pour l’accès concurrentiel ::p arallel_for_each. Simplifiez votre programme|
|Erreur du compilateur C3569|condition de concurrence détectée lors de la compilation du graphique des appels pour l’accès concurrentiel ::p arallel_for_each à : '*Function*'|
|Erreur du compilateur C3570|utilisation non conforme de la portée restreinte amp lors de la compilation avec/CLR|
|Erreur du compilateur C3571|'*type*' : argument de domaine de calcul non conforme ; n’est pas un type de classe|
|Erreur du compilateur C3572|'*type*' : argument de domaine de calcul non conforme ; membre public manquant : 'static const int Rank’ou la valeur de classement est non positive|
|Erreur du compilateur C3573|Le nombre d’instances de Concurrency :: Graphics :: sampler passé à l’accès concurrentiel ::p arallel_for_each ne peut pas dépasser le *nombre*|
|Erreur du compilateur C3574|'*type*' : étendues de mosaïques non conformes : doit être positif et (1) Z < = *nombre*; (2 *) Z X*< = *nombre*|
|Erreur du compilateur C3575|'*type*' : argument de domaine de calcul non conforme ; membre public manquant : 'Concurrency :: index <*nombre*> _map_index (const Concurrency :: index <*Number*> &) Restrict (amp) '|
|Erreur du compilateur C3576|'*type*' : concurrence ::d étails :: _Parallel_for_each argument #*Number* a un type non pris en charge|
|Erreur du compilateur C3577|concurrence ::p argument de noyau arallel_for_each n’est pas conforme : impossible de résoudre l’appel au membre’void Operator () (*type*) Restrict (amp) '|
|Erreur du compilateur C3578|La taille de l’objet de fonction est passée à la concurrence ::p arallel_for_each ne peut pas dépasser le *nombre* d’octets|
|Erreur du compilateur C3579|Nombre d’instances en lecture seule de l’accès concurrentiel :: Array et Concurrency :: Graphics :: texture passées à l’accès concurrentiel ::p arallel_for_each ne peut pas dépasser le *nombre*|
|Erreur du compilateur C3580|Nombre d’instances accessibles en écriture de Concurrency :: Array et Concurrency :: Graphics :: texture passées à l’accès concurrentiel ::p arallel_for_each ne peut pas dépasser le *nombre*|
|Erreur du compilateur C3581|'*type*' : type non pris en charge dans le code restreint amp|
|Erreur du compilateur C3582|Obsolète.|
|Erreur du compilateur C3583|'*identificateur*' : la taille de la variable (*nombre* d’octets) est supérieure à la taille*maximale (octets* ) prise en charge dans le code restreint amp|
|Erreur du compilateur C3584|utilisation non prise en charge de tile_static sur'*identifier*'|
|Erreur du compilateur C3585|'*identifier*'a une classe de stockage non prise en charge dans le code restreint amp|
|Erreur du compilateur C3586|'*identificateur*' : l’utilisation de variables globales ou statiques n’est pas prise en charge dans le code restreint amp|
|Erreur du compilateur C3587|dynamic_cast n’est pas pris en charge dans le code restreint amp|
|Erreur du compilateur C3588|la conversion de'*type1*'en'*type2*'n’est pas prise en charge dans le code restreint amp|
|Erreur du compilateur C3589|'*String*' : utilisation non prise en charge des littéraux de chaîne dans le code restreint amp|
|Erreur du compilateur C3590|'*Token*' : la capture par référence ou la capture’This’n’est pas prise en charge si l’expression lambda est restreinte à amp|
|Erreur du compilateur C3591|l’opérateur typeid n’est pas pris en charge dans le code restreint amp|
|Erreur du compilateur C3592|L’assembly natif inline (' __asm') n’est pas pris en charge dans le code restreint amp|
|Erreur du compilateur C3593|'Goto’n’est pas pris en charge dans le code restreint amp|
|Erreur du compilateur C3594|la gestion des exceptions (TRY, catch, Throw, etc.) n’est pas prise en charge dans le code restreint amp|
|Erreur du compilateur C3595|la valeur de constante est en dehors de la plage prise en charge dans le code restreint amp|
|Erreur du compilateur C3596|'*paramètre*' ('*type*') : la variable capturée par l’expression lambda a un type non pris en charge dans le code restreint amp|
|Erreur du compilateur C3597|'*paramètre*' : '*identificateur*'ne peut pas être capturé par valeur si l’expression lambda est restreinte à amp|
|Erreur du compilateur C3598|l’instruction label n’est pas prise en charge dans le code restreint amp|
|Erreur du compilateur C3599|'*Operator*' : impossible d’effectuer une opération arithmétique de pointeur sur un pointeur vers une valeur booléenne dans du Code restreint amp|
|Erreur du compilateur C3600|'*fonction*' : utilisation de la vignette\_mémoire statique détectée lors de la compilation du graphique des appels pour l’accès concurrentiel sans mosaïque ::p arallel\_for_each à l’adresse : '*fonction*'|
|Erreur du compilateur C3601|'*type*' : type d’argument non valide pour la fonction de diagnostic amp'*Function*'|
|Erreur du compilateur C3602|Un workflow de contrôle non pris en charge a été détecté lors de la compilation du graphique des appels pour l’accès concurrentiel ::p arallel_for_each à : '*Function*'|
|[Erreur du compilateur C3603](compiler-error-c3603.md)|'*symbol*' : le type'*type*'n’est pas encore pris en charge|
|Erreur du compilateur C3604|'*identifier*' : peut uniquement créer un objet managé sur le tas gc|
|Erreur du compilateur C3605|Le nombre total d’échantillonneurs (*nombre* capturé et *nombre* prédéfini) dépasse le *nombre* lors de la compilation du graphique des appels pour l’accès concurrentiel ::p arallel_for_each à : '*fonction*'|
|Erreur du compilateur C3606|Obsolète.|
|Erreur du compilateur C3607|Obsolète.|
|Erreur du compilateur C3608|Obsolète.|
|[Erreur du compilateur C3609](compiler-error-c3609.md)|'*identificateur*' : une fonction’sealed/final’doit être virtuelle|
|[Erreur du compilateur C3610](compiler-error-c3610.md)|'*identificateur*' : le type valeur doit être’boxed’avant que la méthode'*Method*'puisse être appelée|
|[Erreur du compilateur C3611](compiler-error-c3611.md)|'*identifier*' : une fonction sealed ne peut pas avoir de spécificateur pure|
|[Erreur du compilateur C3612](compiler-error-c3612.md)|'*identificateur*' : une classe sealed ne peut pas avoir de méthode virtuelle pure|
|Erreur du compilateur C3613|type de retour manquant après'-> ' ('int’pris par défaut)|
|Erreur du compilateur C3614|Valeurs différentes pour la taille de Pack dans la même classe ; la précédente était'*value*', la nouvelle valeur est'*value*'|
|[Erreur du compilateur C3615](compiler-error-c3615.md)|la fonction constexpr'*Function*'ne peut pas produire une expression constante|
|Erreur du compilateur C3616|Obsolète.|
|Erreur du compilateur C3617|Obsolète.|
|[Erreur du compilateur C3618](compiler-error-c3618.md)|'*déclaration*' : impossible de définir une méthode marquée dllimport|
|[Erreur du compilateur C3619](compiler-error-c3619.md)|un modèle ne peut pas être déclaré dans un type managé/WinRT|
|Erreur du compilateur C3620|'*type*' : la définition de l’alignement n’est pas autorisée sur les types WinRT|
|Erreur du compilateur C3621|'*type*' : seule la valeur de compression par défaut (*Number*) est autorisée pour les types WinRT|
|[Erreur du compilateur C3622](compiler-error-c3622.md)|*type*' : une classe déclarée comme'*Keyword*'ne peut pas être instanciée|
|[Erreur du compilateur C3623](compiler-error-c3623.md)|'*identificateur*' : les champs de bits ne sont pas pris en charge dans les types managés/WinRT|
|[Erreur du compilateur C3624](compiler-error-c3624.md)|'*type*' : l’utilisation de ce type requiert une référence à l’assembly/module'*identifier*'|
|[Erreur du compilateur C3625](compiler-error-c3625.md)|'*classe*' : un type natif ne peut pas dériver d’un type managé/WinRT'*type*'|
|[Erreur du compilateur C3626](compiler-error-c3626.md)|'*identifier*' : le mot clé'*Keyword*'ne peut être utilisé que sur les interfaces com, les fonctions membres et les données membres qui sont des pointeurs vers les délégués|
|[Erreur du compilateur C3627](compiler-error-c3627.md)|Seul un type valeur peut être boxed|
|[Erreur du compilateur C3628](compiler-error-c3628.md)|'*classe*' : les classes managées/WinRT prennent uniquement en charge l’héritage public|
|Erreur du compilateur C3629|'*Token*' : une capture par défaut ne peut apparaître qu’au début d’une liste de capture lambda|
|[Erreur du compilateur C3630](compiler-error-c3630.md)|erreur lors du traitement du jeton'*Token*'|
|[Erreur du compilateur C3631](compiler-error-c3631.md)|'*Event*' : impossible de surcharger les événements managés/WinRT|
|[Erreur du compilateur C3632](compiler-error-c3632.md)|'*Event*' : style d’événement non conforme pour la *construction*|
|[Erreur du compilateur C3633](compiler-error-c3633.md)|Impossible de définir'*identifier*'en tant que membre de'*Class*'managé|
|[Erreur du compilateur C3634](compiler-error-c3634.md)|'*membre*' : impossible de définir une méthode abstraite d’une classe managée/WinRT|
|Erreur du compilateur C3635|'*identificateur*' : ne peut pas être appliqué à une classe managée/WinRT (utilisez'*identifier*'à la place)|
|Erreur du compilateur C3636|'*identificateur*' : ne peut pas être appliqué à ce type|
|[Erreur du compilateur C3637](compiler-error-c3637.md)|'*fonction*' : une définition de fonction friend ne peut pas être une spécialisation d’un modèle de fonction/générique|
|[Erreur du compilateur C3638](compiler-error-c3638.md)|'*Operator*' : impossible de redéfinir les opérateurs de conversion boxing et unboxing standard|
|Erreur du compilateur C3639|Obsolète.|
|[Erreur du compilateur C3640](compiler-error-c3640.md)|'*membre*' : une fonction membre référencée ou virtuelle d’une classe locale doit être définie|
|[Erreur du compilateur C3641](compiler-error-c3641.md)|'*fonction*' : Convention d’appel'*Convention*'non valide pour la fonction compilée avec/clr : pure ou/CLR : safe|
|[Erreur du compilateur C3642](compiler-error-c3642.md)|'*fonction*' : impossible d’appeler une fonction avec __clrcall Convention d’appel à partir du code natif|
|Erreur du compilateur C3643|Obsolète.|
|[Erreur du compilateur C3644](compiler-error-c3644.md)|'*fonction*' : impossible de compiler la fonction pour générer du code managé|
|[Erreur du compilateur C3645](compiler-error-c3645.md)|'*fonction*' : __clrcall ne peut pas être utilisé sur des fonctions compilées en code natif|
|[Erreur du compilateur C3646](compiler-error-c3646.md)|'*identificateur*' : spécificateur de substitution inconnu|
|Erreur du compilateur C3647|Obsolète.|
|[Erreur du compilateur C3648](compiler-error-c3648.md)|Cette syntaxe de substitution explicite n’est pas prise en charge pour les types managés|
|Erreur du compilateur C3649|Cette syntaxe de substitution explicite n’est pas autorisée avec/ZW|
|[Erreur du compilateur C3650](compiler-error-c3650.md)|'*membre*' : ne peut pas être utilisé comme substitution explicite, doit être une fonction membre virtuelle d’une classe de base|
|[Erreur du compilateur C3651](compiler-error-c3651.md)|'*membre*' : ne peut pas être utilisé comme substitution explicite, doit être membre d’une classe de base|
|[Erreur du compilateur C3652](compiler-error-c3652.md)|'*membre*' : une fonction qui substitue explicitement doit être virtuelle|
|[Erreur du compilateur C3653](compiler-error-c3653.md)|'*identificateur*' : ne peut pas être utilisé en tant que substitution nommée : fonction substituée introuvable ; avez-vous oublié de nommer la fonction explicitement, à l’aide d’un opérateur ::?|
|[Erreur du compilateur C3654](compiler-error-c3654.md)|'*Token*' : erreur de syntaxe dans la substitution explicite|
|[Erreur du compilateur C3655](compiler-error-c3655.md)|'*membre*' : fonction déjà substituée explicitement|
|[Erreur du compilateur C3656](compiler-error-c3656.md)|'*Keyword*' : le spécificateur de substitution ne peut pas être répété|
|[Erreur du compilateur C3657](compiler-error-c3657.md)|un destructeur/finaliseur ne peut pas substituer explicitement ou être substitué explicitement|
|Erreur du compilateur C3658|Obsolète.|
|Erreur du compilateur C3659|'*membre*' : le spécificateur de substitution'*MotClé*'n’est pas pris en charge|
|Erreur du compilateur C3660|'*membre1*' : masque le membre hérité'*membre2*'|
|[Erreur du compilateur C3661](compiler-error-c3661.md)|la liste de substitution explicite n’a pas trouvé de méthode à substituer|
|[Erreur du compilateur C3662](compiler-error-c3662.md)|'*membre*' : spécificateur de substitution'*mot clé*'uniquement autorisé sur les fonctions membres des classes managées/WinRT|
|Erreur du compilateur C3663|Obsolète.|
|Erreur du compilateur C3664|'*membre*' : ne peut pas être utilisé comme substitution explicite, doit avoir une accessibilité’public’ou’protected'|
|[Erreur du compilateur C3665](compiler-error-c3665.md)|'*membre*' : spécificateur de substitution'*MotClé*'non autorisé sur un destructeur/finaliseur|
|[Erreur du compilateur C3666](compiler-error-c3666.md)|'*constructor*' : spécificateur de substitution'*MotClé*'non autorisé sur un constructeur|
|Erreur du compilateur C3667|'*attribute*' : l’attribut ne prend pas en charge l’expansion de package|
|[Erreur du compilateur C3668](compiler-error-c3668.md)|'*membre*' : la méthode avec le spécificateur de substitution’override’n’a pas substitué les méthodes de la classe de base|
|[Erreur du compilateur C3669](compiler-error-c3669.md)|'*membre*' : spécificateur de substitution’override’non autorisé sur les fonctions membres ou les constructeurs static|
|[Erreur du compilateur C3670](compiler-error-c3670.md)|'*membre*' : impossible de substituer la méthode de classe de base inaccessible'*membre*'|
|[Erreur du compilateur C3671](compiler-error-c3671.md)|'*membre*' : la fonction ne substitue pas'*member*'|
|[Erreur du compilateur C3672](compiler-error-c3672.md)|une expression Pseudo-destructeur ne peut être utilisée que dans le cadre d’un appel de fonction|
|[Erreur du compilateur C3673](compiler-error-c3673.md)|'*classe*' : la classe n’a pas de constructeur de copie|
|Erreur du compilateur C3674|module de bibliothèque standard'*module*'introuvable|
|[Erreur du compilateur C3675](compiler-error-c3675.md)|'*fonction*' : est réservé, car'*Property*'est défini|
|Erreur du compilateur C3676|'*classe*' : la classe ref et la classe de base ont des attributs incompatibles' [*attribute*] '|
|Erreur du compilateur C3677|le littéral de chaîne après’operator’ne peut pas avoir de préfixe d’encodage|
|Erreur du compilateur C3678|le littéral de chaîne après’operator’doit être la chaîne vide' "" "" "|
|Erreur du compilateur C3679|identificateur de suffixe littéral attendu après’operator "" ""»|
|Erreur du compilateur C3680|Impossible de concaténer des littéraux de chaîne définis par l’utilisateur avec des identificateurs de suffixe littéral incompatibles|
|Erreur du compilateur C3681|'FallThrough' : l’attribut ne peut apparaître que dans une instruction switch englobante|
|Erreur du compilateur C3682|'operator *identifier*' : un modèle opérateur littéral/opérateur littéral ne peut pas être déclaré comme ayant’C liaison'|
|Erreur du compilateur C3683|Impossible de définir à la fois un opérateur de littéral brut et un modèle d’opérateur littéral avec le même identificateur de suffixe littéral|
|Erreur du compilateur C3684|'operator *identifier*' : la déclaration de l’opérateur Literal a une liste de paramètres non valide|
|Erreur du compilateur C3685|' *identificateur*d’opérateur' : le modèle d’opérateur littéral ne peut pas avoir de paramètres de fonction|
|Erreur du compilateur C3686|' *identificateur*d’opérateur' : le modèle d’opérateur littéral doit avoir exactement un paramètre de modèle qui est un package de paramètres|
|Erreur du compilateur C3687|' *identificateur*d’opérateur' : le modèle d’opérateur littéral doit avoir un paramètre de modèle sans type de type’Char'|
|Erreur du compilateur C3688|suffixe littéral non valide'*suffixe*'; opérateur littéral ou modèle d’opérateur littéral' *identificateur*d’opérateur’introuvable|
|Erreur du compilateur C3689|' *identificateur*d’opérateur' : le modèle d’opérateur littéral opérateur/littéral doit figurer dans une portée globale ou d’espace de noms|
|Erreur du compilateur C3690|littéral de chaîne attendu, mais un littéral de chaîne défini par l’utilisateur a été trouvé à la place|
|Erreur du compilateur C3691|préfixe de littéral non valide'*préfixe*'|
|Erreur du compilateur C3692|Obsolète.|
|Erreur du compilateur C3693|Obsolète.|
|Erreur du compilateur C3694|Obsolète.|
|Erreur du compilateur C3695|Obsolète.|
|Erreur du compilateur C3696|'*Keyword*' : impossible d’utiliser ce qualificateur sur'% '|
|[Erreur du compilateur C3697](compiler-error-c3697.md)|'*Keyword*' : impossible d’utiliser ce qualificateur sur' ^ '|
|[Erreur du compilateur C3698](compiler-error-c3698.md)|'*type*' : impossible d’utiliser ce type comme argument de'*Operator*'|
|[Erreur du compilateur C3699](compiler-error-c3699.md)|'*Operator*' : impossible d’utiliser cette indirection sur le type'*type*'|
|Erreur du compilateur C3700|Obsolète.|
|[Erreur du compilateur C3701](compiler-error-c3701.md)|'*fonction*' : la source de l’événement n’a pas d’événements|
|[Erreur du compilateur C3702](compiler-error-c3702.md)|ATL requis pour les événements COM|
|[Erreur du compilateur C3703](compiler-error-c3703.md)|'*event_handler*' : une méthode de gestionnaire d’événements doit avoir la même classe de stockage que le'*Event*'source|
|[Erreur du compilateur C3704](compiler-error-c3704.md)|'*membre*' : une méthode vararg ne peut pas déclencher d’événements|
|[Erreur du compilateur C3705](compiler-error-c3705.md)|'*fonction*' : impossible de trouver l’interface d’événement|
|[Erreur du compilateur C3706](compiler-error-c3706.md)|'*fonction*' : doit être une interface com pour déclencher des événements com|
|[Erreur du compilateur C3707](compiler-error-c3707.md)|'*membre*' : la méthode dispinterface doit avoir un DISPID|
|[Erreur du compilateur C3708](compiler-error-c3708.md)|'*fonction*' : utilisation incorrecte de'*Keyword*'; doit être membre d’une source d’événements compatible|
|[Erreur du compilateur C3709](compiler-error-c3709.md)|'*fonction*' : syntaxe incorrecte pour spécifier un événement dans __hook/__unhook|
|[Erreur du compilateur C3710](compiler-error-c3710.md)|'*fonction*' : syntaxe incorrecte pour spécifier un gestionnaire d’événements dans __hook/__unhook|
|[Erreur du compilateur C3711](compiler-error-c3711.md)|'*Event*' : une méthode source d’événement non managée doit retourner void ou un type intégral|
|[Erreur du compilateur C3712](compiler-error-c3712.md)|'*event_handler*' : une méthode de gestionnaire d’événements doit retourner le même type que le'*Event*'source|
|[Erreur du compilateur C3713](compiler-error-c3713.md)|'*event_handler*' : une méthode de gestionnaire d’événements doit avoir les mêmes paramètres de fonction que le'*Event*'source|
|[Erreur du compilateur C3714](compiler-error-c3714.md)|'*event_handler*' : une méthode de gestionnaire d’événements doit avoir la même convention d’appel que la'*Event*'source|
|[Erreur du compilateur C3715](compiler-error-c3715.md)|'*pointeur*' : doit être un pointeur vers'*type*'|
|Erreur du compilateur C3716|Obsolète.|
|[Erreur du compilateur C3717](compiler-error-c3717.md)|'*membre*' : une méthode qui déclenche des événements ne peut pas être définie|
|[Erreur du compilateur C3718](compiler-error-c3718.md)|peut uniquement appeler' _ _*Keyword*'dans le contexte d’une fonction membre de la classe réceptrice|
|[Erreur du compilateur C3719](compiler-error-c3719.md)|'*membre*' : une source d’événements basée sur une interface ne peut être utilisée que pour les événements com|
|Erreur du compilateur C3720|'*type*' : peut uniquement implémenter IDispatch sur un Dual ou une dispinterface|
|[Erreur du compilateur C3721](compiler-error-c3721.md)|'*signature*' : signature incompatible pour l’événement|
|[Erreur du compilateur C3722](compiler-error-c3722.md)|événement générique non autorisé|
|[Erreur du compilateur C3723](compiler-error-c3723.md)|'*fonction*' : impossible de résoudre l’événement|
|[Erreur du compilateur C3724](compiler-error-c3724.md)|doit #include \<Windows. h > pour utiliser le Multi-Threading avec les événements|
|Erreur du compilateur C3725|Obsolète.|
|Erreur du compilateur C3726|Obsolète.|
|[Erreur du compilateur C3727](compiler-error-c3727.md)|'*Event*' : un événement managé doit être une fonction membre ou un membre de données qui est un pointeur vers un délégué|
|[Erreur du compilateur C3728](compiler-error-c3728.md)|'*Event*' : l’événement n’a pas de méthode Raise|
|Erreur du compilateur C3729|Obsolète.|
|Erreur du compilateur C3730|Obsolète.|
|[Erreur du compilateur C3731](compiler-error-c3731.md)|événement'*Event*'et gestionnaire'*event_handler*'incompatible ; la source d’événements et le gestionnaire d’événements doivent avoir le même type d’événement|
|[Erreur du compilateur C3732](compiler-error-c3732.md)|'*interface*' : une interface personnalisée qui déclenche des événements com ne peut pas hériter de IDispatch|
|[Erreur du compilateur C3733](compiler-error-c3733.md)|'*Event*' : syntaxe incorrecte pour la spécification d’un événement com ; avez-vous oublié' __interface' ?|
|[Erreur du compilateur c3734](compiler-error-c3734.md)|'*classe*' : une classe managée/WinRT ne peut pas être une coclasse|
|Erreur du compilateur C3735|Obsolète.|
|[Erreur du compilateur C3736](compiler-error-c3736.md)|'*membre*' : doit être une méthode ou, dans le cas d’événements managés, éventuellement un membre de données|
|[Erreur du compilateur C3737](compiler-error-c3737.md)|'*identificateur*' : un délégué ne peut pas avoir de convention d’appel explicite|
|[Erreur du compilateur C3738](compiler-error-c3738.md)|'*Convention*' : la Convention d’appel de l’instanciation explicite doit correspondre à celle du modèle instancié|
|[Erreur du compilateur C3739](compiler-error-c3739.md)|'*Class*' : la syntaxe est prise en charge uniquement quand le paramètre’layout\_dependent’de event_receiver a la valeur true|
|[Erreur du compilateur C3740](compiler-error-c3740.md)|'*modèle*' : les modèles ne peuvent pas recevoir d’événements source ou de réception|
|[Erreur du compilateur C3741](compiler-error-c3741.md)|'*Class*' : doit être une coclasse quand le paramètre’layout\_dependent’de event_receiver a la valeur true|
|Erreur du compilateur C3742|'*TOKEN1*' : séquence de jeton déséquilibrée dans l’argument d’attribut de'*attribute*', '*Token2*'attendu|
|[Erreur du compilateur C3743](compiler-error-c3743.md)|peut uniquement raccorder/décrocher une interface entière quand le paramètre « layout_dependent » de event_receiver a la valeur true|
|[Erreur du compilateur C3744](compiler-error-c3744.md)|__unhook doit avoir au moins 3 arguments pour les événements managés|
|[Erreur du compilateur C3745](compiler-error-c3745.md)|'*Function*' : seul un événement peut être’relief'|
|Erreur du compilateur C3746|l’attribut standard'*identifier*'ne peut apparaître qu’une seule fois dans une liste d’attributs|
|[Erreur du compilateur C3747](compiler-error-c3747.md)|paramètre générique/modèle par défaut manquant : *nombre* de paramètres|
|[Erreur du compilateur C3748](compiler-error-c3748.md)|'*interface*' : les interfaces non managées ne peuvent pas déclencher d’événements|
|[Erreur du compilateur C3749](compiler-error-c3749.md)|'*attribute*' : un attribut personnalisé ne peut pas être utilisé dans une fonction|
|Erreur du compilateur C3750|'*Token*' : jeton inattendu dans la liste d’attributs|
|Erreur du compilateur C3751|'*identificateur*' : identificateur inattendu dans la liste d’attributs|
|[Erreur du compilateur C3752](compiler-error-c3752.md)|'*attribute*' : impossible de classer l’attribut ; '*Keyword*'ne doit pas être utilisé dans ce contexte|
|[Erreur du compilateur C3753](compiler-error-c3753.md)|une propriété générique n’est pas autorisée|
|[Erreur du compilateur C3754](compiler-error-c3754.md)|constructeur délégué : la fonction membre'*member*'ne peut pas être appelée sur une instance de type'*type*'|
|[Erreur du compilateur C3755](compiler-error-c3755.md)|'*identificateur*' : un délégué ne peut pas être défini|
|Erreur du compilateur C3756|Obsolète.|
|Erreur du compilateur C3757|'*type*' : type non autorisé pour la fonction’constexpr'|
|Erreur du compilateur C3758|'*membre*' : la fonction virtuelle ne peut pas être déclarée’constexpr'|
|Erreur du compilateur C3759|'*membre*' : une fonction membre de type non littéral ne peut pas être déclarée’constexpr'|
|Erreur du compilateur C3760|Utilisez __property mot clé pour déclarer la propriété dans Managed/WinRT'*Class*'|
|[Erreur du compilateur C3761](compiler-error-c3761.md)|'*fonction*' : 'retval’ne peut figurer que sur le dernier argument d’une fonction|
|[Erreur du compilateur C3762](compiler-error-c3762.md)|Impossible de traiter l’attribut'*attribut*'|
|[Erreur du compilateur C3763](compiler-error-c3763.md)|'*type*' : 'retval’et’out’ne peuvent figurer que sur un type pointeur de données|
|[Erreur du compilateur C3764](compiler-error-c3764.md)|'*membre*' : impossible de substituer la méthode de la classe de base'*membre*'|
|[Erreur du compilateur C3765](compiler-error-c3765.md)|'*Event*' : impossible de définir un événement dans un class/struct'*type*'marqué comme event_receiver|
|[Erreur du compilateur C3766](compiler-error-c3766.md)|'*type*'doit fournir une implémentation pour la méthode d’interface'*Function*'|
|[Erreur du compilateur C3767](compiler-error-c3767.md)|'*fonction*' : la ou les fonctions candidates ne sont pas accessibles|
|[Erreur du compilateur C3768](compiler-error-c3768.md)|Impossible de prendre l’adresse d’une fonction vararg virtuelle dans du code managé pur|
|[Erreur du compilateur C3769](compiler-error-c3769.md)|'*identificateur*' : une classe imbriquée ne peut pas avoir le même nom que la classe immédiatement englobante|
|Erreur du compilateur C3770|'*type*' : n’est pas une classe de base valide|
|[Erreur du compilateur C3771](compiler-error-c3771.md)|'*identificateur*' : déclaration Friend introuvable dans la portée espace de noms la plus proche|
|[Erreur du compilateur C3772](compiler-error-c3772.md)|'*identificateur*' : déclaration de modèle Friend non valide|
|Erreur du compilateur C3773|Utilisez le commutateur de compilateur/await pour activer les coroutines|
|Erreur du compilateur C3774|Impossible de trouver'*scope*::*identifier*' : inclure l’en-tête d' *en* -tête|
|Erreur du compilateur C3775|le type de retour de'*Function*'ne doit pas être'*type*'|
|Erreur du compilateur C3776|Impossible de retourner un en expression de type void dans une Coroutine avec un type de retour éventuel non void|
|Erreur du compilateur C3777|'*fonction*' : une Coroutine ne peut pas accepter une liste d’arguments variable|
|Erreur du compilateur C3778|alloca : ne peut pas être utilisé dans une Coroutine|
|Erreur du compilateur C3779|'*fonction*' : une fonction qui retourne'*type*'ne peut pas être utilisée avant d’être définie|
|Erreur du compilateur C3780|'*fonction*' : une fonction de conversion qui retourne'*type*'ne peut pas être utilisée avant d’être définie|
|Erreur du compilateur C3781|'*Keyword*' : ne peut pas être utilisé dans une Coroutine de type'*type*'. Un *mot clé* ou un *mot clé* doit être présent dans le promise_type associé|
|Erreur du compilateur C3782|*type*: la promesse d’une Coroutine ne peut pas contenir à la fois le mot *clé* et le *mot clé*|
|Erreur du compilateur C3783|'*identificateur*' : ne peut pas être une Coroutine|
|Erreur du compilateur C3784|l’expression de *mot clé* ne peut pas apparaître dans ce contexte|
|Erreur du compilateur C3785|le premier argument template de’std :: integer_sequence’doit être un type entier|
|Erreur du compilateur C3786|le deuxième argument template de’std :: make_integer_sequence’doit être une constante entière supérieure ou égale à zéro|
|Erreur du compilateur C3787|Impossible de déduire le type de retour de cette Coroutine|
|Erreur du compilateur C3788|Obsolète.|
|Erreur du compilateur C3789|Obsolète.|
|Erreur du compilateur C3790|Obsolète.|
|Erreur du compilateur C3791|Obsolète.|
|Erreur du compilateur C3792|Obsolète.|
|Erreur du compilateur C3793|Obsolète.|
|Erreur du compilateur C3794|Obsolète.|
|Erreur du compilateur C3795|Obsolète.|
|Erreur du compilateur C3796|Obsolète.|
|[Erreur du compilateur C3797](compiler-error-c3797.md)|'*Keyword*' : la déclaration d’événement ne peut pas avoir de spécificateur de substitution (doit être placé sur les méthodes Add/Remove/Raise de l’événement à la place)|
|[Erreur du compilateur C3798](compiler-error-c3798.md)|'*Keyword*' : la déclaration de propriété ne peut pas avoir de spécificateur de substitution (doit être placé sur les méthodes Property/Set à la place)|
|[Erreur du compilateur C3799](compiler-error-c3799.md)|la propriété indexée ne peut pas avoir une liste de paramètres vide|
|[Erreur du compilateur C3800](compiler-error-c3800.md)|'*déclaration*' : impossible de mélanger les propriétés et les événements|
|Erreur du compilateur C3801|'*attribute*' : l’attribut ne peut pas avoir de clause argument|
|Erreur du compilateur C3802|Obsolète.|
|[Erreur du compilateur C3803](compiler-error-c3803.md)|'*Property*' : la propriété a un type qui est incompatible avec l’un de ses accesseurs'*accessor*'|
|[Erreur du compilateur C3804](compiler-error-c3804.md)|'*membre*' : les méthodes d’accesseur d’une propriété doivent être toutes statiques ou non statiques|
|[Erreur du compilateur C3805](compiler-error-c3805.md)|'*Token*' : jeton inattendu, '} 'ou', 'attendu|
|Erreur du compilateur C3806|'*Token*' : jeton inattendu, ' {'ou initialiseur de membre ATTENDU|
|[Erreur du compilateur C3807](compiler-error-c3807.md)|'*type*' : une classe avec l’attribut ComImport ne peut pas dériver de'*type*', seule l’implémentation d’interface est autorisée|
|[Erreur du compilateur C3808](compiler-error-c3808.md)|'*type*' : une classe avec l’attribut ComImport ne peut pas définir le membre'*member*', seules les fonctions abstract ou dllimport sont autorisées|
|[Erreur du compilateur C3809](compiler-error-c3809.md)|'*type*' : un type managé/WinRT ne peut pas avoir de fonctions/classes/interfaces Friend|
|Erreur du compilateur C3810|Obsolète.|
|Erreur du compilateur C3811|Obsolète.|
|[Erreur du compilateur C3812](compiler-error-c3812.md)|' __property’doit être le premier jeton dans une déclaration de propriété|
|[Erreur du compilateur C3813](compiler-error-c3813.md)|une déclaration de propriété ne peut apparaître que dans la définition d’un type managé/WinRT|
|Erreur du compilateur C3814|Obsolète.|
|[Erreur du compilateur C3815](compiler-error-c3815.md)|le type de retour de la méthode'*member*'doit correspondre au type du dernier paramètre d’un accesseur Set|
|[Erreur du compilateur C3816](compiler-error-c3816.md)|'class/struct *member*'a été précédemment déclaré ou défini avec un autre modificateur Managed/WinRT|
|[Erreur du compilateur C3817](compiler-error-c3817.md)|'*déclaration*' : la propriété ne peut être appliquée qu’à une fonction|
|[Erreur du compilateur C3818](compiler-error-c3818.md)|la déclaration de propriété de tableau'*Property*'ne doit pas surcharger une propriété d’index'*Property*'|
|Erreur du compilateur C3819|Obsolète.|
|[Erreur du compilateur C3820](compiler-error-c3820.md)|'*identificateur*' : les initialiseurs doivent être managés|
|[Erreur du compilateur C3821](compiler-error-c3821.md)|'*fonction*' : impossible d’utiliser un type ou une fonction managée dans une fonction non managée|
|Erreur du compilateur C3822|Obsolète.|
|Erreur du compilateur C3823|Obsolète.|
|[Erreur du compilateur C3824](compiler-error-c3824.md)|'*type*' : ce type ne peut pas apparaître dans ce contexte (paramètre de fonction, type de retour ou membre statique)|
|[Erreur du compilateur C3825](compiler-error-c3825.md)|'*type*' : une classe managée/WinRT peut uniquement prendre en charge les événements managés/WinRT|
|Erreur du compilateur C3826|Obsolète.|
|Erreur du compilateur C3827|l’attribut standard’Deprecated’peut n’avoir aucun argument ou un littéral de chaîne décrivant la raison|
|[Erreur du compilateur C3828](compiler-error-c3828.md)|les arguments de positionnement ne peuvent pas être spécifiés pour une expression'*Keyword*'pour le type'*type*'|
|Erreur du compilateur C3829|l’attribut standard’noreturn’ne peut être appliqué qu’à des fonctions|
|[Erreur du compilateur C3830](compiler-error-c3830.md)|'*type1*' : ne peut pas hériter de'*type2*', les types valeur peuvent uniquement hériter de classes interface|
|[Erreur du compilateur C3831](compiler-error-c3831.md)|'*identifier*' : '*type*'ne peut pas avoir de membre de données épinglé ou une fonction membre qui retourne un pointeur épingle|
|[Erreur du compilateur C3832](compiler-error-c3832.md)|'*TypeLib*' : la bibliothèque de types semble avoir été créée pour les pointeurs 32 bits ; Modifiez le qualificateur’ptrsize'|
|[Erreur du compilateur C3833](compiler-error-c3833.md)|'*type*' : type de cible non valide pour l' *identificateur*|
|[Erreur du compilateur C3834](compiler-error-c3834.md)|cast explicite non conforme vers un pointeur épingle ; Utilisez une variable locale épinglée à la place|
|Erreur du compilateur C3835|Obsolète.|
|[Erreur du compilateur C3836](compiler-error-c3836.md)|un constructeur statique n’est pas autorisé à avoir une liste d’initialiseurs de membres|
|Erreur du compilateur C3837|les attributs ne sont pas autorisés dans ce contexte|
|[Erreur du compilateur C3838](compiler-error-c3838.md)|Impossible d’hériter de'*type*'|
|[Erreur du compilateur C3839](compiler-error-c3839.md)|Impossible de changer l’alignement dans un type managé/WinRT|
|Erreur du compilateur C3840|Obsolète.|
|Erreur du compilateur C3841|Obsolète.|
|[Erreur du compilateur C3842](compiler-error-c3842.md)|'*identifier*' : les qualificateurs’const’et’volatile’sur les fonctions membres des types managés/WinRT ne sont pas pris en charge|
|Erreur du compilateur C3843|'*identificateur*' : les qualificateurs Ref sur les fonctions membres des types managés/WinRT ne sont pas pris en charge|
|Erreur du compilateur C3844|'*identificateur*' : impossible d’importer le symbole de'*source*' : comme'*identificateur*'existe déjà dans la portée actuelle|
|Erreur du compilateur C3845|Obsolète.|
|[Erreur du compilateur C3846](compiler-error-c3846.md)|'*identificateur*' : impossible d’importer le symbole de'*source*' : car'*identifier*'a déjà été importé à partir d’un autre assembly'*assembly*'|
|Erreur du compilateur C3847|Obsolète.|
|[Erreur du compilateur C3848](compiler-error-c3848.md)|l’expression ayant le type'*type*'perdrait certains qualificateurs const-volatile afin d’appeler'*identifier*'|
|[Erreur du compilateur C3849](compiler-error-c3849.md)|un appel de style fonction sur une expression de type'*type*'perdrait les qualificateurs const et/ou volatile pour toutes les surcharges d’opérateur *nombre* disponibles|
|[Erreur du compilateur C3850](compiler-error-c3850.md)|'*Token*' : un nom de caractère universel spécifie un caractère non valide|
|[Erreur du compilateur C3851](compiler-error-c3851.md)|'*Token*' : un nom de caractère universel ne peut pas désigner un caractère dans le jeu de caractères de base|
|[Erreur du compilateur C3852](compiler-error-c3852.md)|'*membre*'ayant le type'*type*' : l’initialisation d’agrégats n’a pas pu initialiser ce membre|
|[Erreur du compilateur C3853](compiler-error-c3853.md)|' = ' : la réinitialisation d’une référence ou d’une assignation via une référence à la fonction n’est pas conforme|
|[Erreur du compilateur C3854](compiler-error-c3854.md)|l’expression à gauche de' = 'prend la valeur d’une fonction. Impossible d’assigner à une fonction (une fonction n’est pas une l-value)|
|[Erreur du compilateur C3855](compiler-error-c3855.md)|'*fonction*' : le paramètre de modèle/générique'*identifier*'est incompatible avec la déclaration|
|[Erreur du compilateur C3856](compiler-error-c3856.md)|'*classe*' : la classe n’est pas un modèle de classe/générique|
|[Erreur du compilateur C3857](compiler-error-c3857.md)|'*template*' : plusieurs listes de paramètres de modèle/générique ne sont pas autorisées|
|[Erreur du compilateur C3858](compiler-error-c3858.md)|'*identificateur*' : ne peut pas être redéclaré dans la portée actuelle|
|[Erreur du compilateur C3859](compiler-error-c3859.md)|plage de mémoire virtuelle dépassée pour PCH ; Recompilez avec l’option de ligne de commande'-ZM*Number*'ou une valeur supérieure|
|[Erreur du compilateur C3860](compiler-error-c3860.md)|la liste d’arguments modèle/générique suivant le modèle de classe/nom générique doit répertorier les paramètres dans l’ordre utilisé dans la liste de paramètres de modèle/générique|
|[Erreur du compilateur C3861](compiler-error-c3861.md)|'*identificateur*' : identificateur introuvable|
|[Erreur du compilateur C3862](compiler-error-c3862.md)|'*fonction*' : impossible de compiler une fonction non managée avec/clr : pure ou/CLR : safe|
|Erreur du compilateur C3863|le type de tableau'*type*'ne peut pas être assigné|
|Erreur du compilateur C3864|Obsolète.|
|[Erreur du compilateur C3865](compiler-error-c3865.md)|'*Keyword*' : ne peut être utilisé que sur des fonctions membres natives|
|[Erreur du compilateur C3866](compiler-error-c3866.md)|liste d’arguments du destructeur/appel de finaliseur manquant|
|[Erreur du compilateur C3867](compiler-error-c3867.md)|'*fonction*' : syntaxe non standard ; Utilisez' & 'pour créer un pointeur vers un membre|
|[Erreur du compilateur C3868](compiler-error-c3868.md)|'*type*' : les contraintes du paramètre générique'*paramètre*'diffèrent de celles de la déclaration|
|[Erreur du compilateur C3869](compiler-error-c3869.md)|la contrainte gcnew ne contient pas de liste de paramètres vide' () '|
|Erreur du compilateur C3870|'*paramètre*' : ' __declspec (*spécificateur*) 'ne peut s’appliquer qu’aux paramètres de type intégral|
|Erreur du compilateur C3871|'*paramètre*' : ' __declspec (Guard (Overflow)) 'est uniquement pris en charge sur les 64 premiers paramètres d’une fonction|
|[Erreur du compilateur C3872](compiler-error-c3872.md)|' 0x*value*' : ce caractère n’est pas autorisé dans un identificateur|
|[Erreur du compilateur C3873](compiler-error-c3873.md)|' 0x*value*' : ce caractère n’est pas autorisé en tant que premier caractère d’un identificateur|
|[Erreur du compilateur C3874](compiler-error-c3874.md)|le type de retour de'*identifier*'doit être'*type1*'au lieu de'*type2*'|
|Erreur du compilateur C3875|appel d’une fonction membre non statique liste d’arguments manquante|
|Erreur du compilateur C3876|Obsolète.|
|Erreur du compilateur C3877|Obsolète.|
|Erreur du compilateur C3878|Obsolète.|
|Erreur du compilateur C3879|'*membre*' : ne peut pas être un membre de données initonly|
|[Erreur du compilateur C3880](compiler-error-c3880.md)|'*membre*' : ne peut pas être un membre de données littéral|
|Erreur du compilateur C3881|le constructeur peut uniquement hériter de la base directe|
|Erreur du compilateur C3882|'*classe*' : le constructeur a déjà été hérité de'*classe*'|
|Erreur du compilateur C3883|'*membre*' : les données membres static initonly doivent être initialisées|
|Erreur du compilateur C3884|'*type*' : un tableau de taille inconnue ne peut pas être initialisé par une valeur|
|Erreur du compilateur C3885|'*type*' : un tableau de taille inconnue ne peut pas être initialisé avec une liste d’initialiseurs vide|
|[Erreur du compilateur C3886](compiler-error-c3886.md)|'*membre*' : une donnée membre littérale doit être initialisée|
|[Erreur du compilateur C3887](compiler-error-c3887.md)|'*membre*' : l’initialiseur d’une donnée membre littérale doit être une expression constante|
|[Erreur du compilateur C3888](compiler-error-c3888.md)|'*membre*' : l’expression const associée à cette donnée membre littérale n’est pas C++prise en charge par/CLI|
|Erreur du compilateur C3889|Obsolète.|
|[Erreur du compilateur C3890](compiler-error-c3890.md)|'*membre*' : vous ne pouvez pas prendre l’adresse d’un membre de données littéral|
|[Erreur du compilateur C3891](compiler-error-c3891.md)|'*membre*' : un membre de données littéral ne peut pas être utilisé comme l-value|
|[Erreur du compilateur C3892](compiler-error-c3892.md)|'*variable*' : vous ne pouvez pas assigner une variable const|
|[Erreur du compilateur C3893](compiler-error-c3893.md)|'*membre*' : l’utilisation de l-value des données membres initonly n’est autorisée que dans un constructeur d’instance de la classe'*Class*'|
|[Erreur du compilateur C3894](compiler-error-c3894.md)|'*membre*' : l’utilisation de l-value des données membres static initonly n’est autorisée que dans le constructeur de classe de la classe'*Class*'|
|[Erreur du compilateur C3895](compiler-error-c3895.md)|'*membre*' : les données membres de *type* ne peuvent pas être’volatile'|
|[Erreur du compilateur C3896](compiler-error-c3896.md)|'*membre*' : initialiseur incorrect : cette donnée membre littérale ne peut être initialisée qu’avec’nullptr'|
|Erreur du compilateur C3897|Obsolète.|
|[Erreur du compilateur C3898](compiler-error-c3898.md)|'*membre*' : les données membres de *type* ne peuvent être membres que de types managés|
|[Erreur du compilateur C3899](compiler-error-c3899.md)|'*membre*' : l’utilisation de l-value des données membres initonly n’est pas autorisée directement dans une région parallèle de la classe'*Class*'|
|[Erreur du compilateur C3900](compiler-error-c3900.md)|'*membre*' : non autorisé dans la portée actuelle|
|[Erreur du compilateur C3901](compiler-error-c3901.md)|'*fonction*' : doit avoir le type de retour'*type*'|
|[Erreur du compilateur C3902](compiler-error-c3902.md)|'*fonction*' : le type du dernier paramètre doit être'*type*'|
|[Erreur du compilateur C3903](compiler-error-c3903.md)|'*Property*' : n’a pas de méthode Set ou d’extraction|
|[Erreur du compilateur C3904](compiler-error-c3904.md)|'*Property*' : vous devez spécifier un ou plusieurs paramètres de *nombre*|
|Erreur du compilateur C3905|les accès non alignés ne sont pas pris en charge pour le type intrinsèque'*type*'|
|Erreur du compilateur C3906|le type intrinsèque'*type*'n’est pas un type de retour ou d’argument pris en charge pour les fonctions vararg ou non prototypées|
|Erreur du compilateur C3907|Obsolète.|
|[Erreur du compilateur C3908](compiler-error-c3908.md)|niveau d’accès moins restrictif que celui de'*identifier*'|
|[Erreur du compilateur C3909](compiler-error-c3909.md)|une déclaration d’événement managé/WinRT doit se produire dans un type managé/WinRT|
|[Erreur du compilateur C3910](compiler-error-c3910.md)|'*Event*' : doit définir le membre'*member*'|
|[Erreur du compilateur C3911](compiler-error-c3911.md)|'*membre*' : la fonction doit avoir le type'*type*'|
|[Erreur du compilateur C3912](compiler-error-c3912.md)|'*Event*' : le type d’événement doit être un type délégué|
|[Erreur du compilateur C3913](compiler-error-c3913.md)|une propriété par défaut doit être indexée|
|[Erreur du compilateur C3914](compiler-error-c3914.md)|une propriété par défaut ne peut pas être static|
|[Erreur du compilateur C3915](compiler-error-c3915.md)|'*identifier*'n’a pas de propriété indexée par défaut (indexeur de classe)|
|Erreur du compilateur C3916|Obsolète.|
|[Erreur du compilateur C3917](compiler-error-c3917.md)|'*Token*' : style de déclaration de *construction* obsolète (vouliez-vous utiliser' [' '] 'à la place ?)|
|[Erreur du compilateur C3918](compiler-error-c3918.md)|l’utilisation requiert que'*identifier*'soit un membre de données|
|[Erreur du compilateur C3919](compiler-error-c3919.md)|'*fonction*' : la fonction doit avoir le type'*return_type* (*type*) '|
|[Erreur du compilateur C3920](compiler-error-c3920.md)|'*Operator*' : impossible de définir un opérateur d’incrémentation/de décrémentation suffixé/un opérateur WinRT appelant l’opérateur CLR/WinRT postfix qui appellera l’opérateur CLR/WinRT du préfixe correspondant (op_Increment/op_Decrement), mais avec la sémantique suffixée|
|Erreur du compilateur C3921|Obsolète.|
|Erreur du compilateur C3922|Obsolète.|
|[Erreur du compilateur C3923](compiler-error-c3923.md)|'*membre*' : les définitions de classes, de structures ou d’unions locales ne sont pas autorisées dans une fonction membre d’une classe managée/WinRT|
|Erreur du compilateur C3924|erreur dans l’argument #*nombre* d’appels du constructeur délégué'*constructor*' :|
|Erreur du compilateur C3925|boucle attendue (for, while ou do) à la suite de la directive'*directive*'|
|Erreur du compilateur C3926|constante non valide dans la directive’Parallel'|
|Erreur du compilateur C3927|'-> ' : le type de retour de fin n’est pas autorisé après un déclarateur qui n’est pas une fonction|
|Erreur du compilateur C3928|'-> ' : le type de retour de fin n’est pas autorisé après un déclarateur entre parenthèses|
|Erreur du compilateur C3929|Obsolète.|
|Erreur du compilateur C3930|'*fonction*' : aucune fonction surchargée n’a de spécificateurs de restriction qui sont compatibles avec le contexte ambiant'*Context*'|
|Erreur du compilateur C3931|'*type*' : impossible d’appeler une fonction qui a des spécificateurs de restriction incompatibles avec le contexte ambiant|
|Erreur du compilateur C3932|Obsolète.|
|Erreur du compilateur C3933|'*classe*' : les spécificateurs de restriction du destructeur doivent couvrir l’Union des restrictions sur tous les constructeurs|
|Erreur du compilateur C3934|une fonction qui se présente sous n’importe quelle forme de’main’ne peut pas avoir de spécificateurs de restriction autres que Restrict (CPU)|
|Erreur du compilateur C3935|'*identificateur*' : redéfinition ; spécificateurs de restriction qui se chevauchent|
|Erreur du compilateur C3936|'*identificateur*' : spécificateur de restriction non reconnu|
|Erreur du compilateur C3937|spécificateur de restriction vide non autorisé|
|Erreur du compilateur C3938|'*identificateur*' : plusieurs spécificateurs de restriction ne sont pas pris en charge sur les fonctions extern \042C\042|
|Erreur du compilateur C3939|'*identificateur*' : pointeur vers les fonctions membres, pointeurs de fonction, références à des fonctions avec le spécificateur de restriction’amp’non autorisé|
|Erreur du compilateur C3940|'*identificateur*' : identificateur introuvable-incompatibilité possible entre les versions du compilateur et de la bibliothèque. Vérifiez que vccorlib. h/. lib, vccorlib120. dll et c1xx. dll correspondent|
|Erreur du compilateur C3941|'*condition*' : requiert l’option de ligne de commande'/CLR'|
|Erreur du compilateur C3942|Obsolète.|
|Erreur du compilateur C3943|Obsolète.|
|Erreur du compilateur C3944|Obsolète.|
|Erreur du compilateur C3945|'*type*' : impossible de lever ou d’intercepter un objet WinRT qui ne dérive pas de Platform :: exception|
|Erreur du compilateur C3946|'*type*' : typeid ne peut pas être appliqué à ce type|
|Erreur du compilateur C3947|'*typeid*' : typeid ne peut pas être appliqué à une expansion de package|
|Erreur du compilateur C3948|'*Keyword*' : une expansion de package ne peut pas apparaître dans ce contexte|
|Erreur du compilateur C3949|une expansion de package, '... ', ne peut pas apparaître dans un déclarateur abstrait entre parenthèses|
|Erreur du compilateur C3950|Obsolète.|
|Erreur du compilateur C3951|Impossible d’utiliser pointeur vers membre dans le type WinRT projeté'*type*'. Utilisez à la place un délégué.|
|Erreur du compilateur C3952|'*type*' : WinRT ne prend pas en charge les tableaux’in/out'. Utilisez’const Array\<T > ^ 'pour’in’et’WriteOnlyArray\<T > 'ou’array\<T > ^ * 'pour’out’sur les API publiques|
|Erreur du compilateur C3953|Impossible d’utiliser la classe managée'*type*'dans le module WinRT.|
|Erreur du compilateur C3954|'*type*' : un tableau retourné à partir d’une méthode publiée sur un type WinRT doit utiliser le format’array\<t > ^ '|
|Erreur du compilateur C3955|'*type*' : un constructeur public ne peut pas contenir un paramètre’out’ou’WriteOnlyArray\<t > '|
|Erreur du compilateur C3956|'*type*' : le type est marqué comme exclusif à'*type*'et ne peut pas être utilisé comme base de'*derived_type*'|
|Erreur du compilateur C3957|'*type*' : impossible d’utiliser’New’sur un type WinRT ; Utilisez plutôt’Ref New'|
|Erreur du compilateur C3958|'*type*' : impossible d’utiliser’gcnew’sur un type WinRT ; Utilisez plutôt’Ref New'|
|Erreur du compilateur C3959|'Ref New’ne peut être utilisé que pour créer un objet avec le type WinRT|
|Erreur du compilateur C3960|Obsolète.|
|Erreur du compilateur C3961|le constructeur statique n’est pas pris en charge|
|Erreur du compilateur C3962|la classe générique n’est pas prise en charge|
|Erreur du compilateur C3963|le tableau multidimensionnel n’est pas pris en charge|
|Erreur du compilateur C3964|le tableau en escalier n’est pas pris en charge|
|Erreur du compilateur C3965|le tableau de paramètres n’est pas pris en charge|
|Erreur du compilateur C3966|'*fonction*' : la fonction générique n’est pas prise en charge|
|Erreur du compilateur C3967|erreur lors de l’importation de'*identifier*'à partir du module'*module*'|
|Erreur du compilateur C3968|le jeton'*Token*'n’est pas valide en tant que séparateur de nom de module ; Utilisez point ('. ') à la place|
|Erreur du compilateur C3969|noms de modules incohérents : '*Module1*'et'*Module1*'|
|Erreur du compilateur C3970|'*identifier*' : '*Keyword*'peut uniquement être appliqué à’ref class’ou’Ref struct’au niveau de la portée globale ou de la portée espace de noms|
|Erreur du compilateur C3971|'*type*' : une définition partielle ne peut pas apparaître après la définition complète|
|Erreur du compilateur C3972|'*type*' : 'partial’ne peut s’appliquer qu’aux définitions ou déclarations de classe|
|Erreur du compilateur C3973|Obsolète.|
|Erreur du compilateur C3974|Obsolète.|
|Erreur du compilateur C3975|'class/struct *identifier*'a été précédemment déclaré ou défini avec un autre modificateur|
|Erreur du compilateur C3976|'*identificateur1*'doit être déclaré comme’public’afin d’utiliser'*identificateur2*'|
|Erreur du compilateur C3977|L’utilisation requiert une référence à un assembly qui définit'*identifier*'|
|Erreur du compilateur C3978|'*identificateur*' : une propriété statique n’est pas autorisée en tant que membre d’une interface ou d’un type de valeur WinRT|
|Erreur du compilateur C3979|'*type*' : utilisez l’attribut'*attribute*'au lieu de'*value*'|
|Erreur du compilateur C3980|'*type*'ne peut pas être émis dans les métadonnées|
|Erreur du compilateur C3981|'*type*' : un type valeur ne peut pas avoir de membres de données static'*identificateur*'|
|Erreur du compilateur C3982|'*type*' : un type valeur ne peut pas avoir de membres de données non publics'*identificateur*'|
|Erreur du compilateur C3983|'*type*' : un type valeur ne peut pas avoir de membres non-données publics'*identificateur*'|
|Erreur du compilateur C3984|'*type*' : un type non-valeur ne peut pas avoir de membres de données publics'*identificateur*'|
|Erreur du compilateur C3985|'*identificateur*' : la signature du membre public contient le type privé'*membre*'|
|Erreur du compilateur C3986|'*identificateur*' : la signature du membre public contient le type natif'*membre*'|
|Erreur du compilateur C3987|'*identificateur*' : la signature du membre public contient le type natif'*type*'|
|Erreur du compilateur C3988|'*type*' : un type natif ne peut pas être public|
|Erreur du compilateur C3989|'*type*' : un type imbriqué ne peut pas être public|
|Erreur du compilateur C3990|'*type*' : l’attribut'*attribute*'ne peut pas être privé ni imbriqué|
|Erreur du compilateur C3991|'*type*' : impossible d’implémenter une interface non publique ou imbriquée'*interface*'|
|Erreur du compilateur C3992|'*identificateur*' : la signature du membre public contient un type non valide'*type*'|
|Erreur du compilateur C3993|'*type*' : un type valeur doit contenir au moins un champ public|
|Erreur du compilateur C3994|'*type*' : un type valeur ne peut pas implémenter des interfaces ni avoir des fonctions virtuelles|
|Erreur du compilateur C3995|'*type*' : un type valeur ne peut pas avoir de membres d’événement'*identificateur*'|
|Erreur du compilateur C3996|Obsolète.|
|Erreur du compilateur C3998|'c++*version*' : C++ version non prise en charge ; la valeur par défaut est « c++*version*»|
|Erreur du compilateur C3999|ERREUR inconnue choisissez la commande support technique du menu aide visuel C++ , ou ouvrez le fichier d’aide du support technique pour plus d’informations|

## <a name="see-also"></a>Voir aussi

[Erreurs etC++ avertissements du compilateur C/du compilateur et des outils de génération](../compiler-errors-1/c-cpp-build-errors.md) \
[Erreurs du compilateur C2000-C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
