---
title: CDC, classe | Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: reference
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
dev_langs:
- C++
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 9ba5dce4aec85a408b715e2df7bd5756dd534af2
ms.sourcegitcommit: 9a0905c03a73c904014ec9fd3d6e59e4fa7813cd
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/29/2018
ms.locfileid: "43211622"
---
# <a name="cdc-class"></a>CDC (classe)
Définit une classe d’objets de contexte de périphérique.  
  
## <a name="syntax"></a>Syntaxe  
  
```  
class CDC : public CObject  
```  
  
## <a name="members"></a>Membres  
  
### <a name="public-constructors"></a>Constructeurs publics  
  
|Nom|Description|  
|----------|-----------------|  
|[CDC::CDC](#cdc)|Construit un objet `CDC`.|  
  
### <a name="public-methods"></a>M&#233;thodes publiques  
  
|Nom|Description|  
|----------|-----------------|  
|[CDC::AbortDoc](#abortdoc)|Met fin au travail d’impression actuel, effacement de tout ce que l’application a écrit sur le périphérique depuis le dernier appel de la `StartDoc` fonction membre.|  
|[CDC::AbortPath](#abortpath)|Ferme et ignore les chemins d’accès dans le contexte de périphérique.|  
|[CDC::AddMetaFileComment](#addmetafilecomment)|Copie le commentaire d’une mémoire tampon dans un métafichier amélioré au format spécifié.|  
|[CDC::AlphaBlend](#alphablend)|Affiche les bitmaps qui ont des pixels transparents ou semi-transparent.|  
|[CDC::AngleArc](#anglearc)|Dessine un segment de ligne et un arc et déplace la position actuelle vers le point de fin de l’arc.|  
|[CDC::Arc](#arc)|Dessine un arc elliptique.|  
|[CDC::ArcTo](#arcto)|Dessine un arc elliptique. Cette fonction est similaire à `Arc`, sauf que la position actuelle est mise à jour.|  
|[CDC::Attach](#attach)|Attache un contexte de périphérique Windows ce `CDC` objet.|  
|[CDC::BeginPath](#beginpath)|Ouvre un crochet de chemin d’accès dans le contexte de périphérique.|  
|[CDC::BitBlt](#bitblt)|Copie une image bitmap à partir d’un contexte de périphérique spécifié.|  
|[CDC::Chord](#chord)|Dessine un segment (figure fermée délimitée par l’intersection d’une ellipse et un segment de ligne).|  
|[CDC::CloseFigure](#closefigure)|Ferme une figure ouverte dans un chemin d’accès.|  
|[CDC::CreateCompatibleDC](#createcompatibledc)|Crée un contexte de périphérique de mémoire qui est compatible avec un autre contexte de périphérique. Vous pouvez l’utiliser pour préparer des images en mémoire.|  
|[CDC::CreateDC](#createdc)|Crée un contexte de périphérique pour un périphérique spécifique.|  
|[CDC::CreateIC](#createic)|Crée un contexte d’information pour un périphérique spécifique. Cela fournit un moyen rapide pour obtenir des informations sur l’appareil sans créer un contexte de périphérique.|  
|[CDC::DeleteDC](#deletedc)|Supprime le contexte de périphérique Windows associé à cet `CDC` objet.|  
|[CDC::DeleteTempMap](#deletetempmap)|Appelé par le `CWinApp` Gestionnaire de durée d’inactivité à supprimer n’importe quel temporaire `CDC` objet créé par `FromHandle`. Détache également le contexte de périphérique.|  
|[CDC::Detach](#detach)|Détache le contexte de périphérique Windows à partir de ce `CDC` objet.|  
|[CDC::DPtoHIMETRIC](#dptohimetric)|Convertit des unités de périphérique en unités HIMETRIC.|  
|[CDC::DPtoLP](#dptolp)|Convertit des unités de périphérique en unités logiques.|  
|[CDC::Draw3dRect](#draw3drect)|Dessine un rectangle en trois dimensions.|  
|[CDC::DrawDragRect](#drawdragrect)|Efface et redessine un rectangle comme vous le faites glisser.|  
|[CDC::DrawEdge](#drawedge)|Dessine les bords d’un rectangle.|  
|[CDC::DrawEscape](#drawescape)|Accès d’un écran vidéo des fonctionnalités qui ne sont pas directement disponibles via l’interface graphique (GDI) de dessin.|  
|[CDC::DrawFocusRect](#drawfocusrect)|Dessine un rectangle dans le style utilisé pour indiquer le focus.|  
|[CDC::DrawFrameControl](#drawframecontrol)|Dessiner un contrôle frame.|  
|[CDC::DrawIcon](#drawicon)|Dessine une icône.|  
|[CDC::DrawState](#drawstate)|Affiche une image et applique un effet visuel pour indiquer un état.|  
|[CDC::DrawText](#drawtext)|Dessine mis en forme le texte dans le rectangle spécifié.|  
|[CDC::DrawTextEx](#drawtextex)|Dessine mis en forme le texte dans le rectangle spécifié à l’aide des formats supplémentaires.|  
|[CDC::ellipse](#ellipse)|Dessine une ellipse.|  
|[CDC::EndDoc](#enddoc)|Met fin à un travail d’impression démarré par le `StartDoc` fonction membre.|  
|[CDC::EndPage](#endpage)|Informe le pilote de périphérique une page se termine.|  
|[CDC::EndPath](#endpath)|Ferme un crochet de chemin d’accès et sélectionne le chemin d’accès défini par le crochet dans le contexte de périphérique.|  
|[CDC::EnumObjects](#enumobjects)|Énumère les stylets et pinceaux disponibles dans un contexte de périphérique.|  
|[CDC::escape](#escape)|Permet aux applications d’accéder aux fonctionnalités qui ne sont pas directement disponibles à partir d’un appareil particulier via GDI. Autorise également l’accès aux fonctions d’échappement de Windows. Les appels d’échappement effectués par une application sont traduits et envoyées au pilote de périphérique.|  
|[CDC::ExcludeClipRect](#excludecliprect)|Crée une nouvelle zone de découpage qui se compose de la zone de découpage existant moins le rectangle spécifié.|  
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Empêche le dessin dans les zones non valides d’une fenêtre en excluant une région de mise à jour dans la fenêtre à partir d’une zone de découpage.|  
|[CDC::ExtFloodFill](#extfloodfill)|Remplit une zone avec le pinceau actuel. Fournit plus de souplesse que le [CDC::FloodFill](#floodfill) fonction membre.|  
|[CDC::ExtTextOut](#exttextout)|Écrit une chaîne de caractères dans une zone rectangulaire à l’aide de la police actuellement sélectionnée.|  
|[CDC::FillPath](#fillpath)|Ferme des figures ouvertes dans le chemin d’accès actuel et remplit l’intérieur du chemin d’accès en utilisant le pinceau actuel et le mode de remplissage de polygones.|  
|[CDC::FillRect](#fillrect)|Remplit un rectangle donné à l’aide d’un pinceau spécifique.|  
|[CDC::FillRgn](#fillrgn)|Remplit une région spécifique avec le pinceau spécifié.|  
|[CDC::FillSolidRect](#fillsolidrect)|Remplit un rectangle avec une couleur unie.|  
|[CDC::FlattenPath](#flattenpath)|Transforme les courbes dans le chemin d’accès sélectionné dans le contexte de périphérique en cours et transforme chaque courbe en une séquence de lignes.|  
|[CDC::FloodFill](#floodfill)|Remplit une zone avec le pinceau actuel.|  
|[CDC::FrameRect](#framerect)|Dessine une bordure autour d’un rectangle.|  
|[CDC::FrameRgn](#framergn)|Dessine une bordure autour d’une région spécifique à l’aide d’un pinceau.|  
|[CDC::FromHandle](#fromhandle)|Retourne un pointeur vers un `CDC` lorsqu’un handle vers un contexte de périphérique de l’objet. Si aucun objet `CDC` n'est attaché au handle, un objet `CDC` temporaire est créé et attaché.|  
|[CDC::GetArcDirection](#getarcdirection)|Renvoie la direction d’arc de cercle en cours pour le contexte de périphérique.|  
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Récupère le paramètre pour le filtre de proportions en cours.|  
|[CDC::GetBkColor](#getbkcolor)|Récupère la couleur d’arrière-plan actuelle.|  
|[CDC::GetBkMode](#getbkmode)|Récupère le mode d’arrière-plan.|  
|[CDC::GetBoundsRect](#getboundsrect)|Retourne le rectangle englobant cumulé actuel pour le contexte de périphérique spécifié.|  
|[CDC::GetBrushOrg](#getbrushorg)|Récupère l’origine du pinceau actuel.|  
|[CDC::GetCharABCWidths](#getcharabcwidths)|Récupère les largeurs, en unités logiques, de caractères consécutifs dans une plage donnée à partir de la police actuelle.|  
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Récupère les largeurs, en unités logiques, des indices de glyphe consécutives dans une plage spécifiée à partir de la police TrueType actuelle.|  
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Récupère les différents types d’informations sur une chaîne de caractères.|  
|[CDC::GetCharWidth](#getcharwidth)|Récupère la largeur des fractions de seconde de caractères consécutifs dans une plage donnée à partir de la police actuelle.|  
|[CDC::GetCharWidthI](#getcharwidthi)|Récupère les largeurs, en coordonnées logiques, des indices de glyphe consécutives dans une plage spécifiée à partir de la police actuelle.|  
|[CDC::GetClipBox](#getclipbox)|Récupère les dimensions du rectangle englobant plus étroite autour de la limite actuelle de découpage.|  
|[CDC::GetColorAdjustment](#getcoloradjustment)|Récupère les valeurs d’ajustement de couleur pour le contexte de périphérique.|  
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Retourne un pointeur vers actuellement sélectionné `CBitmap` objet.|  
|[CDC::GetCurrentBrush](#getcurrentbrush)|Retourne un pointeur vers actuellement sélectionné `CBrush` objet.|  
|[CDC::GetCurrentFont](#getcurrentfont)|Retourne un pointeur vers actuellement sélectionné `CFont` objet.|  
|[CDC::GetCurrentPalette](#getcurrentpalette)|Retourne un pointeur vers actuellement sélectionné `CPalette` objet.|  
|[CDC::GetCurrentPen](#getcurrentpen)|Retourne un pointeur vers actuellement sélectionné `CPen` objet.|  
|[CDC::GetCurrentPosition](#getcurrentposition)|Récupère la position actuelle du stylet (en coordonnées logiques).|  
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Récupère la couleur actuelle du pinceau.|  
|[CDC::GetDCPenColor](#getdcpencolor)|Récupère la couleur actuelle du stylet.|  
|[CDC::GetDeviceCaps](#getdevicecaps)|Récupère un type spécifié des informations spécifiques au périphérique sur les fonctionnalités d’un périphérique d’affichage donné.|  
|[CDC::GetFontData](#getfontdata)|Récupère des informations de métriques de police à partir d’un fichier de polices évolutives. Les informations à récupérer sont identifiées en spécifiant un décalage dans le fichier de police et la longueur de l’information à retourner.|  
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Retourne des informations sur la police actuellement sélectionnée pour le contexte d’affichage spécifié.|  
|[CDC::GetGlyphOutline](#getglyphoutline)|Récupère la courbe de plan ou d’une image bitmap pour un caractère de contour dans la police actuelle.|  
|[CDC::GetGraphicsMode](#getgraphicsmode)|Récupère le mode graphique actuel pour le contexte de périphérique spécifié.|  
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Récupère un pinceau de demi-teintes.|  
|[CDC::GetKerningPairs](#getkerningpairs)|Récupère le caractère le crénage paires pour la police actuellement sélectionnée dans le contexte de périphérique spécifié.|  
|[CDC::GetLayout](#getlayout)|Récupère la disposition d’un contexte de périphérique (DC). La mise en page peut être soit de gauche à droite (valeur par défaut) ou de droite à gauche (mise en miroir).|  
|[CDC::GetMapMode](#getmapmode)|Récupère le mode de mappage actuel.|  
|[CDC::GetMiterLimit](#getmiterlimit)|Retourne la limite de pointe pour le contexte de périphérique.|  
|[CDC::GetNearestColor](#getnearestcolor)|Récupère la couleur de logique le plus proche à une couleur logique spécifiée que le périphérique donné peut représenter.|  
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Récupère des informations de métriques de police pour les polices TrueType.|  
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Récupère la largeur des caractères individuels d’un groupe de caractères consécutifs à partir de la police actuelle en utilisant le contexte de périphérique de sortie.|  
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Calcule la largeur et la hauteur d’une chaîne de caractères dans le contexte de périphérique de sortie.|  
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Calcule la largeur et la hauteur d’une ligne de texte sur le contexte de périphérique de sortie à l’aide de la police actuelle pour déterminer les dimensions.|  
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Récupère les mesures pour la police actuelle à partir du contexte de périphérique de sortie.|  
|[CDC::GetPath](#getpath)|Récupère les coordonnées définissant les points de terminaison de lignes et les points de contrôle des courbes trouvés dans le chemin d’accès qui est sélectionné dans le contexte de périphérique.|  
|[CDC::GetPixel](#getpixel)|Récupère la valeur de couleur RVB du pixel au point spécifié.|  
|[CDC::GetPolyFillMode](#getpolyfillmode)|Récupère le mode de remplissage de polygone actuel.|  
|[CDC::GetROP2](#getrop2)|Récupère le mode de dessin en cours.|  
|[CDC::GetSafeHdc](#getsafehdc)|Retourne [CDC::m_hDC](#m_hdc), le contexte de périphérique de sortie.|  
|[CDC::GetStretchBltMode](#getstretchbltmode)|Récupère le mode d’étirement de bitmap actuel.|  
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Calcule la largeur et la hauteur d’une chaîne de caractères dans le contexte de l’attribut.|  
|[CDC::GetTextAlign](#gettextalign)|Récupère les indicateurs de l’alignement du texte.|  
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Récupère le paramètre actuel pour la quantité d’espacement entre les caractères.|  
|[CDC::GetTextColor](#gettextcolor)|Récupère la couleur de texte actuelle.|  
|[CDC::GetTextExtent](#gettextextent)|Calcule la largeur et la hauteur d’une ligne de texte sur le contexte de périphérique d’attribut à l’aide de la police actuelle pour déterminer les dimensions.|  
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|Récupère le nombre de caractères dans une chaîne spécifiée qui occupent un espace spécifié et remplit un tableau avec l’étendue de texte pour chacun de ces caractères.|  
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Récupère la largeur et la hauteur du tableau spécifié d’indices de glyphe.|  
|[CDC::GetTextFace](#gettextface)|Copie le nom de la police actuelle dans une mémoire tampon sous la forme d’une chaîne se terminant par null.|  
|[CDC::GetTextMetrics](#gettextmetrics)|Récupère les mesures pour la police actuelle à partir du contexte de périphérique d’attribut.|  
|[CDC::GetViewportExt](#getviewportext)|Récupère les étendues x et y de la fenêtre d’affichage.|  
|[CDC::GetViewportOrg](#getviewportorg)|Récupère les coordonnées x et y de l’origine de la fenêtre d’affichage.|  
|[CDC::GetWindow](#getwindow)|Retourne la fenêtre associée au contexte de périphérique d’affichage.|  
|[CDC::GetWindowExt](#getwindowext)|Récupère les étendues x et y de la fenêtre associée.|  
|[CDC::GetWindowOrg](#getwindoworg)|Récupère les coordonnées x et y de l’origine de la fenêtre associée.|  
|[CDC::GetWorldTransform](#getworldtransform)|Récupère l’espace universel actuel pour la transformation de l’espace de page.|  
|[CDC::GradientFill](#gradientfill)|Remplit les structures de rectangle et un triangle avec une couleur gradating.|  
|[CDC::GrayString](#graystring)|Dessine estompé (grisé) de texte à l’emplacement donné.|  
|[CDC::HIMETRICtoDP](#himetrictodp)|Convertit en unités HIMETRIC en unités de périphérique.|  
|[CDC::HIMETRICtoLP](#himetrictolp)|Convertit en unités HIMETRIC dans des unités logiques.|  
|[CDC::IntersectClipRect](#intersectcliprect)|Crée une nouvelle zone de découpage par l’intersection de la région actuelle et un rectangle.|  
|[CDC::InvertRect](#invertrect)|Inverse le contenu d’un rectangle.|  
|[CDC::InvertRgn](#invertrgn)|Inverse les couleurs dans une région.|  
|[CDC::IsPrinting](#isprinting)|Détermine si le contexte de périphérique est utilisé pour l’impression.|  
|[CDC::LineTo](#lineto)|Dessine une ligne à partir de la position actuelle jusqu'à, non compris, un point.|  
|[CDC::LPtoDP](#lptodp)|Convertit des unités logiques en unités de périphérique.|  
|[CDC::LPtoHIMETRIC](#lptohimetric)|Convertit des unités logiques en unités HIMETRIC.|  
|[CDC::MaskBlt](#maskblt)|Combine les données de couleur pour les bitmaps de source et de destination en utilisant le masque donné et l’opération de rastérisation.|  
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Modifie la transformation universelle pour un contexte de périphérique en utilisant le mode spécifié.|  
|[CDC::MoveTo](#moveto)|Déplace la position actuelle.|  
|[CDC::OffsetClipRgn](#offsetcliprgn)|Déplace la zone de découpage de l’appareil donné.|  
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Modifie l’origine de la fenêtre d’affichage relatif aux coordonnées de l’origine de la fenêtre d’affichage actuel.|  
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Modifie l’origine de la fenêtre relatif aux coordonnées de l’origine de fenêtre actuelle.|  
|[CDC::PaintRgn](#paintrgn)|Remplit une zone avec le pinceau sélectionné.|  
|[CDC::PatBlt](#patblt)|Crée un modèle binaire.|  
|[CDC::Pie](#pie)|Dessine un graphique à secteurs.|  
|[CDC::PlayMetaFile](#playmetafile)|Lit le contenu du métafichier spécifié sur le périphérique donné. La version améliorée du `PlayMetaFile` affiche l’image stockée dans le métafichier de format amélioré donné. Métafichier peut être lus à n’importe quel nombre de fois.|  
|[CDC::PlgBlt](#plgblt)|Effectue un transfert de bloc de bits des bits de données de couleur du rectangle spécifié dans le contexte du périphérique source en parallélogramme spécifié dans le contexte de périphérique donné.|  
|[CDC::PolyBezier](#polybezier)|Dessine une ou plusieurs splines Bzier. La position actuelle n’est ni utilisée ni mis à jour.|  
|[CDC::PolyBezierTo](#polybezierto)|Dessine une ou plusieurs splines Bzier et déplace la position actuelle vers le point de fin de la dernière spline Bzier.|  
|[CDC::PolyDraw](#polydraw)|Dessine un ensemble de segments de ligne et Bzier splines. Cette fonction met à jour la position actuelle.|  
|[CDC::Polygon](#polygon)|Dessine un polygone consistant en deux ou plusieurs points (sommets) reliés par des lignes.|  
|[CDC::Polyline](#polyline)|Dessine un jeu de segments de ligne reliant les points spécifiés.|  
|[CDC::PolylineTo](#polylineto)|Dessine une ou plusieurs lignes droites et déplace la position actuelle vers le point de fin de la dernière ligne.|  
|[CDC::PolyPolygon](#polypolygon)|Crée deux ou plusieurs polygones qui sont remplis à l’aide du mode de remplissage de polygones en cours. Les polygones peuvent être disjoints ou ils peuvent se chevaucher.|  
|[CDC::PolyPolyline](#polypolyline)|Dessine plusieurs séries de segments de ligne connectés. La position actuelle n’est ni utilisée ni mis à jour par cette fonction.|  
|[CDC::PtVisible](#ptvisible)|Spécifie si le point donné se trouve dans la zone de découpage.|  
|[CDC::RealizePalette](#realizepalette)|Mappe des entrées de la palette dans la palette logique en cours à la palette système.|  
|[CDC::rectangle](#rectangle)|Dessine un rectangle en utilisant le stylet actuel et le remplit à l’aide de la brosse courante.|  
|[CDC::RectVisible](#rectvisible)|Détermine si une partie du rectangle donné se trouve dans la zone de découpage.|  
|[CDC::ReleaseAttribDC](#releaseattribdc)|Les versions `m_hAttribDC`, le contexte de l’attribut.|  
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Les versions `m_hDC`, le contexte de périphérique de sortie.|  
|[CDC::ResetDC](#resetdc)|Mises à jour le `m_hAttribDC` contexte de périphérique.|  
|[CDC::RestoreDC](#restoredc)|Restaure le contexte de périphérique à un état antérieur enregistré avec `SaveDC`.|  
|[CDC::RoundRect](#roundrect)|Dessine un rectangle avec coins arrondis à l’aide du stylet courant et rempli à l’aide de la brosse courante.|  
|[CDC::SaveDC](#savedc)|Enregistre l’état actuel du contexte de périphérique.|  
|[CDC::ScaleViewportExt](#scaleviewportext)|Modifie l’étendue de la fenêtre d’affichage par rapport aux valeurs actuelles.|  
|[CDC::ScaleWindowExt](#scalewindowext)|Modifie les étendues de fenêtre par rapport aux valeurs actuelles.|  
|[CDC::ScrollDC](#scrolldc)|Fait défiler un rectangle de bits horizontalement et verticalement.|  
|[CDC::SelectClipPath](#selectclippath)|Sélectionne le chemin d’accès actuel comme une zone de découpage pour le contexte de périphérique, en combinant la nouvelle région avec n’importe quelle région de découpage existant en utilisant le mode spécifié.|  
|[CDC::SelectClipRgn](#selectcliprgn)|Combine la région donnée avec la zone de découpage actuelle en utilisant le mode spécifié.|  
|[CDC::SelectObject](#selectobject)|Sélectionne un objet de dessin GDI telles que d’un stylet.|  
|[CDC::SelectPalette](#selectpalette)|Sélectionne la palette logique.|  
|[CDC::SelectStockObject](#selectstockobject)|Sélectionne l’une des stylets stocks prédéfinis, pinceaux, polices fournies par Windows.|  
|[CDC::SetAbortProc](#setabortproc)|Définit une fonction de rappel fournies par le programmeur Windows appelle si un travail d’impression doit être abandonné.|  
|[CDC::SetArcDirection](#setarcdirection)|Définit le sens de dessin à utiliser pour les fonctions d’arc de cercle et le rectangle.|  
|[CDC::SetAttribDC](#setattribdc)|Jeux `m_hAttribDC`, le contexte de l’attribut.|  
|[CDC::SetBkColor](#setbkcolor)|Définit la couleur d’arrière-plan actuelle.|  
|[CDC::SetBkMode](#setbkmode)|Définit le mode d’arrière-plan.|  
|[CDC::SetBoundsRect](#setboundsrect)|Contrôle l’accumulation des informations de rectangle englobant pour le contexte de périphérique spécifié.|  
|[CDC::SetBrushOrg](#setbrushorg)|Spécifie l’origine pour le pinceau suivant sélectionné dans un contexte de périphérique.|  
|[CDC::SetColorAdjustment](#setcoloradjustment)|Définit les valeurs d’ajustement de couleur pour le contexte de périphérique en utilisant les valeurs spécifiées.|  
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Définit la couleur actuelle du pinceau.|  
|[CDC::SetDCPenColor](#setdcpencolor)|Définit la couleur actuelle du stylet.|  
|[CDC::SetGraphicsMode](#setgraphicsmode)|Définit le mode graphique actuel pour le contexte de périphérique spécifié.|  
|[CDC::SetLayout](#setlayout)|Modifie la disposition d’un contexte de périphérique (DC).|  
|[CDC::SetMapMode](#setmapmode)|Définit le mode de mappage actuel.|  
|[CDC::SetMapperFlags](#setmapperflags)|Modifie l’algorithme utilisé par le mappeur de police lorsqu’il mappe les polices logiques aux polices physiques.|  
|[CDC::SetMiterLimit](#setmiterlimit)|Définit la limite pour la longueur de jointures de pointe pour le contexte de périphérique.|  
|[CDC::SetOutputDC](#setoutputdc)|Jeux `m_hDC`, le contexte de périphérique de sortie.|  
|[CDC::SetPixel](#setpixel)|Définit le pixel au point spécifié pour l’approximation plus proche de la couleur spécifiée.|  
|[CDC::SetPixelV](#setpixelv)|Définit le pixel aux coordonnées spécifiées pour l’approximation plus proche de la couleur spécifiée. `SetPixelV` est plus rapide que `SetPixel` car il n’a pas besoin de retourner la valeur de couleur du point réellement peint.|  
|[CDC::SetPolyFillMode](#setpolyfillmode)|Définit le mode de remplissage de polygones.|  
|[CDC::SetROP2](#setrop2)|Définit le mode de dessin en cours.|  
|[CDC::SetStretchBltMode](#setstretchbltmode)|Définit le mode d’étirement de bitmap.|  
|[CDC::SetTextAlign](#settextalign)|Définit les indicateurs de l’alignement du texte.|  
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Définit l’espacement entre les caractères.|  
|[CDC::SetTextColor](#settextcolor)|Définit la couleur du texte.|  
|[CDC::SetTextJustification](#settextjustification)|Ajoute un espace pour les caractères de saut dans une chaîne.|  
|[CDC::SetViewportExt](#setviewportext)|Définit les étendues x et y de la fenêtre d’affichage.|  
|[CDC::SetViewportOrg](#setviewportorg)|Définit l’origine de la fenêtre d’affichage.|  
|[CDC::SetWindowExt](#setwindowext)|Définit les étendues x et y de la fenêtre associée.|  
|[CDC::SetWindowOrg](#setwindoworg)|Définit l’origine de la fenêtre du contexte de périphérique.|  
|[CDC::SetWorldTransform](#setworldtransform)|Définit l’espace universel actuel sur la transformation de l’espace de page.|  
|[CDC::StartDoc](#startdoc)|Informe le pilote de périphérique qui démarre un nouveau travail d’impression.|  
|[CDC::StartPage](#startpage)|Informe le pilote de périphérique qui démarre une nouvelle page.|  
|[CDC::StretchBlt](#stretchblt)|Déplace une image bitmap à partir d’un rectangle source et un appareil dans un rectangle de destination, étirant ou en compressant le bitmap si nécessaire pour l’adapter aux dimensions du rectangle de destination.|  
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Ferme des figures ouvertes dans un chemin d’accès, frappe le contour du chemin d’accès à l’aide du stylet actuel et remplit son intérieur en utilisant le pinceau actuel.|  
|[CDC::StrokePath](#strokepath)|Restitue le chemin d’accès spécifié à l’aide du stylet actuel.|  
|[CDC::TabbedTextOut](#tabbedtextout)|Écrit une chaîne de caractères à un emplacement spécifié, en développant des onglets pour les valeurs spécifiées dans un tableau de positions de taquet de tabulation.|  
|[CDC::TextOut](#textout)|Écrit une chaîne de caractères à un emplacement spécifié à l’aide de la police actuellement sélectionnée.|  
|[CDC::TransparentBlt](#transparentblt)|Transfère un bloc de bits des données de couleur à partir du contexte de périphérique source spécifié dans un contexte de périphérique de destination, rendu transparent dans le transfert d’une couleur spécifiée.|  
|[CDC::UpdateColors](#updatecolors)|Mises à jour la zone cliente du contexte de périphérique en mettant en correspondance en cours de couleurs dans la zone cliente de la palette système sur un pixel par pixel.|  
|[CDC::WidenPath](#widenpath)|Redéfinit le chemin d’accès actuel en tant que la zone serait être peinte si le chemin d’accès ont été dessiné à l’aide du stylet actuellement sélectionné dans le contexte de périphérique.|  
  
### <a name="public-operators"></a>Op&#233;rateurs publics  
  
|Nom|Description|  
|----------|-----------------|  
|[CDC::operator HDC](#operator_hdc)|Récupère le handle du contexte de périphérique.|  
  
### <a name="public-data-members"></a>Membres de données publics  
  
|Nom|Description|  
|----------|-----------------|  
|[CDC::m_hAttribDC](#m_hattribdc)|Le contexte de périphérique de l’attribut utilisé par ce `CDC` objet.|  
|[CDC::m_hDC](#m_hdc)|Le contexte de périphérique de sortie utilisé par ce `CDC` objet.|  
  
## <a name="remarks"></a>Notes  
 Le `CDC` objet fournit des fonctions membres pour travailler avec un contexte de périphérique, comme un affichage ou des imprimantes, ainsi que des membres pour travailler avec un contexte d’affichage associé à la zone cliente d’une fenêtre.  
  
 Exécuter des fonctions de tout le dessin via le membre un `CDC` objet. La classe fournit des fonctions membres pour les opérations de contexte de périphérique, utilisation des outils, sélection d’objets graphiques de type sécurisé device interface (GDI), de dessin et utilisation des couleurs et palettes. Il fournit également des fonctions membres pour obtenir et de définir les attributs de mappage, l’utilisation de la fenêtre d’affichage, utilisation de l’étendue de la fenêtre, convertir des coordonnées, l’utilisation de régions, de découpage, de tracer des lignes et dessiner des formes simples, points de suspension, de dessin et polygones. Fonctions membres sont également fournies pour dessiner du texte, l’utilisation avec des polices, à l’aide d’échappement d’imprimante, le défilement et lecture des métafichiers.  
  
 Pour utiliser un `CDC` de l’objet, le construire, puis appeler ses fonctions membres qui les fonctions de Windows qui utilisent des contextes de périphérique en parallèle.  
  
> [!NOTE]
>  Sous Windows 95/98, toutes les coordonnées d’écran sont limitées à 16 bits. Par conséquent, un **int** passé à un `CDC` fonction membre doit être compris entre-32768 et 32767.  
  
 Pour des utilisations spécifiques, la bibliothèque Microsoft Foundation Class fournit plusieurs classes dérivées de `CDC` . `CPaintDC` encapsule les appels à `BeginPaint` et `EndPaint`. `CClientDC` gère un contexte d’affichage liée à la zone cliente d’une fenêtre. `CWindowDC` gère un contexte d’affichage associé à une fenêtre entière, y compris son cadre et les contrôles. `CMetaFileDC` associe un contexte de périphérique à un métafichier.  
  
 `CDC` fournit deux fonctions membres, [GetLayout](#getlayout) et [SetLayout](#setlayout), pour inverser la disposition d’un contexte de périphérique, qui n’hérite pas de sa disposition à partir d’une fenêtre. Ce type orientation de droite à gauche est nécessaire pour les applications écrites pour les cultures, telles que l’arabe ou l’hébreu, où la disposition de caractère n’est pas la norme européenne.  
  
 `CDC` contient deux contextes de périphérique, [m_hDC](#m_hdc) et [m_hAttribDC](#m_hattribdc), qui, sur la création d’un `CDC` d’objet, reportez-vous au même appareil. `CDC` Indique à tous les appels GDI de sortie à `m_hDC` et la plupart des attributs GDI appelle à `m_hAttribDC`. (Un exemple d’un appel de l’attribut est `GetTextColor`, tandis que `SetTextColor` est un appel de sortie.)  
  
 Par exemple, le framework utilise ces contextes de deux périphérique pour implémenter un `CMetaFileDC` objet qui enverra sortie d’un métafichier lors de la lecture des attributs d’un appareil physique. Aperçu avant impression est implémentée dans le cadre de la même manière. Vous pouvez également utiliser les contextes de deux périphérique de manière similaire dans votre code spécifique à l’application.  
  
 Il se peut que vous devez parfois des informations de mesure de texte à la fois le `m_hDC` et `m_hAttribDC` contextes de périphérique. Les paires suivantes de fonctions fournissent cette fonctionnalité :  
  
|Utilise m_hAttribDC|Utilise m_hDC|  
|-----------------------|-----------------|  
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|  
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|  
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|  
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|  
  
 Pour plus d’informations sur `CDC`, consultez [contextes de périphérique](../../mfc/device-contexts.md).  
  
## <a name="inheritance-hierarchy"></a>Hiérarchie d'héritage  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 `CDC`  
  
## <a name="requirements"></a>Configuration requise  
 **En-tête :** afxwin.h  
  
##  <a name="abortdoc"></a>  CDC::AbortDoc  
 Met fin au travail d’impression en cours et efface tout ce que l’application a écrit sur le périphérique depuis le dernier appel à la [StartDoc](#startdoc) fonction membre.  
  
```  
int AbortDoc();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur supérieure ou égale à 0 en cas de réussite, ou une valeur négative si une erreur s’est produite. La liste suivante montre les valeurs d’erreur courants et leur signification :  
  
- Erreur générale de SP_ERROR.  
  
- SP_OUTOFDISK pas suffisamment d’espace disque est actuellement disponible pour la mise en attente, et davantage d’espace devient disponible.  
  
- SP_OUTOFMEMORY pas suffisamment de mémoire est disponible pour la mise en attente.  
  
- Utilisateur de SP_USERABORT a interrompu la tâche via le Gestionnaire d’impression.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre remplace la séquence d’échappement ABORTDOC imprimante.  
  
 `AbortDoc` doit être utilisé pour mettre fin à ce qui suit :  
  
-   Les opérations de l’impression qui ne spécifient pas une à l’aide de la fonction d’abort [SetAbortProc](#setabortproc).  
  
-   Les opérations de l’impression qui n’ont pas encore atteint leur première NEWFRAME ou le NEXTBAND d’échappement d’appel.  
  
 Si une application rencontre une erreur d’impression ou d’une opération d’impression a été annulée, elle ne devez pas tenter de terminer l’opération en utilisant le [EndDoc](#enddoc) ou `AbortDoc` fonctions membres de classe `CDC`. GDI termine automatiquement l’opération avant de retourner la valeur d’erreur.  
  
 Si l’application affiche une boîte de dialogue pour autoriser l’utilisateur à annuler l’opération d’impression, il doit appeler `AbortDoc` avant de détruire la boîte de dialogue.  
  
 Si le Gestionnaire d’impression a été utilisé pour démarrer le travail d’impression, l’appel `AbortDoc` efface le travail de spool entière, l’imprimante reçoit rien. Si le Gestionnaire d’impression n’était pas utilisé pour démarrer le travail d’impression, les données peuvent ont été envoyées à l’imprimante avant `AbortDoc` a été appelée. Dans ce cas, le pilote d’imprimante serait avoir réinitialisé l’imprimante (si possible) et fermé le travail d’impression.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::StartDoc](#startdoc).  
  
##  <a name="abortpath"></a>  CDC::AbortPath  
 Ferme et ignore les chemins d’accès dans le contexte de périphérique.  
  
```  
BOOL AbortPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 S’il existe un crochet de tracé ouvert dans le contexte de périphérique, le crochet de chemin d’accès est fermé et le chemin d’accès est ignorée. S’il existe une trajectoire fermée dans le contexte de périphérique, le chemin d’accès est ignoré.  
  
##  <a name="addmetafilecomment"></a>  CDC::AddMetaFileComment  
 Copie le commentaire d’une mémoire tampon dans un métafichier amélioré au format spécifié.  
  
```  
BOOL AddMetaFileComment(
    UINT nDataSize,  
    const BYTE* pCommentData);
```  
  
### <a name="parameters"></a>Paramètres  
 *nDataSize*  
 Spécifie la longueur de la mémoire tampon de commentaire, en octets.  
  
 *pCommentData*  
 Pointe vers la mémoire tampon qui contient le commentaire.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Un commentaire peut inclure des informations confidentielles, par exemple, la source de l’image et la date de création. Un commentaire doit commencer par une signature d’application, suivie des données. Commentaires ne doivent pas contenir de données spécifiques à la position. Données spécifiques à la position spécifient l’emplacement d’un enregistrement, et ne doit pas être inclus, car un métafichier peut être incorporé dans un autre métafichier. Cette fonction peut uniquement être utilisée avec les métafichiers améliorés.  
  
##  <a name="alphablend"></a>  CDC::AlphaBlend  
 Appelez cette fonction membre pour afficher des bitmaps qui ont des pixels transparents ou semi-transparent.  
  
```  
BOOL AlphaBlend(
    int xDest,  
    int yDest,  
    int nDestWidth,  
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    BLENDFUNCTION blend);
```  
  
### <a name="parameters"></a>Paramètres  
 *xDest*  
 Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle de destination.  
  
 *yDest*  
 Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle de destination.  
  
 *nDestWidth*  
 Spécifie la largeur, en unités logiques, du rectangle de destination.  
  
 *nDestHeight*  
 Spécifie la hauteur, en unités logiques, du rectangle de destination.  
  
 *pSrcDC*  
 Pointeur vers le contexte du périphérique source.  
  
 *xSrc*  
 Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle source.  
  
 *ySrc*  
 Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle source.  
  
 *nSrcWidth*  
 Spécifie la largeur, en unités logiques, du rectangle source.  
  
 *nSrcHeight*  
 Spécifie la hauteur, en unités logiques, du rectangle source.  
  
 *Blend*  
 Spécifie un [BLENDFUNCTION](/windows/desktop/api/wingdi/ns-wingdi-_blendfunction) structure.  
  
### <a name="return-value"></a>Valeur de retour  
 TRUE en cas de réussite, sinon FALSE.  
  
### <a name="remarks"></a>Notes  
 Consultez [AlphaBlend](/windows/desktop/api/wingdi/nf-wingdi-alphablend) dans le SDK Windows pour plus d’informations.  
  
##  <a name="anglearc"></a>  CDC::AngleArc  
 Dessine un segment de ligne et un arc.  
  
```  
BOOL AngleArc(
    int x,  
    int y,  
    int nRadius,  
    float fStartAngle,  
    float fSweepAngle);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du centre du cercle.  
  
 *y*  
 Spécifie la coordonnée y logique du centre du cercle.  
  
 *nRadius*  
 Spécifie le rayon du cercle en unités logiques. Cette valeur doit être positive.  
  
 *fStartAngle*  
 Spécifie l’angle de départ en degrés par rapport à l’axe des abscisses.  
  
 *fSweepAngle*  
 Spécifie l’angle de balayage en degrés par rapport à l’angle de départ.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le segment de ligne est dessiné à partir de la position actuelle vers le début de l’arc. L’arc est dessiné le long du périmètre d’un cercle avec le centre et le rayon donnée. La longueur de l’arc est définie par les angles de début et de balayage donnés.  
  
 `AngleArc` Déplace la position actuelle vers le point de fin de l’arc. L’arc dessiné par cette fonction peut sembler être elliptique, selon le mode de transformation et le mappage actuel. Avant de dessiner l’arc, cette fonction Dessine le segment de ligne à partir de la position actuelle vers le début de l’arc. L’arc est dessiné en construisant un cercle imaginaire avec le rayon spécifié autour du point central spécifié. Le point de départ de l’arc est déterminé par la mesure dans le sens anti-horaire à partir de l’axe des abscisses du cercle par le nombre de degrés de l’angle de début. Le point de fin se trouve de la même façon en mesurant dans le sens anti-horaire à partir du point de départ par le nombre de degrés de l’angle de balayage.  
  
 Si l’angle de balayage est supérieur à 360 degrés de l’arc est balayage plusieurs fois. Cette fonction dessine des lignes en utilisant le stylet actuel. La figure n’est pas remplie.  
  
##  <a name="arc"></a>  CDC::Arc  
 Dessine un arc elliptique.  
  
```  
BOOL Arc(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Arc(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Paramètres  
 *x1*  
 Spécifie la coordonnée x du coin supérieur gauche du rectangle englobant (en unités logiques).  
  
 *y1*  
 Spécifie la coordonnée y du coin supérieur gauche du rectangle englobant (en unités logiques).  
  
 *x2*  
 Spécifie la coordonnée x du coin inférieur droit du rectangle englobant (en unités logiques).  
  
 *y2*  
 Spécifie la coordonnée y du coin inférieur droit du rectangle englobant (en unités logiques).  
  
 *x3*  
 Spécifie le point (en unités logiques) de départ de la coordonnée x du point qui définit l’arc. Ce point n’a pas à se trouvent exactement à l’arc.  
  
 *Y3*  
 Spécifie le point (en unités logiques) de départ de la coordonnée y du point qui définit l’arc. Ce point n’a pas à se trouvent exactement à l’arc.  
  
 *X4*  
 Spécifie la coordonnée x du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se trouvent exactement à l’arc.  
  
 *Y4*  
 Spécifie la coordonnée y du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se trouvent exactement à l’arc.  
  
 *lpRect*  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer soit un LPRECT ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 *ptStart*  
 Spécifie les coordonnées x et y du point qui définit l’arc de départ de point (en unités logiques). Ce point n’a pas à se trouvent exactement à l’arc. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
 *ptEnd*  
 Spécifie les coordonnées x et y du point qui définit le point de fin de l’arc (en unités logiques). Ce point n’a pas à se trouvent exactement à l’arc. Vous pouvez passer soit un `POINT` structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 L’arc dessiné à l’aide de la fonction est un segment de l’ellipse définie par le rectangle englobant spécifié.  
  
 Le point de départ réels de l’arc est le point auquel un rayon dessiné à partir du centre du rectangle englobant via le point de départ spécifié entre en intersection avec l’ellipse. Le point de fin réels de l’arc est le point auquel un rayon dessiné à partir du centre du rectangle englobant via le point de fin spécifié entre en intersection avec l’ellipse. L’arc est dessiné dans le sens antihoraire. Dans la mesure où un arc n’est pas une figure fermée, il n’est pas rempli. La largeur et la hauteur du rectangle doivent être supérieures à 2 unités et inférieure à 32 767.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]  
  
##  <a name="arcto"></a>  CDC::ArcTo  
 Dessine un arc elliptique.  
  
```  
BOOL ArcTo(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL ArcTo(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Paramètres  
 *x1*  
 Spécifie la coordonnée x du coin supérieur gauche du rectangle englobant (en unités logiques).  
  
 *y1*  
 Spécifie la coordonnée y du coin supérieur gauche du rectangle englobant (en unités logiques).  
  
 *x2*  
 Spécifie la coordonnée x du coin inférieur droit du rectangle englobant (en unités logiques).  
  
 *y2*  
 Spécifie la coordonnée y du coin inférieur droit du rectangle englobant (en unités logiques).  
  
 *x3*  
 Spécifie le point (en unités logiques) de départ de la coordonnée x du point qui définit l’arc. Ce point n’a pas à se trouvent exactement à l’arc.  
  
 *Y3*  
 Spécifie le point (en unités logiques) de départ de la coordonnée y du point qui définit l’arc. Ce point n’a pas à se trouvent exactement à l’arc.  
  
 *X4*  
 Spécifie la coordonnée x du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se trouvent exactement à l’arc.  
  
 *Y4*  
 Spécifie la coordonnée y du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se trouvent exactement à l’arc.  
  
 *lpRect*  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer soit un pointeur vers un [RECT](../../mfc/reference/rect-structure1.md) structure de données ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 *ptStart*  
 Spécifie les coordonnées x et y du point qui définit l’arc de départ de point (en unités logiques). Ce point n’a pas à se trouvent exactement à l’arc. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure de données ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
 *ptEnd*  
 Spécifie les coordonnées x et y du point qui définit le point de fin de l’arc (en unités logiques). Ce point n’a pas à se trouvent exactement à l’arc. Vous pouvez passer soit un `POINT` structure de données ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction est similaire à `CDC::Arc`, sauf que la position actuelle est mise à jour. Les points ( *x1*, *y1*) et ( *x2*, *y2*) définissent le rectangle englobant. Une ellipse formée par le rectangle englobant donné définit la courbe de l’arc. L’arc s’étend dans le sens anti-horaire (la direction d’arc de cercle par défaut) à partir du point où il entre en intersection avec la ligne radiale à partir du centre du rectangle englobant pour ( *x3*, *y3*). Les terminaisons de l’arc où il entre en intersection avec la ligne radiale à partir du centre du rectangle englobant pour ( *x4*, *y4*). Si le point de départ et le point de fin sont identiques, une ellipse complète est dessinée.  
  
 Une ligne est dessinée à partir de la position actuelle pour le point de départ de l’arc. Si aucune erreur ne se produit, la position actuelle est définie pour le point de fin de l’arc. L’arc est dessiné en utilisant le stylet actuel ; Il n’est pas rempli.  
  
##  <a name="attach"></a>  CDC::Attach  
 Utilisez cette fonction membre pour attacher un *hDC* à la `CDC` objet.  
  
```  
BOOL Attach(HDC hDC);
```  
  
### <a name="parameters"></a>Paramètres  
 *hDC*  
 Un contexte de périphérique Windows.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le *hDC* sont stockées dans les deux `m_hDC`, le contexte de périphérique de sortie, puis, dans `m_hAttribDC`, le contexte de l’attribut.  
  
##  <a name="beginpath"></a>  CDC::BeginPath  
 Ouvre un crochet de chemin d’accès dans le contexte de périphérique.  
  
```  
BOOL BeginPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Après avoir ouvert un crochet de chemin d’accès, une application puisse commencer à l’appel de dessin GDI fonctions pour définir les points qui se trouvent dans le chemin d’accès. Une application peut fermer un crochet de tracé ouvert en appelant le `EndPath` fonction membre. Lorsqu’une application appelle `BeginPath`, les chemins d’accès précédentes sont ignorées.  
  
 Consultez [BeginPath](/windows/desktop/api/wingdi/nf-wingdi-beginpath) dans le SDK Windows pour obtenir la liste des fonctions de dessins qui définissent les points dans un chemin d’accès.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]  
  
##  <a name="bitblt"></a>  CDC::BitBlt  
 Copie une image bitmap à partir du contexte de périphérique source vers ce contexte de périphérique en cours.  
  
```  
BOOL BitBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle de destination.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle de destination.  
  
 *nWidth*  
 Spécifie la largeur (en unités logiques) de la bitmap source et le rectangle de destination.  
  
 *nHeight*  
 Spécifie la hauteur (en unités logiques) de la bitmap source et le rectangle de destination.  
  
 *pSrcDC*  
 Pointeur vers un `CDC` objet qui identifie le contexte de périphérique à partir duquel l’image bitmap est copié. Il doit être NULL si *dwRop* spécifie une opération de rastérisation qui n’inclut pas d’une source.  
  
 *xSrc*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche de la bitmap source.  
  
 *ySrc*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche de la bitmap source.  
  
 *dwRop*  
 Spécifie l'opération de rastérisation à effectuer. Codes d’opération de rastérisation définissent la façon dont GDI associe les couleurs dans les opérations de sortie qui impliquent un pinceau actuel, un éventuel bitmap source et une image bitmap de destination. Consultez [BitBlt](/windows/desktop/api/wingdi/nf-wingdi-bitblt) dans le SDK Windows pour obtenir la liste des codes d’opération de rastérisation pour *dwRop* et leurs descriptions  
  
 Pour obtenir une liste complète des codes d’opération de rastérisation, consultez [sur opération de rastérisation](/windows/desktop/gdi/raster-operation-codes) dans le SDK Windows.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 L’application peut aligner les fenêtres ou les zones clientes sur des limites d’octets pour vous assurer que les `BitBlt` interviennent dans les rectangles aligné sur un octet. (Définissez les indicateurs CS_BYTEALIGNWINDOW ou CS_BYTEALIGNCLIENT lorsque vous inscrivez les classes de fenêtre).  
  
 `BitBlt` opérations sur les rectangles aligné sur un octet sont sensiblement plus rapides que `BitBlt` opérations sur les rectangles qui ne sont pas alignées sur octets. Si vous souhaitez spécifier des styles de classe telles que de l’alignement des octets pour votre propre contexte de périphérique, vous devrez inscrire une classe de fenêtre plutôt que d’utiliser les classes Microsoft Foundation à faire pour vous. Utilisez la fonction globale [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).  
  
 GDI transforme *nWidth* et *nHeight*, une fois en utilisant le contexte de périphérique de destination et qu’une seule fois en utilisant le contexte de périphérique source. Si les étendues qui en résulte ne correspondent pas, GDI utilise le Windows `StretchBlt` fonction permettant de compresser ou étirer l’image bitmap source en fonction des besoins.  
  
 Si la destination, source et les bitmaps de modèle n’ont pas le même format de couleur, la `BitBlt` fonction convertit les bitmaps source et modèle pour correspondre à la destination. Les couleurs de premier plan et d’arrière-plan de la bitmap de destination sont utilisés dans la conversion.  
  
 Lorsque le `BitBlt` fonction convertit une image bitmap monochrome en couleur, il définit les bits blancs (1) à la couleur d’arrière-plan et les bits noirs (0) à la couleur de premier plan. Les couleurs de premier plan et d’arrière-plan du contexte de périphérique de destination sont utilisées. Pour convertir la couleur en monochrome, `BitBlt` définit les pixels qui correspondent à la couleur d’arrière-plan sur blanc et tous les autres pixels sur noir. `BitBlt` utilise les couleurs de premier plan et d’arrière-plan du contexte de périphérique de couleur pour convertir à partir de la couleur en monochrome.  
  
 Notez que la prise en charge pas tous les contextes de périphérique `BitBlt`. Pour vérifier si un contexte de périphérique donné ne prend pas en charge `BitBlt`, utilisez le `GetDeviceCaps` membre de fonction et de spécifier l’index RASTERCAPS.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::CreateCompatibleDC](#createcompatibledc).  
  
##  <a name="cdc"></a>  CDC::CDC  
 Construit un objet `CDC`.  
  
```  
CDC();
```  
  
##  <a name="chord"></a>  CDC::Chord  
 Dessine un segment (figure fermée délimitée par l’intersection d’une ellipse et un segment de ligne).  
  
```  
BOOL Chord(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Chord(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Paramètres  
 *x1*  
 Spécifie que la coordonnée x du coin supérieur gauche de la pression simultanée de délimitation de rectangle (en unités logiques).  
  
 *y1*  
 Spécifie que la coordonnée y du coin supérieur gauche de la pression simultanée de délimitation de rectangle (en unités logiques).  
  
 *x2*  
 Spécifie que la coordonnée x du coin inférieur droit de la pression simultanée de délimitation de rectangle (en unités logiques).  
  
 *y2*  
 Spécifie que la coordonnée y du coin inférieur droit de la pression simultanée de délimitation de rectangle (en unités logiques).  
  
 *x3*  
 Spécifie la coordonnée x du point qui définit la pression simultanée de départ de point (en unités logiques).  
  
 *Y3*  
 Spécifie la coordonnée y du point qui définit la pression simultanée de départ de point (en unités logiques).  
  
 *X4*  
 Spécifie la coordonnée x du point qui définit le point de terminaison de la pression simultanée (en unités logiques).  
  
 *Y4*  
 Spécifie la coordonnée y du point qui définit le point de terminaison de la pression simultanée (en unités logiques).  
  
 *lpRect*  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer soit un LPRECT ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 *ptStart*  
 Spécifie les coordonnées x et y du point qui définit la pression simultanée de départ de point (en unités logiques). Ce point n’a pas à se trouvent exactement à la pression simultanée. Vous pouvez passer soit un `POINT` structure ou un `CPoint` objet pour ce paramètre.  
  
 *ptEnd*  
 Spécifie les coordonnées x et y du point qui définit le point de fin de la pression simultanée (en unités logiques). Ce point n’a pas à se trouvent exactement à la pression simultanée. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le ( *x1*, *y1*) et ( *x2*, *y2*) les paramètres spécifient les angles supérieur gauche et inférieur droit, respectivement, d’un rectangle rectangle englobant de l’ellipse qui fait partie de la pression simultanée. Le ( *x3*, *y3*) et ( *x4*, *y4*) les paramètres spécifient les points de terminaison d’une ligne qui entre en intersection avec l’ellipse. La pression simultanée doit être dessinée à l’aide du stylet sélectionné et remplie à l’aide du pinceau sélectionné.  
  
 La figure dessinée par le `Chord` fonction étend jusqu'à, mais n’inclut pas les coordonnées de droite et en bas. Cela signifie que la hauteur de la figure est *y2* - *y1* et la largeur de la figure est *x2* - *x1*.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]  
  
##  <a name="closefigure"></a>  CDC::CloseFigure  
 Ferme une figure ouverte dans un chemin d’accès.  
  
```  
BOOL CloseFigure();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La fonction ferme la figure en dessinant une ligne à partir de la position actuelle au premier point de la figure (en règle générale, le point spécifié par le dernier appel à la `MoveTo` fonction membre) et se connecte les lignes en utilisant le style de ligne de jointure. Si une figure est fermée à l’aide de la `LineTo` fonction membre au lieu de `CloseFigure`, majuscules sont utilisées pour créer l’angle au lieu d’une jointure. `CloseFigure` doit être appelée uniquement s’il existe un crochet de tracé ouvert dans le contexte de périphérique.  
  
 Une figure dans un chemin d’accès n’est ouverte, sauf si elle est fermée explicitement à l’aide de cette fonction. (Figure peut être ouverte même si le point actuel et le point de départ de la figure sont identiques.) Toute ligne ou la courbe ajouté au chemin après `CloseFigure` démarre une nouvelle figure.  
  
##  <a name="createcompatibledc"></a>  CDC::CreateCompatibleDC  
 Crée un contexte de périphérique de mémoire qui est compatible avec l’appareil spécifié par *pDC*.  
  
```  
BOOL CreateCompatibleDC(CDC* pDC);
```  
  
### <a name="parameters"></a>Paramètres  
 *contrôleur de domaine principal*  
 Pointeur vers un contexte de périphérique. Si *pDC* est NULL, la fonction crée un contexte de périphérique de mémoire qui est compatible avec l’affichage du système.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Un contexte de périphérique de mémoire est un bloc de mémoire qui représente une surface d’affichage. Il peut être utilisé pour préparer des images en mémoire avant de les copier vers la surface de périphérique réel de l’appareil compatible.  
  
 Lorsqu’un contexte de périphérique de mémoire est créé, GDI sélectionne automatiquement un bitmap de stock monochrome 1-par-1 pour celui-ci. Fonctions de sortie GDI peuvent être utilisées avec un contexte de périphérique de mémoire uniquement si une image bitmap a été créée et sélectionnée dans ce contexte.  
  
 Cette fonction peut uniquement être utilisée pour créer des contextes de périphérique compatible pour les appareils qui prennent en charge les opérations raster. Consultez le [CDC::BitBlt](#bitblt) fonction membre pour plus d’informations concernant les transferts de bloc de bits entre les contextes de périphérique. Pour déterminer si un contexte de périphérique prend en charge les opérations raster, consultez la fonctionnalité de raster RC_BITBLT dans la fonction membre `CDC::GetDeviceCaps`.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]  
  
##  <a name="createdc"></a>  CDC::CreateDC  
 Crée un contexte de périphérique pour le périphérique spécifié.  
  
```  
BOOL CreateDC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpszDriverName*  
 Pointe vers une chaîne se terminant par null qui spécifie le nom de fichier (sans extension) du pilote de périphérique (par exemple, « EPSON »). Vous pouvez également passer un `CString` objet pour ce paramètre.  
  
 *lpszDeviceName*  
 Pointe vers une chaîne se terminant par null qui spécifie le nom de l’appareil spécifique pour être pris en charge (par exemple, « EPSON FX-80 »). Le *lpszDeviceName* paramètre est utilisé si le module prend en charge plusieurs appareils. Vous pouvez également passer un `CString` objet pour ce paramètre.  
  
 *lpszOutput*  
 Pointe vers une chaîne se terminant par null qui spécifie le nom de fichier ou périphérique pour la sortie physique du port de fichier ou sortie. Vous pouvez également passer un `CString` objet pour ce paramètre.  
  
 *lpInitData*  
 Pointe vers un `DEVMODE` structure contenant les données d’initialisation spécifique au périphérique pour le pilote de périphérique. Le Windows `DocumentProperties` fonction récupère cette structure renseignée pour un appareil donné. Le *lpInitData* paramètre doit être NULL si le pilote de périphérique est d’utiliser l’initialisation par défaut (le cas échéant) spécifiée par l’utilisateur via le panneau de configuration.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 L’impression. Fichier d’en-tête H est requise si le [DEVMODE](/windows/desktop/api/wingdi/ns-wingdi-_devicemodea) structure est utilisée.  
  
 Noms de périphérique respectent ces conventions : une fin (deux-points) est recommandé mais facultatif. Windows supprime les deux points de terminaison afin qu’un nom de l’appareil se terminant par un signe deux-points est mappé sur le même port que le même nom sans les deux-points. Les noms de pilote et le port ne doivent pas contenir des espaces de début ou de fin. GDI les fonctions de sortie ne peut pas être utilisées dans des contextes d’informations.  
  
##  <a name="createic"></a>  CDC::CreateIC  
 Crée un contexte d’information pour le périphérique spécifié.  
  
```  
BOOL CreateIC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpszDriverName*  
 Pointe vers une chaîne se terminant par null qui spécifie le nom de fichier (sans extension) du pilote de périphérique (par exemple, « EPSON »). Vous pouvez passer un `CString` objet pour ce paramètre.  
  
 *lpszDeviceName*  
 Pointe vers une chaîne se terminant par null qui spécifie le nom de l’appareil spécifique pour être pris en charge (par exemple, « EPSON FX-80 »). Le *lpszDeviceName* paramètre est utilisé si le module prend en charge plusieurs appareils. Vous pouvez passer un `CString` objet pour ce paramètre.  
  
 *lpszOutput*  
 Pointe vers une chaîne se terminant par null qui spécifie le nom de fichier ou périphérique pour le support de sortie physique (fichier ou port). Vous pouvez passer un `CString` objet pour ce paramètre.  
  
 *lpInitData*  
 Points de données d’initialisation spécifique au périphérique pour le pilote de périphérique. Le *lpInitData* paramètre doit être NULL si le pilote de périphérique est d’utiliser l’initialisation par défaut (le cas échéant) spécifiée par l’utilisateur via le panneau de configuration. Consultez `CreateDC` du format de données pour l’initialisation spécifique à l’appareil.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le contexte d’information fournit un moyen rapide pour obtenir des informations sur l’appareil sans créer un contexte de périphérique.  
  
 Noms de périphérique respectent ces conventions : une fin (deux-points) est recommandé mais facultatif. Windows supprime les deux points de terminaison afin qu’un nom de l’appareil se terminant par un signe deux-points est mappé sur le même port que le même nom sans les deux-points. Les noms de pilote et le port ne doivent pas contenir des espaces de début ou de fin. GDI les fonctions de sortie ne peut pas être utilisées dans des contextes d’informations.  
  
##  <a name="deletedc"></a>  CDC::DeleteDC  
 En règle générale, n’appelez pas cette fonction ; le destructeur s’en occuperont pour vous.  
  
```  
BOOL DeleteDC();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la fonction a été effectuée avec succès ; sinon 0.  
  
### <a name="remarks"></a>Notes  
 Le `DeleteDC` fonction membre supprime les contextes de périphérique Windows qui sont associées aux `m_hDC` en cours `CDC` objet. Si cette `CDC` objet est le dernier contexte de périphérique active pour un appareil donné, le périphérique est notifié et toutes les ressources système et de stockage utilisés par l’appareil sont libérées.  
  
 Une application ne doit pas appeler `DeleteDC` si les objets ont été sélectionnés dans le contexte de périphérique. Objets doivent être sélectionnés en premier en dehors du contexte de périphérique avant d’être supprimée.  
  
 Une application ne doit pas supprimer un contexte de périphérique dont le handle a été obtenu en appelant [CWnd::GetDC](../../mfc/reference/cwnd-class.md#getdc). Au lieu de cela, il doit appeler [CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) pour libérer le contexte de périphérique. Le [CClientDC](../../mfc/reference/cclientdc-class.md) et [CWindowDC](../../mfc/reference/cwindowdc-class.md) classes sont fournies pour encapsuler cette fonctionnalité.  
  
 Le `DeleteDC` fonction est généralement utilisée pour supprimer des contextes de périphérique créés avec [CreateDC](#createdc), [CreateIC](#createic), ou [CreateCompatibleDC](#createcompatibledc).  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).  
  
##  <a name="deletetempmap"></a>  CDC::DeleteTempMap  
 Appelé automatiquement par le `CWinApp` Gestionnaire de durée d’inactivité, `DeleteTempMap` supprime temporaires `CDC` objets créés par `FromHandle`, mais ne détruit ne pas les handles de contexte de périphérique ( `hDC`s) temporairement associé à la `CDC` objets.  
  
```  
static void PASCAL DeleteTempMap();
```  
  
##  <a name="detach"></a>  CDC::Detach  
 Appelez cette fonction pour détacher `m_hDC` (le contexte de périphérique de sortie) à partir de la `CDC` de l’objet et définissez les options `m_hDC` et `m_hAttribDC` avec la valeur NULL.  
  
```  
HDC Detach();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un contexte de périphérique Windows.  
  
##  <a name="dptohimetric"></a>  CDC::DPtoHIMETRIC  
 Utilisez cette fonction lorsque vous donnez des tailles HIMETRIC à OLE, conversion HIMETRIC en pixels.  
  
```  
void DPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpSize*  
 Pointe vers un [taille](https://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 Si le mode de mappage de l’objet de contexte de périphérique est MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC ou MM_HIMETRIC, la conversion est basée sur le nombre de pixels dans le pouce physique. Si le mode de mappage est un des autres modes non limité (par exemple, MM_TEXT), la conversion est basée sur le nombre de pixels dans le pouce logique.  
  
##  <a name="dptolp"></a>  CDC::DPtoLP  
 Convertit des unités de périphérique en unités logiques.  
  
```  
void DPtoLP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpPoints*  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) structures ou [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objets.  
  
 *nCount*  
 Le nombre de points dans le tableau.  
  
 *lpRect*  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet. Ce paramètre est utilisé pour le cas simple de conversion d’un rectangle à partir de points de l’appareil aux points de logiques.  
  
 *lpSize*  
 Pointe vers un [taille](https://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 La fonction mappe les coordonnées de chaque point, ou une dimension d’une taille, dans le système de coordonnées de périphérique dans le système de coordonnées logiques du GDI. La conversion varie selon le mode de mappage actuel et les paramètres de l’origine et les étendues de fenêtre et la fenêtre d’affichage de l’appareil.  
  
##  <a name="draw3drect"></a>  CDC::Draw3dRect  
 Appelez cette fonction membre pour dessiner un rectangle en trois dimensions.  
  
```  
void Draw3dRect(
    LPCRECT lpRect,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);

 
void Draw3dRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRect*  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer soit un pointeur vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 *clrTopLeft*  
 Spécifie la couleur des côtés supérieure et gauche du rectangle en trois dimensions.  
  
 *clrBottomRight*  
 Spécifie la couleur du fond et le côté droit du rectangle en trois dimensions.  
  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle en trois dimensions.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle en trois dimensions.  
  
 CX  
 Spécifie la largeur du rectangle en trois dimensions.  
  
 CY  
 Spécifie la hauteur du rectangle en trois dimensions.  
  
### <a name="remarks"></a>Notes  
 Le rectangle sera dessiné avec les côtés supérieure et gauche de la couleur spécifiée par *clrTopLeft* et le bas et à droite dans la couleur spécifiée par *clrBottomRight*.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]  
  
##  <a name="drawdragrect"></a>  CDC::DrawDragRect  
 Appelez cette fonction membre à plusieurs reprises pour redessiner un rectangle de glissement.  
  
```  
void DrawDragRect(
    LPCRECT lpRect,  
    SIZE size,  
    LPCRECT lpRectLast,  
    SIZE sizeLast,  
    CBrush* pBrush = NULL,  
    CBrush* pBrushLast = NULL);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRect*  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui spécifie les coordonnées logiques d’un rectangle, dans ce cas, la position de fin du rectangle est redessiné.  
  
 *size*  
 Spécifie la distance de déplacement à partir de l’angle supérieur gauche de la bordure externe à l’angle supérieur gauche de la bordure interne (autrement dit, l’épaisseur de la bordure) d’un rectangle.  
  
 *lpRectLast*  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui spécifie les coordonnées logiques de la position d’un rectangle, dans ce cas, la position d’origine du rectangle est redessiné.  
  
 *sizeLast*  
 Spécifie la distance de déplacement à partir de l’angle supérieur gauche de la bordure externe à l’angle supérieur gauche de la bordure interne (autrement dit, l’épaisseur de la bordure) du rectangle d’origine est redessiné.  
  
 *pBrush*  
 Pointeur vers un objet de pinceau. La valeur NULL pour utiliser le pinceau de demi-teintes par défaut.  
  
 *pBrushLast*  
 Pointeur vers le dernier objet pinceau utilisé. La valeur NULL pour utiliser le pinceau de demi-teintes par défaut.  
  
### <a name="remarks"></a>Notes  
 Appelez-le dans une boucle comme exemple de la position de la souris, afin de fournir des commentaires visuels. Lorsque vous appelez `DrawDragRect`, le rectangle précédent est effacé et un autre est dessiné. Par exemple, en tant que l’utilisateur fait glisser un rectangle sur l’écran, `DrawDragRect` supprime le rectangle d’origine et redessiner un autre dans sa nouvelle position. Par défaut, `DrawDragRect` Dessine le rectangle à l’aide d’un pinceau de demi-teintes pour éliminer le scintillement et pour créer l’apparence d’un rectangle sans heurts de déplacement.  
  
 La première fois que vous appelez `DrawDragRect`, le *lpRectLast* paramètre doit avoir la valeur NULL.  
  
##  <a name="drawedge"></a>  CDC::DrawEdge  
 Appelez cette fonction membre pour dessiner les bords d’un rectangle du type spécifié et du style.  
  
```  
BOOL DrawEdge(
    LPRECT lpRect,  
    UINT nEdge,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRect*  
 Un pointeur vers un `RECT` structure qui contient les coordonnées logiques du rectangle.  
  
 *nEdge*  
 Spécifie le type de la bordure interne et externe à dessiner. Ce paramètre doit être une combinaison d’un indicateur interne de bordure et un indicateur de la bordure externe. Consultez [DrawEdge](/windows/desktop/api/winuser/nf-winuser-drawedge) dans le SDK Windows pour un tableau de types du paramètre.  
  
 *nIndicateurs*  
 Indicateurs qui spécifient le type de bordure à dessiner. Consultez `DrawEdge` dans le SDK Windows pour obtenir un tableau des valeurs du paramètre. Pour des lignes diagonales, les indicateurs BF_RECT spécifient le point de terminaison du vecteur limité par le paramètre de rectangle.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
##  <a name="drawescape"></a>  CDC::DrawEscape  
 Accès d’un écran vidéo des fonctionnalités qui ne sont pas directement disponibles via l’interface graphique (GDI) de dessin.  
  
```  
int DrawEscape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData);
```  
  
### <a name="parameters"></a>Paramètres  
 *nEscape*  
 Spécifie la fonction d’échappement à effectuer.  
  
 *nInputSize*  
 Spécifie le nombre d’octets de données vers lequel pointées le *lpszInputData* paramètre.  
  
 *lpszInputData*  
 Pointe vers la structure d’entrée requis pour la séquence d’échappement spécifié.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le résultat de la fonction. Supérieur à zéro en cas de réussite, à l’exception de la séquence d’échappement QUERYESCSUPPORT draw qui vérifie pour implémentation uniquement ; ou zéro si la séquence d’échappement n’est pas implémentée ; ou inférieur à zéro si une erreur s’est produite.  
  
### <a name="remarks"></a>Notes  
 Lorsqu’une application appelle `DrawEscape`, les données identifiées par *nInputSize* et *lpszInputData* est transmise directement au pilote d’affichage spécifié.  
  
##  <a name="drawfocusrect"></a>  CDC::DrawFocusRect  
 Dessine un rectangle dans le style utilisé pour indiquer que le rectangle a le focus.  
  
```  
void DrawFocusRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRect*  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui spécifie les coordonnées logiques du rectangle à dessiner.  
  
### <a name="remarks"></a>Notes  
 Dans la mesure où il s’agit d’une fonction booléenne XOR, appel de cette fonction une deuxième fois avec le même rectangle supprime le rectangle de l’affichage. Le rectangle dessiné par cette fonction ne peut pas faire défiler. Pour faire défiler une zone qui contient un rectangle dessiné par cette fonction, appelez d’abord `DrawFocusRect` pour supprimer le rectangle de l’affichage, puis faites défiler la zone, puis appelez `DrawFocusRect` pour dessiner le rectangle à la nouvelle position.  
  
> [!CAUTION]
> `DrawFocusRect` fonctionne uniquement en mode MM_TEXT. Dans les autres modes, cette fonction ne pas Dessine le rectangle de focus correctement, mais elle ne retourne pas de valeurs d’erreur.  
  
##  <a name="drawframecontrol"></a>  CDC::DrawFrameControl  
 Appelez cette fonction membre pour dessiner un contrôle frame du type spécifié et du style.  
  
```  
BOOL DrawFrameControl(
    LPRECT lpRect,  
    UINT nType,  
    UINT nState);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRect*  
 Un pointeur vers un `RECT` structure qui contient les coordonnées logiques du rectangle.  
  
 *%nLes*  
 Spécifie le type de contrôle frame dans lequel dessiner. Consultez le *uType* paramètre dans [DrawFrameControl](/windows/desktop/api/winuser/nf-winuser-drawframecontrol) dans le SDK Windows pour obtenir la liste des valeurs possibles de ce paramètre.  
  
 *nState*  
 Spécifie l’état initial du contrôle frame. Peut être une ou plusieurs des valeurs décrites pour le *uState* paramètre dans `DrawFrameControl` dans le SDK Windows. Utilisez le *nState* valeur DFCS_ADJUSTRECT pour ajuster le rectangle englobant pour exclure le bord environnant du bouton push.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Dans plusieurs cas, *nState* varie selon le *%nLes* paramètre. La liste suivante montre la relation entre les quatre *%nLes* valeurs et *nState*:  
  
- DFC_BUTTON  
  
    - Bouton de trois états DFCS_BUTTON3STATE  
  
    - Case DFCS_BUTTONCHECK vérifier  
  
    - Bouton DFCS_BUTTONPUSH Push  
  
    - Case d’option DFCS_BUTTONRADIO  
  
    - Image DFCS_BUTTONRADIOIMAGE de case (carrés doit image)  
  
    - Masque de DFCS_BUTTONRADIOMASK de case d’option (carrés doit masque)  
  
- DFC_CAPTION  
  
    - Bouton Fermer DFCS_CAPTIONCLOSE  
  
    - Bouton aide DFCS_CAPTIONHELP  
  
    - Bouton Agrandir DFCS_CAPTIONMAX  
  
    - Bouton réduire DFCS_CAPTIONMIN  
  
    - Bouton Restaurer DFCS_CAPTIONRESTORE  
  
- DFC_MENU  
  
    - Flèche de sous-menu de DFCS_MENUARROW  
  
    - Liste à puces DFCS_MENUBULLET  
  
    - DFCS_MENUCHECK coche  
  
- DFC_SCROLL  
  
    - Barre de défilement de zone de liste déroulante DFCS_SCROLLCOMBOBOX  
  
    - DFCS_SCROLLDOWN bas de la barre de défilement  
  
    - DFCS_SCROLLLEFT gauche de la barre de défilement  
  
    - DFCS_SCROLLRIGHT droite de la barre de défilement  
  
    - Poignée de dimensionnement de DFCS_SCROLLSIZEGRIP en bas à droite de fenêtre  
  
    - DFCS_SCROLLUP haut de la barre de défilement  
  
### <a name="example"></a>Exemple  
 Ce code dessine la barre de redimensionnement de taille dans l’angle inférieur droit de la fenêtre. C’est approprié pour le `OnPaint` Gestionnaire de boîte de dialogue, qui n’a aucun style et ne peuvent normalement pas contenir d’autres contrôles (par exemple, une barre d’état) qui peuvent lui donner une barre de redimensionnement de taille.  
  
 [!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]  
  
##  <a name="drawicon"></a>  CDC::DrawIcon  
 Dessine une icône sur l’appareil représenté par les `CDC` objet.  
  
```  
BOOL DrawIcon(
    int x,  
    int y,  
    HICON hIcon);

 
BOOL DrawIcon(
    POINT point,  
    HICON hIcon);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche de l’icône.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche de l’icône.  
  
 *hIcon*  
 Identifie le handle de l’icône à dessiner.  
  
 *point*  
 Spécifie la logique et y-coordonnées x de l’angle supérieur gauche de l’icône. Vous pouvez passer un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la fonction a été effectuée avec succès ; sinon 0.  
  
### <a name="remarks"></a>Notes  
 La fonction place coin supérieur gauche de l’icône à l’emplacement spécifié par *x* et *y*. L’emplacement est susceptibles d’être le mode de mappage actuel du contexte de périphérique.  
  
 La ressource icône doit avoir été précédemment chargée en utilisant les fonctions `CWinApp::LoadIcon`, `CWinApp::LoadStandardIcon`, ou `CWinApp::LoadOEMIcon`. Le `MM_TEXT` mode de mappage doit être sélectionné avant d’utiliser cette fonction.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).  
  
##  <a name="drawstate"></a>  CDC::DrawState  
 Appelez cette fonction membre pour afficher une image et applique un effet visuel pour indiquer un état, par exemple désactivé ou l’état par défaut.  
  
> [!NOTE]
>  Pour toutes les *nFlag* indique à l’exception de DSS_NORMAL, l’image est convertie en monochrome avant l’effet visuel est appliqué.  
  
```  
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HBITMAP hBitmap,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    CBitmap* pBitmap,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    CBrush* pBrush = NULL);
```  
  
### <a name="parameters"></a>Paramètres  
 *pt*  
 Spécifie l’emplacement de l’image.  
  
 *size*  
 Spécifie la taille de l’image.  
  
 *hBitmap*  
 Handle vers une image bitmap.  
  
 *nIndicateurs*  
 Indicateurs qui spécifient le type d’image et l’état. Consultez [DrawState](/windows/desktop/api/winuser/nf-winuser-drawstatea) dans le SDK Windows pour maximum *nIndicateurs* types et les États.  
  
 *hBrush*  
 Handle d’un pinceau.  
  
 *pBitmap*  
 Pointeur vers un objet CBitmap.  
  
 *pBrush*  
 Pointeur vers un objet CBrush.  
  
 *hIcon*  
 Un handle d’une icône.  
  
 *lpszText*  
 Pointeur vers le texte.  
  
 *bPrefixText*  
 Texte qui peut contenir un mnémonique de l’accélérateur. Le *lData* paramètre spécifie l’adresse de la chaîne et le *nTextLen* paramètre spécifie la longueur. Si *nTextLen* est 0, la chaîne est supposée pour être se terminant par null.  
  
 *nTextLen*  
 Longueur de la chaîne de texte vers lequel pointe *lpszText*. Si *nTextLen* est 0, la chaîne est supposée pour être se terminant par null.  
  
 *lpDrawProc*  
 Pointeur vers une fonction de rappel utilisé pour restituer une image. Ce paramètre est obligatoire si le type de l’image dans *nIndicateurs* est DST_COMPLEX. Il est facultatif et peut être NULL si le type d’image est DST_TEXT. Pour tous les autres types d’image, ce paramètre est ignoré. Pour plus d’informations sur la fonction de rappel, consultez la [DrawStateProc](/windows/desktop/api/winuser/nc-winuser-drawstateproc) (fonction) dans le SDK Windows.  
  
 *lData*  
 Spécifie des informations sur l’image. La signification de ce paramètre varie selon le type d’image.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
##  <a name="drawtext"></a>  CDC::DrawText  
 Appelez cette fonction membre pour mettre en forme le texte dans le rectangle donné. Pour spécifier les options de mise en forme supplémentaires, utilisez [CDC::DrawTextEx](#drawtextex).  
  
```  
virtual int DrawText(
    LPCTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat);

 
int DrawText(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpszString*  
 Pointe vers la chaîne à dessiner. Si *nCount* est -1, la chaîne doit être nul.  
  
 *nCount*  
 Spécifie le nombre de caractères dans la chaîne. Si *nCount* est -1, puis *lpszString* est censé pour être un pointeur long désignant une chaîne se terminant par null et `DrawText` calcule le nombre de caractères automatiquement.  
  
 *lpRect*  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui contient le rectangle (en coordonnées logiques) dans lequel le texte doit être mis en forme.  
  
 *str*  
 Un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet qui contient les caractères spécifiés à dessiner.  
  
 *nFormat*  
 Spécifie la méthode de mise en forme le texte. Il peut être n’importe quelle combinaison des valeurs décrites pour le *uFormat* paramètre dans [DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) dans le SDK Windows. (combiner à l’aide de l’opérateur OR au niveau du bit) :  
  
> [!NOTE]
>  Certains *uFormat* combinaisons d’indicateurs peuvent entraîner la chaîne passée à modifier. À l’aide de DT_MODIFYSTRING avec DT_END_ELLIPSIS ou DT_PATH_ELLIPSIS peut entraîner la chaîne à modifier, à l’origine d’une assertion dans le `CString` remplacer. Les valeurs DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP et DT_NOPREFIX ne peut pas être utilisés avec la valeur DT_TABSTOP.  
  
### <a name="return-value"></a>Valeur de retour  
 La hauteur du texte si la fonction réussite.  
  
### <a name="remarks"></a>Notes  
 Il met le texte en développant des onglets dans les espaces appropriés, aligner le texte à gauche, droite, ou le centre du rectangle donné et en divisant de texte en lignes qui tiennent dans le rectangle donné. Le type de mise en forme est spécifié par *nFormat*.  
  
 Cette fonction membre utilise le contexte de périphérique sélectionné police, couleur de texte et couleur d’arrière-plan pour dessiner le texte. À moins que le format DT_NOCLIP est utilisé, `DrawText` découpe le texte afin que le texte n’apparaît pas en dehors du rectangle donné. Toute mise en forme est supposé pour avoir plusieurs lignes, sauf si le format DT_SINGLELINE est donné.  
  
 Si la police sélectionnée est trop grande pour le rectangle spécifié, le `DrawText` fonction membre ne tente pas de substituer une police plus petits.  
  
 Si l’indicateur DT_CALCRECT est spécifié, le rectangle spécifié par *lpRect* sera mis à jour pour refléter la largeur et la hauteur nécessaires pour dessiner le texte.  
  
 Si l’indicateur d’alignement du texte TA_UPDATECP a été définie (voir [CDC::SetTextAlign](#settextalign)), `DrawText` affichera le texte commençant à la position actuelle, plutôt qu’à gauche du rectangle donné. `DrawText` encapsule pas texte lorsque l’indicateur TA_UPDATECP a été défini (autrement dit, l’indicateur DT_WORDBREAK n’a aucun effet).  
  
 La couleur du texte peut être définie par [CDC::SetTextColor](#settextcolor).  
  
##  <a name="drawtextex"></a>  CDC::DrawTextEx  
 Met en forme le texte dans le rectangle donné.  
  
```  
virtual int DrawTextEx(
    LPTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

 
int DrawTextEx(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpszString*  
 Pointe vers la chaîne à dessiner. Si *nCount* est -1, la chaîne doit se terminer par null.  
  
 *nCount*  
 Spécifie le nombre de caractères dans la chaîne. Si *nCount* est -1, puis *lpszString* est censé pour être un pointeur long désignant une chaîne se terminant par null et `DrawText` calcule le nombre de caractères automatiquement.  
  
 *lpRect*  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui contient le rectangle (en coordonnées logiques) dans lequel le texte doit être mis en forme.  
  
 *str*  
 Un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet qui contient les caractères spécifiés à dessiner.  
  
 *nFormat*  
 Spécifie la méthode de mise en forme le texte. Il peut être n’importe quelle combinaison des valeurs décrites pour le *uFormat* paramètre dans [DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) dans le SDK Windows. (Combiner à l’aide de l’opérateur de bits **ou** opérateur) :  
  
> [!NOTE]
>  Certains *uFormat* combinaisons d’indicateurs peuvent entraîner la chaîne passée à modifier. À l’aide de DT_MODIFYSTRING avec DT_END_ELLIPSIS ou DT_PATH_ELLIPSIS peut entraîner la chaîne à modifier, à l’origine d’une assertion dans le `CString` remplacer. Les valeurs DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP et DT_NOPREFIX ne peut pas être utilisés avec la valeur DT_TABSTOP.  
  
 *lpDTParams*  
 Pointeur vers un [DRAWTEXTPARAMS](/windows/desktop/api/winuser/ns-winuser-tagdrawtextparams) options de structure qui spécifie la mise en forme supplémentaires. Ce paramètre peut être NULL.  
  
### <a name="remarks"></a>Notes  
 Il met le texte en développant des onglets dans les espaces appropriés, aligner le texte à gauche, droite, ou le centre du rectangle donné et en divisant de texte en lignes qui tiennent dans le rectangle donné. Le type de mise en forme est spécifié par *nFormat* et *lpDTParams*. Pour plus d’informations, consultez [CDC::DrawText](#drawtext) et [DrawTextEx](/windows/desktop/api/winuser/nf-winuser-drawtextexa) dans le SDK Windows.  
  
 La couleur du texte peut être définie par [CDC::SetTextColor](#settextcolor).  
  
##  <a name="ellipse"></a>  CDC::Ellipse  
 Dessine une ellipse.  
  
```  
BOOL Ellipse(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Ellipse(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 *x1*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle englobant de l’ellipse.  
  
 *y1*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle englobant de l’ellipse.  
  
 *x2*  
 Spécifie la coordonnée x logique de l’angle inférieur droit du rectangle englobant de l’ellipse.  
  
 *y2*  
 Spécifie la coordonnée y logique de l’angle inférieur droit du rectangle englobant de l’ellipse.  
  
 *lpRect*  
 Spécifie le que rectangle englobant de l’ellipse. Vous pouvez également passer un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le centre de l’ellipse est le centre du rectangle englobant spécifié par *x1*, *y1*, *x2*, et *y2*, ou  *lpRect*. L’ellipse est dessinée avec le stylet actuel, et son intérieur est rempli avec le pinceau actuel.  
  
 La figure dessinée par cette fonction s’étend jusqu'à, mais n’inclut pas les coordonnées de droite et en bas. Cela signifie que la hauteur de la figure est *y2* - *y1* et la largeur de la figure est *x2* - *x1*.  
  
 Si la largeur ou la hauteur du rectangle englobant est 0, aucun ellipse n’est dessinée.  
  
##  <a name="enddoc"></a>  CDC::EndDoc  
 Met fin à un travail d’impression démarré par un appel à la [StartDoc](#startdoc) fonction membre.  
  
```  
int EndDoc();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Supérieur ou égal à 0 si la fonction a réussi, ou une valeur négative si une erreur s’est produite.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre remplace la séquence d’échappement ENDDOC imprimante et doit être appelée immédiatement après la fin d’un travail d’impression.  
  
 Si une application rencontre une erreur d’impression ou d’une opération d’impression a été annulée, elle doit ne tente pas terminer l’opération à l’aide `EndDoc` ou [AbortDoc](#abortdoc). GDI termine automatiquement l’opération avant de retourner la valeur d’erreur.  
  
 Cette fonction ne doit pas être utilisée à l’intérieur des métafichiers.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::StartDoc](#startdoc).  
  
##  <a name="endpage"></a>  CDC::EndPage  
 Informe l’appareil que l’application a terminé l’écriture dans une page.  
  
```  
int EndPage();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Supérieur ou égal à 0 si la fonction a réussi, ou une valeur négative si une erreur s’est produite.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre est généralement utilisée pour diriger le pilote de périphérique pour accéder à une nouvelle page.  
  
 Cette fonction membre remplace la séquence d’échappement NEWFRAME imprimante. Contrairement à NEWFRAME, cette fonction est toujours appelée après l’impression d’une page.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::StartDoc](#startdoc).  
  
##  <a name="endpath"></a>  CDC::EndPath  
 Ferme un crochet de chemin d’accès et sélectionne le chemin d’accès défini par le crochet dans le contexte de périphérique.  
  
```  
BOOL EndPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="enumobjects"></a>  CDC::EnumObjects  
 Énumère les stylets et pinceaux disponibles dans un contexte de périphérique.  
  
```  
int EnumObjects(
    int nObjectType,  
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),  
    LPARAM lpData);
```  
  
### <a name="parameters"></a>Paramètres  
 *nObjectType*  
 Spécifie le type d’objet. Il peut avoir les valeurs OBJ_BRUSH ou OBJ_PEN.  
  
 *lpfn*  
 Est l’adresse de l’instance de la procédure de la fonction de rappel fournie par l’application. Consultez la section « Remarques » ci-dessous.  
  
 *lpData*  
 Points de données fournie par l’application. Les données sont transmises à la fonction de rappel ainsi que des informations sur l’objet.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie la dernière valeur retournée par la [fonction de rappel](callback-functions-used-by-mfc.md#enum_objects). Sa signification est définie par l’utilisateur.  
  
### <a name="remarks"></a>Notes  
 Pour chaque objet d’un type donné, la fonction de rappel que vous passez est appelée avec les informations de cet objet. Le système appelle la fonction de rappel jusqu'à ce qu’il n’y aucun autre objet ou la fonction de rappel retourne 0.  
  
 Notez que les fonctionnalités nouvelles de Microsoft Visual C++ vous permettent d’utiliser une fonction ordinaire comme la fonction passé à `EnumObjects`. L’adresse passée à `EnumObjects` est un pointeur vers une fonction exportée avec **exporter** et avec la convention d’appel Pascal. Dans les applications en mode protégé, il est inutile de créer cette fonction avec la fonction Windows MakeProcInstance ou libérez de la fonction après son utilisation avec la fonction FreeProcInstance Windows.  
  
 Aussi inutile exporter le nom de fonction dans une **exportations** instruction dans le fichier de définition de module de votre application. Vous pouvez utiliser à la place la **exporter** fonction modificateur, comme dans  
  
 **int rappel exporter** AFunction **(LPSTR**, **LPSTR) ;**  
  
 Pour contraindre le compilateur à émettre l’enregistrement d’exportation correcte pour l’exportation par son nom sans alias. Cela fonctionne pour la plupart des besoins. Pour certains cas spéciaux, notamment l’exportation d’une fonction par ordinal ou alias de l’exportation, vous devez toujours utiliser un **exportations** instruction dans un fichier de définition de module.  
  
 Pour compiler les programmes de Microsoft Foundation, vous allez normalement utiliser les options de compilateur /GEs /GA. L’option de compilateur /Gw n’est pas utilisée avec Microsoft Foundation classes. (Si vous n’utilisez pas la fonction Windows `MakeProcInstance`, vous devez caster explicitement le pointeur de fonction retournée à partir de FARPROC vers le type nécessaire dans cette API.) Interfaces de rappel d’inscription sont désormais de type sécurisé (vous devez passer un pointeur de fonction qui pointe vers le bon type de fonction pour le rappel spécifique).  
  
 Notez également que toutes les fonctions de rappel doivent intercepter les exceptions de Microsoft Foundation avant de revenir à Windows, étant donné que les exceptions ne peut pas être levées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, consultez l’article [Exceptions](../../mfc/exception-handling-in-mfc.md).  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]  
  
##  <a name="escape"></a>  CDC::Escape  
 Cette fonction membre est pratiquement obsolète pour la programmation Win32.  
  
```  
virtual int Escape(
    int nEscape,  
    int nCount,  
    LPCSTR lpszInData,  
    LPVOID lpOutData);

 
int Escape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData,  
    int nOutputSize,  
    LPSTR lpszOutputData);
```  
  
### <a name="parameters"></a>Paramètres  
 *nEscape*  
 Spécifie la fonction d’échappement à effectuer.  
  
 Pour obtenir une liste complète des fonctions de d’échappement, consultez [échappement](/windows/desktop/api/wingdi/nf-wingdi-escape) dans le SDK Windows.  
  
 *nCount*  
 Spécifie le nombre d’octets de données vers lequel pointées *lpszInData*.  
  
 *lpszInData*  
 Pointe vers la structure de données d’entrée requis pour cette d’échappement.  
  
 *lpOutData*  
 Pointe vers la structure qui doit recevoir une sortie de cette d’échappement. Le *lpOutData* paramètre a la valeur NULL si aucune donnée n’est retournée.  
  
 *nInputSize*  
 Spécifie le nombre d’octets de données vers lequel pointées le *lpszInputData* paramètre.  
  
 *lpszInputData*  
 Pointe vers la structure d’entrée requis pour la séquence d’échappement spécifié.  
  
 *nOutputSize*  
 Spécifie le nombre d’octets de données vers lequel pointées le *lpszOutputData* paramètre.  
  
 *lpszOutputData*  
 Pointe vers la structure qui reçoit le résultat de cette d’échappement. Ce paramètre doit être NULL si aucune donnée n’est retournée.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur positive est retournée si la fonction réussite, à l’exception de la séquence d’échappement QUERYESCSUPPORT, qui vérifie uniquement pour l’implémentation. Valeur zéro est renvoyée si la séquence d’échappement n’est pas implémentée. Une valeur négative est retournée si une erreur s’est produite. Les valeurs d’erreur courantes sont les suivantes :  
  
- Erreur générale de SP_ERROR.  
  
- SP_OUTOFDISK pas suffisamment d’espace disque est actuellement disponible pour la mise en attente, et davantage d’espace devient disponible.  
  
- SP_OUTOFMEMORY pas suffisamment de mémoire est disponible pour la mise en attente.  
  
- SP_USERABORT utilisateur a pris fin le travail via le Gestionnaire d’impression.  
  
### <a name="remarks"></a>Notes  
 De l’échappement d’imprimante d’origine, QUERYESCSUPPORT uniquement est pris en charge pour les applications Win32. Tous les autres séquences d’échappement imprimante sont obsolètes et sont pris en charge uniquement pour la compatibilité avec les applications 16 bits.  
  
 Pour la programmation Win32, `CDC` fournit désormais des six fonctions membres qui remplacent leurs échappement d’imprimante correspondant :  
  
- [CDC::AbortDoc](#abortdoc)  
  
- [CDC::EndDoc](#enddoc)  
  
- [CDC::EndPage](#endpage)  
  
- [CDC::SetAbortProc](#setabortproc)  
  
- [CDC::StartDoc](#startdoc)  
  
- [CDC::StartPage](#startpage)  
  
 En outre, [CDC::GetDeviceCaps](#getdevicecaps) prend en charge les index Win32 qui remplacent d’autres séquences d’échappement des imprimantes. Consultez [GetDeviceCaps](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) dans le SDK Windows pour plus d’informations.  
  
 Cette fonction membre permet aux applications accéder aux fonctionnalités d’un appareil particulier qui ne sont pas directement disponibles via GDI.  
  
 Utilisez la première version, si votre application utilise les valeurs prédéfinies d’échappement. Utilisez la deuxième version, si votre application définit les valeurs d’échappement privé. Consultez [ExtEscape](/windows/desktop/api/wingdi/nf-wingdi-extescape) dans le SDK Windows pour plus d’informations sur la deuxième version.  
  
##  <a name="excludecliprect"></a>  CDC::ExcludeClipRect  
 Crée une nouvelle zone de découpage qui se compose de la zone de découpage existant moins le rectangle spécifié.  
  
```  
int ExcludeClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int ExcludeClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 *x1*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle.  
  
 *y1*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle.  
  
 *x2*  
 Spécifie la coordonnée x logique de l’angle inférieur droit du rectangle.  
  
 *y2*  
 Spécifie la coordonnée y logique de l’angle inférieur droit du rectangle.  
  
 *lpRect*  
 Spécifie le rectangle. Peut également être un `CRect` objet.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le type de la nouvelle région découpage. Il peut être une des valeurs suivantes :  
  
- COMPLEXREGION la région a chevauchement des bordures.  
  
- Aucune région n’a été créée.  
  
- NULLREGION la région est vide.  
  
- SIMPLEREGION la région n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 La largeur du rectangle, spécifié par la valeur absolue de *x2* - *x1*, ne doit pas dépasser 32 767 unités. Cette limite s’applique à la hauteur du rectangle ainsi.  
  
##  <a name="excludeupdatergn"></a>  CDC::ExcludeUpdateRgn  
 Empêche le dessin dans les zones non valides d’une fenêtre en excluant une région de mise à jour dans la fenêtre de la zone de découpage associée à la `CDC` objet.  
  
```  
int ExcludeUpdateRgn(CWnd* pWnd);
```  
  
### <a name="parameters"></a>Paramètres  
 *pWnd*  
 Pointe vers l’objet de fenêtre dont la fenêtre est en cours de mise à jour.  
  
### <a name="return-value"></a>Valeur de retour  
 Le type de région exclu. Il peut prendre l’une des valeurs suivantes :  
  
- COMPLEXREGION la région a chevauchement des bordures.  
  
- Aucune région n’a été créée.  
  
- NULLREGION la région est vide.  
  
- SIMPLEREGION la région n’a aucune bordure qui se chevauchent.  
  
##  <a name="extfloodfill"></a>  CDC::ExtFloodFill  
 Remplit une zone de la surface d’affichage avec le pinceau actuel.  
  
```  
BOOL ExtFloodFill(
    int x,  
    int y,  
    COLORREF crColor,  
    UINT nFillType);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point où commence la saturation de ce dernier.  
  
 *y*  
 Spécifie la coordonnée y logique du point où commence la saturation de ce dernier.  
  
 *crColor*  
 Spécifie la couleur de la limite ou de la zone à remplir. L’interprétation de *crColor* dépend de la valeur de *nFillType*.  
  
 *nFillType*  
 Spécifie le type de remplissage à effectuer. Il doit s’agir des valeurs suivantes :  
  
- FLOODFILLBORDER la zone de remplissage est limitée par la couleur spécifiée par *crColor*. Ce style est identique à la saturation de ce dernier effectuée par `FloodFill`.  
  
- FLOODFILLSURFACE la zone de remplissage est définie par la couleur spécifiée par *crColor*. Remplissage continue vers l’extérieur dans toutes les directions, tant que la couleur est rencontrée. Ce style est utile pour remplir des zones avec des limites multicolores.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la fonction a réussi ; sinon 0 si le remplissage a échoué, si le point donné a la limite de couleur spécifiée par *crColor* (si FLOODFILLBORDER a été demandée), si le point donné ne dispose pas de la couleur spécifiée par *crColor* (si FLOODFILLSURFACE a été demandée), ou si le point est en dehors de la zone de découpage.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre offre plus de souplesse que `FloodFill` , car vous pouvez spécifier un type de remplissage dans *nFillType*.  
  
 Si *nFillType* est définie à FLOODFILLBORDER, la zone est censée être complètement limitée par la couleur spécifiée par *crColor*. La fonction commence au point spécifié par *x* et *y* et renseigne toutes les directions à la limite de couleur.  
  
 Si *nFillType* est définie à FLOODFILLSURFACE, la fonction commence au point spécifié par *x* et *y* et se poursuit dans toutes les directions, remplissage de toutes les zones adjacentes contenant la couleur spécifiée par *crColor*.  
  
 Seuls les contextes de périphérique de mémoire et les appareils qui prennent en charge de la prise en charge de la technologie raster-affichage `ExtFloodFill`. Pour plus d’informations, consultez le [GetDeviceCaps](#getdevicecaps) fonction membre.  
  
##  <a name="exttextout"></a>  CDC::ExtTextOut  
 Appelez cette fonction membre pour écrire une chaîne de caractères dans une zone rectangulaire à l’aide de la police actuellement sélectionnée.  
  
```  
virtual BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    LPCTSTR lpszString,  
    UINT nCount,  
    LPINT lpDxWidths);

 
BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    const CString& str,  
    LPINT lpDxWidths);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de la cellule de caractère pour le premier caractère dans la chaîne spécifiée.  
  
 *y*  
 Spécifie la coordonnée y logique du haut de la cellule de caractère pour le premier caractère dans la chaîne spécifiée.  
  
 *nOptions*  
 Spécifie le type de rectangle. Ce paramètre peut être une, deux ou aucun des valeurs suivantes :  
  
- ETO_CLIPPED Spécifie que le texte est rogné jusqu’au rectangle.  
  
- ETO_OPAQUE Spécifie que la couleur d’arrière-plan actuelle remplit le rectangle. (Vous pouvez définir et interroger la couleur d’arrière-plan actuelle avec le [SetBkColor](#setbkcolor) et [GetBkColor](#getbkcolor) fonctions membres.)  
  
 *lpRect*  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure qui détermine les dimensions du rectangle. Ce paramètre peut être NULL. Vous pouvez également passer un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 *lpszString*  
 Pointe vers la chaîne de caractères spécifié à dessiner. Vous pouvez également passer un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 *nCount*  
 Spécifie le nombre de caractères de la chaîne.  
  
 *lpDxWidths*  
 Pointe vers un tableau de valeurs qui indiquent la distance entre les origines de cellules de caractères adjacents. Par exemple, *lpDxWidths*[ *je*] les origines de cellule de caractère pour séparer les unités logiques *je* et la cellule de caractère *je* + 1. Si *lpDxWidths* est NULL, `ExtTextOut` utilise l’espacement par défaut entre les caractères.  
  
 *str*  
 Un `CString` objet qui contient les caractères spécifiés à dessiner.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La zone rectangulaire peut être opaque (rempli avec la couleur d’arrière-plan actuelle), et il peut être une zone de découpage.  
  
 Si *nOptions* est égal à 0 et *lpRect* est NULL, la fonction écrit du texte dans le contexte de périphérique sans l’aide d’une zone rectangulaire. Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction. Si une application doit mettre à jour la position actuelle lorsqu’il appelle `ExtTextOut`, l’application peut appeler le `CDC` fonction membre [SetTextAlign](#settextalign) avec *nIndicateurs* TA_UPDATECP la valeur. Lorsque cet indicateur est défini, Windows ignore *x* et *y* lors des appels ultérieurs à `ExtTextOut` et utilise à la place de la position actuelle. Lorsqu’une application utilise TA_UPDATECP pour mettre à jour la position actuelle, `ExtTextOut` définit la position actuelle vers la fin de la ligne précédente du texte ou à la position spécifiée par le dernier élément du tableau vers lequel pointé *lpDxWidths*, deux valeurs étant retenue.  
  
##  <a name="fillpath"></a>  CDC::FillPath  
 Ferme des figures ouvertes dans le chemin d’accès actuel et remplit l’intérieur du chemin d’accès en utilisant le pinceau actuel et le mode de remplissage de polygones.  
  
```  
BOOL FillPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Une fois que son intérieur est renseigné, le chemin d’accès est ignorée à partir du contexte de périphérique.  
  
##  <a name="fillrect"></a>  CDC::FillRect  
 Appelez cette fonction membre pour remplir un rectangle donné à l’aide du pinceau spécifié.  
  
```  
void FillRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRect*  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure qui contient les coordonnées logiques du rectangle à remplir. Vous pouvez également passer un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 *pBrush*  
 Identifie le pinceau utilisé pour remplir le rectangle.  
  
### <a name="remarks"></a>Notes  
 La fonction remplit le rectangle complète, y compris les bordures gauche et supérieure, mais elle ne remplit pas les bordures droite et inférieure.  
  
 Le pinceau doit soit être créé à l’aide de la [CBrush](../../mfc/reference/cbrush-class.md) fonctions membres [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush), et [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush), ou récupérée par le `GetStockObject` (fonction) Windows.  
  
 Lors du remplissage du rectangle spécifié, `FillRect` n’inclut pas les côtés droit et inférieur du rectangle. GDI remplit un rectangle jusqu'à, mais n’inclut pas la ligne de colonne et inférieure droite, quel que soit le mode de mappage en cours. `FillRect` Compare les valeurs de la `top`, `bottom`, `left`, et `right` membres du rectangle spécifié. Si `bottom` est inférieure ou égale à `top`, ou si `right` est inférieure ou égale à `left`, le rectangle n’est pas dessiné.  
  
 `FillRect` est similaire à [CDC::FillSolidRect](#fillsolidrect); Toutefois, `FillRect` prend un pinceau et par conséquent peut être utilisé pour remplir un rectangle avec une couleur unie, une couleur tramée, pinceaux hachurée ou un modèle. `FillSolidRect` utilise uniquement des couleurs unies (indiqués par un paramètre COLORREF). `FillRect` est généralement plus lent que `FillSolidRect`.  
  
##  <a name="fillrgn"></a>  CDC::FillRgn  
 Remplit la zone spécifiée par *pRgn* avec le pinceau spécifié par *pBrush*.  
  
```  
BOOL FillRgn(
    CRgn* pRgn,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>Paramètres  
 *pRgn*  
 Pointeur vers la zone à remplir. Les coordonnées de la région donnée sont spécifiées en unités logiques.  
  
 *pBrush*  
 Identifie le pinceau à utiliser pour remplir la région.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le pinceau doit être créé à l’aide de la `CBrush` fonctions membres `CreateHatchBrush`, `CreatePatternBrush`, `CreateSolidBrush`, ou être récupérées par `GetStockObject`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).  
  
##  <a name="fillsolidrect"></a>  CDC::FillSolidRect  
 Appelez cette fonction membre pour remplir le rectangle donné avec la couleur unie spécifiée.  
  
```  
void FillSolidRect(
    LPCRECT lpRect,  
    COLORREF clr);

 
void FillSolidRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clr);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRect*  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer soit un pointeur vers un [RECT](../../mfc/reference/rect-structure1.md) structure de données ou un `CRect` objet pour ce paramètre.  
  
 *CLR* spécifie la couleur à utiliser pour remplir le rectangle.  
  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle de destination.  
  
 *CX*  
 Spécifie la largeur du rectangle.  
  
 *CY*  
 Spécifie la hauteur du rectangle.  
  
### <a name="remarks"></a>Notes  
 `FillSolidRect` est très similaire à [CDC::FillRect](#fillrect); Toutefois, `FillSolidRect` utilise uniquement des couleurs unies (indiqués par le paramètre COLORREF), tout en `FillRect` prend un pinceau et par conséquent peut être utilisé pour remplir un rectangle avec une couleur unie, un tramée couleur, des pinceaux hachurées ou un modèle. `FillSolidRect` est généralement plus rapide que `FillRect`.  
  
> [!NOTE]
>  Lorsque vous appelez `FillSolidRect`, la couleur d’arrière-plan, ce qui a été définie précédemment à l’aide de [SetBkColor](#setbkcolor), est défini sur la couleur indiquée par *clr*.  
  
##  <a name="flattenpath"></a>  CDC::FlattenPath  
 Transforme les courbes dans le chemin d’accès sélectionné dans le contexte de périphérique en cours et transforme chaque courbe en une séquence de lignes.  
  
```  
BOOL FlattenPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="floodfill"></a>  CDC::FloodFill  
 Remplit une zone de la surface d’affichage avec le pinceau actuel.  
  
```  
BOOL FloodFill(
    int x,  
    int y,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point où commence la saturation de ce dernier.  
  
 *y*  
 Spécifie la coordonnée y logique du point où commence la saturation de ce dernier.  
  
 *crColor*  
 Spécifie la couleur de la limite.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la fonction a réussi ; Sinon, 0 est retournée si le remplissage n’a pas pu être effectué, le point donné a la couleur de la limite spécifiée par *crColor*, ou le point se trouve en dehors de la zone de découpage.  
  
### <a name="remarks"></a>Notes  
 La zone est supposée être délimité comme spécifiée par *crColor*. Le `FloodFill` fonction commence au point spécifié par *x* et *y* et se poursuit dans toutes les directions à la limite de couleur.  
  
 Seuls les contextes de périphérique de mémoire et les appareils qui prennent en charge de la prise en charge de la technologie raster-affichage le `FloodFill` fonction membre. Pour plus d’informations sur la fonctionnalité RC_BITBLT, consultez le `GetDeviceCaps` fonction membre.  
  
 Le `ExtFloodFill` fonction fournit une fonctionnalité similaire, mais une plus grande flexibilité.  
  
##  <a name="framerect"></a>  CDC::FrameRect  
 Dessine une bordure autour du rectangle spécifié par *lpRect*.  
  
```  
void FrameRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRect*  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui contient les coordonnées logiques des angles supérieur gauche et inférieur droit du rectangle. Vous pouvez également passer un `CRect` objet pour ce paramètre.  
  
 *pBrush*  
 Identifie le pinceau à utiliser pour le rectangle de tramage.  
  
### <a name="remarks"></a>Notes  
 La fonction utilise le pinceau donné pour dessiner la bordure. La largeur et la hauteur de la bordure est toujours 1 unité logique.  
  
 Si le rectangle `bottom` coordonnée est inférieure ou égale à `top`, ou si `right` est inférieure ou égale à `left`, le rectangle n’est pas dessiné.  
  
 La bordure dessinée par `FrameRect` est dans la même position qu’une bordure dessinée par le `Rectangle` fonction membre à l’aide des mêmes coordonnées (si `Rectangle` utilise un stylet qui est l’unité logique 1 large). L’intérieur du rectangle n’est pas rempli par `FrameRect`.  
  
##  <a name="framergn"></a>  CDC::FrameRgn  
 Dessine une bordure autour de la région spécifiée par *pRgn* à l’aide de la forme spécifiée par *pBrush*.  
  
```  
BOOL FrameRgn(
    CRgn* pRgn,  
    CBrush* pBrush,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Paramètres  
 *pRgn*  
 Pointe vers le `CRgn` objet qui identifie la région pour être placés dans une bordure. Les coordonnées de la région donnée sont spécifiées en unités logiques.  
  
 *pBrush*  
 Pointe vers le `CBrush` objet qui identifie le pinceau à utiliser pour dessiner la bordure.  
  
 *nWidth*  
 Spécifie la largeur de la bordure en traits de pinceau vertical en unités de périphérique.  
  
 *nHeight*  
 Spécifie la hauteur de la bordure de traits de pinceau horizontal en unités de périphérique.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).  
  
##  <a name="fromhandle"></a>  CDC::FromHandle  
 Retourne un pointeur vers un `CDC` lorsqu’un handle vers un contexte de périphérique de l’objet.  
  
```  
static CDC* PASCAL FromHandle(HDC hDC);
```  
  
### <a name="parameters"></a>Paramètres  
 *hDC*  
 Contient un handle vers un contexte de périphérique Windows.  
  
### <a name="return-value"></a>Valeur de retour  
 Le pointeur peut être temporaire et ne doit pas être stocké au-delà d’une utilisation immédiate.  
  
### <a name="remarks"></a>Notes  
 Si aucun objet `CDC` n'est attaché au handle, un objet `CDC` temporaire est créé et attaché.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).  
  
##  <a name="getarcdirection"></a>  CDC::GetArcDirection  
 Renvoie la direction d’arc de cercle en cours pour le contexte de périphérique.  
  
```  
int GetArcDirection() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie la direction d’arc de cercle en cours, en cas de réussite. Voici les valeurs de retournés valides :  
  
- AD_COUNTERCLOCKWISE Arcs et rectangles dessinés dans le sens anti-horaire.  
  
- AD_CLOCKWISE Arcs et rectangles dessinés dans le sens horaire.  
  
 Si une erreur se produit, la valeur de retour est zéro.  
  
### <a name="remarks"></a>Notes  
 Les fonctions d’arc de cercle et le rectangle utilisent la direction de l’arc.  
  
##  <a name="getaspectratiofilter"></a>  CDC::GetAspectRatioFilter  
 Récupère le paramètre pour le filtre de proportions en cours.  
  
```  
CSize GetAspectRatioFilter() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un `CSize` objet représentant le rapport hauteur / largeur utilisé par le filtre de rapport hauteur / largeur actuelle.  
  
### <a name="remarks"></a>Notes  
 Le rapport hauteur / largeur est le ratio formé par la largeur en pixels d’un appareil et la hauteur. Plus d’informations sur le rapport hauteur / largeur d’un appareil sont utilisés dans la création, la sélection et affichage des polices. Windows fournit un filtre spécial, le filtre proportions, pour sélectionner les polices conçues pour un rapport hauteur / largeur particulier à partir de toutes les polices disponibles. Le filtre utilise le rapport hauteur / largeur spécifié par la `SetMapperFlags` fonction membre.  
  
##  <a name="getbkcolor"></a>  CDC::GetBkColor  
 Retourne la couleur d’arrière-plan actuelle.  
  
```  
COLORREF GetBkColor() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur de couleur RVB.  
  
### <a name="remarks"></a>Notes  
 Si le mode d’arrière-plan est OPAQUE, le système utilise la couleur d’arrière-plan pour remplir les écarts dans les lignes de style, les écarts entre les lignes hachurées de pinceaux et de l’arrière-plan dans les cellules de caractères. Le système utilise également la couleur d’arrière-plan lors de la conversion de bitmaps entre la couleur et les contextes de périphérique monochrome.  
  
##  <a name="getbkmode"></a>  CDC::GetBkMode  
 Retourne le mode d’arrière-plan.  
  
```  
int GetBkMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode d’arrière-plan actuelle, qui peut être OPAQUE ou TRANSPARENT.  
  
### <a name="remarks"></a>Notes  
 Le mode d’arrière-plan définit si le système supprime les couleurs d’arrière-plan sur la surface de dessin avant de dessiner du texte, des pinceaux hachurées ou n’importe quel style de stylet qui n’est pas une ligne pleine.  
  
##  <a name="getboundsrect"></a>  CDC::GetBoundsRect  
 Retourne le rectangle englobant cumulé actuel pour le contexte de périphérique spécifié.  
  
```  
UINT GetBoundsRect(
    LPRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRectBounds*  
 Pointe vers une mémoire tampon qui recevra le rectangle englobant actuel. Le rectangle est retourné en coordonnées logiques.  
  
 *flags*  
 Spécifie si le rectangle englobant doit être effacée après qu’elle est retournée. Ce paramètre doit être égal à zéro ou la valeur suivante :  
  
- DCB_RESET force le rectangle englobant pour être supprimé une fois qu’il est retourné.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie l’état actuel du rectangle englobant, si la fonction réussite. Il peut être une combinaison des valeurs suivantes :  
  
- Accumulation de rectangle englobant DCB_ACCUMULATE est en cours.  
  
- Rectangle englobant DCB_RESET est vide.  
  
- Rectangle englobant DCB_SET n’est pas vide.  
  
- Accumulation DCB_ENABLE englobant est activée.  
  
- Accumulation DCB_DISABLE englobant est désactivée.  
  
##  <a name="getbrushorg"></a>  CDC::GetBrushOrg  
 Récupère l’origine (en unités de périphérique) du pinceau actuellement sélectionné pour le contexte de périphérique.  
  
```  
CPoint GetBrushOrg() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine actuelle du pinceau (en unités de périphérique) comme un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 Le pinceau initiale a son origine à (0,0) de la zone cliente. La valeur de retour spécifie ce point en unités de périphérique relatif à l’origine de la fenêtre du bureau.  
  
##  <a name="getcharacterplacement"></a>  CDC::GetCharacterPlacement  
 Récupère les différents types d’informations sur une chaîne de caractères.  
  
```  
DWORD GetCharacterPlacement(
    LPCTSTR lpString,  
    int nCount,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
  
DWORD GetCharacterPlacement(
    CString& str,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpString*  
 Pointeur vers la chaîne de caractères à traiter.  
  
 *nCount*  
 Spécifie la longueur de la chaîne. Pour la version ANSI, il est un nombre d’octets et pour la fonction Unicode, il est un nombre de mots. Pour plus d’informations, consultez [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa).  
  
 *nMaxExtent*  
 Spécifie l’étendue maximale (en unités logiques) à laquelle la chaîne est traitée. Les caractères qui, si traités, dépasseraient cette étendue sont ignorés. Calculs pour des tableaux de glyphe ou d’ordonnancement requis s’appliquent uniquement aux caractères inclus. Ce paramètre est utilisé uniquement si la valeur GCP_MAXEXTENT est spécifiée dans le *dwFlags* paramètre. Pendant que la fonction traite la chaîne d’entrée, chaque caractère et son étendue est ajoutée à la sortie, étendue et les autres tableaux uniquement si l’étendue totale n’a pas encore dépassé le nombre maximal. Une fois que la limite est atteinte, le traitement s’arrête.  
  
 lpResults  
 Pointeur vers un [GCP_Results](/windows/desktop/api/wingdi/ns-wingdi-taggcp_resultsa) structure qui reçoit les résultats de la fonction.  
  
 *dwFlags*  
 Spécifie comment traiter la chaîne dans les tableaux requis. Ce paramètre peut prendre l’une ou plusieurs des valeurs répertoriées dans le *dwFlags* section de la [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa) rubrique.  
  
 *str*  
 Un pointeur vers un [CString](../../atl-mfc-shared/reference/cstringt-class.md) au processus de l’objet.  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour est la largeur et la hauteur de la chaîne en unités logiques.  
  
 Si la fonction échoue, la valeur de retour est égale à zéro.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre émule la fonctionnalité de la fonction [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa), comme décrit dans le SDK Windows.  
  
##  <a name="getcharabcwidths"></a>  CDC::GetCharABCWidths  
 Récupère la largeur des caractères consécutifs dans une plage spécifiée à partir de la police TrueType actuelle.  
  
```  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABC lpabc) const;  
  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABCFLOAT lpABCF) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *nFirstChar*  
 Spécifie le premier caractère dans la plage de caractères à partir de la police actuelle pour laquelle la largeur des caractères sont retournés.  
  
 *nLastChar*  
 Spécifie le dernier caractère dans la plage de caractères à partir de la police actuelle pour laquelle la largeur des caractères sont retournés.  
  
 *lpabc*  
 Pointe vers un tableau de [ABC](../../mfc/reference/abc-structure.md) structures qui reçoivent les largeurs de caractère lorsque la fonction retourne. Ce tableau doit contenir au moins autant `ABC` structures en tant qu’il existe des caractères dans la plage spécifiée par la *nFirstChar* et *nLastChar* paramètres.  
  
 *lpABCF*  
 Pointe vers une mémoire tampon de fournie par l’application avec un tableau de [ABCFLOAT](../../mfc/reference/abcfloat-structure.md) structures pour recevoir les largeurs de caractère lorsque la fonction retourne. Les largeurs retournées par cette fonction sont au format à virgule flottante IEEE.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Les largeurs sont retournées en unités logiques. Cette fonction réussit uniquement avec des polices TrueType.  
  
 Le rastériseur TrueType fournit l’espacement des caractères « ABC » après la sélection d’une taille spécifique. Espacement de « A » est la distance qui est ajoutée à la position actuelle avant de placer le glyphe. Espacement de « B » est la largeur de la partie noire de glyphe. Espacement de « C » est ajouté à la position actuelle pour prendre en compte les espaces blancs à droite du glyphe. Le total avancée de la largeur est donné par un + B + C.  
  
 Lorsque le `GetCharABCWidths` fonction membre récupère négatif « A » ou les largeurs de « C » pour un caractère, ce caractère inclut underhangs ou des interférences.  
  
 Pour convertir les largeurs de ABC en unités de design de police, une application doit créer une police dont la hauteur (tel que spécifié dans le `lfHeight` membre de la [LOGFONT](/windows/desktop/api/wingdi/ns-wingdi-taglogfonta) structure) est égal à la valeur stockée dans le `ntmSizeEM` membre de la [ NEWTEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagnewtextmetrica) structure. (La valeur de la `ntmSizeEM` membre peut être récupéré en appelant le [EnumFontFamilies](/windows/desktop/api/wingdi/nf-wingdi-enumfontfamiliesa) fonction de Windows.)  
  
 Les largeurs de ABC de caractère par défaut sont utilisés pour les caractères situés en dehors de la plage de la police actuellement sélectionnée.  
  
 Pour récupérer les largeurs de caractères dans les polices non TrueType, les applications doivent utiliser le [GetCharWidth](/windows/desktop/api/wingdi/nf-wingdi-getcharwidtha) (fonction) Windows.  
  
##  <a name="getcharabcwidthsi"></a>  CDC::GetCharABCWidthsI  
 Récupère les largeurs, en unités logiques, des indices de glyphe consécutives dans une plage spécifiée à partir de la police TrueType actuelle.  
  
```  
BOOL GetCharABCWidthsI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPABC lpabc) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *giFirst*  
 Spécifie le premier index de glyphe dans le groupe d’indices de glyphe consécutives à partir de la police actuelle. Ce paramètre est utilisé uniquement si le *IGP* paramètre est NULL.  
  
 *CGI*  
 Spécifie le nombre d’indices de glyphe.  
  
 *IGP*  
 Pointeur vers un tableau contenant les indices de glyphe. Si la valeur est NULL, le *giFirst* paramètre est utilisé à la place. Le *cgi* paramètre spécifie le nombre d’indices de glyphe de ce tableau.  
  
 *lpabc*  
 Pointeur vers un tableau de [ABC](/windows/desktop/api/wingdi/ns-wingdi-_abc) structures de réception de la largeur des caractères. Ce tableau doit contenir au moins autant `ABC` structures en tant qu’il existe des indices de glyphe spécifiés par le *cgi* paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre émule la fonctionnalité de la fonction [GetCharABCWidthsI](/windows/desktop/api/wingdi/nf-wingdi-getcharabcwidthsi), comme décrit dans le SDK Windows.  
  
##  <a name="getcharwidth"></a>  CDC::GetCharWidth  
 Récupère la largeur des caractères individuels d’un groupe de caractères consécutifs à partir de la police actuelle, à l’aide de `m_hAttribDC`, le contexte de périphérique d’entrée.  
  
```  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    float* lpFloatBuffer) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *nFirstChar*  
 Spécifie le premier caractère dans un groupe de caractères dans la police actuelle consécutifs.  
  
 *nLastChar*  
 Spécifie le dernier caractère dans un groupe de caractères dans la police actuelle consécutifs.  
  
 *lpBuffer*  
 Pointe vers une mémoire tampon qui recevra les valeurs de la largeur pour un groupe de caractères consécutifs dans la police actuelle.  
  
 *lpFloatBuffer*  
 Pointe vers une mémoire tampon pour recevoir les largeurs de caractère. Les largeurs retournées sont au format à virgule flottante IEEE 32 bits. (Les largeurs sont mesurées le long de la ligne de base des caractères).  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Par exemple, si *nFirstChar* identifie la lettre « a » et *nLastChar* identifie la lettre « z », la fonction extrait les largeurs de toutes les minuscules.  
  
 La fonction stocke les valeurs dans la mémoire tampon vers laquelle pointée *lpBuffer*. Cette mémoire tampon doit être suffisamment grand pour contenir toutes les largeurs. Autrement dit, au moins 26 entrées doit être dans l’exemple donné.  
  
 Si un caractère dans le groupe de caractères consécutifs n’existe pas dans une police particulière, la valeur de la largeur du caractère par défaut lui sera assignée.  
  
##  <a name="getcharwidthi"></a>  CDC::GetCharWidthI  
 Récupère les largeurs, en coordonnées logiques, des indices de glyphe consécutives dans une plage spécifiée à partir de la police actuelle.  
  
```  
BOOL GetCharWidthI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *giFirst*  
 Spécifie le premier index de glyphe dans le groupe d’indices de glyphe consécutives à partir de la police actuelle. Ce paramètre est utilisé uniquement si le *IGP* paramètre est NULL.  
  
 *CGI*  
 Spécifie le nombre d’indices de glyphe.  
  
 *IGP*  
 Pointeur vers un tableau contenant les indices de glyphe. Si la valeur est NULL, le *giFirst* paramètre est utilisé à la place. Le *cgi* paramètre spécifie le nombre d’indices de glyphe de ce tableau.  
  
 *lpBuffer*  
 Pointeur vers une mémoire tampon qui reçoit les largeurs.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre émule la fonctionnalité de la fonction [GetCharWidthI](/windows/desktop/api/wingdi/nf-wingdi-getcharwidthi), comme décrit dans le SDK Windows.  
  
##  <a name="getclipbox"></a>  CDC::GetClipBox  
 Récupère les dimensions du rectangle englobant plus étroite autour de la limite actuelle de découpage.  
  
```  
virtual int GetClipBox(LPRECT lpRect) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRect*  
 Pointe vers le [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui doit recevoir les dimensions du rectangle.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de la région découpage. Il peut être une des valeurs suivantes :  
  
- Région de découpage COMPLEXREGION a chevauchement des bordures.  
  
- Contexte de périphérique d’erreur n’est pas valide.  
  
- Région de découpage NULLREGION est vide.  
  
- Région de découpage SIMPLEREGION n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 Les dimensions sont copiées dans la mémoire tampon vers laquelle pointée *lpRect*.  
  
##  <a name="getcoloradjustment"></a>  CDC::GetColorAdjustment  
 Récupère les valeurs d’ajustement de couleur pour le contexte de périphérique.  
  
```  
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpColorAdjust*  
 Pointe vers un [réglage des couleurs](../../mfc/reference/coloradjustment-structure.md) structure de données pour recevoir les valeurs d’ajustement de couleur.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="getcurrentbitmap"></a>  CDC::GetCurrentBitmap  
 Retourne un pointeur vers actuellement sélectionné `CBitmap` objet.  
  
```  
CBitmap* GetCurrentBitmap() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CBitmap` de l’objet, en cas de réussite ; sinon, NULL.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentbrush"></a>  CDC::GetCurrentBrush  
 Retourne un pointeur vers actuellement sélectionné `CBrush` objet.  
  
```  
CBrush* GetCurrentBrush() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CBrush` de l’objet, en cas de réussite ; sinon, NULL.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentfont"></a>  CDC::GetCurrentFont  
 Retourne un pointeur vers actuellement sélectionné `CFont` objet.  
  
```  
CFont* GetCurrentFont() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CFont` de l’objet, en cas de réussite ; sinon, NULL.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentpalette"></a>  CDC::GetCurrentPalette  
 Retourne un pointeur vers actuellement sélectionné `CPalette` objet.  
  
```  
CPalette* GetCurrentPalette() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CPalette` de l’objet, en cas de réussite ; sinon, NULL.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentpen"></a>  CDC::GetCurrentPen  
 Retourne un pointeur vers actuellement sélectionné `CPen` objet.  
  
```  
CPen* GetCurrentPen() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CPen` de l’objet, en cas de réussite ; sinon, NULL.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentposition"></a>  CDC::GetCurrentPosition  
 Récupère la position actuelle (en coordonnées logiques).  
  
```  
CPoint GetCurrentPosition() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La position actuelle comme un `CPoint` objet.  
  
### <a name="remarks"></a>Notes  
 La position actuelle peut être définie avec la `MoveTo` fonction membre.  
  
##  <a name="getdcbrushcolor"></a>  CDC::GetDCBrushColor  
 Récupère la couleur actuelle du pinceau.  
  
```  
COLORREF GetDCBrushColor() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour est la [COLORREF](/windows/desktop/gdi/colorref) valeur pour la couleur actuelle du pinceau.  
  
 Si la fonction échoue, la valeur de retour est CLR_INVALID.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre émule la fonctionnalité de la fonction [GetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-getdcbrushcolor), comme décrit dans le SDK Windows.  
  
##  <a name="getdcpencolor"></a>  CDC::GetDCPenColor  
 Récupère la couleur actuelle du stylet.  
  
```  
COLORREF GetDCPenColor() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour est la [COLORREF](/windows/desktop/gdi/colorref) valeur pour la couleur actuelle du stylet.  
  
 Si la fonction échoue, la valeur de retour est CLR_INVALID.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre utilise la fonction Win32 [GetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-getdcpencolor), comme décrit dans le SDK Windows.  
  
##  <a name="getdevicecaps"></a>  CDC::GetDeviceCaps  
 Récupère un large éventail d’informations spécifiques à l’appareil sur le périphérique d’affichage.  
  
```  
int GetDeviceCaps(int nIndex) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *nIndex*  
 Spécifie le type d’informations à retourner. Consultez [GetDeviceCaps](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) dans le SDK Windows pour obtenir la liste de valeurs.  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur de la fonction demandée si la fonction réussite.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).  
  
##  <a name="getfontdata"></a>  CDC::GetFontData  
 Récupère les informations de métriques de police à partir d’un fichier de polices évolutives.  
  
```  
DWORD GetFontData(
    DWORD dwTable,  
    DWORD dwOffset,  
    LPVOID lpData,  
    DWORD cbData) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *dwTable*  
 Spécifie le nom de la table de métriques à retourner. Ce paramètre peut être une des tables de métriques documentées dans la spécification de fichiers de polices TrueType publiée par Microsoft Corporation. Si ce paramètre est 0, les informations sont récupérées en commençant au début du fichier de police.  
  
 *dwOffset*  
 Spécifie le décalage à partir du début de la table à partir duquel commencer la récupération des informations. Si ce paramètre est 0, les informations sont récupérées en commençant au début de la table spécifiée par le *dwTable* paramètre. Si cette valeur est supérieure ou égale à la taille de la table, `GetFontData` retourne 0.  
  
 *lpData*  
 Pointe vers une mémoire tampon qui recevra les informations de police. Si cette valeur est NULL, la fonction retourne la taille de la mémoire tampon requise pour les données de police spécifiées dans le *dwTable* paramètre.  
  
 *cbData*  
 Spécifie la longueur, en octets, des informations à récupérer. Si ce paramètre est 0, `GetFontData` retourne la taille des données spécifiées dans le *dwTable* paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le nombre d’octets retournés dans la mémoire tampon vers laquelle pointée *lpData* si la fonction réussit ; sinon -1.  
  
### <a name="remarks"></a>Notes  
 Les informations à récupérer sont identifiées en spécifiant un décalage dans le fichier de police et la longueur de l’information à retourner.  
  
 Une application peut parfois utiliser le `GetFontData` fonction membre pour enregistrer une police TrueType avec un document. Pour ce faire, l’application détermine si la police peut être incorporée et récupère ensuite le fichier de police entière, en spécifiant 0 pour le *dwTable*, *dwOffset*, et *cbData* paramètres.  
  
 Si une police peut être incorporée en vérifiant les applications peuvent déterminer la `otmfsType` membre de la [OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica) structure. Si le bit 1 de `otmfsType` est défini, l’incorporation n’est pas autorisée pour la police. Si le bit 1 est clair, la police peut être incorporée. Si le bit 2 est défini, l’incorporation est en lecture seule.  
  
 Si une application tente d’utiliser cette fonction pour récupérer des informations pour une police non TrueType, les `GetFontData` fonction membre retourne -1.  
  
##  <a name="getfontlanguageinfo"></a>  CDC::GetFontLanguageInfo  
 Retourne des informations sur la police actuellement sélectionnée pour le contexte d’affichage spécifié.  
  
```  
DWORD GetFontLanguageInfo() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur de retour identifie les caractéristiques de la police actuellement sélectionnée. Pour obtenir une liste complète des valeurs possibles, consultez [GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo).  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre émule la fonctionnalité de la fonction [GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo), comme décrit dans le SDK Windows.  
  
##  <a name="getglyphoutline"></a>  CDC::GetGlyphOutline  
 Récupère la courbe de plan ou d’une image bitmap pour un caractère de contour dans la police actuelle.  
  
```  
DWORD GetGlyphOutline(
    UINT nChar,  
    UINT nFormat,  
    LPGLYPHMETRICS lpgm,  
    DWORD cbBuffer,  
    LPVOID lpBuffer,  
    const MAT2* lpmat2) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *NChar*  
 Spécifie le caractère pour lequel les informations sont à retourner.  
  
 *nFormat*  
 Spécifie le format dans lequel la fonction doit retourner des informations. Il peut être une des valeurs suivantes, ou 0 :  
  
|Value|Signification|  
|-----------|-------------|  
|GGO_BITMAP|Retourne le bitmap de glyphe. Lorsque la fonction est retournée, la mémoire tampon vers laquelle pointe *lpBuffer* contient un bitmap de 1 bit par pixel dont les lignes démarrer sur des limites de mot double.|  
|GGO_NATIVE|Retourne la courbe de points de données au format natif du rastériseur, à l’aide d’unités de périphérique. Lorsque cette valeur est spécifiée, toutes les transformations spécifiées dans *lpmat2* est ignoré.|  
  
 Lorsque la valeur de *nFormat* est 0, la fonction insère un [GLYPHMETRICS](/windows/desktop/api/wingdi/ns-wingdi-_glyphmetrics) structure mais ne retourne pas de données de la structure du glyphe.  
  
 *lpgm*  
 Pointe vers une structure GLYPHMETRICS qui décrit le positionnement du glyphe dans la cellule de caractère.  
  
 *cbBuffer :*  
 Spécifie la taille de la mémoire tampon dans laquelle la fonction copie les informations sur le contour de caractère. Si cette valeur est 0 et le *nFormat* paramètre est les valeurs GGO_NATIVE ou GGO_BITMAP, la fonction retourne la taille requise de la mémoire tampon.  
  
 *lpBuffer*  
 Pointe vers une mémoire tampon dans laquelle la fonction copie les informations sur le contour de caractère. Si *nFormat* spécifie la valeur GGO_NATIVE, les informations sont copiées sous la forme de structures TTPOLYGONHEADER et TTPOLYCURVE. Si cette valeur est NULL et *nFormat* est la GGO_BITMAP GGO_NATIVE valeur ou, la fonction retourne la taille requise de la mémoire tampon.  
  
 *lpmat2*  
 Pointe vers un [MAT2](/windows/desktop/api/wingdi/ns-wingdi-_mat2) structure qui contient une matrice de transformation pour le caractère. Ce paramètre ne peut pas être NULL, même lorsque la valeur GGO_NATIVE est spécifiée pour *nFormat*.  
  
### <a name="return-value"></a>Valeur de retour  
 La taille, en octets, de la mémoire tampon requise pour les informations récupérées si *cbBuffer* est égal à 0 ou *lpBuffer* a la valeur NULL. Sinon, c’est une valeur positive si la fonction a réussi, ou -1 s’il existe une erreur.  
  
### <a name="remarks"></a>Notes  
 Une application peut faire pivoter de caractères récupérés au format bitmap en spécifiant une matrice de transformation de 2 x 2 dans la structure vers laquelle pointée *lpmat2*.  
  
 Un contour du glyphe est retourné en tant que série de contours. Chaque contour est défini par un [TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader) structure suivie autant `TTPOLYCURVE` structures en tant que sont requis pour le décrire. Tous les points sont retournés en tant que [POINTFX](/windows/desktop/api/wingdi/ns-wingdi-tagpointfx) structures et représentent des positions absolues, se déplace pas relatif. Le point de départ donnée par le `pfxStart` membre de la [TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader) structure est le point à partir duquel commence le contour pour un profil de charge. Le [TTPOLYCURVE](/windows/desktop/api/wingdi/ns-wingdi-tagttpolycurve) les structures qui suivent peuvent être des enregistrements de type polyligne ou enregistrements de spline. Les enregistrements de type polyligne sont une série de points ; les lignes tracées entre les points de décrivent le contour du caractère. Les enregistrements de spline représentent les courbes quadratiques utilisés par TrueType (autrement dit, quadratiques b-splines).  
  
##  <a name="getgraphicsmode"></a>  CDC::GetGraphicsMode  
 Récupère le mode graphique actuel pour le contexte de périphérique spécifié.  
  
```  
int GetGraphicsMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne le mode graphique actuel. Pour obtenir la liste des valeurs que cette méthode peut retourner, consultez [GetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode).  
  
 Retourne 0 en cas d’échec.  
  
 Pour obtenir les informations d’erreur étendues, appelez [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Notes  
 Cette méthode encapsule la fonction Windows GDI [GetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode).  
  
##  <a name="gethalftonebrush"></a>  CDC::GetHalftoneBrush  
 Appelez cette fonction membre pour récupérer un pinceau de demi-teintes.  
  
```  
static CBrush* PASCAL GetHalftoneBrush();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un pointeur vers un `CBrush` objet en cas de réussite ; sinon, NULL.  
  
### <a name="remarks"></a>Notes  
 Un pinceau de demi-teintes montre les pixels qui sont également les couleurs de premier plan et d’arrière-plan pour créer un motif tramé. Voici un exemple d’un motif tramé créé par un pinceau de demi-teintes.  
  
 ![Détail d’un trait de stylet tramé](../../mfc/reference/media/vc318s1.gif "vc318s1")  
  
##  <a name="getkerningpairs"></a>  CDC::GetKerningPairs  
 Récupère le caractère le crénage paires pour la police actuellement sélectionnée dans le contexte de périphérique spécifié.  
  
```  
int GetKerningPairs(
    int nPairs,  
    LPKERNINGPAIR lpkrnpair) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *nPairs*  
 Spécifie le nombre de [KERNINGPAIR](/windows/desktop/api/wingdi/ns-wingdi-tagkerningpair) structures vers lequel pointe *lpkrnpair*. La fonction ne copie pas les paires de crénage plus que ceux spécifiés par *nPairs*.  
  
 *lpkrnpair*  
 Pointe vers un tableau de `KERNINGPAIR` structures qui reçoivent le crénage paires lorsque la fonction retourne. Ce tableau doit contenir au moins autant de structures comme spécifié par *nPairs*. Si ce paramètre est NULL, la fonction retourne le nombre total de crénage paires pour la police.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le nombre de paires récupérés le crénage ou le nombre total de crénage paires dans la police, si la fonction réussite. Valeur zéro est renvoyée si la fonction échoue ou il n’existe aucune paire crénage pour la police.  
  
##  <a name="getlayout"></a>  CDC::GetLayout  
 Appelez cette fonction membre pour déterminer la disposition du texte et des graphiques pour un contexte de périphérique, comme une imprimante ou un métafichier.  
  
```  
DWORD GetLayout() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, la disposition des indicateurs pour le contexte de périphérique en cours. Sinon, GDI_ERROR. Pour des informations d’erreur étendues, appelez [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360). Pour obtenir la liste des indicateurs de mise en page, consultez [CDC::SetLayout](#setlayout).  
  
### <a name="remarks"></a>Notes  
 La disposition par défaut est de gauche à droite.  
  
##  <a name="getmapmode"></a>  CDC::GetMapMode  
 Récupère le mode de mappage actuel.  
  
```  
int GetMapMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de mappage.  
  
### <a name="remarks"></a>Notes  
 Pour obtenir une description des modes de mappage, consultez le `SetMapMode` fonction membre.  
  
> [!NOTE]
>  Si vous appelez [SetLayout](#setlayout) pour modifier le contrôleur de domaine à la disposition de droite à gauche, `SetLayout` MM_ISOTROPIC change automatiquement le mode de mappage. Par conséquent, n’importe quel appel ultérieur à `GetMapMode` retournera MM_ISOTROPIC.  
  
##  <a name="getmiterlimit"></a>  CDC::GetMiterLimit  
 Retourne la limite de pointe pour le contexte de périphérique.  
  
```  
float GetMiterLimit() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La limite de l’onglet est utilisée lorsque le dessins géométriques lignes angle aigu jointures.  
  
##  <a name="getnearestcolor"></a>  CDC::GetNearestColor  
 Retourne la couleur unie qui correspond le mieux à une couleur logique spécifiée.  
  
```  
COLORREF GetNearestColor(COLORREF crColor) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *crColor*  
 Spécifie la couleur à mettre en correspondance.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur de couleur RVB (rouge, vert, bleu) qui définit le solide de couleur plus proche de la *crColor* valeur que l’appareil peut représenter.  
  
### <a name="remarks"></a>Notes  
 L’appareil donné doit être en mesure de représenter cette couleur.  
  
##  <a name="getoutlinetextmetrics"></a>  CDC::GetOutlineTextMetrics  
 Récupère les informations métrique des polices TrueType.  
  
```  
UINT GetOutlineTextMetrics(
    UINT cbData,  
    LPOUTLINETEXTMETRIC lpotm) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpotm*  
 Pointe vers un tableau de [OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica) structures. Si ce paramètre est NULL, la fonction retourne la taille de la mémoire tampon requise pour les données de métrique récupérées.  
  
 *cbData*  
 Spécifie la taille, en octets, de la mémoire tampon à laquelle les informations sont retournées.  
  
 *lpotm*  
 Pointe vers une `OUTLINETEXTMETRIC` structure. Si ce paramètre est NULL, la fonction retourne la taille de la mémoire tampon requise pour les informations de métriques récupérées.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le [OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica) structure contient la plupart des informations de métriques de police fournies avec le format TrueType, y compris un [TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica) structure. Les quatre derniers membres de la `OUTLINETEXTMETRIC` structure sont des pointeurs vers des chaînes. Applications doivent allouer de l’espace pour ces chaînes en plus de l’espace requis pour les autres membres. Comme il n’existe aucune limite imposée par le système à la taille des chaînes, la méthode la plus simple pour allouer de la mémoire consiste à récupérer la taille requise en spécifiant la valeur NULL *lpotm* dans le premier appel à la `GetOutlineTextMetrics` (fonction).  
  
##  <a name="getoutputcharwidth"></a>  CDC::GetOutputCharWidth  
 Utilise le contexte de périphérique de sortie, `m_hDC`et récupère la largeur des caractères individuels d’un groupe de caractères consécutifs à partir de la police actuelle.  
  
```  
BOOL GetOutputCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *nFirstChar*  
 Spécifie le premier caractère dans un groupe de caractères dans la police actuelle consécutifs.  
  
 *nLastChar*  
 Spécifie le dernier caractère dans un groupe de caractères dans la police actuelle consécutifs.  
  
 *lpBuffer*  
 Pointe vers une mémoire tampon qui recevra les valeurs de la largeur pour un groupe de caractères consécutifs dans la police actuelle.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Par exemple, si *nFirstChar* identifie la lettre « a » et *nLastChar* identifie la lettre « z », la fonction extrait les largeurs de toutes les minuscules.  
  
 La fonction stocke les valeurs dans la mémoire tampon vers laquelle pointée *lpBuffer*. Cette mémoire tampon doit être suffisamment grand pour contenir tous les largeurs. Autrement dit, au moins 26 entrées doit être dans l’exemple donné.  
  
 Si un caractère dans le groupe de caractères consécutifs n’existe pas dans une police particulière, la valeur de la largeur du caractère par défaut lui sera assignée.  
  
##  <a name="getoutputtabbedtextextent"></a>  CDC::GetOutputTabbedTextExtent  
 Appelez cette fonction membre pour calculer la largeur et la hauteur d’une chaîne de caractères à l’aide [m_hDC](#m_hdc), le contexte de périphérique de sortie.  
  
```  
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetOutputTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpszString*  
 Pointe vers une chaîne de caractères à mesurer. Vous pouvez également passer un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 *nCount*  
 Spécifie le nombre de caractères de la chaîne. Si *nCount* est -1, la longueur est calculée.  
  
 *nTabPositions*  
 Spécifie le nombre de positions de taquet de tabulation dans le tableau pointé par *lpnTabStopPositions*.  
  
 *lpnTabStopPositions*  
 Pointe vers un tableau d’entiers qui contient les positions de taquet de tabulation en unités logiques. Les taquets de tabulation doivent être triées dans l’ordre ; croissant la plus petite valeur de x doit être le premier élément du tableau. Onglets précédent ne sont pas autorisés.  
  
 *str*  
 Un `CString` objet qui contient les caractères spécifiés à mesurer.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) dans un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 Si la chaîne contient un ou plusieurs caractères de tabulation, la largeur de la chaîne est basée sur les taquets de tabulation spécifiés par *lpnTabStopPositions*. La fonction utilise la police actuellement sélectionnée pour calculer les dimensions de la chaîne.  
  
 La zone de découpage en cours ne pas décalage de la largeur et la hauteur retournée par la `GetOutputTabbedTextExtent` (fonction).  
  
 Étant donné que certains appareils ne placent pas de caractères dans les tableaux de cellule standard (autrement dit, ils crénage les caractères), la somme des étendues des caractères dans une chaîne peut être différent dans la mesure de la chaîne.  
  
 Si *nTabPositions* est égal à 0 et *lpnTabStopPositions* est NULL, onglets sont développés en huit largeurs de caractère moyenne. Si *nTabPositions* est 1, les taquets de tabulation sont séparés par la distance spécifiée par la première valeur dans le tableau vers lequel *lpnTabStopPositions* points. Si *lpnTabStopPositions* points à plus d’une valeur unique, un taquet de tabulation est défini pour chaque valeur dans le tableau, jusqu’au nombre spécifié par *nTabPositions*.  
  
##  <a name="getoutputtextextent"></a>  CDC::GetOutputTextExtent  
 Appelez cette fonction membre pour utiliser le contexte de périphérique de sortie, [m_hDC](#m_hdc)et le calcul de la largeur et la hauteur d’une ligne de texte, à l’aide de la police actuelle.  
  
```  
CSize GetOutputTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetOutputTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpszString*  
 Pointe vers une chaîne de caractères. Vous pouvez également passer un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 *nCount*  
 Spécifie le nombre de caractères de la chaîne. Si *nCount* est -1, la longueur est calculée.  
  
 *str*  
 Un `CString` objet qui contient les caractères spécifiés à mesurer.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) retournées dans un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 La zone de découpage en cours n’affecte pas la largeur et la hauteur retournée par `GetOutputTextExtent`.  
  
 Étant donné que certains appareils ne placent pas de caractères dans les tableaux de cellule standard (autrement dit, ils effectuent le crénage), la somme des étendues des caractères dans une chaîne peut être différent dans la mesure de la chaîne.  
  
##  <a name="getoutputtextmetrics"></a>  CDC::GetOutputTextMetrics  
 Récupère les mesures pour la police actuelle à l’aide `m_hDC`, le contexte de périphérique de sortie.  
  
```  
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpMetrics*  
 Pointe vers le [TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica) structure qui reçoit les mesures.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="getpath"></a>  CDC::GetPath  
 Récupère les coordonnées définissant les points de terminaison de lignes et les points de contrôle des courbes trouvés dans le chemin d’accès qui est sélectionné dans le contexte de périphérique.  
  
```  
int GetPath(
    LPPOINT lpPoints,  
    LPBYTE lpTypes,  
    int nCount) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpPoints*  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données ou `CPoint` où des points de contrôle de points de terminaison de ligne et de la courbe des objets sont placés.  
  
 *lpTypes*  
 Pointe vers un tableau d’octets où sont placés les types de vertex. Les valeurs sont parmi les options suivantes :  
  
- PT_MOVETO Spécifie que le point correspondant dans *lpPoints* démarre une figure disjointe.  
  
- PT_LINETO Spécifie que le point précédent et correspondants point dans *lpPoints* sont les points de terminaison d’une ligne.  
  
- PT_BEZIERTO Spécifie que le point correspondant dans *lpPoints* est un point de contrôle ou d’un point de fin pour une courbe Bzier.  
  
 PT_BEZIERTO toujours se produire dans les ensembles de trois. Le point dans le chemin d’accès faisant immédiatement précéder définit le point de départ de la courbe Bzier. Les deux premiers points PT_BEZIERTO sont les points de contrôle et le troisième point PT_BEZIERTO est le point de terminaison (si codées en dur).  
  
     Un type PT_LINETO ou PT_BEZIERTO peut-être être combiné avec l’indicateur suivant (à l’aide de l’opérateur de bits **OR**) pour indiquer que le point correspondant est le dernier point dans une figure et que la figure doit être fermée :  
  
- PT_CLOSEFIGURE Spécifie que la figure est fermée automatiquement après la ligne correspondante ou courbe est dessinée. La figure est fermée en dessinant une ligne du point de terminaison ou la courbe au point correspondant au dernier PT_MOVETO.  
  
 *nCount*  
 Spécifie le nombre total de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui peuvent être placés dans le *lpPoints* tableau. Cette valeur doit être le même que le nombre d’octets qui peut-être être placé dans le *lpTypes* tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Si le *nCount* paramètre est différent de zéro, le nombre de points énumérés. Si *nCount* est 0, le nombre total de points dans le chemin d’accès (et `GetPath` n’écrit rien dans les mémoires tampons). Si *nCount* est différent de zéro et est inférieur au nombre de points dans le chemin d’accès, la valeur de retour est -1.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique doit contenir une trajectoire fermée. Les points du chemin d’accès sont retournées en coordonnées logiques. Points sont stockés dans le chemin d’accès dans les coordonnées de périphérique, par conséquent, `GetPath` remplace les points de coordonnées de périphérique coordonnées logiques à l’aide de l’inverse de la transformation actuelle. Le `FlattenPath` fonction membre peut être appelée avant `GetPath`, pour convertir toutes les courbes dans le chemin d’accès en segments de ligne.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="getpixel"></a>  CDC::GetPixel  
 Récupère la valeur de couleur RVB du pixel au point spécifié par *x* et *y*.  
  
```  
COLORREF GetPixel(
    int x,  
    int y) const;  
  
COLORREF GetPixel(POINT point) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point doit être examinée.  
  
 *y*  
 Spécifie la coordonnée y logique du point doit être examinée.  
  
 *point*  
 Spécifie la logique - coordonnées x et y-du point doit être examinée.  
  
### <a name="return-value"></a>Valeur de retour  
 Pour les deux versions de la fonction, une valeur de couleur RVB de la couleur du point donné. Il est -1 si les coordonnées ne spécifient pas un point dans la zone de découpage.  
  
### <a name="remarks"></a>Notes  
 Le point doit être dans la zone de découpage. Si le point n’est pas dans la zone de découpage, la fonction n’a aucun effet et retourne -1.  
  
 La fonction `GetPixel` n'est pas prise en charge par tous les périphériques. Pour plus d’informations, consultez la fonctionnalité de raster RC_BITBLT sous le [GetDeviceCaps](#getdevicecaps) fonction membre.  
  
 Le `GetPixel` fonction membre a deux formes. Le premier prend deux valeurs de coordonnées ; la deuxième prend soit un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet.  
  
##  <a name="getpolyfillmode"></a>  CDC::GetPolyFillMode  
 Récupère le mode de remplissage de polygone actuel.  
  
```  
int GetPolyFillMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Rempli de polygone mode actuel, de remplacement ou l’enroulement, si la fonction réussite.  
  
### <a name="remarks"></a>Notes  
 Consultez le `SetPolyFillMode` fonction membre pour obtenir une description des modes de remplissage de polygones.  
  
##  <a name="getrop2"></a>  CDC::GetROP2  
 Récupère le mode de dessin en cours.  
  
```  
int GetROP2() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de dessin. Pour obtenir la liste des valeurs de mode dessin, consultez le `SetROP2` fonction membre.  
  
### <a name="remarks"></a>Notes  
 Le mode dessin spécifie comment les couleurs du stylet et l’intérieur d’objets sont combinées avec la couleur déjà sur la surface d’affichage.  
  
##  <a name="getsafehdc"></a>  CDC::GetSafeHdc  
 Appelez cette fonction membre pour obtenir [m_hDC](#m_hdc), le contexte de périphérique de sortie.  
  
```  
HDC GetSafeHdc() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un handle de contexte de périphérique.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre fonctionne également avec des pointeurs null.  
  
##  <a name="getstretchbltmode"></a>  CDC::GetStretchBltMode  
 Récupère le mode d’étirement de bitmap actuel.  
  
```  
int GetStretchBltMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur de retour Spécifie le mode d’étirement de bitmap actuel : STRETCH_ANDSCANS, STRETCH_DELETESCANS ou STRETCH_ORSCANS, si la fonction réussite.  
  
### <a name="remarks"></a>Notes  
 Le mode d’étirement de bitmap définit comment les informations sont supprimées de bitmaps qui sont étirées ou compressées par le `StretchBlt` fonction membre.  
  
 Les modes STRETCH_ANDSCANS et STRETCH_ORSCANS sont généralement utilisés pour conserver les pixels de premier plan dans les images bitmap monochromes. Le mode STRETCH_DELETESCANS est généralement utilisé pour conserver les couleurs dans les images bitmap de couleur.  
  
##  <a name="gettabbedtextextent"></a>  CDC::GetTabbedTextExtent  
 Appelez cette fonction membre pour calculer la largeur et la hauteur d’une chaîne de caractères à l’aide [m_hAttribDC](#m_hattribdc), le contexte de l’attribut.  
  
```  
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpszString*  
 Pointe vers une chaîne de caractères. Vous pouvez également passer un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 *nCount*  
 Spécifie le nombre de caractères de la chaîne. Si *nCount* est -1, la longueur est calculée.  
  
 *nTabPositions*  
 Spécifie le nombre de positions de taquet de tabulation dans le tableau pointé par *lpnTabStopPositions*.  
  
 *lpnTabStopPositions*  
 Pointe vers un tableau d’entiers qui contient les positions de taquet de tabulation en unités logiques. Les taquets de tabulation doivent être triées dans l’ordre ; croissant la plus petite valeur de x doit être le premier élément du tableau. Onglets précédent ne sont pas autorisés.  
  
 *str*  
 Un `CString` objet qui contient les caractères spécifiés à dessiner.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) dans un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 Si la chaîne contient un ou plusieurs caractères de tabulation, la largeur de la chaîne est basée sur les taquets de tabulation spécifiés par *lpnTabStopPositions*. La fonction utilise la police actuellement sélectionnée pour calculer les dimensions de la chaîne.  
  
 La zone de découpage en cours ne pas décalage de la largeur et la hauteur retournée par la `GetTabbedTextExtent` (fonction).  
  
 Étant donné que certains appareils ne placent pas de caractères dans les tableaux de cellule standard (autrement dit, ils crénage les caractères), la somme des étendues des caractères dans une chaîne peut être différent dans la mesure de la chaîne.  
  
 Si *nTabPositions* est égal à 0 et *lpnTabStopPositions* est NULL, onglets sont développés en huit fois la moyenne largeur des caractères. Si *nTabPositions* est 1, les taquets de tabulation sont séparés par la distance spécifiée par la première valeur dans le tableau vers lequel *lpnTabStopPositions* points. Si *lpnTabStopPositions* points à plus d’une valeur unique, un taquet de tabulation est défini pour chaque valeur dans le tableau, jusqu’au nombre spécifié par *nTabPositions*.  
  
##  <a name="gettextalign"></a>  CDC::GetTextAlign  
 Récupère l’état des indicateurs d’alignement du texte pour le contexte de périphérique.  
  
```  
UINT GetTextAlign() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 L’état des indicateurs d’alignement du texte. La valeur de retour est une ou plusieurs des valeurs suivantes :  
  
- Alignement TA_BASELINE spécifie de l’axe des abscisses et de la ligne de base de la police choisie dans le rectangle englobant.  
  
- Alignement TA_BOTTOM spécifie de l’axe des abscisses et le bas du rectangle englobant.  
  
- Alignement TA_CENTER spécifie de l’axe y et le centre du rectangle englobant.  
  
- Alignement TA_LEFT spécifie de l’axe y et le côté gauche du rectangle englobant.  
  
- TA_NOUPDATECP Spécifie que la position actuelle n’est pas mis à jour.  
  
- Alignement TA_RIGHT spécifie de l’axe y et le côté droit du rectangle englobant.  
  
- Alignement TA_TOP spécifie de l’axe des abscisses et le haut du rectangle englobant.  
  
- TA_UPDATECP Spécifie que la position actuelle est à jour.  
  
### <a name="remarks"></a>Notes  
 Les indicateurs de l’alignement du texte déterminent comment la `TextOut` et `ExtTextOut` fonctions membres alignement une chaîne de texte en relation avec le point de départ de la chaîne. Les indicateurs de l’alignement du texte ne sont pas nécessairement unique bits indicateurs et peuvent être égales à 0. Pour tester si un indicateur est défini, une application doit procéder comme suit :  
  
1.  Appliquer l’opérateur OR au niveau du bit à l’indicateur et ses indicateurs associés, regroupées comme suit :  
  
    - TA_LEFT, TA_CENTER et TA_RIGHT  
  
    - TA_BASELINE, TA_BOTTOM et TA_TOP  
  
    - TA_NOUPDATECP et TA_UPDATECP  
  
2.  Appliquer l’opérateur de bits- et opérateur pour le résultat et la valeur de retour de `GetTextAlign`.  
  
3.  Tester l’égalité de ce résultat et l’indicateur.  
  
##  <a name="gettextcharacterextra"></a>  CDC::GetTextCharacterExtra  
 Récupère le paramètre actuel pour la quantité d’espacement entre les caractères.  
  
```  
int GetTextCharacterExtra() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La quantité de l’espacement entre les caractères.  
  
### <a name="remarks"></a>Notes  
 GDI ajoute cet espacement à chaque caractère, y compris les caractères de saut, lorsqu’il écrit une ligne de texte dans le contexte de périphérique.  
  
 La valeur par défaut pour la quantité de l’espacement est 0.  
  
##  <a name="gettextcolor"></a>  CDC::GetTextColor  
 Récupère la couleur de texte actuelle.  
  
```  
COLORREF GetTextColor() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La couleur de texte actuelle avec une valeur de couleur RVB.  
  
### <a name="remarks"></a>Notes  
 La couleur du texte est la couleur de premier plan de caractères dessiné en utilisant les fonctions de membre de la sortie de texte GDI [TextOut](#textout), [ExtTextOut](#exttextout), et [TabbedTextOut](#tabbedtextout).  
  
##  <a name="gettextextent"></a>  CDC::GetTextExtent  
 Appelez cette fonction membre pour calculer la largeur et la hauteur d’une ligne de texte à l’aide de la police actuelle pour déterminer les dimensions.  
  
```  
CSize GetTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpszString*  
 Pointe vers une chaîne de caractères. Vous pouvez également passer un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 *nCount*  
 Spécifie le nombre de caractères de la chaîne.  
  
 *str*  
 Un `CString` objet qui contient les caractères spécifiés.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) dans un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 Les informations sont récupérées à partir de [m_hAttribDC](#m_hattribdc), le contexte de l’attribut.  
  
 Par défaut, `GetTextExtent` suppose que le texte pour lequel il récupère de la dimension est défini le long d’une ligne horizontale (autrement dit, Escapement la valeur est 0). Si vous créez une police en spécifiant un échappement différent de zéro, vous devez convertir l’angle du texte explicitement à obtenir les dimensions de la chaîne.  
  
 La zone de découpage en cours n’affecte pas la largeur et la hauteur retournée par `GetTextExtent`.  
  
 Étant donné que certains appareils ne placent pas de caractères dans les tableaux de cellule standard (autrement dit, ils effectuent le crénage), la somme des étendues des caractères dans une chaîne peut être différent dans la mesure de la chaîne.  
  
##  <a name="gettextextentexpointi"></a>  CDC::GetTextExtentExPointI  
 Récupère le nombre de caractères dans une chaîne spécifiée qui occupent un espace spécifié et remplit un tableau avec l’étendue de texte pour chacun de ces caractères.  
  
```  
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,  
    int cgi,  
    int nMaxExtent,  
    LPINT lpnFit,  
    LPINT alpDx,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *pgiIn*  
 Pointeur vers un tableau d’indices de glyphe pour lequel les extensions doivent être récupérés.  
  
 *CGI*  
 Spécifie le nombre de glyphes dans le tableau vers lequel pointé *pgiIn*.  
  
 *nMaxExtent*  
 Spécifie la largeur maximale autorisée, en unités logiques, de la chaîne mise en forme.  
  
 *lpnFit*  
 Un pointeur vers un entier qui reçoit un nombre du nombre maximal de caractères qui tiendront dans l’espace spécifié par *nMaxExtent*. Lorsque *lpnFit* est NULL, *nMaxExtent* est ignoré.  
  
 *alpDx*  
 Pointeur vers un tableau d’entiers qui reçoit des étendues de glyphe partielle. Chaque élément du tableau donne la distance, en unités logiques, entre le début du tableau d’indices de glyphe et celui des glyphes qui s’intègre dans l’espace spécifié par *nMaxExtent*. Bien que ce tableau doit avoir au moins autant d’éléments en tant qu’index de glyphe spécifiés par *cgi*, la fonction remplit le tableau avec les étendues uniquement pour les index de glyphes autant spécifiés par *lpnFit*. Si *lpnDx* est NULL, la fonction ne calcule pas les largeurs de chaîne partielle.  
  
 *lpSize*  
 Pointeur vers un [taille](https://msdn.microsoft.com/library/windows/desktop/dd145106) structure qui reçoit les dimensions du tableau d’indices de glyphe, en unités logiques. Cette valeur ne peut pas être NULL.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre émule la fonctionnalité de la fonction [GetTextExtentExPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentexpointi), comme décrit dans le SDK Windows.  
  
##  <a name="gettextextentpointi"></a>  CDC::GetTextExtentPointI  
 Récupère la largeur et la hauteur du tableau spécifié d’indices de glyphe.  
  
```  
BOOL GetTextExtentPointI(
    LPWORD pgiIn,  
    int cgi,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *pgiIn*  
 Pointeur vers un tableau d’indices de glyphe pour lequel les extensions doivent être récupérés.  
  
 *CGI*  
 Spécifie le nombre de glyphes dans le tableau vers lequel pointé *pgiIn*.  
  
 *lpSize*  
 Pointeur vers un [taille](https://msdn.microsoft.com/library/windows/desktop/dd145106) structure qui reçoit les dimensions du tableau d’indices de glyphe, en unités logiques. Cette valeur ne peut pas être NULL.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre émule la fonctionnalité de la fonction [GetTextExtentPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentpointi), comme décrit dans le SDK Windows.  
  
##  <a name="gettextface"></a>  CDC::GetTextFace  
 Appelez cette fonction membre pour copier le nom de la police actuelle dans une mémoire tampon.  
  
```  
int GetTextFace(
    int nCount,  
    LPTSTR lpszFacename) const;  
  
int GetTextFace(CString& rString) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *nCount*  
 Spécifie la taille de la mémoire tampon (en octets). Si le nom de la police est plus long que le nombre d’octets spécifié par ce paramètre, le nom sera tronqué.  
  
 *lpszFacename*  
 Pointe vers la mémoire tampon pour le nom de police.  
  
 *rString*  
 Une référence à un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet.  
  
### <a name="return-value"></a>Valeur de retour  
 Le nombre d’octets copiés vers la mémoire tampon, non compris le caractère null de fin. Il est 0 si une erreur se produit.  
  
### <a name="remarks"></a>Notes  
 Le nom de type de caractères sont copiés sous forme de chaîne se terminant par null.  
  
##  <a name="gettextmetrics"></a>  CDC::GetTextMetrics  
 Récupère les mesures pour la police actuelle en utilisant le contexte de périphérique d’attribut.  
  
```  
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpMetrics*  
 Pointe vers le [TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica) structure qui reçoit les mesures.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="getviewportext"></a>  CDC::GetViewportExt  
 Récupère les étendues x et y de la fenêtre d’affichage du contexte de périphérique.  
  
```  
CSize GetViewportExt() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le x - et y-extensions (en unités de périphérique) comme un `CSize` objet.  
  
##  <a name="getviewportorg"></a>  CDC::GetViewportOrg  
 Récupère les coordonnées x et y de l’origine de la fenêtre d’affichage associé au contexte de périphérique.  
  
```  
CPoint GetViewportOrg() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de la fenêtre d’affichage (dans les coordonnées de périphérique) comme un `CPoint` objet.  
  
##  <a name="getwindow"></a>  CDC::GetWindow  
 Retourne la fenêtre associée au contexte de périphérique d’affichage.  
  
```  
CWnd* GetWindow() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CWnd` objet en cas de réussite ; sinon, NULL.  
  
### <a name="remarks"></a>Notes  
 Il s’agit d’une fonction avancée. Par exemple, cette fonction membre ne peut pas retourner la fenêtre d’affichage lors de l’impression ou dans l’aperçu avant impression. Elle retourne toujours la fenêtre de sortie. Les fonctions de sortie qui utilisent le contrôleur de domaine donné dessinent dans cette fenêtre.  
  
##  <a name="getwindowext"></a>  CDC::GetWindowExt  
 Récupère les étendues x et y de la fenêtre associée au contexte de périphérique.  
  
```  
CSize GetWindowExt() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le x - et y-extensions (en unités logiques) comme un `CSize` objet.  
  
##  <a name="getwindoworg"></a>  CDC::GetWindowOrg  
 Récupère les coordonnées x et y de l’origine de la fenêtre associée au contexte de périphérique.  
  
```  
CPoint GetWindowOrg() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de la fenêtre (en coordonnées logiques) selon une `CPoint` objet.  
  
##  <a name="getworldtransform"></a>  CDC::GetWorldTransform  
 Récupère l’espace universel actuel pour la transformation de l’espace de page.  
  
```  
BOOL GetWorldTransform(XFORM& rXform) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *rXform*  
 Référence à un [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform) structure qui reçoit l’espace universel actuel pour la transformation de l’espace de page.  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne une valeur différente de zéro.  
  
 Retourne 0 en cas d’échec.  
  
 Pour obtenir les informations d’erreur étendues, appelez [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Notes  
 Cette méthode encapsule la fonction Windows GDI [GetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-getworldtransform).  
  
##  <a name="gradientfill"></a>  CDC::GradientFill  
 Appelez cette fonction membre pour remplir les structures de rectangle et un triangle avec couleur sans heurts fondu d’un côté à l’autre.  
  
```  
BOOL GradientFill(
    TRIVERTEX* pVertices,  
    ULONG nVertices,  
    void* pMesh,  
    ULONG nMeshElements,  
    DWORD dwMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *pVertices*  
 Pointeur vers un tableau de [TRIVERTEX](/windows/desktop/api/wingdi/ns-wingdi-_trivertex) structures que définissent chacun un vertex du triangle.  
  
 *nVertices*  
 Le nombre de vertex.  
  
 *pMesh*  
 Tableau de [GRADIENT_TRIANGLE](/windows/desktop/api/wingdi/ns-wingdi-_gradient_triangle) en mode de triangle ou un tableau de structures de [GRADIENT_RECT](/windows/desktop/api/wingdi/ns-wingdi-_gradient_rect) structures en mode de rectangle.  
  
 *nMeshElements*  
 Le nombre d’éléments (triangles ou les rectangles) dans *pMesh*.  
  
 *dwMode*  
 Spécifie le mode de remplissage dégradé. Pour obtenir la liste des valeurs possibles, consultez [GradientFill](/windows/desktop/api/wingdi/nf-wingdi-gradientfill) dans le SDK Windows.  
  
### <a name="return-value"></a>Valeur de retour  
 TRUE en cas de réussite, sinon FALSE.  
  
### <a name="remarks"></a>Notes  
 Pour plus d’informations, consultez `GradientFill` dans le SDK Windows.  
  
##  <a name="graystring"></a>  CDC::GrayString  
 Dessine estompé (gris) à l’emplacement donné en écrivant le texte dans une image bitmap de mémoire, estomper le bitmap et puis en copiant la bitmap à l’affichage.  
  
```  
virtual BOOL GrayString(
    CBrush* pBrush,  
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),  
    LPARAM lpData,  
    int nCount,  
    int x,  
    int y,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Paramètres  
 *pBrush*  
 Identifie le pinceau à utiliser pour l’estompage (qui en devient).  
  
 *lpfnOutput*  
 Spécifie l’adresse de l’instance de la procédure de la fonction de rappel fournie par l’application qui dessine la chaîne. Pour plus d’informations, consultez la description de la Windows `OutputFunc` [fonction de rappel](callback-functions-used-by-mfc.md#graystring). Si ce paramètre est NULL, le système utilise le Windows `TextOut` fonction pour dessiner la chaîne, et *lpData* est censé pour être un pointeur long désignant la chaîne de caractères en sortie.  
  
 *lpData*  
 Spécifie un pointeur lointain vers les données à passer à la fonction de sortie. Si *lpfnOutput* est NULL, *lpData* doit être un pointeur long désignant la chaîne de sortie.  
  
 *nCount*  
 Spécifie le nombre de caractères en sortie. Si ce paramètre est 0, `GrayString` calcule la longueur de la chaîne (en supposant que *lpData* est un pointeur vers la chaîne). Si *nCount* est -1 et la fonction vers laquelle pointé *lpfnOutput* retourne 0, l’image est indiqué mais non estompés.  
  
 *x*  
 Spécifie la coordonnée x logique de la position de départ du rectangle qui englobe la chaîne.  
  
 *y*  
 Spécifie la coordonnée y logique de la position de départ du rectangle qui englobe la chaîne.  
  
 *nWidth*  
 Spécifie la largeur (en unités logiques) du rectangle qui englobe la chaîne. Si *nWidth* est 0, `GrayString` calcule la largeur de la zone, en supposant que *lpData* est un pointeur vers la chaîne.  
  
 *nHeight*  
 Spécifie la hauteur (en unités logiques) du rectangle qui englobe la chaîne. Si *nHeight* est 0, `GrayString` calcule la hauteur de la zone, en supposant que *lpData* est un pointeur vers la chaîne.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la chaîne est dessinée, ou 0 si le `TextOut` fonction ou la fonction de sortie fourni par l’application a retourné 0, ou si la mémoire était insuffisante pour créer une image bitmap de mémoire pour cette fonction.  
  
### <a name="remarks"></a>Notes  
 La fonction efface le texte, quel que soit le pinceau sélectionné et l’arrière-plan. Le `GrayString` fonction membre utilise la police actuellement sélectionnée. Le mode de mappage MM_TEXT doit être sélectionné avant d’utiliser cette fonction.  
  
 Une application peut dessiner estompés chaînes (grisées) sur les appareils qui prennent en charge le gris uni sans appeler le `GrayString` fonction membre. La couleur système COLOR_GRAYTEXT est la couleur unie-gris système utilisée pour dessiner le texte désactivé. L’application peut appeler le `GetSysColor` (fonction) Windows pour récupérer la valeur de couleur de COLOR_GRAYTEXT. Si la couleur est différente de 0 (noir), l’application peut appeler le `SetTextColor` fonction membre à définir la couleur du texte à la valeur de couleur et puis dessiner directement la chaîne. Si la couleur extraite est noire, l’application doit appeler `GrayString` atténue (gris) le texte.  
  
 Si *lpfnOutput* est NULL, GDI utilise le Windows [TextOut](/windows/desktop/api/wingdi/nf-wingdi-textouta) (fonction), et *lpData* est censé pour être un pointeur lointain vers le caractère à sortir. Si les caractères en sortie ne peut pas être gérés par le `TextOut` fonction membre (par exemple, la chaîne est stockée sous forme de bitmap), l’application doit fournir sa propre fonction de sortie.  
  
 Notez également que toutes les fonctions de rappel doivent intercepter les exceptions de Microsoft Foundation avant de revenir à Windows, étant donné que les exceptions ne peut pas être levées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, consultez l’article [Exceptions](../../mfc/exception-handling-in-mfc.md).  
  
 La fonction de rappel passé à `GrayString` doit utiliser le `__stdcall` convention d’appel et doit être exporté avec `__declspec`.  
  
 Lorsque l’infrastructure est en mode Aperçu, un appel à la `GrayString` fonction membre est traduite en une `TextOut` appel et la fonction de rappel n’est pas appelée.  
  
##  <a name="himetrictodp"></a>  CDC::HIMETRICtoDP  
 Utilisez cette fonction lorsque vous convertissez des tailles HIMETRIC à OLE, en pixels.  
  
```  
void HIMETRICtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpSize*  
 Pointe vers un [taille](https://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 Si le mode de mappage de l’objet de contexte de périphérique est MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC ou MM_HIMETRIC, la conversion est basée sur le nombre de pixels dans le pouce physique. Si le mode de mappage est un des autres modes non limité (par exemple, MM_TEXT), la conversion est basée sur le nombre de pixels dans le pouce logique.  
  
##  <a name="himetrictolp"></a>  CDC::HIMETRICtoLP  
 Appelez cette fonction pour convertir les unités HIMETRIC en unités logiques.  
  
```  
void HIMETRICtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpSize*  
 Pointe vers un [taille](https://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 Utilisez cette fonction lorsque vous obtenez des tailles HIMETRIC de OLE et que vous souhaitez convertir en mode de mappage naturel de votre application.  
  
 La conversion s’effectue en convertissant d’abord en unités HIMETRIC en pixels, puis en convertissant ces unités dans des unités logiques à l’aide d’unités de mappage de contexte de périphérique en cours. Notez que les étendues de fenêtre et la fenêtre d’affichage de l’appareil affecte le résultat.  
  
##  <a name="intersectcliprect"></a>  CDC::IntersectClipRect  
 Crée une nouvelle zone de découpage par l’intersection de la zone en cours et le rectangle spécifié par *x1*, *y1*, *x2*, et *y2*.  
  
```  
int IntersectClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int IntersectClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 *x1*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle.  
  
 *y1*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle.  
  
 *x2*  
 Spécifie la coordonnée x logique de l’angle inférieur droit du rectangle.  
  
 *y2*  
 Spécifie la coordonnée y logique de l’angle inférieur droit du rectangle.  
  
 *lpRect*  
 Spécifie le rectangle. Vous pouvez passer soit un `CRect` objet ou un pointeur vers un `RECT` structure pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de la nouvelle région découpage. Il peut prendre l’une des valeurs suivantes :  
  
- COMPLEXREGION nouvelle zone de découpage a chevauchement des bordures.  
  
- Contexte de périphérique d’erreur n’est pas valide.  
  
- NULLREGION nouvelle zone de découpage est vide.  
  
- SIMPLEREGION nouvelle zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 GDI découpe toutes les sorties suivantes pour tenir dans la nouvelle limite. La largeur et la hauteur ne doivent pas dépasser 32 767.  
  
##  <a name="invertrect"></a>  CDC::InvertRect  
 Inverse le contenu du rectangle donné.  
  
```  
void InvertRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRect*  
 Pointe vers un `RECT` qui contient les coordonnées logiques du rectangle à inverser. Vous pouvez également passer un `CRect` objet pour ce paramètre.  
  
### <a name="remarks"></a>Notes  
 Inversion est un opérateur logique non opération et les retournements de bits de chaque pixel. Sur un écran monochrome, la fonction effectue pixels blanc noir et noir pixels blanc. Sur les écrans de couleur, l’inversion dépend de la façon dont les couleurs sont générés pour l’affichage. Appel `InvertRect` à deux reprises avec le même rectangle restaure l’affichage à ses couleurs précédentes.  
  
 Si le rectangle est vide, rien n’est dessiné.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]  
  
##  <a name="invertrgn"></a>  CDC::InvertRgn  
 Inverse les couleurs dans la région spécifiée par *pRgn*.  
  
```  
BOOL InvertRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>Paramètres  
 *pRgn*  
 Identifie la région à inverser. Les coordonnées de la région sont spécifiées en unités logiques.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Sur un écran monochrome, la fonction effectue pixels blanc noir et noir pixels blanc. Sur les écrans de couleur, l’inversion dépend de la façon dont les couleurs sont générés pour l’affichage.  
  
##  <a name="isprinting"></a>  CDC::IsPrinting  
 Détermine si le contexte de périphérique est utilisé pour l’impression.  
  
```  
BOOL IsPrinting() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si le `CDC` objet est une imprimante DC ; sinon 0.  
  
##  <a name="lineto"></a>  CDC::LineTo  
 Dessine une ligne à partir de la position actuelle jusqu'à, non compris, le point spécifié par *x* et *y* (ou *point*).  
  
```  
BOOL LineTo(
    int x,  
    int y);  
  
BOOL LineTo(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point de terminaison de la ligne.  
  
 *y*  
 Spécifie la coordonnée y logique du point de terminaison de la ligne.  
  
 *point*  
 Spécifie le point de terminaison de la ligne. Vous pouvez passer soit un `POINT` structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la ligne est dessinée ; sinon 0.  
  
### <a name="remarks"></a>Notes  
 La ligne est dessinée avec le stylet sélectionné. La position actuelle est définie sur *x*, *y* ou *point*.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).  
  
##  <a name="lptodp"></a>  CDC::LPtoDP  
 Convertit des unités logiques en unités de périphérique.  
  
```  
void LPtoDP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpPoints*  
 Pointe vers un tableau de points. Chaque point dans le tableau est un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet.  
  
 *nCount*  
 Le nombre de points dans le tableau.  
  
 *lpRect*  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet. Ce paramètre est utilisé pour le cas courant consistant à mapper un rectangle exprimé en coordonnées logiques à des unités de périphérique.  
  
 *lpSize*  
 Pointe vers un [taille](https://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 La fonction mappe les coordonnées de chaque point, ou les dimensions de taille, à partir du système de coordonnées logiques du GDI dans un système de coordonnées de périphérique. La conversion varie selon le mode de mappage actuel et les paramètres des origines et les étendues de fenêtre et la fenêtre d’affichage de l’appareil.  
  
 Les coordonnées x et y de points sont des entiers signés de 2 octets dans la plage-32 768 à 32 767. Dans les cas où le mode de mappage entraînerait des valeurs supérieures à ces limites, le système définit les valeurs de-32 768 et 32 767, respectivement.  
  
##  <a name="lptohimetric"></a>  CDC::LPtoHIMETRIC  
 Appelez cette fonction pour convertir les unités logiques en unités HIMETRIC.  
  
```  
void LPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpSize*  
 Pointe vers un `SIZE` structure ou un `CSize` objet.  
  
### <a name="remarks"></a>Notes  
 Utilisez cette fonction lorsque vous donnez les tailles HIMETRIC à OLE, le passage du mode de mappage naturel de votre application. Notez que les étendues de fenêtre et la fenêtre d’affichage de l’appareil affecte le résultat.  
  
 La conversion s’effectue en convertissant d’abord en unités logiques en pixels à l’aide d’unités de mappage de contexte de périphérique en cours, puis en convertissant ces unités en unités HIMETRIC.  
  
##  <a name="m_hattribdc"></a>  CDC::m_hAttribDC  
 Le contexte de périphérique d’attribut pour ce `CDC` objet.  
  
```  
HDC m_hAttribDC;  
```  
  
### <a name="remarks"></a>Notes  
 Par défaut, ce contexte de périphérique est égal à `m_hDC`. En règle générale, `CDC` appels GDI qui demandent des informations à partir du contexte de périphérique sont dirigées vers `m_hAttribDC`. Consultez le [CDC](../../mfc/reference/cdc-class.md) description pour plus d’informations sur l’utilisation de ces contextes de deux périphérique de classe.  
  
##  <a name="m_hdc"></a>  CDC::m_hDC  
 Le contexte de périphérique de sortie pour ce `CDC` objet.  
  
```  
HDC m_hDC;  
```  
  
### <a name="remarks"></a>Notes  
 Par défaut, `m_hDC` est égal à `m_hAttribDC`, l’autre contexte de périphérique encapsulé par `CDC`. En règle générale, `CDC` appels GDI qui créent la sortie atteindre le `m_hDC` contexte de périphérique. Vous pouvez initialiser `m_hDC` et `m_hAttribDC` pour pointer vers différents appareils. Consultez le [CDC](../../mfc/reference/cdc-class.md) description pour plus d’informations sur l’utilisation de ces contextes de deux périphérique de classe.  
  
##  <a name="maskblt"></a>  CDC::MaskBlt  
 Combine les données de couleur pour les bitmaps de source et de destination en utilisant le masque donné et l’opération de rastérisation.  
  
```  
BOOL MaskBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle de destination.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle de destination.  
  
 *nWidth*  
 Spécifie la largeur, en unités logiques, de la bitmap source et le rectangle de destination.  
  
 *nHeight*  
 Spécifie la hauteur, en unités logiques, de la bitmap source et le rectangle de destination.  
  
 *pSrcDC*  
 Identifie le contexte de périphérique à partir duquel l’image bitmap doit être copiée. Il doit être zéro si le *dwRop* paramètre spécifie une opération de rastérisation qui n’inclut pas d’une source.  
  
 *xSrc*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche de la bitmap source.  
  
 *ySrc*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche de la bitmap source.  
  
 *maskBitmap*  
 Identifie la bitmap de masque monochrome combinée avec le bitmap de couleur dans le contexte du périphérique source.  
  
 *xMask*  
 Spécifie le décalage horizontal pixel de la bitmap de masque spécifié par le *maskBitmap* paramètre.  
  
 *yMask*  
 Spécifie le décalage vertical de pixel pour l’image bitmap de masque spécifié par le *maskBitmap* paramètre.  
  
 *dwRop*  
 Spécifie le premier plan et arrière-plan ternaire opération de rastérisation, dont la fonction utilise pour contrôler la combinaison de données source et de destination. Le code d’opération d’arrière-plan raster est stocké dans l’octet de poids fort du mot haut de cette valeur ; le code d’opération de premier plan raster est stocké dans l’octet faible des mot haut de cette valeur ; le mot de poids faible de cette valeur est ignorée et doit être égal à zéro. La macro MAKEROP4 crée ces combinaisons de premier plan et arrière-plan opération de rastérisation. Consultez la section Notes pour une présentation de premier plan et d’arrière-plan dans le contexte de cette fonction. Consultez le `BitBlt` fonction membre pour obtenir la liste des codes d’opération raster courants.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Une valeur de 1 dans le masque spécifié par *maskBitmap* indique que le code d’opération de premier plan raster spécifié par *dwRop* doit être appliqué à cet emplacement. La valeur 0 dans le masque indique que le code d’opération d’arrière-plan raster spécifié par *dwRop* doit être appliqué à cet emplacement. Si les opérations de raster requièrent une source, le rectangle masque doit couvrir le rectangle source. Si elle n’est pas le cas, la fonction échoue. Si les opérations raster ne nécessitent pas d’une source, le rectangle masque doit couvrir le rectangle de destination. Si elle n’est pas le cas, la fonction échoue.  
  
 Si une transformation de rotation ou inclinaison est appliquée pour le contexte de périphérique source quand cette fonction est appelée, une erreur se produit. Toutefois, les autres types de transformations sont autorisés.  
  
 Si les formats de couleur de la source, modèle et les bitmaps de destination diffèrent, cette fonction convertit le modèle ou le format source ou les deux, pour correspondre au format de destination. Si la bitmap masque n’est pas une bitmap monochrome, une erreur se produit. Quand un métafichier amélioré est en cours d’enregistrement, une erreur se produit (et la fonction retourne 0) si le contexte de périphérique source identifie un contexte de périphérique de métafichier amélioré. Tous les périphériques prennent en charge `MaskBlt`. Une application doit appeler `GetDeviceCaps` pour déterminer si un périphérique prend en charge cette fonction. Si aucune bitmap masque n’est fournie, cette fonction se comporte exactement comme `BitBlt`, à l’aide de code d’opération de premier plan raster. Le pixel offsets dans la carte de bitmap de masque pour le point (0,0) dans l’image bitmap du contexte de périphérique source. Cela est utile pour les cas où une image bitmap masque contient un ensemble de masques ; une application peut facilement appliquer l’un d'entre eux à une tâche de fusion de masque en ajustant les décalages de pixels et tailles de rectangle envoyées à `MaskBlt`.  
  
##  <a name="modifyworldtransform"></a>  CDC::ModifyWorldTransform  
 Modifie la transformation universelle pour un contexte de périphérique en utilisant le mode spécifié.  
  
```  
BOOL ModifyWorldTransform(
    const XFORM& rXform,  
    DWORD iMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *rXform*  
 Référence à un [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform) structure utilisée pour modifier la transformation universelle pour le contexte de périphérique donné.  
  
 *iMode*  
 Spécifie comment les données de transformation modifie la transformation de monde actuel. Pour obtenir la liste des valeurs que ce paramètre peut prendre, consultez [ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform).  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne une valeur différente de zéro.  
  
 Retourne 0 en cas d’échec.  
  
 Pour obtenir les informations d’erreur étendues, appelez [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Notes  
 Cette méthode encapsule la fonction Windows GDI [ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform).  
  
##  <a name="moveto"></a>  CDC::MoveTo  
 Déplace la position actuelle vers le point spécifié par *x* et *y* (ou par *point*).  
  
```  
CPoint MoveTo(
    int x,  
    int y);  
  
CPoint MoveTo(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de la nouvelle position.  
  
 *y*  
 Spécifie la coordonnée y logique de la nouvelle position.  
  
 *point*  
 Spécifie la nouvelle position. Vous pouvez passer soit un `POINT` structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Les coordonnées x et y de la position précédente comme un `CPoint` objet.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).  
  
##  <a name="offsetcliprgn"></a>  CDC::OffsetClipRgn  
 Déplace la zone de découpage du contexte de périphérique en offsets spécifiés.  
  
```  
int OffsetClipRgn(
    int x,  
    int y);  
  
int OffsetClipRgn(SIZE size);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie le nombre d’unités logiques à déplacer vers la gauche ou droite.  
  
 *y*  
 Spécifie le nombre d’unités logiques pour faire monter ou Descendre.  
  
 *size*  
 Spécifie la valeur de décalage.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de la nouvelle région. Il peut prendre l’une des valeurs suivantes :  
  
- Région de découpage COMPLEXREGION a chevauchement des bordures.  
  
- Contexte de périphérique d’erreur n’est pas valide.  
  
- Région de découpage NULLREGION est vide.  
  
- Région de découpage SIMPLEREGION n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 La fonction déplace la région *x* unités sur l’axe x et *y* unités sur l’axe y.  
  
##  <a name="offsetviewportorg"></a>  CDC::OffsetViewportOrg  
 Modifie les coordonnées de l’origine de la fenêtre d’affichage relatif aux coordonnées de l’origine de la fenêtre d’affichage actuel.  
  
```  
virtual CPoint OffsetViewportOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Paramètres  
 *nWidth*  
 Spécifie le nombre d’unités de périphérique à ajouter à la coordonnée x de l’origine actuelle.  
  
 *nHeight*  
 Spécifie le nombre d’unités de périphérique à ajouter à la coordonnée y de l’origine actuelle.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de la fenêtre d’affichage précédente (dans les coordonnées de périphérique) comme un `CPoint` objet.  
  
##  <a name="offsetwindoworg"></a>  CDC::OffsetWindowOrg  
 Modifie les coordonnées de l’origine de la fenêtre relatif aux coordonnées de l’origine de fenêtre actuelle.  
  
```  
CPoint OffsetWindowOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Paramètres  
 *nWidth*  
 Spécifie le nombre d’unités logiques à ajouter à la coordonnée x de l’origine actuelle.  
  
 *nHeight*  
 Spécifie le nombre d’unités logiques à ajouter à la coordonnée y de l’origine actuelle.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de fenêtre précédente (en coordonnées logiques) comme un `CPoint` objet.  
  
##  <a name="operator_hdc"></a>  CDC::operator HDC  
 Utilisez cet opérateur pour récupérer le handle de contexte de périphérique de le `CDC` objet.  
  
```  
operator HDC() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, le handle de l’objet de contexte de périphérique ; Sinon, NULL.  
  
### <a name="remarks"></a>Notes  
 Vous pouvez utiliser le handle d’appeler directement les API de Windows.  
  
##  <a name="paintrgn"></a>  CDC::PaintRgn  
 Remplit la zone spécifiée par *pRgn* à l’aide de la brosse courante.  
  
```  
BOOL PaintRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>Paramètres  
 *pRgn*  
 Identifie la zone à remplir. Les coordonnées de la région donnée sont spécifiées en unités logiques.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="patblt"></a>  CDC::PatBlt  
 Crée une série de bits sur l’appareil.  
  
```  
BOOL PatBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle qui doit recevoir le modèle.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle qui doit recevoir le modèle.  
  
 *nWidth*  
 Spécifie la largeur (en unités logiques) du rectangle qui doit recevoir le modèle.  
  
 *nHeight*  
 Spécifie la hauteur (en unités logiques) du rectangle qui doit recevoir le modèle.  
  
 *dwRop*  
 Spécifie le code d’opération de rastérisation. Codes d’opération de rastérisation (ROP) définissent la façon dont GDI associe les couleurs dans les opérations de sortie qui impliquent un pinceau actuel, un éventuel bitmap source et une image bitmap de destination. Ce paramètre peut être une des valeurs suivantes :  
  
- Modèle de Copies de PATCOPY à la bitmap de destination.  
  
- PATINVERT associe le bitmap de destination avec le modèle à l’aide de l’opérateur booléen XOR.  
  
- DSTINVERT inverse le bitmap de destination.  
  
- Active NOIRCEUR que toutes les sorties noir.  
  
- Active de blancheur que toutes les sorties blanc.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le modèle est une combinaison du pinceau sélectionné et le modèle déjà sur l’appareil. Le code d’opération de rastérisation spécifié par *dwRop* définit la façon dont les modèles doivent être combinés. Les opérations raster répertoriées pour cette fonction sont un sous-ensemble limité des codes d’opération de rastérisation ternaire 256 complète ; en particulier, un code d’opération de rastérisation qui fait référence à une source ne peut pas être utilisé.  
  
 Pas tous les contextes de périphérique prend en charge le `PatBlt` (fonction). Pour déterminer si un contexte de périphérique prend en charge `PatBlt`, appelez le `GetDeviceCaps` membre de fonction avec l’index RASTERCAPS et vérifiez la valeur de retour pour l’indicateur RC_BITBLT.  
  
##  <a name="pie"></a>  CDC::Pie  
 Dessine un graphique à secteurs-en dessinant un arc elliptique dont le centre et deux points de terminaison sont jointes par des lignes.  
  
```  
BOOL Pie(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Paramètres  
 *x1*  
 Spécifie la coordonnée x du coin supérieur gauche du rectangle englobant (en unités logiques).  
  
 *y1*  
 Spécifie la coordonnée y du coin supérieur gauche du rectangle englobant (en unités logiques).  
  
 *x2*  
 Spécifie la coordonnée x du coin inférieur droit du rectangle englobant (en unités logiques).  
  
 *y2*  
 Spécifie la coordonnée y du coin inférieur droit du rectangle englobant (en unités logiques).  
  
 *x3*  
 Spécifie la coordonnée x du point de départ de l’arc (en unités logiques). Ce point n’a pas à se trouvent exactement à l’arc.  
  
 *Y3*  
 Spécifie la coordonnée y du point de départ de l’arc (en unités logiques). Ce point n’a pas à se trouvent exactement à l’arc.  
  
 *X4*  
 Spécifie la coordonnée x du point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se trouvent exactement à l’arc.  
  
 *Y4*  
 Spécifie la coordonnée y du point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se trouvent exactement à l’arc.  
  
 *lpRect*  
 Spécifie le rectangle englobant. Vous pouvez passer soit un `CRect` objet ou un pointeur vers un `RECT` structure pour ce paramètre.  
  
 *ptStart*  
 Spécifie le point de départ de l’arc. Ce point n’a pas à se trouvent exactement à l’arc. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
 *ptEnd*  
 Spécifie le point de terminaison de l’arc. Ce point n’a pas à se trouvent exactement à l’arc. Vous pouvez passer soit un `POINT` structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le centre de l’arc est le centre du rectangle englobant spécifié par *x1*, *y1*, *x2*, et *y2* (ou par *lpRect* ). Le début et fin de l’arc sont spécifiées par *x3*, *y3*, *x4*, et *y4* (ou par *ptStart*et *ptEnd*).  
  
 L’arc est dessiné avec le stylet sélectionné, déplacement dans le sens antihoraire. Deux lignes supplémentaires sont dessinés au centre de l’arc à partir de chaque point de terminaison. La zone en forme de graphique à secteurs est remplie avec le pinceau actuel. Si *x3* est égal à *x4* et *y3* est égal à *y4*, il en résulte une ellipse avec une seule ligne à partir du centre de l’ellipse et le point ( *x3*, *y3*) ou ( *x4*, *y4*).  
  
 La figure dessinée par cette fonction s’étend jusqu'à mais n’inclut pas les coordonnées de droite et en bas. Cela signifie que la hauteur de la figure est *y2* - *y1* et la largeur de la figure est *x2* - *x1*. La largeur et la hauteur du rectangle englobant doivent être supérieures à 2 unités et inférieure à 32 767.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]  
  
##  <a name="playmetafile"></a>  CDC::PlayMetaFile  
 Lit le contenu du métafichier spécifié sur le contexte de périphérique.  
  
```  
BOOL PlayMetaFile(HMETAFILE hMF);

 
BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,  
    LPCRECT lpBounds);
```  
  
### <a name="parameters"></a>Paramètres  
 *hMF*  
 Identifie le métafichier à lire.  
  
 *hEnhMetaFile*  
 Identifie le métafichier amélioré.  
  
 *lpBounds*  
 Pointe vers un `RECT` structure ou un `CRect` objet qui contient les coordonnées du rectangle englobant utilisé pour afficher l’image. Les coordonnées sont spécifiées en unités logiques.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Métafichier peut être lus à n’importe quel nombre de fois.  
  
 La deuxième version de `PlayMetaFile` affiche l’image stockée dans le métafichier de format amélioré donné. Lorsqu’une application appelle la deuxième version de `PlayMetaFile`, Windows utilise le cadre de l’image dans l’en-tête de métafichier amélioré pour mapper l’image sur le rectangle vers lequel pointé le *lpBounds* paramètre. (Cette image peut être inclinée ou pivotée en définissant la transformation universelle dans le périphérique de sortie avant d’appeler `PlayMetaFile`.) Points le long des bords du rectangle sont inclus dans l’image. Une image du métafichier amélioré peut être découpée en définissant la zone de découpage dans le périphérique de sortie avant de lire le métafichier amélioré.  
  
 Si un métafichier amélioré contient une palette facultative, une application peut atteindre des couleurs cohérentes en configurant une palette de couleurs sur le périphérique de sortie avant d’appeler la deuxième version de `PlayMetaFile`. Pour récupérer la palette facultative, utilisez le `GetEnhMetaFilePaletteEntries` (fonction) Windows. Un métafichier amélioré peut être incorporé dans un métafichier amélioré nouvellement créé en appelant la deuxième version de `PlayMetaFile` et lecture de métafichier amélioré de source dans le contexte de périphérique pour le nouveau métafichier amélioré.  
  
 Les États du contexte de périphérique de sortie sont conservés par cette fonction. Tout objet créé, mais ne pas supprimé dans le métafichier amélioré est supprimé par cette fonction. Pour arrêter cette fonction, une application peut appeler le `CancelDC` fonction Windows à partir d’un autre thread pour terminer l’opération. Dans ce cas, la fonction retourne zéro.  
  
##  <a name="plgblt"></a>  CDC::PlgBlt  
 Effectue un transfert de bloc de bits des bits de données de couleur du rectangle spécifié dans le contexte du périphérique source en parallélogramme spécifié dans le contexte de périphérique donné.  
  
```  
BOOL PlgBlt(
    LPPOINT lpPoint,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nWidth,  
    int nHeight,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpPoint*  
 Pointe vers un tableau de trois points dans l’espace logique qui identifie les trois angles du parallélogramme de destination. Le coin supérieur gauche du rectangle source est mappé au premier point dans ce tableau, le coin supérieur droit et le deuxième point dans ce tableau et le coin inférieur gauche pour le troisième point. Le coin inférieur droit du rectangle source est mappé au quatrième point dans un parallélogramme implicit.  
  
 *pSrcDC*  
 Identifie le contexte du périphérique source.  
  
 *xSrc*  
 Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle source.  
  
 *ySrc*  
 Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle source.  
  
 *nWidth*  
 Spécifie la largeur, en unités logiques, du rectangle source.  
  
 *nHeight*  
 Spécifie la hauteur, en unités logiques, du rectangle source.  
  
 *maskBitmap*  
 Identifie un bitmap monochrome facultatif servant à masquer les couleurs du rectangle source.  
  
 *xMask*  
 Spécifie la coordonnée x de l’angle supérieur gauche de l’image bitmap monochrome.  
  
 *yMask*  
 Spécifie la coordonnée y de l’angle supérieur gauche de l’image bitmap monochrome.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Si le descripteur de masque de bits donné identifie un bitmap monochrome valide, la fonction utilise cette image bitmap pour masquer les bits des données de couleur du rectangle source.  
  
 Le quatrième vertex du parallélogramme (D) est défini en traitant les trois premiers points (A, B et C) en tant que les vecteurs et informatique D = B + C - A.  
  
 Si le masque de bits existe, la valeur 1 dans le masque indique que la couleur du pixel source doit être copiée vers la destination. La valeur 0 dans le masque indique que la couleur de pixel de destination doit ne pas être modifié.  
  
 Si le rectangle de masque est plus petit que les rectangles de source et de destination, la fonction réplique le modèle de masque.  
  
 Les transformations de mise à l’échelle, de translation et de réflexion sont autorisées dans le contexte du périphérique source ; Toutefois, les transformations de rotation et l’inclinaison ne sont pas. Si la bitmap masque n’est pas une bitmap monochrome, une erreur se produit. Le mode d’étirement pour le contexte de périphérique de destination est utilisé pour déterminer comment étirer ou compresser les pixels, si ce n’est nécessaire. Quand un métafichier amélioré est en cours d’enregistrement, une erreur se produit si le contexte de périphérique source identifie un contexte de périphérique de métafichier amélioré.  
  
 Les coordonnées de destination sont transformées en fonction du contexte du périphérique de destination ; les coordonnées sources sont transformées en fonction du contexte du périphérique source. Si la transformation source a une rotation ou une inclinaison, une erreur est retournée. Si les rectangles de source et de destination n’ont pas le même format de couleur, `PlgBlt` convertit le rectangle source pour faire correspondre le rectangle de destination. Tous les périphériques prennent en charge `PlgBlt`. Pour plus d’informations, consultez la description de la fonctionnalité de raster RC_BITBLT dans le `CDC::GetDeviceCaps` fonction membre.  
  
 Si les contextes de périphérique source et destination représentent des périphériques incompatibles, `PlgBlt` retourne une erreur.  
  
##  <a name="polybezier"></a>  CDC::PolyBezier  
 Dessine une ou plusieurs splines Bzier.  
  
```  
BOOL PolyBezier(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpPoints*  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui contiennent les points de terminaison et de points de contrôle de la spline(s).  
  
 *nCount*  
 Spécifie le nombre de points dans le *lpPoints* tableau. Cette valeur doit être un à trois fois plus le nombre de splines à dessiner, étant donné que chaque Bzier nécessitent deux points de contrôle et un point de terminaison et la spline initiale nécessite un point de départ supplémentaire.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction dessine des splines Bzier cubiques en utilisant les points de terminaison et les points de contrôle spécifiés par le *lpPoints* paramètre. La première spline est dessinée à partir du premier point au quatrième point à l’aide des deuxième et troisième points comme points de contrôle. Chaque spline suivante dans la séquence doit exactement trois points supplémentaires : le point de terminaison de la spline précédent est utilisé comme point de départ, les deux points dans la séquence sont des points de contrôle, et le troisième est le point de terminaison.  
  
 La position actuelle n’est ni utilisée ni mis à jour par le `PolyBezier` (fonction). La figure n’est pas remplie. Cette fonction dessine des lignes en utilisant le stylet actuel.  
  
##  <a name="polybezierto"></a>  CDC::PolyBezierTo  
 Dessine une ou plusieurs splines Bzier.  
  
```  
BOOL PolyBezierTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpPoints*  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) pointe des structures de données qui contient les points de terminaison et le contrôle.  
  
 *nCount*  
 Spécifie le nombre de points dans le *lpPoints* tableau. Cette valeur doit être de trois fois le nombre de splines à dessiner, étant donné que chaque Bzier nécessitent deux points de contrôle et un point de terminaison.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction dessine des splines Bzier cubiques en utilisant les points de contrôle spécifiés par le *lpPoints* paramètre. La première spline est dessinée à partir de la position actuelle pour le troisième point en utilisant les deux premiers points comme points de contrôle. Pour chaque spline ultérieur, la fonction doit exactement trois points supplémentaires et utilise le point de terminaison de la spline précédente comme point de départ pour le prochain. `PolyBezierTo` Déplace la position actuelle vers le point de terminaison de la dernière spline Bzier. La figure n’est pas remplie. Cette fonction dessine des lignes en utilisant le stylet actuel.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="polydraw"></a>  CDC::PolyDraw  
 Dessine un ensemble de segments de ligne et Bzier splines.  
  
```  
BOOL PolyDraw(
    const POINT* lpPoints,  
    const BYTE* lpTypes,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpPoints*  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui contient les points de terminaison pour chaque segment et les points de terminaison de ligne et de points pour chaque spline Bzier de contrôle.  
  
 *lpTypes*  
 Pointe vers un tableau qui spécifie la façon dont chaque point dans le *lpPoints* tableau est utilisé. Valeurs peuvent être une des opérations suivantes :  
  
- PT_MOVETO Spécifie que ce point démarre une figure disjointe. Ce point devient la nouvelle position actuelle.  
  
- PT_LINETO indique qu’une ligne est dessiné à partir de la position actuelle à ce stade, ce qui devient alors la nouvelle position actuelle.  
  
- PT_BEZIERTO Spécifie que ce point est un point de contrôle ou d’un point de fin d’une spline Bzier.  
  
 PT_BEZIERTO toujours se produire dans les ensembles de trois. La position actuelle définit le point de départ pour la fonction spline Bzier. Les deux premiers points PT_BEZIERTO sont les points de contrôle et le troisième point PT_BEZIERTO est le point de fin. Le point de fin devient la nouvelle position actuelle. S’il n’y a pas trois points PT_BEZIERTO consécutifs, une erreur se produit.  
  
     Un type PT_LINETO ou PT_BEZIERTO peut être combiné avec la constante suivante à l’aide de l’opérateur au niveau du bit ou pour indiquer que le point correspondant est le dernier point dans une illustration et la figure est fermée :  
  
- PT_CLOSEFIGURE Spécifie que la figure est fermée automatiquement après le PT_LINETO ou PT_BEZIERTO pour ce point est effectuée. Une ligne est dessinée à partir de ce point à la plus récente PT_MOVETO ou `MoveTo` point.  
  
     Cet indicateur est combiné avec le type PT_LINETO pour une ligne, ou avec le type PT_BEZIERTO de point de fin pour une spline Bzier, à l’aide de l’opérateur de bits **OR** opérateur. La position actuelle est définie pour le point de fin de la ligne fermante.  
  
 *nCount*  
 Spécifie le nombre total de points dans le *lpPoints* de tableau, le même que le nombre d’octets dans le *lpTypes* tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction peut être utilisée pour dessiner des figures disjoints à la place des appels successifs à `CDC::MoveTo`, `CDC::LineTo`, et `CDC::PolyBezierTo` fonctions membres. Splines les lignes sont dessinées à l’aide du stylet actuel, et les chiffres ne sont pas remplis. S’il existe un chemin d’accès active lancée en appelant le `CDC::BeginPath` fonction membre, `PolyDraw` ajoute le chemin d’accès. Les points contenus dans le *lpPoints* tableau et dans *lpTypes* indiquer si chaque point fait partie d’un `CDC::MoveTo`, un `CDC::LineTo`, ou un `CDC::BezierTo` opération. Il est également possible de fermer des chiffres. Cette fonction met à jour la position actuelle.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="polygon"></a>  CDC::Polygon  
 Dessine un polygone consistant en deux ou plusieurs points (sommets) reliés par des lignes, à l’aide du stylet actuel.  
  
```  
BOOL Polygon(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpPoints*  
 Pointe vers un tableau de points qui spécifie les sommets du polygone. Chaque point dans le tableau est un `POINT` structure ou un `CPoint` objet.  
  
 *nCount*  
 Spécifie le nombre de vertex dans le tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le système ferme le polygone automatiquement, si nécessaire, en dessinant une ligne à partir du dernier sommet au premier.  
  
 Le mode de remplissage de polygone actuel peut être récupéré ou défini à l’aide de la `GetPolyFillMode` et `SetPolyFillMode` fonctions membres.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]  
  
##  <a name="polyline"></a>  CDC::Polyline  
 Dessine un ensemble de segments de ligne reliant les points spécifiés par *lpPoints*.  
  
```  
BOOL Polyline(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpPoints*  
 Pointe vers un tableau de `POINT` structures ou `CPoint` objets d’être connecté.  
  
 *nCount*  
 Spécifie le nombre de points dans le tableau. Cette valeur doit être au moins 2.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Les lignes sont dessinées à partir du premier point via les points suivants à l’aide de stylet actuel. Contrairement à la `LineTo` fonction membre, le `Polyline` fonction utilise ni mises à jour de la position actuelle.  
  
 Pour plus d’informations, consultez [polyligne](/windows/desktop/api/wingdi/nf-wingdi-polyline) dans le SDK Windows.  
  
##  <a name="polylineto"></a>  CDC::PolylineTo  
 Dessine une ou plusieurs lignes droites.  
  
```  
BOOL PolylineTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpPoints*  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui contient les sommets de la ligne.  
  
 *nCount*  
 Spécifie le nombre de points dans le tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Une ligne est dessinée à partir de la position actuelle au premier point spécifié par le *lpPoints* paramètre en utilisant le stylet actuel. Pour chaque ligne supplémentaire, la fonction de trace à partir du point de fin de la ligne précédente au point suivant spécifié par *lpPoints*. `PolylineTo` Déplace la position actuelle vers le point de fin de la dernière ligne. Si les segments de ligne dessinées par cette fonction forment une figure fermée, la figure n’est pas remplie.  
  
##  <a name="polypolygon"></a>  CDC::PolyPolygon  
 Crée deux ou plusieurs polygones qui sont remplis à l’aide du mode de remplissage de polygones en cours.  
  
```  
BOOL PolyPolygon(
    LPPOINT lpPoints,  
    LPINT lpPolyCounts,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpPoints*  
 Pointe vers un tableau de `POINT` structures ou `CPoint` les objets qui définissent les sommets du polygone.  
  
 *lpPolyCounts*  
 Pointe vers un tableau d’entiers, chacun d’eux spécifie le nombre de points dans un des polygones dans le *lpPoints* tableau.  
  
 *nCount*  
 Le nombre d’entrées dans le *lpPolyCounts* tableau. Ce nombre spécifie le nombre de polygones à dessiner. Cette valeur doit être au moins 2.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Les polygones peuvent être disjoints ou qui se chevauchent.  
  
 Chaque polygone spécifié dans un appel à la `PolyPolygon` fonction doit être fermée. Contrairement aux polygones créés par le `Polygon` fonction membre, les polygones créés par `PolyPolygon` ne sont pas fermées automatiquement.  
  
 La fonction crée deux ou plusieurs polygones. Pour créer un polygone unique, une application doit utiliser le `Polygon` fonction membre.  
  
 Le mode de remplissage de polygone actuel peut être récupéré ou défini à l’aide de la `GetPolyFillMode` et `SetPolyFillMode` fonctions membres.  
  
##  <a name="polypolyline"></a>  CDC::PolyPolyline  
 Dessine plusieurs séries de segments de ligne connectés.  
  
```  
BOOL PolyPolyline(
    const POINT* lpPoints,  
    const DWORD* lpPolyPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpPoints*  
 Pointe vers un tableau de structures qui contient les sommets des polylignes. Les polylignes sont consécutifs spécifiés.  
  
 *lpPolyPoints*  
 Pointe vers un tableau de variables en spécifiant le nombre de points dans le *lpPoints* tableau pour le polygone correspondant. Chaque entrée doit être supérieur ou égal à 2.  
  
 *nCount*  
 Spécifie le nombre total des nombres dans les *lpPolyPoints* tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Les segments de ligne sont dessinés à l’aide du stylet actuel. Les figures formées par les segments ne sont pas remplis. La position actuelle n’est ni utilisée ni mis à jour par cette fonction.  
  
##  <a name="ptvisible"></a>  CDC::PtVisible  
 Détermine si le point donné se trouve dans la zone de découpage du contexte de périphérique.  
  
```  
virtual BOOL PtVisible(
    int x,  
    int y) const;  
  
BOOL PtVisible(POINT point) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point.  
  
 *y*  
 Spécifie la coordonnée y logique du point.  
  
 *point*  
 Spécifie le point à vérifier en coordonnées logiques. Vous pouvez passer soit un `POINT` structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si le point spécifié se trouve dans la zone de découpage ; sinon 0.  
  
##  <a name="queryabort"></a>  CDC::QueryAbort  
 Appelle la fonction abort installée par le [SetAbortProc](#setabortproc) fonction membre pour l’application d’impression et les requêtes si l’impression doit s’arrêter.  
  
```  
BOOL QueryAbort() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur de retour est différent de zéro si l’impression doit continuer ou s’il n’existe aucune procédure d’abandon. Il est 0 si le travail d’impression doit s’arrêter. La valeur de retour est fournie par la fonction d’abandon.  
  
##  <a name="realizepalette"></a>  CDC::RealizePalette  
 Mappe des entrées à partir de la palette logique en cours à la palette système.  
  
```  
UINT RealizePalette();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Indique le nombre d’entrées dans la palette logique ont été mappé à des entrées différentes dans la palette système. Cela représente le nombre d’entrées remappée de cette fonction pour prendre en compte les modifications dans la palette système dans la mesure où la palette logique a été réalisée dernière.  
  
### <a name="remarks"></a>Notes  
 Une palette de couleurs logique agit comme une mémoire tampon entre les applications gourmandes en couleur et le système, permettant à une application à utiliser comme nombre de couleurs en fonction des besoins sans interférer avec son propre affiche les couleurs ou avec des couleurs affichées par d’autres fenêtres.  
  
 Quand une fenêtre a le focus d’entrée et appelle `RealizePalette`, Windows garantit que la fenêtre affiche toutes les couleurs demandées, le nombre maximal disponible simultanément sur l’écran. Windows affiche également les couleurs introuvables dans la palette de la fenêtre en faisant correspondre les couleurs disponibles.  
  
 En outre, Windows met en correspondance les couleurs demandés par les fenêtres inactives qui appellent la fonction aussi fidèlement que possible pour les couleurs disponibles. Cela réduit considérablement les modifications indésirables dans les couleurs affichées dans les fenêtres inactives.  
  
##  <a name="rectangle"></a>  CDC::Rectangle  
 Dessine un rectangle en utilisant le stylet actuel.  
  
```  
BOOL Rectangle(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Rectangle(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 *x1*  
 Spécifie la coordonnée x du coin supérieur gauche du rectangle (en unités logiques).  
  
 *y1*  
 Spécifie la coordonnée y du coin supérieur gauche du rectangle (en unités logiques).  
  
 *x2*  
 Spécifie la coordonnée x du coin inférieur droit du rectangle (en unités logiques).  
  
 *y2*  
 Spécifie la coordonnée y du coin inférieur droit du rectangle (en unités logiques).  
  
 *lpRect*  
 Spécifie le rectangle en unités logiques. Vous pouvez passer soit un `CRect` objet ou un pointeur vers un `RECT` structure pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 L’intérieur du rectangle est rempli en utilisant le pinceau actuel.  
  
 Le rectangle s’étend jusqu'à, mais n’inclut pas les coordonnées de droite et en bas. Cela signifie que la hauteur du rectangle est *y2* - *y1* et la largeur du rectangle est *x2* - *x1*. La largeur et la hauteur d’un rectangle doivent être supérieures à 2 unités et inférieure à 32 767.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]  
  
##  <a name="rectvisible"></a>  CDC::RectVisible  
 Détermine si une partie du rectangle donné se trouve dans la zone de découpage du contexte d’affichage.  
  
```  
virtual BOOL RectVisible(LPCRECT lpRect) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRect*  
 Pointe vers un `RECT` structure ou un `CRect` objet qui contient les coordonnées logiques du rectangle spécifié.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si une partie du rectangle donné se trouve dans la zone de découpage ; sinon 0.  
  
##  <a name="releaseattribdc"></a>  CDC::ReleaseAttribDC  
 Appelez cette fonction membre pour définir `m_hAttribDC` avec la valeur NULL.  
  
```  
virtual void ReleaseAttribDC();
```  
  
### <a name="remarks"></a>Notes  
 Cela ne provoque pas une `Detach` se produise. Uniquement le contexte de périphérique de sortie est attaché à la `CDC` objet et seulement il peuvent être détachée.  
  
##  <a name="releaseoutputdc"></a>  CDC::ReleaseOutputDC  
 Appelez cette fonction membre pour définir le `m_hDC` membre avec la valeur NULL.  
  
```  
virtual void ReleaseOutputDC();
```  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre ne peut pas être appelée lorsque le contexte de périphérique de sortie est attaché à la `CDC` objet. Utilisez le `Detach` fonction membre pour détacher le contexte de périphérique de sortie.  
  
##  <a name="resetdc"></a>  CDC::ResetDC  
 Appelez cette fonction membre pour mettre à jour le contexte de périphérique encapsulé par le `CDC` objet.  
  
```  
BOOL ResetDC(const DEVMODE* lpDevMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpDevMode*  
 Un pointeur vers un Windows `DEVMODE` structure.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique est mis à jour à partir des informations spécifiées dans le Windows `DEVMODE` structure. Cette fonction membre réinitialise uniquement le contexte de l’attribut.  
  
 Une application utilise généralement le `ResetDC` fonction membre lorsqu’une fenêtre traite un `WM_DEVMODECHANGE` message. Vous pouvez également utiliser cette fonction membre pour modifier l’orientation du papier ou les emplacements de papier lors de l’impression d’un document.  
  
 Vous ne pouvez pas utiliser cette fonction membre pour modifier le nom du pilote, le nom de l’appareil ou le port de sortie. Lorsque l’utilisateur modifie la connexion au port ou le nom de l’appareil, vous devez supprimer le contexte de périphérique d’origine et créer un nouveau contexte de périphérique avec les nouvelles informations.  
  
 Avant d’appeler cette fonction membre, vous devez vous assurer que tous les objets (autres que les objets de stock) qui avaient été sélectionnés dans le contexte de périphérique ont été sélectionnés.  
  
##  <a name="restoredc"></a>  CDC::RestoreDC  
 Restaure le contexte de périphérique à l’état précédent identifié par *nSavedDC*.  
  
```  
virtual BOOL RestoreDC(int nSavedDC);
```  
  
### <a name="parameters"></a>Paramètres  
 *nSavedDC*  
 Spécifie le contexte de périphérique à restaurer. Il peut être une valeur retournée par une précédente `SaveDC` appel de fonction. Si *nSavedDC* est -1, le plus récemment enregistré contexte de périphérique est restauré.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si le contexte spécifié a été restauré ; sinon 0.  
  
### <a name="remarks"></a>Notes  
 `RestoreDC` Restaure le contexte de périphérique en affichant les informations d’état d’une pile créée par les appels antérieurs à la `SaveDC` fonction membre.  
  
 La pile peut contenir les informations d’état pour plusieurs contextes de périphérique. Si le contexte spécifié par *nSavedDC* n’est pas en haut de la pile, `RestoreDC` supprime toutes les informations d’état entre le contexte de périphérique spécifié par *nSavedDC* et le haut de la pile. Les informations supprimées sont perdues.  
  
##  <a name="roundrect"></a>  CDC::RoundRect  
 Dessine un rectangle avec coins arrondis à l’aide du stylet actuel.  
  
```  
BOOL RoundRect(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3);

 
BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x1*  
 Spécifie la coordonnée x du coin supérieur gauche du rectangle (en unités logiques).  
  
 *y1*  
 Spécifie la coordonnée y du coin supérieur gauche du rectangle (en unités logiques).  
  
 *x2*  
 Spécifie la coordonnée x du coin inférieur droit du rectangle (en unités logiques).  
  
 *y2*  
 Spécifie la coordonnée y du coin inférieur droit du rectangle (en unités logiques).  
  
 *x3*  
 Spécifie la largeur de l’ellipse utilisée pour dessiner les angles arrondis est utilisée (en unités logiques).  
  
 *Y3*  
 Spécifie la hauteur de l’ellipse utilisée pour dessiner les angles arrondis est utilisée (en unités logiques).  
  
 *lpRect*  
 Spécifie le rectangle englobant dans les unités logiques. Vous pouvez passer soit un `CRect` objet ou un pointeur vers un `RECT` structure pour ce paramètre.  
  
 *point*  
 La coordonnée x de *point* spécifie la largeur de l’ellipse pour dessiner les angles arrondis est utilisée (en unités logiques). La coordonnée y de *point* spécifie la hauteur de l’ellipse pour dessiner les angles arrondis est utilisée (en unités logiques). Vous pouvez passer soit un `POINT` structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 L’intérieur du rectangle est rempli en utilisant le pinceau actuel.  
  
 L’illustration de que cette fonction dessine étend jusqu'à mais n’inclut pas les coordonnées de droite et en bas. Cela signifie que la hauteur de la figure est *y2* - *y1* et la largeur de la figure est *x2* - *x1*. La hauteur et la largeur du rectangle englobant doivent être supérieures à 2 unités et inférieure à 32 767.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]  
  
##  <a name="savedc"></a>  CDC::SaveDC  
 Enregistre l’état actuel du contexte de périphérique en copiant les informations d’état (par exemple, la zone de découpage, les objets sélectionnés et mode de mappage) à une pile de contexte gérée par Windows.  
  
```  
virtual int SaveDC();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un entier qui identifie le contexte de périphérique enregistré. Il est 0 si une erreur se produit. Cela retourne la valeur peut être utilisée pour restaurer le contexte de périphérique en appelant `RestoreDC`.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique enregistré ultérieurement peut être restauré à l’aide de `RestoreDC`.  
  
 `SaveDC` peut être utilisée n’importe quel nombre de fois pour enregistrer n’importe quel nombre d’états de contexte de périphérique.  
  
##  <a name="scaleviewportext"></a>  CDC::ScaleViewportExt  
 Modifie les étendues de la fenêtre d’affichage par rapport aux valeurs actuelles.  
  
```  
virtual CSize ScaleViewportExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>Paramètres  
 *xNum*  
 Spécifie le montant par lequel multiplier l’étendue x actuel.  
  
 *xDenom*  
 Spécifie le montant par lequel diviser le résultat de la multiplication de l’étendue de x actuelle par la valeur de la *xNum* paramètre.  
  
 *yNum*  
 Spécifie le montant par lequel multiplier l’étendue y actuelle.  
  
 *yDenom*  
 Spécifie le montant par lequel diviser le résultat de la multiplication de l’étendue d’y actuelle par la valeur de la *yNum* paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Les étendues de la fenêtre d’affichage précédente (en unités de périphérique) comme un `CSize` objet.  
  
### <a name="remarks"></a>Notes  
 Les formules sont écrites comme suit :  
  
 `xNewVE = ( xOldVE * xNum ) / xDenom`  
  
 `yNewVE = ( yOldVE * yNum ) / yDenom`  
  
 Les nouvelles étendues de la fenêtre d’affichage sont calculées en multipliant les étendues actuels par le numérateur donné, puis en divisant par le dénominateur donné.  
  
##  <a name="scalewindowext"></a>  CDC::ScaleWindowExt  
 Modifie les étendues de fenêtre par rapport aux valeurs actuelles.  
  
```  
virtual CSize ScaleWindowExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>Paramètres  
 *xNum*  
 Spécifie le montant par lequel multiplier l’étendue x actuel.  
  
 *xDenom*  
 Spécifie le montant par lequel diviser le résultat de la multiplication de l’étendue de x actuelle par la valeur de la *xNum* paramètre.  
  
 *yNum*  
 Spécifie le montant par lequel multiplier l’étendue y actuelle.  
  
 *yDenom*  
 Spécifie le montant par lequel diviser le résultat de la multiplication de l’étendue d’y actuelle par la valeur de la *yNum* paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Les étendues de fenêtre précédente (en unités logiques) comme un `CSize` objet.  
  
### <a name="remarks"></a>Notes  
 Les formules sont écrites comme suit :  
  
 `xNewWE = ( xOldWE * xNum ) / xDenom`  
  
 `yNewWE = ( yOldWE * yNum ) / yDenom`  
  
 Les nouvelles étendues de fenêtre sont calculées en multipliant les étendues actuels par le numérateur donné, puis en divisant par le dénominateur donné.  
  
##  <a name="scrolldc"></a>  CDC::ScrollDC  
 Fait défiler un rectangle de bits horizontalement et verticalement.  
  
```  
BOOL ScrollDC(
    int dx,  
    int dy,  
    LPCRECT lpRectScroll,  
    LPCRECT lpRectClip,  
    CRgn* pRgnUpdate,  
    LPRECT lpRectUpdate);
```  
  
### <a name="parameters"></a>Paramètres  
 *DX*  
 Spécifie le nombre d’unités de défilement horizontale.  
  
 *dy*  
 Spécifie le nombre d’unités de défilement verticale.  
  
 *lpRectScroll*  
 Pointe vers le `RECT` structure ou `CRect` objet qui contient les coordonnées du rectangle de défilement.  
  
 *lpRectClip*  
 Pointe vers le `RECT` structure ou `CRect` objet qui contient les coordonnées du rectangle de découpage. Lorsque ce rectangle est inférieur à la version d’origine un vers laquelle pointe *lpRectScroll*, le défilement se produit uniquement dans le plus petit rectangle.  
  
 *pRgnUpdate*  
 Identifie la région non traitée par le processus de défilement. Le `ScrollDC` fonction définit cette région ; il n’est pas nécessairement un rectangle.  
  
 *lpRectUpdate*  
 Pointe vers le `RECT` structure ou `CRect` objet qui reçoit les coordonnées du rectangle qui délimite la zone de mise à jour de défilement. Il s’agit de la plus grande zone rectangulaire qui nécessite la mise à jour. Les valeurs de la structure ou l’objet lorsque la fonction retournée sont dans les coordonnées clientes, quel que soit le mode de mappage pour le contexte de périphérique donné.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si le défilement est exécuté ; sinon 0.  
  
### <a name="remarks"></a>Notes  
 Si *lpRectUpdate* est NULL, Windows ne calcule pas le rectangle de mise à jour. Si les deux *pRgnUpdate* et *lpRectUpdate* ont la valeur NULL, Windows ne calcule pas la région de mise à jour. Si *pRgnUpdate* n’est pas NULL, Windows part du principe qu’il contient un pointeur valide vers la région non traité par le processus de défilement (défini par le `ScrollDC` fonction membre). La région de mise à jour retournée dans *lpRectUpdate* peut être passé à `CWnd::InvalidateRgn` si nécessaire.  
  
 Une application doit utiliser le `ScrollWindow` fonction membre de classe `CWnd` lorsqu’il est nécessaire faire défiler la zone cliente d’une fenêtre. Sinon, il doit utiliser `ScrollDC`.  
  
##  <a name="selectclippath"></a>  CDC::SelectClipPath  
 Sélectionne le chemin d’accès actuel comme une zone de découpage pour le contexte de périphérique, en combinant la nouvelle région avec n’importe quelle région de découpage existant en utilisant le mode spécifié.  
  
```  
BOOL SelectClipPath(int nMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *nMode*  
 Spécifie la façon d’utiliser le chemin d’accès. Les valeurs suivantes sont autorisées :  
  
- La nouvelle zone de découpage de RGN_AND inclut l’intersection (zones qui se chevauchent) de la zone de découpage active et le chemin d’accès actuel.  
  
- RGN_COPY la nouvelle zone de découpage est le chemin d’accès actuel.  
  
- RGN_DIFF la nouvelle région de découpage inclut les zones de la zone de découpage en cours et celles du chemin d’accès actuel sont exclues.  
  
- La nouvelle zone de découpage de RGN_OR inclut l’union (zones combinés) de la zone de découpage active et le chemin d’accès actuel.  
  
- La nouvelle zone de découpage de RGN_XOR inclut l’union de la zone de découpage active et le chemin d’accès actuel, mais sans les zones qui se chevauchent.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique identifié doit contenir une trajectoire fermée.  
  
##  <a name="selectcliprgn"></a>  CDC::SelectClipRgn  
 Sélectionne la zone donnée en tant que la zone de découpage en cours pour le contexte de périphérique.  
  
```  
int SelectClipRgn(CRgn* pRgn);

 
int SelectClipRgn(
    CRgn* pRgn,  
    int nMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *pRgn*  
 Identifie la région à sélectionner.  
  
-   Pour la première version de cette fonction, si cette valeur est NULL, la zone client entière est sélectionnée et de sortie est encore attachée à la fenêtre.  
  
-   Pour la deuxième version de cette fonction, ce handle peut être NULL uniquement lorsque le mode RGN_COPY est spécifié.  
  
 *nMode*  
 Spécifie l’opération à effectuer. Il doit être une des valeurs suivantes :  
  
- RGN_AND la nouvelle région de découpage combine les zones qui se chevauchent de la zone de découpage active et de la région identifiée par *pRgn*.  
  
- RGN_COPY la nouvelle zone de découpage est une copie de la région identifiée par *pRgn*. Cette fonctionnalité est identique à la première version de `SelectClipRgn`. Si la région identifiée par *pRgn* est NULL, la nouvelle région de découpage devient la zone de découpage par défaut (région null).  
  
- RGN_DIFF la nouvelle région de découpage combine les zones de la zone de découpage active avec ces domaines exclues de la région identifiée par *pRgn*.  
  
- RGN_OR la nouvelle région de découpage combine la zone de découpage active et de la région identifiée par *pRgn*.  
  
- RGN_XOR la nouvelle région de découpage combine la zone de découpage active et de la région identifiée par *pRgn* mais exclut les zones qui se chevauchent.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de la région. Il peut être une des valeurs suivantes :  
  
- COMPLEXREGION nouvelle zone de découpage a chevauchement des bordures.  
  
- Contexte de périphérique d’erreur ou la région n’est pas valide.  
  
- NULLREGION nouvelle zone de découpage est vide.  
  
- SIMPLEREGION nouvelle zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 Uniquement une copie de la zone sélectionnée est utilisée. La zone elle-même peut être sélectionnée pour n’importe quel nombre d’autres contextes de périphérique, ou il peut être supprimé.  
  
 La fonction suppose que les coordonnées de la région donnée sont spécifiées dans les unités de périphérique. Certains périphériques d’imprimante prend en charge la sortie de texte à une résolution supérieure à la sortie graphique afin de conserver la précision nécessaire pour exprimer des métriques de texte. Ces appareils signalent les unités de périphérique à la résolution plus élevée, autrement dit, en unités de texte. Ces appareils puis mettre à l’échelle les coordonnées pour les graphiques afin que plusieurs signalées mappage des unités de périphérique uniquement 1 unité de graphique. Vous devez toujours appeler la `SelectClipRgn` fonction à l’aide d’unités de texte.  
  
 Les applications que doivent effectuer la mise à l’échelle d’objets graphiques dans GDI peuvent utiliser l’échappement d’imprimante GETSCALINGFACTOR pour déterminer le facteur d’échelle. Ce facteur d’échelle affecte le découpage. Si une région est utilisée pour découper les graphiques, GDI divise les coordonnées par le facteur d’échelle. Si la région est utilisée pour découper le texte, GDI n’effectue aucun ajustement de mise à l’échelle. Un facteur d’échelle de 1 provoque les coordonnées à diviser par 2 ; un facteur d’échelle de 2 entraîne les coordonnées doit être divisé par 4 ; et ainsi de suite.  
  
##  <a name="selectobject"></a>  CDC::SelectObject  
 Sélectionne un objet dans le contexte de périphérique.  
  
```  
CPen* SelectObject(CPen* pPen);  
CBrush* SelectObject(CBrush* pBrush);  
virtual CFont* SelectObject(CFont* pFont);  
CBitmap* SelectObject(CBitmap* pBitmap);  
int SelectObject(CRgn* pRgn);  
CGdiObject* SelectObject(CGdiObject* pObject);
```  
  
### <a name="parameters"></a>Paramètres  
 *pPen*  
 Un pointeur vers un [CPen](../../mfc/reference/cpen-class.md) objet à sélectionner.  
  
 *pBrush*  
 Un pointeur vers un [CBrush](../../mfc/reference/cbrush-class.md) objet à sélectionner.  
  
 *pFont*  
 Un pointeur vers un [CFont](../../mfc/reference/cfont-class.md) objet à sélectionner.  
  
 *pBitmap*  
 Un pointeur vers un [CBitmap](../../mfc/reference/cbitmap-class.md) objet à sélectionner.  
  
 *pRgn*  
 Un pointeur vers un [CRgn](../../mfc/reference/crgn-class.md) objet à sélectionner.  
  
 *pObject*  
 Un pointeur vers un [CGdiObject](../../mfc/reference/cgdiobject-class.md) objet à sélectionner.  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers l’objet remplacé. Il s’agit d’un pointeur vers un objet de l’une des classes dérivées de `CGdiObject`, tel que `CPen`, selon la version de la fonction est utilisée. La valeur de retour est NULL s’il existe une erreur. Cette fonction peut retourner un pointeur vers un objet temporaire. Cet objet temporaire est uniquement valid pendant le traitement d’un message Windows. Pour plus d'informations, consultez `CGdiObject::FromHandle`.  
  
 La version de la fonction membre qui accepte un paramètre de région effectue la même tâche que le `SelectClipRgn` fonction membre. Sa valeur de retour peut être une des opérations suivantes :  
  
- COMPLEXREGION nouvelle zone de découpage a chevauchement des bordures.  
  
- Contexte de périphérique d’erreur ou la région n’est pas valide.  
  
- NULLREGION nouvelle zone de découpage est vide.  
  
- SIMPLEREGION nouvelle zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 Classe `CDC` fournit cinq versions spécialisées pour des types particuliers d’objets GDI, y compris les stylets, pinceaux, polices, images bitmap et régions. L’objet qui vient d’être sélectionné remplace l’objet précédent du même type. Par exemple, si *pObject* de la version générale de `SelectObject` pointe vers un [CPen](../../mfc/reference/cpen-class.md) de l’objet, la fonction remplace le stylet actuel avec le stylet spécifié par *pObject* .  
  
 Une application peut sélectionner une image bitmap dans les contextes de périphérique de mémoire uniquement et dans le contexte de périphérique de mémoire qu’un seul à la fois. Le format de l’image bitmap doit être monochrome ou compatible avec le contexte de périphérique ; le cas contraire, `SelectObject` retourne une erreur.  
  
 Pour Windows 3.1 et versions ultérieures, le `SelectObject` fonction retourne la même valeur qu’il est ou non utilisée dans un métafichier. Sous les versions précédentes de Windows, `SelectObject` retourné une valeur différente de zéro pour la réussite et la valeur 0 pour un échec lorsqu’il a été utilisé dans un métafichier.  
  
##  <a name="selectpalette"></a>  CDC::SelectPalette  
 Sélectionne la palette logique qui est spécifiée par *pPalette* que l’objet de palette sélectionné du contexte de périphérique.  
  
```  
CPalette* SelectPalette(
    CPalette* pPalette,  
    BOOL bForceBackground);
```  
  
### <a name="parameters"></a>Paramètres  
 *pPalette*  
 Identifie la palette logique à être sélectionné. Cette palette contient doit avoir déjà été créée avec le `CPalette` fonction membre [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).  
  
 *bForceBackground*  
 Spécifie si la palette logique est forcée à être une palette d’arrière-plan. Si *bForceBackground* est différent de zéro, la palette sélectionnée est toujours une palette d’arrière-plan, indépendamment de si la fenêtre a le focus d’entrée. Si *bForceBackground* est 0 et le contexte de périphérique est attaché à une fenêtre, la palette logique une palette de premier plan lorsque la fenêtre a le focus d’entrée.  
  
### <a name="return-value"></a>Valeur de retour  
 Un pointeur vers un `CPalette` objet identifiant la palette logique remplacée par la palette spécifiée par *pPalette*. Sa valeur est NULL s’il existe une erreur.  
  
### <a name="remarks"></a>Notes  
 La nouvelle palette devienne l’objet de la palette utilisée par GDI pour les couleurs de contrôle affichés dans le contexte de périphérique et remplace la palette précédente.  
  
 Une application peut sélectionner une palette logique dans plusieurs contextes de périphérique. Toutefois, les modifications vers une palette logique affectent tous les contextes de périphérique pour lequel il est sélectionné. Si une application sélectionne une palette dans plus d’un contexte de périphérique, les contextes de périphérique doivent tous appartenir au même appareil physique.  
  
##  <a name="selectstockobject"></a>  CDC::SelectStockObject  
 Sélectionne un [CGdiObject](../../mfc/reference/cgdiobject-class.md) objet qui correspond à un des stylets de stock prédéfinis, des pinceaux ou des polices.  
  
```  
virtual CGdiObject* SelectStockObject(int nIndex);
```  
  
### <a name="parameters"></a>Paramètres  
 *nIndex*  
 Spécifie le type d’objet stock souhaité. Il peut prendre l’une des valeurs suivantes :  
  
- Pinceau de BLACK_BRUSH noir.  
  
- Pinceau gris DKGRAY_BRUSH foncé.  
  
- Pinceau de GRAY_BRUSH gris.  
  
- Pinceau HOLLOW_BRUSH creux.  
  
- Pinceau de la lumière LTGRAY_BRUSH gris.  
  
- Pinceau NULL_BRUSH Null.  
  
- Pinceau de WHITE_BRUSH blanc.  
  
- Stylet de BLACK_PEN noir.  
  
- Stylet NULL_PEN Null.  
  
- Stylet de WHITE_PEN blanc.  
  
- ANSI ANSI_FIXED_FONT fixe de police système.  
  
- Police de variables système ANSI_VAR_FONT ANSI.  
  
- Police de périphérique dépendant DEVICE_DEFAULT_FONT.  
  
- OEM_FIXED_FONT OEM dépendant police fixé.  
  
- SYSTEM_FONT la police système. Par défaut, Windows utilise la police système pour dessiner les menus, les contrôles de boîte de dialogue et d’autres textes. Toutefois, il est préférable, ne pas à s’appuyer sur SYSTEM_FONT pour obtenir la police utilisée par windows et les boîtes de dialogue. Au lieu de cela, utilisez le `SystemParametersInfo` fonction avec le paramètre SPI_GETNONCLIENTMETRICS pour récupérer la police actuelle. `SystemParametersInfo` prend en compte le thème actuel et fournit des informations de police des légendes, des menus et des boîtes de dialogue de message.  
  
- SYSTEM_FIXED_FONT la police de largeur fixe système utilisée dans Windows antérieures à la version 3.0. Cet objet est disponible pour la compatibilité avec les versions antérieures de Windows.  
  
- Palette de couleurs DEFAULT_PALETTE par défaut. Cette palette contient 20 couleurs statiques dans la palette système.  
  
### <a name="return-value"></a>Valeur de retour  
 Un pointeur vers le `CGdiObject` objet qui a été remplacé si la fonction réussite. L’objet réel désigné est un [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md), ou [CFont](../../mfc/reference/cfont-class.md) objet. Si l’appel n’aboutit pas, la valeur de retour est NULL.  
  
##  <a name="setabortproc"></a>  CDC::SetAbortProc  
 Installe la procédure d’abandon pour le travail d’impression.  
  
```  
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```  
  
### <a name="parameters"></a>Paramètres  
 *lpfn*  
 Pointeur vers la fonction abort pour installer en tant que la procédure d’abandon. Pour plus d’informations sur la fonction de rappel, consultez [fonction de rappel pour CDC::SetAbortProc](callback-functions-used-by-mfc.md#setabortproc).  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le résultat de la `SetAbortProc` (fonction). Certaines des valeurs suivantes sont plus probables que d’autres, mais tous sont possibles.  
  
- Erreur générale de SP_ERROR.  
  
- SP_OUTOFDISK pas suffisamment d’espace disque est actuellement disponible pour la mise en attente, et davantage d’espace devient disponible.  
  
- SP_OUTOFMEMORY pas suffisamment de mémoire est disponible pour la mise en attente.  
  
- SP_USERABORT utilisateur a pris fin le travail via le Gestionnaire d’impression.  
  
### <a name="remarks"></a>Notes  
 Si une application doit autoriser le travail d’impression doit être annulée au cours de la mise en attente, il doit définir la fonction d’annulation avant que le travail d’impression est démarré avec le [StartDoc](#startdoc) fonction membre. Le Gestionnaire d’impression appelle la fonction de l’abandon lors de la mise en attente pour permettre à l’application d’annuler le travail d’impression ou pour traiter les conditions d’espace disque. Si aucune fonction d’abandon est définie, le travail d’impression échoue s’il n’est pas suffisamment d’espace disque pour la mise en attente.  
  
 Notez que les fonctionnalités de Microsoft Visual C++ simplifient la création de la fonction de rappel passée à `SetAbortProc`. L’adresse passée à la `EnumObjects` fonction membre est un pointeur vers une fonction exportée avec `__declspec(dllexport)` et avec le `__stdcall` convention d’appel.  
  
 Aussi inutile exporter le nom de fonction dans une **exportations** instruction dans le fichier de définition de module de votre application. Vous pouvez utiliser à la place la **exporter** fonction modificateur, comme dans  
  
 **EXPORTATION de rappel BOOL** AFunction ( **HDC**, `int` **) ;**  
  
 Pour contraindre le compilateur à émettre l’enregistrement d’exportation correcte pour l’exportation par son nom sans alias. Cela fonctionne pour la plupart des besoins. Pour certains cas spéciaux, notamment l’exportation d’une fonction par ordinal ou alias de l’exportation, vous devez toujours utiliser un **exportations** instruction dans un fichier de définition de module.  
  
 Interfaces de rappel d’inscription sont désormais de type sécurisé (vous devez passer un pointeur de fonction qui pointe vers le bon type de fonction pour le rappel spécifique).  
  
 Notez également que toutes les fonctions de rappel doivent intercepter les exceptions de Microsoft Foundation avant de revenir à Windows, étant donné que les exceptions ne peut pas être levées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, consultez l’article [Exceptions](../../mfc/exception-handling-in-mfc.md).  
  
##  <a name="setarcdirection"></a>  CDC::SetArcDirection  
 Définit le sens de dessin à utiliser pour les fonctions d’arc de cercle et le rectangle.  
  
```  
int SetArcDirection(int nArcDirection);
```  
  
### <a name="parameters"></a>Paramètres  
 *nArcDirection*  
 Spécifie la nouvelle direction d’arc de cercle. Ce paramètre peut être une des valeurs suivantes :  
  
- Figures AD_COUNTERCLOCKWISE dessiné dans le sens anti-horaire.  
  
- Figures AD_CLOCKWISE dessiné dans le sens horaire.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie la direction d’arc de cercle ancien, en cas de réussite ; sinon 0.  
  
### <a name="remarks"></a>Notes  
 La direction par défaut est dans le sens inverse. Le `SetArcDirection` fonction spécifie la direction dans laquelle les fonctions suivantes dessin :  
  
|Arc|Secteur|  
|---------|---------|  
|`ArcTo`|`Rectangle`|  
|`Chord`|`RoundRect`|  
|`Ellipse`||  
  
##  <a name="setattribdc"></a>  CDC::SetAttribDC  
 Appelez cette fonction pour définir le contexte de périphérique attribut `m_hAttribDC`.  
  
```  
virtual void SetAttribDC(HDC hDC);
```  
  
### <a name="parameters"></a>Paramètres  
 *hDC*  
 Un contexte de périphérique Windows.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre ne s’attache pas le contexte de périphérique pour le `CDC` objet. Uniquement le contexte de périphérique de sortie est attaché à un `CDC` objet.  
  
##  <a name="setbkcolor"></a>  CDC::SetBkColor  
 Définit la couleur d’arrière-plan actuelle à la couleur spécifiée.  
  
```  
virtual COLORREF SetBkColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *crColor*  
 Spécifie la nouvelle couleur d’arrière-plan.  
  
### <a name="return-value"></a>Valeur de retour  
 La couleur d’arrière-plan précédente comme une valeur de couleur RVB. Si une erreur se produit, la valeur de retour est 0 x 80000000.  
  
### <a name="remarks"></a>Notes  
 Si le mode d’arrière-plan est OPAQUE, le système utilise la couleur d’arrière-plan pour remplir les écarts dans les lignes de style, les écarts entre les lignes hachurées de pinceaux et de l’arrière-plan dans les cellules de caractères. Le système utilise également la couleur d’arrière-plan lors de la conversion de bitmaps entre la couleur et les contextes de périphérique monochrome.  
  
 Si l’appareil ne peut pas afficher la couleur spécifiée, le système définit la couleur d’arrière-plan de la couleur physique le plus proche.  
  
##  <a name="setbkmode"></a>  CDC::SetBkMode  
 Définit le mode d’arrière-plan.  
  
```  
int SetBkMode(int nBkMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *nBkMode*  
 Spécifie le mode à définir. Ce paramètre peut être une des valeurs suivantes :  
  
- Arrière-plan OPAQUE est rempli avec la couleur d’arrière-plan actuelle avant le texte, hachuré pinceau, ou le stylet est dessiné. Il s’agit du mode d’arrière-plan par défaut.  
  
- Arrière-plan TRANSPARENT n’est pas modifié avant le dessin.  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode précédent de l’arrière-plan.  
  
### <a name="remarks"></a>Notes  
 Le mode d’arrière-plan définit si le système supprime les couleurs d’arrière-plan sur la surface de dessin avant de dessiner du texte, des pinceaux hachurées ou n’importe quel style de stylet qui n’est pas une ligne pleine.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).  
  
##  <a name="setboundsrect"></a>  CDC::SetBoundsRect  
 Contrôle l’accumulation des informations de rectangle englobant pour le contexte de périphérique spécifié.  
  
```  
UINT SetBoundsRect(
    LPCRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpRectBounds*  
 Pointe vers un `RECT` structure ou `CRect` objet qui est utilisé pour définir le rectangle englobant. Dimensions du rectangle sont indiquées dans les coordonnées logiques. Ce paramètre peut être NULL.  
  
 *flags*  
 Spécifie comment le nouveau rectangle à combiner avec le rectangle cumulé. Ce paramètre peut être une combinaison des valeurs suivantes :  
  
- DCB_ACCUMULATE ajouter le rectangle spécifié par *lpRectBounds* au rectangle englobant (à l’aide d’une opération union rectangle).  
  
- DCB_DISABLE désactiver accumulation de limites.  
  
- DCB_ENABLE allumez accumulation de limites. (Le paramètre par défaut pour l’accumulation de limites est désactivé.)  
  
### <a name="return-value"></a>Valeur de retour  
 L’état actuel du rectangle englobant, si la fonction réussite. Comme *indicateurs*, la valeur de retour peut être une combinaison de **DCB_** valeurs :  
  
- DCB_ACCUMULATE le rectangle englobant n’est pas vide. Cette valeur sera toujours être définie.  
  
- Accumulation de limites de DCB_DISABLE est désactivée.  
  
- Accumulation de limites de DCB_ENABLE est activée.  
  
### <a name="remarks"></a>Notes  
 Windows peut maintenir un rectangle englobant pour toutes les opérations de dessins. Ce rectangle peut être interrogé et réinitialisation par l’application. Les limites de dessins sont utiles pour invalider les caches de la bitmap.  
  
##  <a name="setbrushorg"></a>  CDC::SetBrushOrg  
 Spécifie l’origine GDI affecte au pinceau suivant qui sélectionne de l’application dans le contexte de périphérique.  
  
```  
CPoint SetBrushOrg(
    int x,  
    int y);  
  
CPoint SetBrushOrg(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x (en unités de périphérique) de l’origine. Cette valeur doit être dans la plage 0-7.  
  
 *y*  
 Spécifie la coordonnée y (en unités de périphérique) de l’origine. Cette valeur doit être dans la plage 0-7.  
  
 *point*  
 Spécifie les coordonnées x et y de l’origine. Chaque valeur doit être dans la plage 0-7. Vous pouvez passer soit un `POINT` structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine précédente du pinceau en unités de périphérique.  
  
### <a name="remarks"></a>Notes  
 Coordonnées de la valeur par défaut pour l’origine de pinceau sont (0, 0). Pour modifier l’origine d’un pinceau, appelez le `UnrealizeObject` fonctionner pour la `CBrush` de l’objet, appelez `SetBrushOrg`, puis appelez le `SelectObject` membre afin de sélectionner le pinceau dans le contexte de périphérique.  
  
 N’utilisez pas `SetBrushOrg` avec stock `CBrush` objets.  
  
##  <a name="setcoloradjustment"></a>  CDC::SetColorAdjustment  
 Définit les valeurs d’ajustement de couleur pour le contexte de périphérique en utilisant les valeurs spécifiées.  
  
```  
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpColorAdjust*  
 Pointe vers un [réglage des couleurs](../../mfc/reference/coloradjustment-structure.md) structure de données contenant les valeurs d’ajustement de couleur.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Les valeurs d’ajustement de couleur sont utilisées pour ajuster la couleur d’entrée de la bitmap source pour les appels à la `CDC::StretchBlt` fonction membre lorsque le mode de demi-teintes.  
  
##  <a name="setdcbrushcolor"></a>  CDC::SetDCBrushColor  
 Définit la couleur actuelle du pinceau de contexte (DC) de l’appareil à la valeur de la couleur spécifiée.  
  
```  
COLORREF SetDCBrushColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *crColor*  
 Spécifie la couleur du pinceau.  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour spécifie la couleur précédente de pinceau de contrôleur de domaine en tant que valeur COLORREF.  
  
 Si la fonction échoue, la valeur de retour est CLR_INVALID.  
  
### <a name="remarks"></a>Notes  
 Cette méthode émule la fonctionnalité de la fonction [SetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-setdcbrushcolor), comme décrit dans le SDK Windows.  
  
##  <a name="setdcpencolor"></a>  CDC::SetDCPenColor  
 Définit la couleur actuelle du stylet de contexte (DC) de l’appareil à la valeur de la couleur spécifiée.  
  
```  
COLORREF SetDCPenColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *crColor*  
 Spécifie la couleur du stylet.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre utilise la fonction Win32 [SetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-setdcpencolor), comme décrit dans le SDK Windows.  
  
##  <a name="setgraphicsmode"></a>  CDC::SetGraphicsMode  
 Définit le mode de graphiques pour le contexte de périphérique spécifié.  
  
```  
int SetGraphicsMode(int iMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *iMode*  
 Spécifie le mode graphique. Pour obtenir la liste des valeurs que ce paramètre peut prendre, consultez [SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode).  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne l’ancien mode de graphiques.  
  
 Retourne 0 en cas d’échec. Pour obtenir les informations d’erreur étendues, appelez [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Notes  
 Cette méthode encapsule la fonction Windows GDI [SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode).  
  
##  <a name="setlayout"></a>  CDC::SetLayout  
 Appelez cette fonction membre pour modifier la disposition du texte et des graphiques pour un contexte de périphérique à droite à gauche, la mise en forme standard pour les cultures telles que l’arabe et l’hébreu.  
  
```  
DWORD SetLayout(DWORD dwLayout);
```  
  
### <a name="parameters"></a>Paramètres  
 *dwLayout*  
 Indicateurs de contrôle de disposition de contexte de périphérique et de la bitmap. Il peut être une combinaison des valeurs suivantes.  
  
|Value|Signification|  
|-----------|-------------|  
|LAYOUT_BITMAPORIENTATIONPRESERVED|Désactive toute la réflexion pour les appels à [CDC::BitBlt](#bitblt) et [CDC::StretchBlt](#stretchblt).|  
|LAYOUT_RTL|Définit la disposition horizontale par défaut de droite à gauche.|  
|LAYOUT_LTR|Définit la disposition par défaut pour être de gauche à droite.|  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, la disposition précédente du contexte de périphérique.  
  
 En cas d’échec, GDI_ERROR. Pour obtenir les informations d’erreur étendues, appelez [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Notes  
 Normalement, vous n’appelez pas `SetLayout` pour une fenêtre. Au lieu de cela, vous contrôlez la disposition de droite à gauche dans une fenêtre en définissant le [les styles de fenêtre étendus](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) tels que WS_EX_RTLREADING. Un contexte de périphérique, comme une imprimante ou un métafichier, n’hérite pas de cette disposition. La seule façon de définir le contexte de périphérique pour une disposition de droite à gauche est en appelant `SetLayout`.  
  
 Si vous appelez **SetLayout (LAYOUT_RTL** ), `SetLayout` MM_ISOTROPIC change automatiquement le mode de mappage. Par conséquent, un appel ultérieur à [GetMapMode](#getmapmode) retournera MM_ISOTROPIC au lieu de MM_TEXT.  
  
 Dans certains cas, comme avec nombreux bitmaps, vous souhaiterez éventuellement conserver la disposition de gauche à droite. Dans ce cas, afficher l’image en appelant `BitBlt` ou `StretchBlt`, puis définissez l’indicateur de contrôle d’image bitmap pour *dwLayout* à LAYOUT_BITMAPORIENTATIONPRESERVED.  
  
 Une fois que vous modifiez la disposition avec l’indicateur LAYOUT_RTL, les indicateurs spécifiant normalement gauche ou droite est inversés. Pour éviter toute confusion, vous souhaiterez sans doute définir d’autres noms pour les indicateurs standards. Pour obtenir la liste des noms d’indicateur de remplacement suggérées, consultez [SetLayout](/windows/desktop/api/wingdi/nf-wingdi-setlayout) dans le SDK Windows.  
  
##  <a name="setmapmode"></a>  CDC::SetMapMode  
 Définit le mode de mappage.  
  
```  
virtual int SetMapMode(int nMapMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *nMapMode*  
 Spécifie le nouveau mode de mappage. Il peut prendre l’une des valeurs suivantes :  
  
- Unités logiques MM_ANISOTROPIC sont converties en unités arbitraires avec des axes à l’échelle de façon arbitraire. Définition du mode de mappage MM_ANISOTROPIC ne modifie pas les paramètres actuels de fenêtre ou la fenêtre d’affichage. Pour modifier les unités, l’orientation et la mise à l’échelle, appellent le [SetWindowExt](#setwindowext) et [SetViewportExt](#setviewportext) fonctions membres.  
  
- MM_HIENGLISH chaque unité logique est converti en 0,001 pouce. Positif x est vers la droite. y positif est.  
  
- MM_HIMETRIC chaque unité logique est converti en 0,01 millimètre. Positif x est vers la droite. y positif est.  
  
- Unités logiques MM_ISOTROPIC sont converties en unités arbitraires avec tout aussi des axes à l’échelle ; Autrement dit, 1 unité sur l’axe x est égale à 1 unité sur l’axe y. Utilisez le `SetWindowExt` et `SetViewportExt` les fonctions membres pour spécifier les unités souhaitées et l’orientation des axes. GDI apporte des ajustements en fonction des besoins pour vous assurer que les coordonnées x et y unités conservent la même taille.  
  
- MM_LOENGLISH chaque unité logique est converti en 0,01 pouce. Positif x est vers la droite. y positif est.  
  
- MM_LOMETRIC chaque unité logique est converti en 0,1 millimètre. Positif x est vers la droite. y positif est.  
  
- MM_TEXT chaque unité logique est convertie en pixels de 1 périphérique. Positif x est vers la droite. y positif est arrêté.  
  
- MM_TWIPS chaque unité logique est converti en 1/20 d’un point. (Comme un point est 1/72ème de pouce, un twips est 1/1440 pouce). Positif x est vers la droite. y positif est.  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de mappage précédent.  
  
### <a name="remarks"></a>Notes  
 Le mode de mappage définit l’unité de mesure utilisée pour convertir les unités logiques en unités de périphérique ; Il définit également l’orientation de l’appareil x et y. GDI utilise le mode de mappage pour convertir les coordonnées logiques en les coordonnées de périphérique approprié. Le mode MM_TEXT aux applications de travailler en pixels de périphérique, où 1 unité est égale à 1 pixel. La taille physique d’un pixel varie d’un périphérique à l’autre.  
  
 Les modes MM_HIENGLISH MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC et MM_TWIPS sont utiles pour les applications qui doivent dessiner dans des unités significatives physiquement (par exemple, des pouces ou des millimètres). Le mode MM_ISOTROPIC garantit les proportions de 1:1, ce qui est utile lorsqu’il est important de conserver la forme d’une image exacte. Le mode MM_ANISOTROPIC permet les coordonnées x et y être ajustée de manière indépendante.  
  
> [!NOTE]
>  Si vous appelez [SetLayout](#setlayout) pour modifier le contrôleur de domaine (contexte de périphérique) à la disposition de droite à gauche, `SetLayout` MM_ISOTROPIC change automatiquement le mode de mappage.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setmapperflags"></a>  CDC::SetMapperFlags  
 Modifie la méthode utilisée par le mappeur de police lorsqu’il convertit une police logique pour une police physique.  
  
```  
DWORD SetMapperFlags(DWORD dwFlag);
```  
  
### <a name="parameters"></a>Paramètres  
 *dwFlag*  
 Spécifie si le mappeur de polices tente de faire correspondre une hauteur de police aspect et la largeur à l’appareil. Lorsque cette valeur est ASPECT_FILTERING, le Mappeur sélectionne uniquement les polices dont les aspect de x et y-aspect correspondent exactement à ceux de l’appareil spécifié.  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur précédente de l’indicateur de mappeur de police.  
  
### <a name="remarks"></a>Notes  
 Une application peut utiliser `SetMapperFlags` pour provoquer le mappeur de police pour essayer de choisir uniquement une police physique qui correspond exactement aux proportions de l’appareil spécifié.  
  
 Une application qui utilise uniquement les polices raster peut utiliser le `SetMapperFlags` (fonction) pour vous assurer que la police sélectionnée par le mappeur de police est attrayante et lisible sur le périphérique spécifié. Les applications qui utilisent généralement des polices dimensionnables (TrueType) n’utilisent pas `SetMapperFlags`.  
  
 Si aucune police physique n’a des proportions qui correspond à la spécification de la police logique, GDI choisit un nouveau rapport hauteur / largeur et sélectionne une police qui correspond à ce nouveau rapport hauteur / largeur.  
  
##  <a name="setmiterlimit"></a>  CDC::SetMiterLimit  
 Définit la limite pour la longueur de jointures de pointe pour le contexte de périphérique.  
  
```  
BOOL SetMiterLimit(float fMiterLimit);
```  
  
### <a name="parameters"></a>Paramètres  
 *fMiterLimit*  
 Spécifie la nouvelle limite de pointe pour le contexte de périphérique.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La longueur d’onglet est définie comme la distance entre l’intersection des murs de ligne à l’intérieur de la jointure et l’intersection des murs de ligne à l’extérieur de la jointure. La limite est le taux maximal autorisé de la longueur d’onglet à la largeur de ligne. La limite de l’onglet par défaut est 10.0.  
  
##  <a name="setoutputdc"></a>  CDC::SetOutputDC  
 Appelez cette fonction membre pour définir le contexte de périphérique de sortie, `m_hDC`.  
  
```  
virtual void SetOutputDC(HDC hDC);
```  
  
### <a name="parameters"></a>Paramètres  
 *hDC*  
 Un contexte de périphérique Windows.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre peut uniquement être appelée lorsqu’un contexte de périphérique n’a pas été attaché à la `CDC` objet. Cette fonction membre définit `m_hDC` mais ne s’attache ne pas le contexte de périphérique pour le `CDC` objet.  
  
##  <a name="setpixel"></a>  CDC::SetPixel  
 Définit le pixel au point spécifié pour l’approximation plus proche de la couleur spécifiée par *crColor*.  
  
```  
COLORREF SetPixel(
    int x,  
    int y,  
    COLORREF crColor);

 
COLORREF SetPixel(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point à définir.  
  
 *y*  
 Spécifie la coordonnée y logique du point à définir.  
  
 *crColor*  
 Valeur COLORREF RGB qui spécifie la couleur utilisée pour peindre le point. Consultez [COLORREF](/windows/desktop/gdi/colorref) dans le SDK Windows pour obtenir une description de cette valeur.  
  
 *point*  
 Spécifie la logique et y-coordonnées x du point à définir. Vous pouvez passer soit un `POINT` structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur RVB de la couleur que le point est réellement peint. Cette valeur peut être différente de celui spécifié par *crColor* si une approximation de cette couleur est utilisée. Si la fonction échoue (si le point est en dehors de la zone de découpage), la valeur de retour est -1.  
  
### <a name="remarks"></a>Notes  
 Le point doit être dans la zone de découpage. Si le point n’est pas dans la zone de découpage, la fonction ne fait rien.  
  
 La fonction `SetPixel` n'est pas prise en charge par tous les périphériques. Pour déterminer si un périphérique prend en charge `SetPixel`, appelez le `GetDeviceCaps` membre de fonction avec l’index RASTERCAPS et vérifiez la valeur de retour pour l’indicateur RC_BITBLT.  
  
##  <a name="setpixelv"></a>  CDC::SetPixelV  
 Définit le pixel aux coordonnées spécifiées pour l’approximation plus proche de la couleur spécifiée.  
  
```  
BOOL SetPixelV(
    int x,  
    int y,  
    COLORREF crColor);

 
BOOL SetPixelV(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x, en unités logiques, du point à définir.  
  
 *y*  
 Spécifie la coordonnée y, en unités logiques, du point à définir.  
  
 *crColor*  
 Spécifie la couleur à utiliser pour peindre le point.  
  
 *point*  
 Spécifie la logique et y-coordonnées x du point à définir. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure de données ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le point doit être dans la zone de découpage et de la partie visible de la surface de l’appareil. Tous les périphériques prennent en charge la fonction membre. Pour plus d’informations, consultez la fonction RC_BITBLT dans le `CDC::GetDeviceCaps` fonction membre. `SetPixelV` est plus rapide que `SetPixel` car il n’a pas besoin de retourner la valeur de couleur du point réellement peint.  
  
##  <a name="setpolyfillmode"></a>  CDC::SetPolyFillMode  
 Définit le mode de remplissage de polygones.  
  
```  
int SetPolyFillMode(int nPolyFillMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *nPolyFillMode*  
 Spécifie le nouveau mode de remplissage. Cette valeur peut être autre ou cachés. Le mode par défaut défini dans Windows est un autre.  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de remplissage de la précédente, en cas de réussite ; sinon 0.  
  
### <a name="remarks"></a>Notes  
 Lorsque le mode de remplissage de polygone est autre, le système remplit la zone entre les côtés d’un polygone impaires et paires sur chaque ligne de numérisation. Autrement dit, le système remplit la zone entre le côté de la première et deuxième, entre le troisième et quatrième et ainsi de suite. Ce mode est la valeur par défaut.  
  
 Lorsque le mode de remplissage de polygone est enroulement, le système utilise la direction dans laquelle figure a été extraite pour déterminer s’il faut remplir une zone. Chaque segment de ligne dans un polygone est dessiné dans un sens ou aiguilles. Chaque fois qu’une ligne imaginaire dessinée à partir d’une zone fermée à l’extérieur d’une figure traverse un segment de ligne dans le sens horaire, un nombre est incrémenté. Lorsque la ligne passe par un segment de ligne dans le sens inverse, le nombre est décrémenté. La zone est remplie si le nombre est différent de zéro lorsque la ligne atteint l’extérieur de la figure.  
  
##  <a name="setrop2"></a>  CDC::SetROP2  
 Définit le mode de dessin en cours.  
  
```  
int SetROP2(int nDrawMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *nDrawMode*  
 Spécifie le nouveau mode de dessin. Il peut être une des valeurs suivantes :  
  
- R2_BLACK Pixel est toujours noir.  
  
- R2_WHITE Pixel est toujours blanc.  
  
- R2_NOP Pixel reste inchangé.  
  
- R2_NOT Pixel est l’inverse de la couleur de l’écran.  
  
- R2_COPYPEN Pixel est la couleur du stylet.  
  
- R2_NOTCOPYPEN Pixel est l’inverse de la couleur du stylet.  
  
- R2_MERGEPENNOT Pixel est une combinaison de la couleur du stylet et l’inverse de la couleur de l’écran (pixel finale = (pas pixel d’écran) ou de stylet).  
  
- R2_MASKPENNOT Pixel est une combinaison des couleurs courantes pour le stylet et l’inverse de l’écran (pixel finale = (pas pixel d’écran) et du stylet).  
  
- R2_MERGENOTPEN Pixel est une combinaison de la couleur de l’écran et l’inverse de la couleur du stylet (pixel finale = (non stylet) ou de pixel d’écran).  
  
- R2_MASKNOTPEN Pixel est une combinaison des couleurs courantes à l’écran et l’inverse du stylet (pixel finale = (non stylet) et l’écran de pixel).  
  
- R2_MERGEPEN Pixel est une combinaison de la couleur du stylet et la couleur de l’écran (pixel finale = Plume pixel d’écran OR).  
  
- R2_NOTMERGEPEN Pixel est l’inverse de la couleur R2_MERGEPEN (pixel finale = non (pen pixel d’écran OR)).  
  
- R2_MASKPEN Pixel est une combinaison des couleurs courantes pour le stylet et l’écran (pixel finale = pen AND pixel d’écran).  
  
- R2_NOTMASKPEN Pixel est l’inverse de la couleur R2_MASKPEN (pixel finale = non (pen AND pixel d’écran)).  
  
- R2_XORPEN Pixel est une combinaison des couleurs qui sont dans le stylet ou dans l’écran, mais pas dans les deux (pixel finale = pixel d’écran de stylet XOR).  
  
- R2_NOTXORPEN Pixel est l’inverse de la couleur R2_XORPEN (pixel finale = non (stylet XOR écran en pixels)).  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de dessin précédent.  
  
 Il peut être une des valeurs fournies dans le SDK Windows.  
  
### <a name="remarks"></a>Notes  
 Le mode dessin spécifie comment les couleurs du stylet et l’intérieur d’objets sont combinées avec la couleur déjà sur la surface d’affichage.  
  
 Le mode dessin est destinée aux appareils de raster uniquement ; Il ne s’applique pas aux appareils de vecteur. Modes de dessin sont des codes d’opération de rastérisation binaire qui représente toutes les combinaisons Boolean de deux variables, à l’aide des opérateurs binaires AND, OR et XOR (OR exclusif) et l’opération unaire ne pas.  
  
##  <a name="setstretchbltmode"></a>  CDC::SetStretchBltMode  
 Définit le mode d’étirement de bitmap pour le `StretchBlt` fonction membre.  
  
```  
int SetStretchBltMode(int nStretchMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *nStretchMode*  
 Spécifie le mode d’étirement. Il peut être une des valeurs suivantes :  
  
|Value|Description|  
|-----------|-----------------|  
|BLACKONWHITE|Effectue une opération booléenne et utilisant les valeurs de couleur pour les pixels éliminés et existants. Si la bitmap est un bitmap monochrome, ce mode permet de conserver les pixels noirs au détriment des pixels blancs.|  
|COLORONCOLOR|Supprime les pixels. Ce mode supprime éliminés toutes les lignes de pixels sans essayer de préserver leurs informations.|  
|DEMI-TEINTES|Mappe les pixels du rectangle source en blocs de pixels dans le rectangle de destination. La couleur moyenne sur le bloc de destination de pixels est proche de la couleur des pixels de la source.|  
||Après avoir défini le mode d’étirement de demi-teintes, une application doit appeler la fonction Win32 [SetBrushOrgEx](/windows/desktop/api/wingdi/nf-wingdi-setbrushorgex) pour définir l’origine du pinceau. En cas d’échec pour ce faire, alignement incorrect de pinceau se produit.|  
|STRETCH_ANDSCANS|**Windows 95/98**: identique à BLACKONWHITE|  
|STRETCH_DELETESCANS|**Windows 95/98**: identique à COLORONCOLOR|  
|STRETCH_HALFTONE|**Windows 95/98**: identique à celle de demi-teintes.|  
|STRETCH_ORSCANS|**Windows 95/98**: identique à WHITEONBLACK|  
|WHITEONBLACK|Effectue une opération booléenne ou utilisant les valeurs de couleur pour les pixels éliminés et existants. Si la bitmap est un bitmap monochrome, ce mode préserve pixels blancs au détriment des pixels noirs.|  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode d’étirement précédent. Il peut être STRETCH_ANDSCANS, STRETCH_DELETESCANS ou STRETCH_ORSCANS.  
  
### <a name="remarks"></a>Notes  
 Le mode d’étirement de bitmap définit la façon dont les informations sont supprimées de bitmaps qui sont compressées à l’aide de la fonction.  
  
 Les modes BLACKONWHITE (STRETCH_ANDSCANS) et WHITEONBLACK (STRETCH_ORSCANS) sont généralement utilisés pour conserver les pixels de premier plan dans les images bitmap monochromes. Le mode COLORONCOLOR (STRETCH_DELETESCANS) est généralement utilisé pour conserver les couleurs dans les images bitmap de couleur.  
  
 Le mode de demi-teintes nécessite davantage de traitement de l’image source que les trois autres modes ; Il est plus lent que les autres, mais produit des images de qualité supérieure. Notez également que `SetBrushOrgEx` doit être appelée après la définition du mode de demi-teintes afin d’éviter un mauvais alignement du pinceau.  
  
 Modes d’extension supplémentaires peuvent également être disponibles selon les capacités du pilote de périphérique.  
  
##  <a name="settextalign"></a>  CDC::SetTextAlign  
 Définit les indicateurs de l’alignement du texte.  
  
```  
UINT SetTextAlign(UINT nFlags);
```  
  
### <a name="parameters"></a>Paramètres  
 *nIndicateurs*  
 Spécifie les indicateurs de l’alignement du texte. Les indicateurs spécifient la relation entre un point et un rectangle qui englobe le texte. Le point peut être soit la position actuelle ou les coordonnées spécifiées par une fonction de sortie de texte. Le rectangle qui délimite le texte est défini par les cellules adjacentes de caractère dans la chaîne de texte. Le *nIndicateurs* paramètre peut être un ou plusieurs indicateurs à partir de le des trois catégories suivantes. Choisir qu’un seul indicateur de chaque catégorie. La première catégorie affecte l’alignement du texte sur l’axe x :  
  
- TA_CENTER aligne le point avec le Centre horizontal du rectangle englobant.  
  
- TA_LEFT aligne le point sur le côté gauche du rectangle englobant. Il s'agit du paramètre par défaut.  
  
- TA_RIGHT aligne le point avec le côté droit du rectangle englobant.  
  
 La seconde catégorie affecte l’alignement du texte sur l’axe y :  
  
- TA_BASELINE aligne le point avec la ligne de base de la police choisie.  
  
- TA_BOTTOM aligne le point avec le bas du rectangle englobant.  
  
- TA_TOP aligne le point avec le bord supérieur du rectangle englobant. Il s'agit du paramètre par défaut.  
  
 La troisième catégorie détermine si la position actuelle est mise à jour lorsque le texte est écrit :  
  
- TA_NOUPDATECP ne met pas à jour la position actuelle après chaque appel à une fonction de sortie de texte. Il s'agit du paramètre par défaut.  
  
- TA_UPDATECP mises à jour de la position x actuelle après chaque appel à une fonction de sortie de texte. La nouvelle position est sur le côté droit du rectangle englobant pour le texte. Lorsque cet indicateur est défini, les coordonnées spécifiées dans les appels à la `TextOut` fonction membre sont ignorés.  
  
### <a name="return-value"></a>Valeur de retour  
 L’alignement du texte paramètre précédent, si l’opération réussit. L’octet de poids faible contient le paramètre horizontal et l’octet de poids fort du paramètre vertical. sinon 0.  
  
### <a name="remarks"></a>Notes  
 Le `TextOut` et `ExtTextOut` fonctions membres utilisent ces indicateurs lors du positionnement d’une chaîne de texte sur un appareil ou un affichage. Les indicateurs spécifient la relation entre un point spécifique et un rectangle qui englobe le texte. Les coordonnées de ce point sont passées comme paramètres à la `TextOut` fonction membre. Le rectangle qui délimite le texte est formé par les cellules adjacentes de caractère dans la chaîne de texte.  
  
##  <a name="settextcharacterextra"></a>  CDC::SetTextCharacterExtra  
 Définit l’espacement entre les caractères.  
  
```  
int SetTextCharacterExtra(int nCharExtra);
```  
  
### <a name="parameters"></a>Paramètres  
 *nCharExtra*  
 Spécifie la quantité d’espace supplémentaire (en unités logiques) pour être ajouté à chaque caractère. Si le mode de mappage actuel n’est pas `MM_TEXT`, *nCharExtra* est transformé et arrondi au pixel le plus proche.  
  
### <a name="return-value"></a>Valeur de retour  
 La quantité de l’espacement entre les caractères précédent.  
  
### <a name="remarks"></a>Notes  
 GDI ajoute cet espacement à chaque caractère, y compris les caractères de saut, lorsqu’il écrit une ligne de texte dans le contexte de périphérique. La valeur par défaut pour la quantité de l’espacement est 0.  
  
##  <a name="settextcolor"></a>  CDC::SetTextColor  
 Définit la couleur du texte à la couleur spécifiée.  
  
```  
virtual COLORREF SetTextColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *crColor*  
 Spécifie la couleur du texte avec une valeur de couleur RVB.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur RVB de la couleur du texte précédent.  
  
### <a name="remarks"></a>Notes  
 Le système utilisera cette couleur de texte lors de l’écriture de texte pour ce contexte de périphérique et également lorsque les bitmaps de conversion entre les couleurs et les contextes de périphérique monochrome.  
  
 Si l’appareil ne peut pas représenter la couleur spécifiée, le système définit la couleur du texte sur la couleur physique le plus proche. La couleur d’arrière-plan pour un caractère spécifiée par le `SetBkColor` et `SetBkMode` fonctions membres.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).  
  
##  <a name="settextjustification"></a>  CDC::SetTextJustification  
 Ajoute un espace pour les caractères de saut dans une chaîne.  
  
```  
int SetTextJustification(
    int nBreakExtra,  
    int nBreakCount);
```  
  
### <a name="parameters"></a>Paramètres  
 *nBreakExtra*  
 Spécifie l’espace total supplémentaire à ajouter à la ligne de texte (en unités logiques). Si le mode de mappage actuel n’est pas `MM_TEXT`, la valeur indiquée par ce paramètre est convertie vers le mode de mappage actuel et arrondie à l’unité de périphérique le plus proche.  
  
 *nBreakCount*  
 Spécifie le nombre de caractères de saut dans la ligne.  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction a réussi ; sinon 0.  
  
### <a name="remarks"></a>Notes  
 Une application peut utiliser le `GetTextMetrics` des fonctions membres pour récupérer d’une police rompre le caractère.  
  
 Après le `SetTextJustification` fonction membre est appelée, un appel à une fonction de sortie de texte (tel que `TextOut`) répartit l’espace supplémentaire spécifié uniformément parmi le nombre spécifié de caractères de saut. Le caractère de saut est généralement le caractère espace (ASCII 32), mais peut être défini par une police en tant que d’autres caractères.  
  
 La fonction membre `GetTextExtent` est généralement utilisé avec `SetTextJustification`. `GetTextExtent` calcule la largeur d’une ligne donnée avant d’alignement. Une application peut déterminer la quantité d’espace pour spécifier dans le *nBreakExtra* paramètre en soustrayant la valeur retournée par `GetTextExtent` à partir de la largeur de la chaîne après alignement.  
  
 Le `SetTextJustification` fonction peut être utilisée pour aligner une ligne qui contient plusieurs séries dans des polices. Dans ce cas, la ligne doit être créée fragmentaire l’alignement et l’écriture de chaque exécution séparément.  
  
 Étant donné que les erreurs d’arrondi peuvent se produire pendant l’alignement, le système conserve un terme d’erreur en cours d’exécution qui définit l’erreur actuelle. Lors de l’alignement d’une ligne qui contient plusieurs exécutions, `GetTextExtent` utilise automatiquement ce terme d’erreur quand il calcule l’étendue de la prochaine exécution. Ainsi, la fonction de sortie de texte fusionner l’erreur dans la nouvelle exécution.  
  
 Une fois que chaque ligne a été alignée, ce terme d’erreur doit être désactivé pour l’empêcher d’être incorporées dans la ligne suivante. Le terme peut être supprimé en appelant `SetTextJustification` avec *nBreakExtra* définie sur 0.  
  
##  <a name="setviewportext"></a>  CDC::SetViewportExt  
 Définit les étendues x et y de la fenêtre d’affichage du contexte de périphérique.  
  
```  
virtual CSize SetViewportExt(
    int cx,  
    int cy);  
  
CSize SetViewportExt(SIZE size);
```  
  
### <a name="parameters"></a>Paramètres  
 *CX*  
 Spécifie l’étendue de x de la fenêtre d’affichage (en unités de périphérique).  
  
 *CY*  
 Spécifie l’étendue de y de la fenêtre d’affichage (en unités de périphérique).  
  
 *size*  
 Spécifie les extensions x et y de la fenêtre d’affichage (en unités de périphérique).  
  
### <a name="return-value"></a>Valeur de retour  
 Les étendues précédentes de la fenêtre d’affichage comme un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet. Lorsqu’une erreur se produit, les coordonnées x et y de retourné `CSize` de l’objet sont toutes deux définies sur 0.  
  
### <a name="remarks"></a>Notes  
 La fenêtre d’affichage, ainsi que la fenêtre de contexte de périphérique, définit la façon dont GDI mappe les points dans le système de coordonnées logiques aux points dans le système de coordonnées de l’appareil réel. En d’autres termes, elles définissent la façon dont GDI convertit les coordonnées logiques en coordonnées de périphérique.  
  
 Lorsque les modes de mappage suivantes sont définies, les appels à `SetWindowExt` et `SetViewportExt` sont ignorés :  
  
|MM_HIENGLISH|MM_LOMETRIC|  
|-------------------|------------------|  
|MM_HIMETRIC|MM_TEXT|  
|MM_LOENGLISH|MM_TWIPS|  
  
 Lorsque le mode MM_ISOTROPIC est défini, une application doit appeler la `SetWindowExt` fonction membre avant d’appeler `SetViewportExt`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setviewportorg"></a>  CDC::SetViewportOrg  
 Définit l’origine de la fenêtre d’affichage du contexte de périphérique.  
  
```  
virtual CPoint SetViewportOrg(
    int x,  
    int y);  
  
CPoint SetViewportOrg(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x (en unités de périphérique) de l’origine de la fenêtre d’affichage. La valeur doit être dans la plage du système de coordonnées de périphérique.  
  
 *y*  
 Spécifie la coordonnée y (en unités de périphérique) de l’origine de la fenêtre d’affichage. La valeur doit être dans la plage du système de coordonnées de périphérique.  
  
 *point*  
 Spécifie l’origine de la fenêtre d’affichage. Les valeurs doivent être dans la plage du système de coordonnées de périphérique. Vous pouvez passer soit un `POINT` structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine précédente de la fenêtre d’affichage (dans les coordonnées de périphérique) comme un `CPoint` objet.  
  
### <a name="remarks"></a>Notes  
 La fenêtre d’affichage, ainsi que la fenêtre de contexte de périphérique, définit la façon dont GDI mappe les points dans le système de coordonnées logiques aux points dans le système de coordonnées de l’appareil réel. En d’autres termes, elles définissent la façon dont GDI convertit les coordonnées logiques en coordonnées de périphérique.  
  
 L’origine de la fenêtre d’affichage marque le point dans le système de coordonnées de périphérique à laquelle GDI est mappée à l’origine de la fenêtre, un point dans le système de coordonnées logiques, spécifié par la `SetWindowOrg` fonction membre. GDI mappe tous les autres points en suivant le même processus requis pour mapper l’origine de la fenêtre à l’origine de la fenêtre d’affichage. Par exemple, tous les points dans un cercle autour du point à l’origine de la fenêtre sera dans un cercle autour du point à l’origine de la fenêtre d’affichage. De même, tous les points dans une ligne qui passe par l’origine de la fenêtre sera dans une ligne qui passe par l’origine de la fenêtre d’affichage.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setwindowext"></a>  CDC::SetWindowExt  
 Définit les étendues x et y de la fenêtre associée au contexte de périphérique.  
  
```  
virtual CSize SetWindowExt(
    int cx,  
    int cy);  
  
CSize SetWindowExt(SIZE size);
```  
  
### <a name="parameters"></a>Paramètres  
 *CX*  
 Spécifie l’étendue-x (en unités logiques) de la fenêtre.  
  
 *CY*  
 Spécifie l’étendue-y (en unités logiques) de la fenêtre.  
  
 *size*  
 Spécifie les x - et y-étendues (en unités logiques) de la fenêtre.  
  
### <a name="return-value"></a>Valeur de retour  
 Les étendues précédentes de la fenêtre (en unités logiques) selon une `CSize` objet. Si une erreur se produit, les coordonnées x et y de retourné `CSize` de l’objet sont toutes deux définies sur 0.  
  
### <a name="remarks"></a>Notes  
 La fenêtre, ainsi que de la fenêtre d’affichage du contexte de périphérique, définit la façon dont GDI mappe les points dans le système de coordonnées logiques à points dans le système de coordonnées de périphérique.  
  
 Lorsque les modes de mappage suivantes sont définies, les appels à `SetWindowExt` et `SetViewportExt` fonctions sont ignorées :  
  
- MM_HIENGLISH  
  
- MM_HIMETRIC  
  
- MM_LOENGLISH  
  
- MM_LOMETRIC  
  
- MM_TEXT  
  
- MM_TWIPS  
  
 Lorsque le mode MM_ISOTROPIC est défini, une application doit appeler la `SetWindowExt` fonction membre avant d’appeler `SetViewportExt`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setwindoworg"></a>  CDC::SetWindowOrg  
 Définit l’origine de la fenêtre du contexte de périphérique.  
  
```  
CPoint SetWindowOrg(
    int x,  
    int y);  
  
CPoint SetWindowOrg(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’origine de la fenêtre.  
  
 *y*  
 Spécifie la coordonnée y logique de l’origine de la fenêtre.  
  
 *point*  
 Spécifie les coordonnées logiques de l’origine de la fenêtre. Vous pouvez passer soit un `POINT` structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine précédente de la fenêtre comme un `CPoint` objet.  
  
### <a name="remarks"></a>Notes  
 La fenêtre, ainsi que de la fenêtre d’affichage du contexte de périphérique, définit la façon dont GDI mappe les points dans le système de coordonnées logiques à points dans le système de coordonnées de périphérique.  
  
 L’origine de la fenêtre marque le point dans le système de coordonnées logiques à partir de laquelle GDI mappe l’origine de la fenêtre d’affichage, un point dans le système de coordonnées de périphérique spécifié par le `SetWindowOrg` (fonction). GDI mappe tous les autres points en suivant le même processus requis pour mapper l’origine de la fenêtre à l’origine de la fenêtre d’affichage. Par exemple, tous les points dans un cercle autour du point à l’origine de la fenêtre sera dans un cercle autour du point à l’origine de la fenêtre d’affichage. De même, tous les points dans une ligne qui passe par l’origine de la fenêtre sera dans une ligne qui passe par l’origine de la fenêtre d’affichage.  
  
##  <a name="setworldtransform"></a>  CDC::SetWorldTransform  
 Définit une transformation linéaire à deux dimensions entre l’espace universel et l’espace de page pour le contexte de périphérique spécifié. Cette transformation peut être utilisée pour mettre à l’échelle, faire pivoter, altérer ou traduire la sortie graphique.  
  
```  
BOOL SetWorldTransform(const XFORM& rXform);
```  
  
### <a name="parameters"></a>Paramètres  
 *rXform*  
 Référence à un [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform) structure qui contient les données de la transformation.  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne une valeur différente de zéro.  
  
 Retourne 0 en cas d’échec.  
  
 Pour obtenir les informations d’erreur étendues, appelez [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Notes  
 Cette méthode encapsule la fonction Windows GDI [SetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-setworldtransform).  
  
##  <a name="startdoc"></a>  CDC::StartDoc  
 Informe le pilote de périphérique qui démarre un nouveau travail d’impression et que toutes les `StartPage` et `EndPage` appels doivent être mis en attente sous le même travail jusqu'à ce qu’une `EndDoc` appel se produit.  
  
```  
int StartDoc(LPDOCINFO lpDocInfo);  
int StartDoc(LPCTSTR lpszDocName);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpDocInfo*  
 Pointe vers un [DOCINFO](/windows/desktop/api/wingdi/ns-wingdi-_docinfoa) structure contenant le nom du fichier de document et le nom du fichier de sortie.  
  
 *lpszDocName*  
 Pointeur vers une chaîne contenant le nom de fichier du document.  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour est supérieure à zéro. Cette valeur est l’identificateur de travail d’impression pour le document.  
  
 Si la fonction échoue, la valeur de retour est inférieure ou égale à zéro.  
  
### <a name="remarks"></a>Notes  
 Cela garantit que les documents plus d’une page ne seront pas intercalées avec d’autres tâches.  
  
 Pour Windows 3.1 et versions ultérieures, cette fonction remplace la séquence d’échappement STARTDOC imprimante. À l’aide de cette fonction garantit que les documents contenant plusieurs pages ne sont pas mélangées avec les autres travaux d’impression.  
  
 `StartDoc` Il ne doit pas être utilisé à l’intérieur des métafichiers.  
  
### <a name="example"></a>Exemple  
 Ce fragment de code obtient l’imprimante par défaut, ouvre un travail d’impression et met en attente d’une page avec « Hello, World ! » sur ce dernier. Étant donné que le texte imprimé par ce code n’est pas mis à l’échelle les unités logiques de l’imprimante, le texte de sortie peut être dans ces petites lettres que le résultat est illisible. La capture de données modifiées mise à l’échelle des fonctions, telles que `SetMapMode`, `SetViewportOrg`, et `SetWindowExt`, peut être utilisé pour corriger la mise à l’échelle.  
  
 [!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]  
  
##  <a name="startpage"></a>  CDC::StartPage  
 Appelez cette fonction membre pour préparer le pilote d’imprimante pour recevoir des données.  
  
```  
int StartPage();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Supérieur ou égal à 0 si la fonction a réussi, ou une valeur négative si une erreur s’est produite.  
  
### <a name="remarks"></a>Notes  
 `StartPage` remplace les séquences d’échappement NEWFRAME et BANDINFO.  
  
 Pour une vue d’ensemble de la séquence d’appels d’impression, consultez le [StartDoc](#startdoc) fonction membre.  
  
 Le système désactive le `ResetDC` fonction membre entre les appels à `StartPage` et `EndPage`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::StartDoc](#startdoc).  
  
##  <a name="stretchblt"></a>  CDC::StretchBlt  
 Copie une image bitmap depuis un rectangle source vers un rectangle de destination, en étirant ou en compressant le bitmap si nécessaire pour l'adapter aux dimensions du rectangle de destination.  
  
```  
BOOL StretchBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x (en unités logiques) de l'angle supérieur gauche du rectangle de destination.  
  
 *y*  
 Spécifie la coordonnée y (en unités logiques) de l'angle supérieur gauche du rectangle de destination.  
  
 *nWidth*  
 Spécifie la largeur (en unités logiques) du rectangle de destination.  
  
 *nHeight*  
 Spécifie la hauteur (en unités logiques) du rectangle de destination.  
  
 *pSrcDC*  
 Spécifie le contexte du périphérique source.  
  
 *xSrc*  
 Spécifie la coordonnée x (en unités logiques) de l'angle supérieur gauche du rectangle source.  
  
 *ySrc*  
 Spécifie la coordonnée y (en unités logiques) de l'angle supérieur gauche du rectangle source.  
  
 *nSrcWidth*  
 Spécifie la largeur (en unités logiques) du rectangle source.  
  
 *nSrcHeight*  
 Spécifie la hauteur (en unités logiques) du rectangle source.  
  
 *dwRop*  
 Spécifie l'opération de rastérisation à effectuer. Le code d'une opération de rastérisation définit la façon dont GDI associe les couleurs dans les opérations de sortie qui impliquent le pinceau actuel, un éventuel bitmap source et un bitmap de destination. Ce paramètre peut avoir l'une des valeurs suivantes :  
  
- Active NOIRCEUR que toutes les sorties noir.  
  
- DSTINVERT inverse le bitmap de destination.  
  
- MERGECOPY associe le modèle et la bitmap source à l’aide de l’opérateur booléen AND.  
  
- MERGEPAINT associe le bitmap source inversé au bitmap de destination à l’aide de l’opérateur booléen OR.  
  
- NOTSRCCOPY copie le bitmap source inversé vers la destination.  
  
- NOTSRCERASE inverse le résultat de la combinaison de la bitmap source et de destination à l’aide de l’opérateur booléen OR.  
  
- PATCOPY copie le modèle vers le bitmap de destination.  
  
- PATINVERT associe le bitmap de destination avec le modèle à l’aide de l’opérateur booléen XOR.  
  
- PATPAINT associe le bitmap source inversé avec le modèle à l’aide de l’opérateur booléen OR. Associe le résultat de cette opération au bitmap de destination à l'aide de l'opérateur booléen OR.  
  
- Src et combine les pixels du bitmap du bitmap source et de destination à l’aide de l’opérateur booléen AND.  
  
- SRCCOPY copie le bitmap source vers la bitmap de destination.  
  
- SRCERASE inverse le bitmap de destination et associe le résultat de la bitmap source à l’aide de l’opérateur booléen AND.  
  
- SRCINVERT combine les pixels du bitmap du bitmap source et de destination à l’aide de l’opérateur booléen XOR.  
  
- SRCPAINT combine les pixels du bitmap du bitmap source et de destination à l’aide de l’opérateur booléen OR.  
  
- Active de blancheur que toutes les sorties blanc.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si le bitmap est dessiné ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La fonction utilise le mode d'étirement du contexte du périphérique de destination (défini par `SetStretchBltMode`) afin de savoir comment étirer ou compresser le bitmap.  
  
 Le `StretchBlt` fonction déplace le bitmap depuis le périphérique source fourni par *pSrcDC* à l’appareil de destination représenté par l’objet de contexte de périphérique dont la fonction membre est appelée. Le *xSrc*, *ySrc*, *nSrcWidth*, et *nSrcHeight* paramètres définissent l’angle supérieur gauche et les dimensions du rectangle source . Le *x*, *y*, *nWidth*, et *nHeight* paramètres donnent à l’angle supérieur gauche et les dimensions du rectangle de destination. L’opération de rastérisation spécifiée par *dwRop* définit comment le bitmap source et les bits déjà sur le périphérique de destination sont combinées.  
  
 Le `StretchBlt` fonction crée une image miroir d’une image bitmap si les signes de la *nSrcWidth* et *nWidth* ou *nSrcHeight* et *nHeight* paramètres diffèrent. Si *nSrcWidth* et *nWidth* ont des signes différents, la fonction crée une image miroir du bitmap le long de l’axe des abscisses. Si *nSrcHeight* et *nHeight* ont des signes différents, la fonction crée une image miroir du bitmap le long de l’axe des ordonnées.  
  
 La fonction `StretchBlt` étire ou compresse le bitmap source en mémoire, puis copie le résultat vers la destination. Si un modèle doit être fusionné avec le résultat, il ne le sera pas tant que le bitmap source étiré n'est pas copié vers la destination. Si un pinceau est utilisé, il s'agira du pinceau sélectionné dans le contexte de périphérique de destination. Les coordonnées de destination sont transformées en fonction du contexte du périphérique de destination ; les coordonnées sources sont transformées en fonction du contexte du périphérique source.  
  
 Si les bitmaps sources, les bitmaps de destination et les bitmaps de modèle n'ont pas le même format de couleur, `StretchBlt` convertit les bitmaps sources et les bitmaps de modèle pour qu'ils correspondent aux bitmaps de destination. Les couleurs de premier plan et d'arrière-plan du contexte du périphérique de destination sont utilisées dans la conversion.  
  
 Si `StretchBlt` doit convertir un bitmap monochrome en bitmap de couleur, il définit les bits blancs (1) sur la couleur d'arrière-plan et les bits noirs (0) sur la couleur de premier plan. Pour convertir la couleur en monochrome, il définit les pixels qui correspondent à la couleur d'arrière-plan sur blanc (1) et définit tous les autres pixels sur noir (0). Les couleurs de premier plan et d'arrière-plan du contexte du périphérique coloré sont utilisées.  
  
 La fonction `StretchBlt` n'est pas prise en charge par tous les périphériques. Pour déterminer si un périphérique prend en charge `StretchBlt`, appelez le `GetDeviceCaps` membre de fonction avec l’index RASTERCAPS et vérifiez la valeur de retour pour l’indicateur RC_STRETCHBLT.  
  
##  <a name="strokeandfillpath"></a>  CDC::StrokeAndFillPath  
 Ferme des figures ouvertes dans un chemin d’accès, des traits le contour du chemin d’accès à l’aide du stylet actuel et remplit son intérieur en utilisant le pinceau actuel.  
  
```  
BOOL StrokeAndFillPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique doit contenir une trajectoire fermée. Le `StrokeAndFillPath` fonction membre a le même effet que la fermeture de toutes les figures ouvertes dans le chemin d’accès et de contour et en remplissant le chemin d’accès de séparément, à ceci près que la région remplie ne se superposent pas au tracé de région, même si le stylet est large.  
  
##  <a name="strokepath"></a>  CDC::StrokePath  
 Restitue le chemin d’accès spécifié à l’aide du stylet actuel.  
  
```  
BOOL StrokePath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique doit contenir une trajectoire fermée.  
  
##  <a name="tabbedtextout"></a>  CDC::TabbedTextOut  
 Appelez cette fonction membre pour écrire une chaîne de caractères à l’emplacement spécifié, en développant des onglets pour les valeurs spécifiées dans le tableau de positions de taquet de tabulation.  
  
```  
virtual CSize TabbedTextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);

 
CSize TabbedTextOut(
    int x,  
    int y,  
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point de départ de la chaîne.  
  
 *y*  
 Spécifie la coordonnée y logique du point de départ de la chaîne.  
  
 *lpszString*  
 Pointe vers une chaîne de caractères à dessiner. Vous pouvez passer soit un pointeur vers un tableau de caractères ou un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 *nCount*  
 Spécifie le nombre de caractères de la chaîne. Si *nCount* est -1, la longueur est calculée.  
  
 *nTabPositions*  
 Spécifie le nombre de valeurs dans le tableau de positions de taquet de tabulation.  
  
 *lpnTabStopPositions*  
 Pointe vers un tableau qui contient les positions de taquet de tabulation (en unités logiques). Les taquets de tabulation doivent être triées dans l’ordre ; croissant la plus petite valeur de x doit être le premier élément du tableau.  
  
 *nTabOrigin*  
 Spécifie la coordonnée x de la position de départ à partir duquel les onglets sont développées (en unités logiques).  
  
 *str*  
 Un `CString` objet qui contient les caractères spécifiés.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) comme un `CSize` objet.  
  
### <a name="remarks"></a>Notes  
 Texte est écrit dans la police actuellement sélectionnée. Si *nTabPositions* est égal à 0 et *lpnTabStopPositions* est NULL, onglets sont développés en huit fois la moyenne largeur des caractères.  
  
 Si *nTabPositions* est 1, l’onglet s’arrête est séparés par la distance spécifiée par la première valeur dans le *lpnTabStopPositions* tableau. Si le *lpnTabStopPositions* tableau contient plusieurs valeurs, un taquet de tabulation est défini pour chaque valeur dans le tableau, jusqu’au nombre spécifié par *nTabPositions*. Le *nTabOrigin* paramètre permet à une application appeler le `TabbedTextOut` fonction plusieurs fois pour une seule ligne. Si l’application appelle la fonction plusieurs fois avec le *nTabOrigin* définie sur la même valeur chaque fois, la fonction développe tous les onglets par rapport à la position spécifiée par *nTabOrigin*.  
  
 Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction. Si une application a besoin mettre à jour la position actuelle lorsqu’il appelle la fonction, l’application peut appeler le [SetTextAlign](#settextalign) fonction membre avec *nIndicateurs* TA_UPDATECP la valeur. Lorsque cet indicateur est défini, Windows ignore le *x* et *y* paramètres lors des appels ultérieurs à `TabbedTextOut`, à l’aide de la position actuelle à la place.  
  
##  <a name="textout"></a>  CDC::TextOut  
 Écrit une chaîne de caractères à l'emplacement spécifié à l'aide de la police sélectionnée.  
  
```  
virtual BOOL TextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount);

 
BOOL TextOut(
    int x,
    int y,
    const CString& str);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point de départ du texte.  
  
 *y*  
 Spécifie la coordonnée y logique du point de départ du texte.  
  
 *lpszString*  
 Pointe vers la chaîne de caractères à ajouter.  
  
 *nCount*  
 Spécifie le nombre de caractères de la chaîne.  
  
 *str*  
 Objet `CString` qui contient les caractères à ajouter.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 L'origine des caractères se trouve dans l'angle supérieur gauche de la cellule de caractère. Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction.  
  
 Si une application doit mettre à jour la position actuelle lorsqu’il appelle `TextOut`, l’application peut appeler le `SetTextAlign` fonction membre avec *nIndicateurs* TA_UPDATECP la valeur. Lorsque cet indicateur est défini, Windows ignore le *x* et *y* paramètres lors des appels ultérieurs à `TextOut`, à l’aide de la position actuelle à la place.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="transparentblt"></a>  CDC::TransparentBlt  
 Appelez cette fonction membre pour transférer un bloc de bits des données de couleur, qui correspond à un rectangle de pixels à partir du contexte de périphérique source spécifiée, dans un contexte de périphérique de destination.  
  
```  
BOOL TransparentBlt(
    int xDest,  
    int yDest,
    int nDestWidth,
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    UINT clrTransparent);
```  
  
### <a name="parameters"></a>Paramètres  
 *xDest*  
 Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle de destination.  
  
 *yDest*  
 Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle de destination.  
  
 *nDestWidth*  
 Spécifie la largeur, en unités logiques, du rectangle de destination.  
  
 *nDestHeight*  
 Spécifie la hauteur, en unités logiques, du rectangle de destination.  
  
 *pSrcDC*  
 Pointeur vers le contexte du périphérique source.  
  
 *xSrc*  
 Spécifie la coordonnée x, en unités logiques, du rectangle source.  
  
 *ySrc*  
 Spécifie la coordonnée y, en unités logiques, du rectangle source.  
  
 *nSrcWidth*  
 Spécifie la largeur, en unités logiques, du rectangle source.  
  
 *nSrcHeight*  
 Spécifie la hauteur, en unités logiques, du rectangle source.  
  
 *clrTransparent*  
 La couleur RVB de la bitmap source à traiter comme transparente.  
  
### <a name="return-value"></a>Valeur de retour  
 TRUE en cas de réussite, sinon FALSE.  
  
### <a name="remarks"></a>Notes  
 `TransparentBlt` permet la transparence ; Autrement dit, la couleur RVB indiqué par *clrTransparent* est rendu transparent pour le transfert.  
  
 Pour plus d’informations, consultez [TransparentBlt](/windows/desktop/api/wingdi/nf-wingdi-transparentblt) dans le SDK Windows.  
  
##  <a name="updatecolors"></a>  CDC::UpdateColors  
 Mises à jour la zone cliente du contexte de périphérique en mettant en correspondance en cours de couleurs dans la zone cliente de la palette système sur un pixel par pixel.  
  
```  
void UpdateColors();
```  
  
### <a name="remarks"></a>Notes  
 Une fenêtre inactive avec une palette logique réalisée peut appeler `UpdateColors` au lieu d’être redessiné sa zone cliente lors de la palette système change.  
  
 Pour plus d’informations sur l’utilisation des palettes de couleurs, consultez [UpdateColors](/windows/desktop/api/wingdi/nf-wingdi-updatecolors) dans le SDK Windows.  
  
 Le `UpdateColors` fonction membre met généralement à jour une zone cliente plus rapidement que le nouveau dessin de la zone. Toutefois, étant donné que la fonction effectue la traduction de couleur en fonction de la couleur de chaque pixel avant la modification de la palette système, chaque appel à cette fonction entraîne la perte de précision de certaines couleurs.  
  
##  <a name="widenpath"></a>  CDC::WidenPath  
 Redéfinit le chemin d’accès actuel en tant que la zone serait être peinte si le chemin d’accès ont été dessiné à l’aide du stylet actuellement sélectionné dans le contexte de périphérique.  
  
```  
BOOL WidenPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction réussit uniquement si le stylet actuel est un stylet géométrique créé par la deuxième version de `CreatePen` fonction membre, ou si le stylet est créé avec la première version de `CreatePen` et a une largeur, en unités de périphérique, supérieure à 1. Le contexte de périphérique doit contenir une trajectoire fermée. Les courbes Bzier dans le chemin d’accès sont convertis en séquences de lignes droites se rapprochant les courbes élargies. Par conséquent, aucune courbe Bzier ne reste dans le chemin d’accès après `WidenPath` est appelée.  
  
## <a name="see-also"></a>Voir aussi  
 [CObject (classe)](../../mfc/reference/cobject-class.md)   
 [Graphique hiérarchique](../../mfc/hierarchy-chart.md)   
 [CPaintDC (classe)](../../mfc/reference/cpaintdc-class.md)   
 [Cwindowdc, classe](../../mfc/reference/cwindowdc-class.md)   
 [CClientDC (classe)](../../mfc/reference/cclientdc-class.md)   
 [CMetaFileDC, classe](../../mfc/reference/cmetafiledc-class.md)
