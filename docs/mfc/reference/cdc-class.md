---
title: Classe CDC
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 830c6d068a5074d0918107ca601c51d198a8a912
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81375713"
---
# <a name="cdc-class"></a>Classe CDC

Définit une classe d’objets de contexte de périphérique.

## <a name="syntax"></a>Syntaxe

```
class CDC : public CObject
```

## <a name="members"></a>Membres

### <a name="public-constructors"></a>Constructeurs publics

|Nom|Description|
|----------|-----------------|
|[CDC::CDC](#cdc)|Construit un objet `CDC`.|

### <a name="public-methods"></a>M&#233;thodes publiques

|Nom|Description|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|Termine le travail d’impression actuel, effaçant tout ce que l’application a écrit à l’appareil depuis le dernier appel de la `StartDoc` fonction membre.|
|[CDC::AbortPath](#abortpath)|Ferme et écarte les chemins dans le contexte de l’appareil.|
|[CDC::AddMetaFileComment](#addmetafilecomment)|Copie le commentaire d’un tampon en un métaafile amélioré spécifié.|
|[CDC::AlphaBlend](#alphablend)|Affiche des bitmaps qui ont des pixels transparents ou semi-transparents.|
|[CDC::AngleArc](#anglearc)|Dessine un segment de ligne et un arc, et déplace la position actuelle au point de fin de l’arc.|
|[CDC::Arc](#arc)|Dessine un arc elliptique.|
|[CDC::ArcTo](#arcto)|Dessine un arc elliptique. Cette fonction est `Arc`similaire à , sauf que la position actuelle est mise à jour.|
|[CDC::Attach](#attach)|Attache un contexte d’appareil Windows à cet `CDC` objet.|
|[CDC::BeginPath](#beginpath)|Ouvre un support de chemin dans le contexte de l’appareil.|
|[CDC::BitBlt](#bitblt)|Copies d’un bitmap à partir d’un contexte d’appareil spécifié.|
|[CDC::Chord](#chord)|Dessine un accord (une figure fermée délimitée par l’intersection d’une ellipse et d’un segment de ligne).|
|[CDC::CloseFigure](#closefigure)|Ferme une figure ouverte sur un chemin.|
|[CDC::CréerCompatibleDC](#createcompatibledc)|Crée un contexte mémoire-dispositif compatible avec un autre contexte d’appareil. Vous pouvez l’utiliser pour préparer des images en mémoire.|
|[CDC::CreateDC](#createdc)|Crée un contexte d’appareil pour un appareil spécifique.|
|[CDC::CreateIC](#createic)|Crée un contexte d’information pour un appareil spécifique. Cela fournit un moyen rapide d’obtenir des informations sur l’appareil sans créer un contexte d’appareil.|
|[CDC::DeleteDC](#deletedc)|Supprime le contexte de l’appareil Windows associé à cet `CDC` objet.|
|[CDC::DeleteTempMap](#deletetempmap)|Appelé par `CWinApp` le gestionnaire de temps `CDC` d’inactivité pour supprimer tout objet temporaire créé par `FromHandle`. détache également le contexte de l’appareil.|
|[CDC::Detach](#detach)|Détache le contexte de l’appareil Windows de cet `CDC` objet.|
|[CDC::DPtoHIMETRIC](#dptohimetric)|Convertit les unités de périphériques en unités HIMETRIC.|
|[CDC::DPtoLP](#dptolp)|Convertit les unités de périphériques en unités logiques.|
|[CDC::Draw3dRect](#draw3drect)|Dessine un rectangle tridimensionnel.|
|[CDC::DrawDragRect](#drawdragrect)|Efface et redessine un rectangle pendant qu’il est traîné.|
|[CDC::DrawEdge](#drawedge)|Dessine les bords d’un rectangle.|
|[CDC::DrawEscape](#drawescape)|Accès aux capacités de dessin d’un écran vidéo qui ne sont pas directement disponibles via l’interface de périphérique graphique (GDI).|
|[CDC::DrawFocusRect](#drawfocusrect)|Dessine un rectangle dans le style utilisé pour indiquer la mise au point.|
|[CDC::DrawFrameControl](#drawframecontrol)|Dessinez un contrôle de cadre.|
|[CDC::DrawIcon](#drawicon)|Dessine une icône.|
|[CDC::DrawState](#drawstate)|Affiche une image et applique un effet visuel pour indiquer un état.|
|[CDC::DrawText](#drawtext)|Dessine du texte formaté dans le rectangle spécifié.|
|[CDC::DrawTextEx](#drawtextex)|Dessine du texte formaté dans le rectangle spécifié à l’aide de formats supplémentaires.|
|[CDC::Ellipse](#ellipse)|Dessine une ellipse.|
|[CDC::EndDoc](#enddoc)|Termine un travail d’impression commencé par la `StartDoc` fonction membre.|
|[CDC::EndPage](#endpage)|Informe le pilote de l’appareil qu’une page se termine.|
|[CDC::EndPath](#endpath)|Ferme un support de chemin et sélectionne le chemin défini par le support dans le contexte de l’appareil.|
|[CDC::EnumObjects](#enumobjects)|Énumère les stylos et les pinceaux disponibles dans un contexte d’appareil.|
|[CDC::Escape](#escape)|Permet aux applications d’accéder à des installations qui ne sont pas directement disponibles à partir d’un appareil particulier via GDI. Permet également l’accès aux fonctions d’évasion Windows. Les appels d’évasion effectués par une application sont traduits et envoyés au conducteur de l’appareil.|
|[CDC::ExcludeClipRect](#excludecliprect)|Crée une nouvelle région de coupure qui se compose de la région de coupure existante moins le rectangle spécifié.|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Empêche de dessiner dans les zones non valides d’une fenêtre en excluant une région mise à jour dans la fenêtre d’une région de coupure.|
|[CDC::ExtFloodFill](#extfloodfill)|Remplit une zone avec la brosse actuelle. Fournit plus de flexibilité que le [CDC::FloodFill](#floodfill) fonction membre.|
|[CDC::ExtTextOut](#exttextout)|Écrit une chaîne de caractères dans une région rectangulaire à l’aide de la police actuellement sélectionnée.|
|[CDC::FillPath](#fillpath)|Ferme toutes les figures ouvertes dans le chemin actuel et remplit l’intérieur du chemin en utilisant la brosse actuelle et le mode de remplissage du polygone.|
|[CDC::FillRect](#fillrect)|Remplit un rectangle donné à l’aide d’une brosse spécifique.|
|[CDC::FillRgn](#fillrgn)|Remplit une région spécifique avec le pinceau spécifié.|
|[CDC::FillSolidRect](#fillsolidrect)|Remplit un rectangle d’une couleur solide.|
|[CDC::FlattenPath](#flattenpath)|Transforme toutes les courbes du chemin choisi dans le contexte actuel de l’appareil et transforme chaque courbe en une séquence de lignes.|
|[CDC::FloodFill](#floodfill)|Remplit une zone avec la brosse actuelle.|
|[CDC::FrameRect](#framerect)|Dessine une bordure autour d’un rectangle.|
|[CDC::FrameRgn](#framergn)|Dessine une bordure autour d’une région spécifique à l’aide d’une brosse.|
|[CDC::DeHandle](#fromhandle)|Renvoie un `CDC` pointeur à un objet lorsqu’on lui donne une poignée dans un contexte d’appareil. Si aucun objet `CDC` n'est attaché au handle, un objet `CDC` temporaire est créé et attaché.|
|[CDC::GetArcDirection](#getarcdirection)|Retourne la direction actuelle de l’arc pour le contexte de l’appareil.|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Récupère le paramètre pour le filtre actuel de rapport d’aspect.|
|[CDC::GetBkColor](#getbkcolor)|Récupère la couleur de fond actuelle.|
|[CDC::GetBkMode](#getbkmode)|Récupère le mode arrière-plan.|
|[CDC::GetBoundsRect](#getboundsrect)|Retourne le rectangle de délimitation accumulé en cours pour le contexte spécifié de l’appareil.|
|[CDC::GetBrushOrg](#getbrushorg)|Récupère l’origine de la brosse actuelle.|
|[CDC::GetCharABCWidths](#getcharabcwidths)|Récupère les largeurs, en unités logiques, de caractères consécutifs dans une plage donnée de la police actuelle.|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Récupère les largeurs, en unités logiques, d’indices glyphes consécutifs dans une plage spécifiée de la police TrueType actuelle.|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Récupère différents types d’informations sur une chaîne de caractères.|
|[CDC::GetCharWidth](#getcharwidth)|Récupère les largeurs fractionnées des caractères consécutifs dans une plage donnée de la police actuelle.|
|[CDC::GetCharWidthI](#getcharwidthi)|Récupère les largeurs, dans les coordonnées logiques, des indices glyphes consécutifs dans une plage spécifiée de la police actuelle.|
|[CDC::GetClipBox](#getclipbox)|Récupère les dimensions du rectangle de délimitation le plus serré autour de la limite de coupure actuelle.|
|[CDC::GetColorAdjustment](#getcoloradjustment)|Récupère les valeurs d’ajustement des couleurs pour le contexte de l’appareil.|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Retourne un pointeur `CBitmap` à l’objet actuellement sélectionné.|
|[CDC::GetCurrentBrush](#getcurrentbrush)|Retourne un pointeur `CBrush` à l’objet actuellement sélectionné.|
|[CDC::GetCurrentFont](#getcurrentfont)|Retourne un pointeur `CFont` à l’objet actuellement sélectionné.|
|[CDC::GetCurrentPalette](#getcurrentpalette)|Retourne un pointeur `CPalette` à l’objet actuellement sélectionné.|
|[CDC::GetCurrentPen](#getcurrentpen)|Retourne un pointeur `CPen` à l’objet actuellement sélectionné.|
|[CDC::GetCurrentPosition](#getcurrentposition)|Récupère la position actuelle du stylo (dans les coordonnées logiques).|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Récupère la couleur actuelle du pinceau.|
|[CDC::GetDCPenColor](#getdcpencolor)|Récupère la couleur actuelle du stylet.|
|[CDC::GetDeviceCaps](#getdevicecaps)|Récupère un type d’informations spécifiques à l’appareil sur les capacités d’un appareil d’affichage donné.|
|[CDC::GetFontData](#getfontdata)|Récupère les informations métriques de police d’un fichier de police évolutif. Les informations à récupérer sont identifiées en spécifiant un décalage dans le fichier de police et la durée des informations à retourner.|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Renvoie des informations sur la police actuellement sélectionnée pour le contexte d’affichage spécifié.|
|[CDC::GetGlyphOutline](#getglyphoutline)|Récupère la courbe de contour ou le bitmap pour un personnage de contour dans la police actuelle.|
|[CDC::GetGraphicsMode](#getgraphicsmode)|Récupère le mode graphique actuel pour le contexte de l’appareil spécifié.|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Récupère une brosse à demi-teinte.|
|[CDC::GetKerningPairs](#getkerningpairs)|Récupère les paires de kerning de caractère pour la police qui est actuellement sélectionnée dans le contexte spécifié de l’appareil.|
|[CDC::GetLayout](#getlayout)|Récupère la disposition d’un contexte d’appareil (DC). La disposition peut être de gauche à droite (par défaut) ou de droite à gauche (reflétée).|
|[CDC::GetMapMode](#getmapmode)|Récupère le mode de cartographie actuel.|
|[CDC::GetMiterLimit](#getmiterlimit)|Retourne la limite d’attrage pour le contexte de l’appareil.|
|[CDC::GetNearestColor](#getnearestcolor)|Récupère la couleur logique la plus proche d’une couleur logique spécifiée que l’appareil donné peut représenter.|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Récupère les informations métriques de police pour les polices TrueType.|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Récupère les largeurs des caractères individuels dans un groupe consécutif de caractères de la police actuelle en utilisant le contexte du périphérique de sortie.|
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Calcule la largeur et la hauteur d’une chaîne de caractères sur le contexte du périphérique de sortie.|
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Calcule la largeur et la hauteur d’une ligne de texte sur le contexte du périphérique de sortie à l’aide de la police actuelle pour déterminer les dimensions.|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Récupère les mesures de la police actuelle dans le contexte du périphérique de sortie.|
|[CDC::GetPath](#getpath)|Récupère les coordonnées définissant les points de terminaison des lignes et les points de contrôle des courbes trouvées dans le chemin qui est sélectionné dans le contexte de l’appareil.|
|[CDC::GetPixel](#getpixel)|Récupère la valeur couleur RGB du pixel au point spécifié.|
|[CDC::GetPolyFillMode](#getpolyfillmode)|Récupère le mode de remplissage actuel du polygone.|
|[CDC::GetROP2](#getrop2)|Récupère le mode de dessin actuel.|
|[CDC::GetSafeHdc](#getsafehdc)|Retourne [CDC::m_hDC](#m_hdc), le contexte du périphérique de sortie.|
|[CDC::GetStretchBltMode](#getstretchbltmode)|Récupère le mode d’étirement de la bitmap actuelle.|
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Calcule la largeur et la hauteur d’une chaîne de caractères sur le contexte de l’appareil d’attribut.|
|[CDC::GetTextAlign](#gettextalign)|Récupère les drapeaux d’alignement de texte.|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Récupère le paramètre actuel pour la quantité d’espacement intercharacter.|
|[CDC::GetTextColor](#gettextcolor)|Récupère la couleur actuelle du texte.|
|[CDC::GetTextExtent](#gettextextent)|Calcule la largeur et la hauteur d’une ligne de texte sur le contexte de l’appareil d’attribut à l’aide de la police actuelle pour déterminer les dimensions.|
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|Récupère le nombre de caractères dans une chaîne spécifiée qui s’adaptera dans un espace spécifié et remplit un tableau avec l’étendue du texte pour chacun de ces personnages.|
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Récupère la largeur et la hauteur de la gamme spécifiée d’indices glyphes.|
|[CDC::GetTextFace](#gettextface)|Copie le nom de police de la police actuelle en tampon comme une chaîne non terminée.|
|[CDC::GetTextMetrics](#gettextmetrics)|Récupère les mesures de la police actuelle dans le contexte de l’appareil d’attribut.|
|[CDC::GetViewportExt](#getviewportext)|Récupère les x- et y-extents du viewport.|
|[CDC::GetViewportOrg](#getviewportorg)|Récupère les coordonnées x et y de l’origine du viewport.|
|[CDC::GetWindow](#getwindow)|Retourne la fenêtre associée au contexte de l’appareil d’affichage.|
|[CDC::GetWindowExt](#getwindowext)|Récupère les x- et y-extents de la fenêtre associée.|
|[CDC::GetWindowOrg](#getwindoworg)|Récupère les coordonnées x et y de l’origine de la fenêtre associée.|
|[CDC::GetWorldTransform](#getworldtransform)|Récupère la transformation actuelle de l’espace mondial en espace de page.|
|[CDC::GradientFill](#gradientfill)|Remplit les structures de rectangle et de triangle avec une couleur gradante.|
|[CDC::GrayString](#graystring)|Dessine du texte tamisé (grisé) à l’endroit donné.|
|[CDC::HIMETRICtoDP](#himetrictodp)|Convertit les unités HIMETRIC en unités d’appareils.|
|[CDC::HIMETRICtoLP](#himetrictolp)|Convertit les unités HIMETRIC en unités logiques.|
|[CDC::IntersectClipRect](#intersectcliprect)|Crée une nouvelle région de coupure en formant l’intersection de la région actuelle et d’un rectangle.|
|[CDC::InvertRect](#invertrect)|Inverse le contenu d’un rectangle.|
|[CDC::InvertRgn](#invertrgn)|Inverti les couleurs dans une région.|
|[CDC::IsPrinting](#isprinting)|Détermine si le contexte de l’appareil est utilisé pour l’impression.|
|[CDC::LineTo](#lineto)|Établit une ligne de la position actuelle jusqu’à, mais sans inclure, un point.|
|[CDC::LPtoDP](#lptodp)|Convertit les unités logiques en unités d’appareils.|
|[CDC::LPtoHIMETRIC](#lptohimetric)|Convertit les unités logiques en unités HIMETRIC.|
|[CDC::MaskBlt](#maskblt)|Combine les données de couleur pour les bitmaps source et destination à l’aide du masque donné et de l’opération raster.|
|[CDC::ModifierWorldTransform](#modifyworldtransform)|Modifications de la transformation du monde pour un contexte d’appareil en utilisant le mode spécifié.|
|[CDC::MoveTo](#moveto)|Déplace la position actuelle.|
|[CDC::OffsetClipRgn](#offsetcliprgn)|Déplace la région de coupure de l’appareil donné.|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Modifie l’origine du port de vue par rapport aux coordonnées de l’origine actuelle du port de vue.|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Modifie l’origine de la fenêtre par rapport aux coordonnées de l’origine actuelle de la fenêtre.|
|[CDC::PaintRgn](#paintrgn)|Remplit une région avec le pinceau sélectionné.|
|[CDC::PatBlt](#patblt)|Crée un peu de modèle.|
|[CDC::Pie](#pie)|Dessine un coin en forme de tarte.|
|[CDC::PlayMetaFile](#playmetafile)|Joue le contenu du métaafile spécifié sur l’appareil donné. La version `PlayMetaFile` améliorée de l’image stockée dans le métaafile amélioré donné. Le metafile peut être joué n’importe quel nombre de fois.|
|[CDC::PlgBlt](#plgblt)|Effectue un transfert de bit-bloc des bits de données de couleur à partir du rectangle spécifié dans le contexte de l’appareil source au parallélogramme spécifié dans le contexte du périphérique donné.|
|[CDC::PolyBezier](#polybezier)|Dessine un ou plusieurs éclats de Bzier. La position actuelle n’est ni utilisée ni mise à jour.|
|[CDC::PolyBezierTo](#polybezierto)|Dessine un ou plusieurs éclats de Bzier, et déplace la position actuelle au point de fin du dernier éclat de Bzier.|
|[CDC::PolyDraw](#polydraw)|Dessine un ensemble de segments de ligne et de splines Bzier. Cette fonction met à jour la position actuelle.|
|[CDC::Polygon](#polygon)|Dessine un polygone composé de deux points ou plus (vertices) reliés par des lignes.|
|[CDC::Polyline](#polyline)|Dessine un ensemble de segments de ligne reliant les points spécifiés.|
|[CDC::PolylineTo](#polylineto)|Dessine une ou plusieurs lignes droites et déplace la position actuelle jusqu’au point de fin de la dernière ligne.|
|[CDC::PolyPolygon](#polypolygon)|Crée deux polygones ou plus qui sont remplis en utilisant le mode de remplissage actuel du polygone. Les polygones peuvent être disjoints ou ils peuvent se chevaucher.|
|[CDC::PolyPolyline](#polypolyline)|Dessine plusieurs séries de segments de lignes connectées. La position actuelle n’est ni utilisée ni mise à jour par cette fonction.|
|[CDC::PtVisible](#ptvisible)|Précise si le point donné se trouve dans la région de coupure.|
|[CDC::RealizePalette](#realizepalette)|Cartes entrées de palette dans la palette logique actuelle à la palette du système.|
|[CDC::Rectangle](#rectangle)|Dessine un rectangle à l’aide du stylo actuel et le remplit à l’aide de la brosse actuelle.|
|[CDC::RectVisible](#rectvisible)|Détermine si une partie du rectangle donné se trouve dans la région de coupure.|
|[CDC::ReleaseAttribDC](#releaseattribdc)|Communiqués `m_hAttribDC`, le contexte de l’appareil d’attribut.|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Communiqués `m_hDC`, le contexte du périphérique de sortie.|
|[CDC::ResetDC](#resetdc)|Mise `m_hAttribDC` à jour du contexte de l’appareil.|
|[CDC::RestoreDC](#restoredc)|Restaure le contexte de l’appareil à un état précédent enregistré avec `SaveDC`.|
|[CDC::RoundRect](#roundrect)|Dessine un rectangle avec des coins arrondis à l’aide du stylo actuel et rempli à l’aide de la brosse actuelle.|
|[CDC::SaveDC](#savedc)|Enregistre l’état actuel du contexte de l’appareil.|
|[CDC::ScaleViewportExt](#scaleviewportext)|Modifie l’étendue du viewport par rapport aux valeurs actuelles.|
|[CDC::ScaleWindowExt](#scalewindowext)|Modifie les étendues de fenêtre par rapport aux valeurs actuelles.|
|[CDC::ScrollDC](#scrolldc)|Faites défiler un rectangle de bits horizontalement et verticalement.|
|[CDC::SelectClipPath](#selectclippath)|Sélectionne le chemin actuel comme une région de coupure pour le contexte de l’appareil, combinant la nouvelle région avec n’importe quelle région de coupure existante en utilisant le mode spécifié.|
|[CDC::SelectClipRgn](#selectcliprgn)|Combine la région donnée avec la région de coupure actuelle en utilisant le mode spécifié.|
|[CDC::SelectObject](#selectobject)|Sélectionne un objet de dessin GDI tel qu’un stylo.|
|[CDC::SelectPalette](#selectpalette)|Sélectionne la palette logique.|
|[CDC::SelectStockObject](#selectstockobject)|Sélectionne l’un des stylos de stock prédéfinis, des brosses ou des polices fournies par Windows.|
|[CDC::SetAbortProc](#setabortproc)|Définit une fonction de rappel fournie par un programmeur que Windows appelle si un travail d’impression doit être avorté.|
|[CDC::SetArcDirection](#setarcdirection)|Définit la direction de dessin à utiliser pour les fonctions d’arc et de rectangle.|
|[CDC::SetAttribDC](#setattribdc)|Ensembles `m_hAttribDC`, le contexte de l’appareil d’attribut.|
|[CDC::SetBkColor](#setbkcolor)|Définit la couleur de fond actuelle.|
|[CDC::SetBkMode](#setbkmode)|Définit le mode arrière-plan.|
|[CDC::SetBoundsRect](#setboundsrect)|Contrôle l’accumulation d’informations de délimitation-rectangle pour le contexte spécifié de l’appareil.|
|[CDC::SetBrushOrg](#setbrushorg)|Spécifie l’origine de la prochaine brosse sélectionnée dans un contexte d’appareil.|
|[CDC::SetColorAdjustment](#setcoloradjustment)|Définit les valeurs d’ajustement des couleurs pour le contexte de l’appareil à l’aide des valeurs spécifiées.|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Définit la couleur actuelle du pinceau.|
|[CDC::SetDCPenColor](#setdcpencolor)|Définit la couleur actuelle du stylo.|
|[CDC::SetGraphicsMode](#setgraphicsmode)|Définit le mode graphique actuel pour le contexte de l’appareil spécifié.|
|[CDC::SetLayout](#setlayout)|Modifications de la disposition d’un contexte d’appareil (DC).|
|[CDC::SetMapMode](#setmapmode)|Définit le mode de cartographie actuel.|
|[CDC::SetMapperFlags](#setmapperflags)|Modifie l’algorithme que le mapper de police utilise lorsqu’il cartographie les polices logiques en polices physiques.|
|[CDC::SetMiterLimit](#setmiterlimit)|Définit la limite pour la longueur des jointures miter pour le contexte de l’appareil.|
|[CDC::SetOutputDC](#setoutputdc)|Ensembles `m_hDC`, le contexte du périphérique de sortie.|
|[CDC::SetPixel](#setpixel)|Définit le pixel au point spécifié à l’approximation la plus proche de la couleur spécifiée.|
|[CDC::SetPixelV](#setpixelv)|Définit le pixel aux coordonnées spécifiées à l’approximation la plus proche de la couleur spécifiée. `SetPixelV`est plus `SetPixel` rapide que parce qu’il n’a pas besoin de retourner la valeur de couleur du point effectivement peint.|
|[CDC::SetPolyFillMode](#setpolyfillmode)|Définit le mode de remplissage du polygone.|
|[CDC::SetROP2](#setrop2)|Définit le mode de dessin actuel.|
|[CDC::SetStretchBltMode](#setstretchbltmode)|Définit le mode bitmap-étirement.|
|[CDC::SetTextAlign](#settextalign)|Définit les drapeaux d’alignement de texte.|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Définit la quantité d’espacement intercharacter.|
|[CDC::SetTextColor](#settextcolor)|Définit la couleur du texte.|
|[CDC::SetTextJustification](#settextjustification)|Ajoute de l’espace aux personnages de rupture dans une chaîne.|
|[CDC::SetViewportExt](#setviewportext)|Définit les x- et y-étendues du viewport.|
|[CDC::SetViewportOrg](#setviewportorg)|Définit l’origine du port de vue.|
|[CDC::SetWindowExt](#setwindowext)|Définit les x- et y-étendues de la fenêtre associée.|
|[CDC::SetWindowOrg](#setwindoworg)|Définit l’origine de la fenêtre du contexte de l’appareil.|
|[CDC::SetWorldTransform](#setworldtransform)|Définit l’espace mondial actuel à la transformation de l’espace de page.|
|[CDC::StartDoc](#startdoc)|Informe le pilote de l’appareil qu’un nouveau travail d’impression commence.|
|[CDC::StartPage](#startpage)|Informe le pilote de l’appareil qu’une nouvelle page démarre.|
|[CDC::StretchBlt](#stretchblt)|Déplace une bitmap à partir d’un rectangle source et d’un appareil dans un rectangle de destination, en étirant ou comprimant la bitmap si nécessaire pour s’adapter aux dimensions du rectangle de destination.|
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Ferme toutes les figures ouvertes sur un chemin, frappe le contour du chemin en utilisant le stylo actuel, et remplit son intérieur en utilisant la brosse actuelle.|
|[CDC::StrokePath](#strokepath)|Rend le chemin spécifié à l’aide du stylo actuel.|
|[CDC::TabbedTextOut](#tabbedtextout)|Écrit une chaîne de caractère à un endroit spécifié, en élargissant les onglets aux valeurs spécifiées dans un tableau de positions d’onglet-arrêt.|
|[CDC::TextOut](#textout)|Écrit une chaîne de caractères à un endroit spécifié à l’aide de la police actuellement sélectionnée.|
|[CDC::TransparentBlt](#transparentblt)|Transfère un bloc de données de couleur du contexte de l’appareil source spécifié dans un contexte de périphérique de destination, rendant une couleur spécifiée transparente dans le transfert.|
|[CDC::Mise à jourColors](#updatecolors)|Mise à jour de la zone cliente du contexte de l’appareil en faisant correspondre les couleurs actuelles de la zone client à la palette du système pixel par pixel.|
|[CDC::WidenPath](#widenpath)|Redéfinit le chemin actuel comme la zone qui serait peinte si le chemin était caressé à l’aide du stylo actuellement sélectionné dans le contexte de l’appareil.|

### <a name="public-operators"></a>Op&#233;rateurs publics

|Nom|Description|
|----------|-----------------|
|[CDC::opérateur HDC](#operator_hdc)|Récupère la poignée du contexte de l’appareil.|

### <a name="public-data-members"></a>Membres de données publics

|Nom|Description|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|Le contexte attribut-dispositif `CDC` utilisé par cet objet.|
|[CDC::m_hDC](#m_hdc)|Le contexte de sortie-dispositif utilisé par cet `CDC` objet.|

## <a name="remarks"></a>Notes

L’objet `CDC` fournit aux membres des fonctions pour travailler avec un contexte d’appareil, comme un écran ou une imprimante, ainsi que des membres pour travailler avec un contexte d’affichage associé à la zone client d’une fenêtre.

Faites tout le dessin à `CDC` travers les fonctions de membre d’un objet. La classe fournit des fonctions de membre pour les opérations de contexte de l’appareil, travaillant avec des outils de dessin, la sélection d’objets d’interface graphique (GDI) sécurisée et le travail avec les couleurs et les palettes. Il fournit également des fonctions de membre pour obtenir et définir des attributs de dessin, cartographier, travailler avec le viewport, travailler avec l’étendue de la fenêtre, convertir les coordonnées, travailler avec les régions, couper, dessiner des lignes, et dessiner des formes simples, des ellipses, et des polygones. Les fonctions des membres sont également prévues pour dessiner du texte, travailler avec des polices, utiliser des évasions d’imprimantes, faire défiler et jouer des métafiles.

Pour utiliser `CDC` un objet, construisez-le, puis appelez ses fonctions membres qui font le parallèle avec windows et qui utilisent des contextes d’appareils.

> [!NOTE]
> Sous Windows 95/98, toutes les coordonnées d’écran sont limitées à 16 bits. Par conséquent, un **int** passé à une `CDC` fonction membre doit se situer dans la gamme -32768 à 32767.

Pour des utilisations spécifiques, la Microsoft `CDC` Foundation Class Library offre plusieurs classes dérivées de . `CPaintDC`encapsule les `BeginPaint` appels `EndPaint`vers et . `CClientDC`gère un contexte d’affichage associé à la zone cliente d’une fenêtre. `CWindowDC`gère un contexte d’affichage associé à une fenêtre entière, y compris son cadre et ses commandes. `CMetaFileDC`associe un contexte d’appareil à un métaafile.

`CDC`fournit deux fonctions de membre, [GetLayout](#getlayout) et [SetLayout](#setlayout), pour inverser la disposition d’un contexte d’appareil, qui n’hérite pas de sa disposition à partir d’une fenêtre. Une telle orientation de droite à gauche est nécessaire pour les applications écrites pour des cultures, telles que l’arabe ou l’hébreu, où la disposition du personnage n’est pas la norme européenne.

`CDC`contient deux contextes [d’appareils, m_hDC](#m_hdc) et [m_hAttribDC](#m_hattribdc), `CDC` qui, lors de la création d’un objet, se réfèrent au même appareil. `CDC`dirige tous les appels `m_hDC` de sortie GDI `m_hAttribDC`vers et la plupart attribuent les appels GDI à . (Un exemple d’appel `GetTextColor`d’attribut est, tandis qu’est `SetTextColor` un appel de sortie.)

Par exemple, le cadre utilise ces deux `CMetaFileDC` contextes d’appareils pour implémenter un objet qui enverra la sortie à un métaafile tout en lisant les attributs à partir d’un appareil physique. L’aperçu d’impression est mis en œuvre dans le cadre de la même manière. Vous pouvez également utiliser les deux contextes d’appareils de la même manière dans votre code spécifique à l’application.

Il y a des moments où vous `m_hDC` `m_hAttribDC` pouvez avoir besoin d’informations textuelles à partir des contextes et des paramètres de l’appareil. Les paires de fonctions suivantes fournissent cette capacité :

|Utilise m_hAttribDC|Utilise m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics (en)](#gettextmetrics)|[GetOutputTextMetrics (en)](#getoutputtextmetrics)|
|[ObtenezCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

Pour plus `CDC`d’informations sur , voir [Contextes périphériques](../../mfc/device-contexts.md).

## <a name="inheritance-hierarchy"></a>Hiérarchie d'héritage

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Spécifications

**En-tête :** afxwin.h

## <a name="cdcabortdoc"></a><a name="abortdoc"></a>CDC::AbortDoc

Termine le travail d’impression actuel et efface tout ce que l’application a écrit à l’appareil depuis le dernier appel à la fonction membre [StartDoc.](#startdoc)

```
int AbortDoc();
```

### <a name="return-value"></a>Valeur de retour

Une valeur supérieure ou égale à 0 en cas de succès, ou une valeur négative si une erreur s’est produite. La liste suivante montre les valeurs d’erreur communes et leurs significations :

- SP_ERROR erreur générale.

- SP_OUTOFDISK Pas assez d’espace de disque est actuellement disponible pour le covoiturage, et plus d’espace ne sera disponible.

- SP_OUTOFMEMORY Pas assez de mémoire est disponible pour le covoiturage.

- SP_USERABORT’utilisateur a mis fin à son travail par l’intermédiaire du gestionnaire d’impression.

### <a name="remarks"></a>Notes

Cette fonction de membre remplace l’échappement de l’imprimante ABORTDOC.

`AbortDoc`devrait être utilisé pour mettre fin à ce qui suit :

- Opérations d’impression qui ne spécifient pas une fonction d’interruption à l’aide [de SetAbortProc](#setabortproc).

- Opérations d’impression qui n’ont pas encore atteint leur premier appel d’évasion NEWFRAME ou NEXTBAND.

Si une application rencontre une erreur d’impression ou une opération d’impression annulée, `AbortDoc` elle ne doit `CDC`pas tenter de mettre fin à l’opération en utilisant les fonctions [EndDoc](#enddoc) ou membres de la classe . GDI met automatiquement fin à l’opération avant de retourner la valeur d’erreur.

Si l’application affiche une boîte de dialogue pour permettre à `AbortDoc` l’utilisateur d’annuler l’opération d’impression, elle doit appeler avant de détruire la boîte de dialogue.

Si Print Manager a été utilisé `AbortDoc` pour commencer le travail d’impression, l’appel efface l’ensemble du travail de bobine - l’imprimante ne reçoit rien. Si Print Manager n’a pas été utilisé pour commencer le `AbortDoc` travail d’impression, les données peuvent avoir été envoyées à l’imprimante avant a été appelé. Dans ce cas, le pilote de l’imprimante aurait réinitialisé l’imprimante (si possible) et fermé le travail d’impression.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CDC::StartDoc](#startdoc).

## <a name="cdcabortpath"></a><a name="abortpath"></a>CDC::AbortPath

Ferme et écarte les chemins dans le contexte de l’appareil.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

S’il y a un support de voie ouvert dans le contexte de l’appareil, le support de chemin est fermé et le chemin est jeté. S’il y a un chemin fermé dans le contexte de l’appareil, le chemin est écarté.

## <a name="cdcaddmetafilecomment"></a><a name="addmetafilecomment"></a>CDC::AddMetaFileComment

Copie le commentaire d’un tampon en un métaafile amélioré spécifié.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Paramètres

*nDataSize (en)*<br/>
Spécifie la longueur du tampon de commentaire, dans les octets.

*pCommentData (en)*<br/>
Points à la mémoire tampon qui contient le commentaire.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Un commentaire peut inclure toute information privée — par exemple, la source de l’image et la date à laquelle elle a été créée. Un commentaire doit commencer par une signature d’application, suivie des données. Les commentaires ne doivent pas contenir de données spécifiques à la position. Les données spécifiques à la position spécifient l’emplacement d’un enregistrement, et elles ne doivent pas être incluses parce qu’un metafile peut être intégré dans un autre metafile. Cette fonction ne peut être utilisée qu’avec des métafiles améliorées.

## <a name="cdcalphablend"></a><a name="alphablend"></a>CDC::AlphaBlend

Appelez cette fonction de membre pour afficher des bitmaps qui ont des pixels transparents ou semi-transparents.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Paramètres

*xDest*<br/>
Spécifie le x-coordonner, dans les unités logiques, du coin supérieur gauche du rectangle de destination.

*yDest*<br/>
Spécifie le y-coordinate, dans les unités logiques, du coin supérieur gauche du rectangle de destination.

*nDestWidth (en)*<br/>
Spécifie la largeur, en unités logiques, du rectangle de destination.

*nDestHeight*<br/>
Spécifie la hauteur, en unités logiques, du rectangle de destination.

*pSrcDC (en)*<br/>
Un pointeur sur le contexte de l’appareil source.

*xSrc (en)*<br/>
Spécifie le x-coordonner, dans les unités logiques, du coin supérieur gauche du rectangle source.

*ySrc (en)*<br/>
Spécifie le y-coordinate, dans les unités logiques, du coin supérieur gauche du rectangle source.

*nSrcWidth (en)*<br/>
Spécifie la largeur, en unités logiques, du rectangle source.

*nSrcHeight (en)*<br/>
Spécifie la hauteur, en unités logiques, du rectangle source.

*Mélange*<br/>
Spécifie une structure [BLENDFUNCTION.](/windows/win32/api/wingdi/ns-wingdi-blendfunction)

### <a name="return-value"></a>Valeur de retour

TRUE en cas de réussite, sinon FALSE.

### <a name="remarks"></a>Notes

Voir [AlphaBlend](/windows/win32/api/wingdi/nf-wingdi-alphablend) dans le Windows SDK pour plus d’informations.

## <a name="cdcanglearc"></a><a name="anglearc"></a>CDC::AngleArc

Dessine un segment de ligne et un arc.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordonner logique du centre du cercle.

*y*<br/>
Spécifie la logique y-coordinate du centre du cercle.

*nRadius (nRadius)*<br/>
Spécifie le rayon du cercle en unités logiques. Cette valeur doit être positive.

*fStartAngle (en)*<br/>
Spécifie l’angle de départ en degrés par rapport à l’axe x.

*fSweepAngle*<br/>
Spécifie l’angle de balayage en degrés par rapport à l’angle de départ.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Le segment de ligne est tiré de la position actuelle au début de l’arc. L’arc est dessiné le long du périmètre d’un cercle avec le rayon donné et le centre. La longueur de l’arc est définie par les angles de démarrage et de balayage donnés.

`AngleArc`déplace la position actuelle jusqu’au point de fin de l’arc. L’arc dessiné par cette fonction peut sembler elliptique, selon le mode de transformation et de cartographie actuel. Avant de dessiner l’arc, cette fonction trace le segment de ligne de la position actuelle au début de l’arc. L’arc est dessiné en construisant un cercle imaginaire avec le rayon spécifié autour du point central spécifié. Le point de départ de l’arc est déterminé en mesurant dans le sens inverse des aiguilles d’une montre à partir de l’axe x du cercle par le nombre de degrés dans l’angle de départ. Le point de fin est également situé en mesurant dans le sens inverse des aiguilles d’une montre à partir du point de départ par le nombre de degrés dans l’angle de balayage.

Si l’angle de balayage est supérieur à 360 degrés, l’arc est balayé plusieurs fois. Cette fonction dessine des lignes à l’aide du stylo actuel. Le chiffre n’est pas rempli.

## <a name="cdcarc"></a><a name="arc"></a>CDC::Arc

Dessine un arc elliptique.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la x-coordonnées du coin supérieur gauche du rectangle de délimitation (dans les unités logiques).

*y1 (en)*<br/>
Spécifie la y-coordonnées du coin supérieur gauche du rectangle de délimitation (dans les unités logiques).

*x2*<br/>
Spécifie la x-coordonnées du coin inférieur droit du rectangle de délimitation (en unités logiques).

*y2*<br/>
Spécifie la y-coordonnées du coin inférieur droit du rectangle de délimitation (en unités logiques).

*x3*<br/>
Spécifie la x-coordonner le point qui définit le point de départ de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc.

*y3 (en)*<br/>
Spécifie la y-coordonner le point qui définit le point de départ de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc.

*x4*<br/>
Spécifie la x-coordonner le point qui définit le point de terminaison de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc.

*y4*<br/>
Spécifie la y-coordonner le point qui définit le point de terminaison de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc.

*lpRect*<br/>
Spécifie le rectangle de délimitation (en unités logiques). Vous pouvez passer un LPRECT ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

*ptStart (en)*<br/>
Spécifie les coordonnées x et y du point qui définit le point de départ de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc. Vous pouvez passer une structure [POINT](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) pour ce paramètre.

*ptEnd*<br/>
Spécifie les coordonnées x et y du point qui définit le point de fin de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc. Vous pouvez passer `POINT` une structure `CPoint` ou un objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

L’arc dessiné à l’aide de la fonction est un segment de l’ellipse défini par le rectangle de délimitation spécifié.

Le point de départ réel de l’arc est le point où un rayon tiré du centre du rectangle de délimitation à travers le point de départ spécifié croise l’ellipse. Le point de fin réel de l’arc est le point où un rayon tiré du centre du rectangle de délimitation à travers le point de fin spécifié croise l’ellipse. L’arc est dessiné dans le sens inverse des aiguilles d’une montre. Comme un arc n’est pas un chiffre fermé, il n’est pas rempli. La largeur et la hauteur du rectangle doivent être supérieures à 2 unités et moins de 32 767 unités.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

## <a name="cdcarcto"></a><a name="arcto"></a>CDC::ArcTo

Dessine un arc elliptique.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la x-coordonnées du coin supérieur gauche du rectangle de délimitation (dans les unités logiques).

*y1 (en)*<br/>
Spécifie la y-coordonnées du coin supérieur gauche du rectangle de délimitation (dans les unités logiques).

*x2*<br/>
Spécifie la x-coordonnées du coin inférieur droit du rectangle de délimitation (en unités logiques).

*y2*<br/>
Spécifie la y-coordonnées du coin inférieur droit du rectangle de délimitation (en unités logiques).

*x3*<br/>
Spécifie la x-coordonner le point qui définit le point de départ de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc.

*y3 (en)*<br/>
Spécifie la y-coordonner le point qui définit le point de départ de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc.

*x4*<br/>
Spécifie la x-coordonner le point qui définit le point de terminaison de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc.

*y4*<br/>
Spécifie la y-coordonner le point qui définit le point de terminaison de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc.

*lpRect*<br/>
Spécifie le rectangle de délimitation (en unités logiques). Vous pouvez passer soit un pointeur à une structure de données [RECT](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

*ptStart (en)*<br/>
Spécifie les coordonnées x et y du point qui définit le point de départ de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc. Vous pouvez passer une structure de données [POINT](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) pour ce paramètre.

*ptEnd*<br/>
Spécifie les coordonnées x et y du point qui définit le point de fin de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc. Vous pouvez passer `POINT` une structure `CPoint` de données ou un objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction est `CDC::Arc`similaire à , sauf que la position actuelle est mise à jour. Les points ( *x1*, *y1*) et ( *x2*, *y2*) spécifient le rectangle de délimitation. Une ellipse formée par le rectangle de délimitation donné définit la courbe de l’arc. L’arc s’étend dans le sens inverse des aiguilles d’une montre (la direction de l’arc par défaut) à partir du point où il croise la ligne radiale du centre du rectangle de délimitation à ( *x3*, *y3*). L’arc se termine là où il croise la ligne radiale du centre du rectangle de délimitation à ( *x4*, *y4*). Si le point de départ et le point de fin sont les mêmes, une ellipse complète est tirée.

Une ligne est tracée de la position actuelle au point de départ de l’arc. En cas d’erreur, la position actuelle est réglée au point de fin de l’arc. L’arc est dessiné à l’aide du stylo actuel; il n’est pas rempli.

## <a name="cdcattach"></a><a name="attach"></a>CDC::Attach

Utilisez cette fonction de membre pour `CDC` attacher un *HDC* à l’objet.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Paramètres

*Hdc*<br/>
Un contexte d’appareil Windows.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le *hDC* est `m_hDC`stocké à la fois, `m_hAttribDC`le contexte du périphérique de sortie, et dans , le contexte de l’appareil d’attribut.

## <a name="cdcbeginpath"></a><a name="beginpath"></a>CDC::BeginPath

Ouvre un support de chemin dans le contexte de l’appareil.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Une fois qu’un support de chemin est ouvert, une application peut commencer à appeler les fonctions de dessin GDI pour définir les points qui se trouvent dans le chemin. Une application peut fermer un support `EndPath` de voie ouvert en appelant la fonction membre. Lorsqu’une `BeginPath`application appelle, les chemins précédents sont jetés.

Voir [BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath) dans le SDK Windows pour une liste des fonctions de dessin qui définissent les points dans un chemin.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

## <a name="cdcbitblt"></a><a name="bitblt"></a>CDC::BitBlt

Copies d’un bitmap du contexte de l’appareil source à ce contexte actuel de l’appareil.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la logique x-coordonner le coin supérieur gauche du rectangle de destination.

*y*<br/>
Spécifie la logique y-coordinate du coin supérieur gauche du rectangle de destination.

*nWidth (en)*<br/>
Spécifie la largeur (en unités logiques) du rectangle de destination et de la bitmap source.

*nHeight (en)*<br/>
Spécifie la hauteur (en unités logiques) du rectangle de destination et de la bitmap source.

*pSrcDC (en)*<br/>
Pointeur `CDC` vers un objet qui identifie le contexte de l’appareil à partir duquel la bitmap sera copiée. Il doit être NULL si *dwRop* spécifie une opération de raster qui n’inclut pas une source.

*xSrc (en)*<br/>
Spécifie la logique x-coordonner le coin supérieur gauche de la bitmap source.

*ySrc (en)*<br/>
Specifie la logique y-coordinate du coin supérieur gauche de la bitmap source.

*dwRop*<br/>
Spécifie l'opération de rastérisation à effectuer. Les codes raster-opération définissent comment le GDI combine des couleurs dans les opérations de sortie qui impliquent un pinceau actuel, une source possible de bitmap, et une bitmap de destination. Voir [BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt) dans le Windows SDK pour une liste des codes d’exploitation raster pour *dwRop* et leurs descriptions

Pour une liste complète des codes d’exploitation raster, voir [à propos des codes d’opération Raster](/windows/win32/gdi/raster-operation-codes) dans le SDK Windows.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

L’application peut aligner les fenêtres ou les zones `BitBlt` clientes sur les limites des byte pour s’assurer que les opérations se produisent sur des rectangles alignés sur les parois. (Réglez les CS_BYTEALIGNWINDOW ou CS_BYTEALIGNCLIENT des drapeaux lorsque vous enregistrez les classes de fenêtre.)

`BitBlt`les opérations sur les rectangles alignés `BitBlt` sur les fourre-tout sont considérablement plus rapides que les opérations sur des rectangles qui ne sont pas alignés par les audaux. Si vous souhaitez spécifier des styles de classe tels que l’alignement des bytes pour le contexte de votre propre appareil, vous devrez enregistrer une classe de fenêtre plutôt que de compter sur les classes microsoft Foundation pour le faire pour vous. Utilisez la fonction globale [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

GDI transforme *nWidth* et *nHeight*, une fois en utilisant le contexte de l’appareil de destination, et une fois en utilisant le contexte de l’appareil source. Si les étendues qui en résultent `StretchBlt` ne correspondent pas, GDI utilise la fonction Windows pour comprimer ou étirer la bitmap source au besoin.

Si les bitmaps de destination, de source et `BitBlt` de modèle n’ont pas le même format de couleur, la fonction convertit les bitmaps de source et de modèle pour correspondre à la destination. Les couleurs de premier plan et de fond de la bitmap de destination sont utilisées dans la conversion.

Lorsque `BitBlt` la fonction convertit une bitmap monochrome en couleur, elle met les morceaux blancs (1) à la couleur de fond et les morceaux noirs (0) à la couleur du premier plan. Les couleurs de premier plan et de fond du contexte de l’appareil de destination sont utilisées. Pour convertir la couleur `BitBlt` en monochrome, définit des pixels qui correspondent à la couleur de fond en blanc et définit tous les autres pixels en noir. `BitBlt`utilise les couleurs de premier plan et de fond du contexte de l’appareil de couleur pour convertir de la couleur au monochrome.

Notez que tous les `BitBlt`contextes d’appareils ne prennent pas en charge . Pour vérifier si le contexte `BitBlt`d’un appareil donné prend en charge, utilisez la `GetDeviceCaps` fonction membre et spécifiez l’index RASTERCAPS.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CDC::CreateCompatibleDC](#createcompatibledc).

## <a name="cdccdc"></a><a name="cdc"></a>CDC::CDC

Construit un objet `CDC`.

```
CDC();
```

## <a name="cdcchord"></a><a name="chord"></a>CDC::Chord

Dessine un accord (une figure fermée délimitée par l’intersection d’une ellipse et d’un segment de ligne).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la x-coordonnées du coin supérieur gauche du rectangle de délimitation de l’accord (en unités logiques).

*y1 (en)*<br/>
Spécifie la y-coordonnées du coin supérieur gauche du rectangle de délimitation de l’accord (en unités logiques).

*x2*<br/>
Spécifie la x-coordonnées du coin inférieur droit du rectangle de délimitation de l’accord (en unités logiques).

*y2*<br/>
Spécifie la y-coordonnées du coin inférieur droit du rectangle de délimitation de l’accord (en unités logiques).

*x3*<br/>
Spécifie la x-coordonner le point qui définit le point de départ de l’accord (dans les unités logiques).

*y3 (en)*<br/>
Spécifie la y-coordonner le point qui définit le point de départ de l’accord (dans les unités logiques).

*x4*<br/>
Spécifie la x-coordonner le point qui définit le point de terminaison de l’accord (en unités logiques).

*y4*<br/>
Spécifie la y-coordinate du point qui définit le point de terminaison de l’accord (dans les unités logiques).

*lpRect*<br/>
Spécifie le rectangle de délimitation (en unités logiques). Vous pouvez passer un LPRECT ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

*ptStart (en)*<br/>
Spécifie les coordonnées x et y du point qui définit le point de départ de l’accord (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’accord. Vous pouvez passer `POINT` une structure `CPoint` ou un objet pour ce paramètre.

*ptEnd*<br/>
Spécifie les coordonnées x et y du point qui définit le point de fin de l’accord (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’accord. Vous pouvez passer une structure [POINT](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Les paramètres ( *x1*, *y1*) et ( *x2*, *y2*) spécifient les coins supérieurs gauche et inférieur-droit, respectivement, d’un rectangle délimitant l’ellipse qui fait partie de l’accord. Les paramètres ( *x3*, *y3*) et ( *x4*, *y4*) spécifient les paramètres d’une ligne qui croise l’ellipse. L’accord est dessiné à l’aide du stylo sélectionné et rempli à l’aide de la brosse sélectionnée.

La figure dessinée `Chord` par la fonction s’étend jusqu’à, mais n’inclut pas les coordonnées droites et inférieures. Cela signifie que la hauteur de la figure est *y2* - *y1* et la largeur de la figure est *x2* - *x1*.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

## <a name="cdcclosefigure"></a><a name="closefigure"></a>CDC::CloseFigure

Ferme une figure ouverte sur un chemin.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

La fonction ferme la figure en dessinant une ligne de la position actuelle au premier point de `MoveTo` la figure (généralement, le point spécifié par l’appel le plus récent à la fonction membre) et relie les lignes en utilisant le style de jointure de ligne. Si un chiffre est `LineTo` fermé en `CloseFigure`utilisant la fonction membre au lieu de , bouchons d’extrémité sont utilisés pour créer le coin au lieu d’une jointure. `CloseFigure`ne doit être appelé que s’il y a un support de voie ouvert dans le contexte de l’appareil.

Une figure dans un chemin est ouverte à moins qu’elle ne soit explicitement fermée en utilisant cette fonction. (Un chiffre peut être ouvert même si le point actuel et le point de départ du chiffre sont les mêmes.) Toute ligne ou courbe ajoutée `CloseFigure` au chemin après commence une nouvelle figure.

## <a name="cdccreatecompatibledc"></a><a name="createcompatibledc"></a>CDC::CréerCompatibleDC

Crée un contexte de dispositif de mémoire compatible avec l’appareil spécifié par *pDC*.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Paramètres

*pDC*<br/>
Pointeur vers un contexte de périphérique. Si *pDC* est NULL, la fonction crée un contexte de dispositif de mémoire compatible avec l’affichage du système.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Un contexte de dispositif de mémoire est un bloc de mémoire qui représente une surface d’affichage. Il peut être utilisé pour préparer des images en mémoire avant de les copier à la surface réelle de l’appareil compatible.

Lorsqu’un contexte de dispositif de mémoire est créé, GDI sélectionne automatiquement un bitmap de stock monochrome de 1 par 1 pour elle. Les fonctions de sortie GDI ne peuvent être utilisées avec un contexte de dispositif de mémoire que si un bitmap a été créé et sélectionné dans ce contexte.

Cette fonction ne peut être utilisée que pour créer des contextes d’appareils compatibles pour les appareils qui prennent en charge les opérations de raster. Voir le [CDC::BitBlt](#bitblt) fonction membre pour les informations concernant les transferts bit-bloc entre les contextes de périphérique. Pour déterminer si le contexte d’un appareil prend en charge les `CDC::GetDeviceCaps`opérations de raster, consultez la capacité de raster RC_BITBLT dans la fonction membre .

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

## <a name="cdccreatedc"></a><a name="createdc"></a>CDC::CreateDC

Crée un contexte d’appareil pour l’appareil spécifié.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Paramètres

*lpszDriverName (en)*<br/>
Indique une chaîne non ajustée qui spécifie le nom de fichier (sans extension) du pilote de l’appareil (par exemple, "EPSON"). Vous pouvez également `CString` passer un objet pour ce paramètre.

*lpszDeviceName*<br/>
Indique une chaîne non ajustée qui précise le nom de l’appareil spécifique à prendre en charge (par exemple, "EPSON FX-80"). Le *paramètre lpszDeviceName* est utilisé si le module prend en charge plus d’un appareil. Vous pouvez également `CString` passer un objet pour ce paramètre.

*lpszOutput*<br/>
Indique une chaîne non résiliée qui spécifie le nom du fichier ou de l’appareil pour le support de sortie physique (fichier ou port de sortie). Vous pouvez également `CString` passer un objet pour ce paramètre.

*lpInitData*<br/>
Indique une `DEVMODE` structure contenant des données d’initialisation spécifiques à l’appareil pour le conducteur de l’appareil. La `DocumentProperties` fonction Windows récupère cette structure remplie pour un appareil donné. Le *paramètre lpInitData* doit être NULL si le pilote de l’appareil doit utiliser l’initialisation par défaut (le cas échéant) spécifiée par l’utilisateur via le panneau de contrôle.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

L’PRINT. Le fichier d’en-tête H est nécessaire si la structure [DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea) est utilisée.

Les noms des appareils suivent ces conventions : un côlon de fin (:) est recommandé, mais facultatif. Windows bandes du côlon de fin de sorte qu’un nom d’appareil se terminant par un côlon est cartographié au même port que le même nom sans un côlon. Les noms du conducteur et du port ne doivent pas contenir d’espaces de tête ou de fuite. Les fonctions de sortie GDI ne peuvent pas être utilisées dans les contextes d’information.

## <a name="cdccreateic"></a><a name="createic"></a>CDC::CreateIC

Crée un contexte d’information pour l’appareil spécifié.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Paramètres

*lpszDriverName (en)*<br/>
Indique une chaîne non ajustée qui spécifie le nom de fichier (sans extension) du pilote de l’appareil (par exemple, "EPSON"). Vous pouvez passer `CString` un objet pour ce paramètre.

*lpszDeviceName*<br/>
Indique une chaîne non ajustée qui précise le nom de l’appareil spécifique à prendre en charge (par exemple, "EPSON FX-80"). Le *paramètre lpszDeviceName* est utilisé si le module prend en charge plus d’un appareil. Vous pouvez passer `CString` un objet pour ce paramètre.

*lpszOutput*<br/>
Indique une chaîne non résiliée qui spécifie le nom du fichier ou de l’appareil pour le support de sortie physique (fichier ou port). Vous pouvez passer `CString` un objet pour ce paramètre.

*lpInitData*<br/>
Points à des données d’initialisation spécifiques à l’appareil pour le pilote de l’appareil. Le *paramètre lpInitData* doit être NULL si le pilote de l’appareil doit utiliser l’initialisation par défaut (le cas échéant) spécifiée par l’utilisateur via le panneau de contrôle. Voir `CreateDC` le format de données pour une initialisation spécifique à l’appareil.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Le contexte de l’information fournit un moyen rapide d’obtenir des informations sur l’appareil sans créer un contexte d’appareil.

Les noms des appareils suivent ces conventions : un côlon de fin (:) est recommandé, mais facultatif. Windows bandes du côlon de fin de sorte qu’un nom d’appareil se terminant par un côlon est cartographié au même port que le même nom sans un côlon. Les noms du conducteur et du port ne doivent pas contenir d’espaces de tête ou de fuite. Les fonctions de sortie GDI ne peuvent pas être utilisées dans les contextes d’information.

## <a name="cdcdeletedc"></a><a name="deletedc"></a>CDC::DeleteDC

En général, n’appelez pas cette fonction; le destructeur le fera pour vous.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Valeur de retour

Nonzero si la fonction terminée avec succès; sinon 0.

### <a name="remarks"></a>Notes

La `DeleteDC` fonction membre supprime les contextes de `m_hDC` périphérique `CDC` Windows qui sont associés dans l’objet actuel. Si `CDC` cet objet est le dernier contexte d’appareil actif pour un appareil donné, l’appareil est notifié et toutes les ressources de stockage et de système utilisées par l’appareil sont libérées.

Une application ne `DeleteDC` doit pas appeler si des objets ont été sélectionnés dans le contexte de l’appareil. Les objets doivent d’abord être sélectionnés dans le contexte de l’appareil avant d’être supprimés.

Une application ne doit pas supprimer un contexte de périphérique dont la poignée a été obtenue en appelant [CWnd::GetDC](../../mfc/reference/cwnd-class.md#getdc). Au lieu de cela, il doit appeler [CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) pour libérer le contexte de l’appareil. Les classes [CClientDC](../../mfc/reference/cclientdc-class.md) et [CWindowDC](../../mfc/reference/cwindowdc-class.md) sont fournies pour enrouler cette fonctionnalité.

La `DeleteDC` fonction est généralement utilisée pour supprimer les contextes de périphériques créés avec [CreateDC](#createdc), [CreateIC](#createic), ou [CreateCompatibleDC](#createcompatibledc).

### <a name="example"></a>Exemple

  Voir l’exemple pour [CPrintDialog:GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcdeletetempmap"></a><a name="deletetempmap"></a>CDC::DeleteTempMap

Appelé automatiquement `CWinApp` par le gestionnaire `DeleteTempMap` de temps `CDC` d’arrêt, supprime tous les objets temporaires créés par `FromHandle`, mais ne détruit pas les poignées de contexte de l’appareil (s) `hDC`temporairement associés aux `CDC` objets.

```
static void PASCAL DeleteTempMap();
```

## <a name="cdcdetach"></a><a name="detach"></a>CDC::Detach

Appelez cette fonction `m_hDC` pour détacher (le `CDC` contexte du `m_hDC` périphérique `m_hAttribDC` de sortie) de l’objet et définissez à la fois et à NULL.

```
HDC Detach();
```

### <a name="return-value"></a>Valeur de retour

Un contexte d’appareil Windows.

## <a name="cdcdptohimetric"></a><a name="dptohimetric"></a>CDC::DPtoHIMETRIC

Utilisez cette fonction lorsque vous donnez des tailles HIMETRIC à OLE, en convertissant les pixels en HIMETRIC.

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*lpSize*<br/>
Indique une structure [SIZE](/windows/win32/api/windef/ns-windef-size) ou un objet [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Notes

Si le mode de cartographie de l’objet contextuelle de l’appareil est MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC ou MM_HIMETRIC, la conversion est basée sur le nombre de pixels dans le pouce physique. Si le mode de cartographie est l’un des autres modes non contraints (par exemple, MM_TEXT), la conversion est basée sur le nombre de pixels dans le pouce logique.

## <a name="cdcdptolp"></a><a name="dptolp"></a>CDC::DPtoLP

Convertit les unités de périphériques en unités logiques.

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*lpPoints (en)*<br/>
Points à une gamme de structures [POINT](/windows/win32/api/windef/ns-windef-point) ou d’objets [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*nCompte*<br/>
Le nombre de points dans le tableau.

*lpRect*<br/>
Indique une structure [RECT](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect.](../../atl-mfc-shared/reference/crect-class.md) Ce paramètre est utilisé pour le cas simple de convertir un rectangle à partir de points d’appareil en points logiques.

*lpSize*<br/>
Indique une structure [SIZE](/windows/win32/api/windef/ns-windef-size) ou un objet [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Notes

La fonction cartographie les coordonnées de chaque point, ou dimension d’une taille, du système de coordonnées de l’appareil dans le système de coordonnées logiques de GDI. La conversion dépend du mode de cartographie actuel et des paramètres des origines et des étendues de la fenêtre et du viewport de l’appareil.

## <a name="cdcdraw3drect"></a><a name="draw3drect"></a>CDC::Draw3dRect

Appelez cette fonction de membre pour dessiner un rectangle tridimensionnel.

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Spécifie le rectangle de délimitation (en unités logiques). Vous pouvez passer soit un pointeur à une structure [RECT](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

*clrTopLeft*<br/>
Spécifie la couleur du dessus et des côtés gauches du rectangle tridimensionnel.

*clrBottomRight*<br/>
Spécifie la couleur du côté inférieur et droit du rectangle tridimensionnel.

*x*<br/>
Spécifie la logique x-coordonner le coin supérieur gauche du rectangle tridimensionnel.

*y*<br/>
Spécifie la logique y-coordinate du coin supérieur gauche du rectangle tridimensionnel.

*Cx*<br/>
Spécifie la largeur du rectangle tridimensionnel.

*Cy*<br/>
Spécifie la hauteur du rectangle tridimensionnel.

### <a name="remarks"></a>Notes

Le rectangle sera dessiné avec les côtés supérieurs et gauches dans la couleur spécifiée par *clrTopLeft* et les côtés inférieurs et droit dans la couleur spécifiée par *clrBottomRight*.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

## <a name="cdcdrawdragrect"></a><a name="drawdragrect"></a>CDC::DrawDragRect

Appelez cette fonction de membre à plusieurs reprises pour redessiner un rectangle de traînée.

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Indique une structure [RECT](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui spécifie les coordonnées logiques d’un rectangle — dans ce cas, la position de fin du rectangle étant redessiné.

*Taille*<br/>
Spécifie le déplacement du coin supérieur gauche de la frontière extérieure jusqu’au coin supérieur gauche de la bordure intérieure (c’est-à-dire l’épaisseur de la bordure) d’un rectangle.

*lpRectLast*<br/>
Indique une structure [RECT](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui spécifie les coordonnées logiques de la position d’un rectangle — dans ce cas, la position originale du rectangle étant redessiné.

*tailleLast*<br/>
Spécifie le déplacement du coin supérieur gauche de la frontière extérieure jusqu’au coin supérieur gauche de la bordure intérieure (c’est-à-dire l’épaisseur de la bordure) du rectangle d’origine redessiné.

*pBrush*<br/>
Pointeur vers un objet de pinceau. Réglez-le à NULL pour utiliser la brosse à demi-teinte par défaut.

*pBrushLast*<br/>
Pointeur vers le dernier objet de brosse utilisé. Réglez-le à NULL pour utiliser la brosse à demi-teinte par défaut.

### <a name="remarks"></a>Notes

Appelez-le en boucle lorsque vous échantillonnez la position de la souris, afin de donner une rétroaction visuelle. Lorsque vous `DrawDragRect`appelez, le rectangle précédent est effacé et un nouveau est dessiné. Par exemple, lorsque l’utilisateur traîne un `DrawDragRect` rectangle à travers l’écran, effacera le rectangle d’origine et en redessinera un nouveau dans sa nouvelle position. Par défaut, `DrawDragRect` dessine le rectangle à l’aide d’un pinceau demi-ton pour éliminer le scintillement et pour créer l’apparence d’un rectangle en douceur en mouvement.

La première fois `DrawDragRect`que vous appelez, le *paramètre lpRectLast* devrait être NULL.

## <a name="cdcdrawedge"></a><a name="drawedge"></a>CDC::DrawEdge

Appelez cette fonction de membre pour dessiner les bords d’un rectangle du type et du style spécifiés.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Pointeur d’une `RECT` structure qui contient les coordonnées logiques du rectangle.

*nEdge (en)*<br/>
Spécifie le type de bord intérieur et extérieur à dessiner. Ce paramètre doit être une combinaison d’un drapeau frontalier interne et d’un drapeau frontalier extérieur. Voir [DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) dans le Windows SDK pour une table des types de paramètres.

*nFlags*<br/>
Les drapeaux qui spécifient le type de bordure à tracer. Voir `DrawEdge` dans le SDK Windows pour un tableau des valeurs du paramètre. Pour les lignes diagonales, les BF_RECT drapeaux spécifient le point final du vecteur délimité par le paramètre du rectangle.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

## <a name="cdcdrawescape"></a><a name="drawescape"></a>CDC::DrawEscape

Accès aux capacités de dessin d’un écran vidéo qui ne sont pas directement disponibles via l’interface de périphérique graphique (GDI).

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Paramètres

*nEscape (en anglais)*<br/>
Spécifie la fonction d’évasion à effectuer.

*nInputSize*<br/>
Spécifie le nombre d’octets de données indiqués par le paramètre *lpszInputData.*

*lpszInputData*<br/>
Indique la structure d’entrée requise pour l’évasion spécifiée.

### <a name="return-value"></a>Valeur de retour

Spécifie le résultat de la fonction. Plus de zéro en cas de succès, à l’exception de l’évasion de tirage QUERYESCSUPPORT, qui vérifie seulement la mise en œuvre; ou zéro si l’évasion n’est pas mise en œuvre; ou moins de zéro en cas d’erreur.

### <a name="remarks"></a>Notes

Lorsqu’une `DrawEscape`application appelle, les données identifiées par *nInputSize* et *lpszInputData* sont transmises directement au pilote d’affichage spécifié.

## <a name="cdcdrawfocusrect"></a><a name="drawfocusrect"></a>CDC::DrawFocusRect

Dessine un rectangle dans le style utilisé pour indiquer que le rectangle a la mise au point.

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Indique une structure [RECT](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui spécifie les coordonnées logiques du rectangle à dessiner.

### <a name="remarks"></a>Notes

Puisqu’il s’agit d’une fonction Boolean XOR, l’appel de cette fonction une deuxième fois avec le même rectangle enlève le rectangle de l’écran. Le rectangle dessiné par cette fonction ne peut pas être défilé. Pour faire défiler une zone contenant un `DrawFocusRect` rectangle dessiné par cette fonction, appelez d’abord pour enlever le rectangle de l’écran, puis faites défiler la zone, puis appelez `DrawFocusRect` à nouveau pour dessiner le rectangle dans la nouvelle position.

> [!CAUTION]
> `DrawFocusRect`ne fonctionne qu’en mode MM_TEXT. Dans d’autres modes, cette fonction ne tire pas correctement le rectangle de mise au point, mais elle ne renvoie pas les valeurs d’erreur.

## <a name="cdcdrawframecontrol"></a><a name="drawframecontrol"></a>CDC::DrawFrameControl

Appelez cette fonction de membre pour dessiner un contrôle de cadre du type et du style spécifiés.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Pointeur d’une `RECT` structure qui contient les coordonnées logiques du rectangle.

*nType*<br/>
Spécifie le type de contrôle du cadre à dessiner. Voir le *paramètre uType* dans [DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol) dans le SDK Windows pour une liste des valeurs possibles de ce paramètre.

*nState (États-Unis)*<br/>
Spécifie l’état initial du contrôle du cadre. Peut être une ou plusieurs des valeurs décrites pour le paramètre *uState* dans `DrawFrameControl` le SDK Windows. Utilisez la valeur *nState* DFCS_ADJUSTRECT pour ajuster le rectangle de délimitation pour exclure le bord environnant du bouton poussoir.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Dans plusieurs cas, *nState* dépend du *paramètre nType.* La liste suivante montre la relation entre les quatre valeurs *nType* et *nState*:

- DFC_BUTTON

  - DFCS_BUTTON3STATE bouton à trois états

  - boîte à DFCS_BUTTONCHECK de cocher

  - bouton DFCS_BUTTONPUSH Push

  - bouton radio DFCS_BUTTONRADIO

  - DFCS_BUTTONRADIOIMAGE Image pour bouton radio (nonsquare a besoin d’image)

  - masque DFCS_BUTTONRADIOMASK pour bouton radio (nonsquare a besoin de masque)

- DFC_CAPTION

  - bouton DFCS_CAPTIONCLOSE Fermer

  - bouton d’aide DFCS_CAPTIONHELP

  - DFCS_CAPTIONMAX Maximiser le bouton

  - DFCS_CAPTIONMIN Minimiser le bouton

  - DFCS_CAPTIONRESTORE Restaurer le bouton

- DFC_MENU

  - DFCS_MENUARROW flèche Submenu

  - DFCS_MENUBULLET Bullet

  - DFCS_MENUCHECK Vérifier la marque

- DFC_SCROLL

  - barre de défilement de boîte de DFCS_SCROLLCOMBOBOX Combo

  - DFCS_SCROLLDOWN Flèche vers le bas de la barre de défilement

  - DFCS_SCROLLLEFT flèche gauche de la barre de défilement

  - DFCS_SCROLLRIGHT flèche droite de la barre de défilement

  - DFCS_SCROLLSIZEGRIP poignée de taille dans le coin inférieur droit de la fenêtre

  - DFCS_SCROLLUP Flèche vers le haut de la barre de défilement

### <a name="example"></a>Exemple

Ce code attire la pince de taille dans le coin inférieur droit de votre fenêtre. Il est approprié `OnPaint` pour le gestionnaire d’une boîte de dialogue, qui n’a pas de styles et ne contient normalement pas d’autres contrôles (comme une barre d’état) qui peut lui donner une pince de taille.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

## <a name="cdcdrawicon"></a><a name="drawicon"></a>CDC::DrawIcon

Dessine une icône sur l’appareil représenté par l’objet actuel. `CDC`

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordonnées logique du coin supérieur gauche de l’icône.

*y*<br/>
Spécifie la logique y-coordinate du coin supérieur gauche de l’icône.

*hIcon (en)*<br/>
Identifie la poignée de l’icône à dessiner.

*Point*<br/>
Spécifie les coordonnées logiques x et y du coin supérieur gauche de l’icône. Vous pouvez passer une structure [POINT](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Nonzero si la fonction terminée avec succès; sinon 0.

### <a name="remarks"></a>Notes

La fonction place le coin supérieur gauche de l’icône à l’emplacement spécifié par *x* et *y*. L’emplacement est soumis au mode de cartographie actuel du contexte de l’appareil.

La ressource d’icône doit avoir été `CWinApp::LoadIcon` `CWinApp::LoadStandardIcon`précédemment `CWinApp::LoadOEMIcon`chargée en utilisant les fonctions, , , ou . Le `MM_TEXT` mode de cartographie doit être sélectionné avant d’utiliser cette fonction.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).

## <a name="cdcdrawstate"></a><a name="drawstate"></a>CDC::DrawState

Appelez cette fonction membre pour afficher une image et appliquer un effet visuel pour indiquer un état, tel qu’un état désactivé ou par défaut.

> [!NOTE]
> Pour tous les états *nFlag* sauf DSS_NORMAL, l’image est convertie en monochrome avant l’effet visuel est appliqué.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Paramètres

*Pt*<br/>
Spécifie l’emplacement de l’image.

*Taille*<br/>
Précise la taille de l’image.

*hBitmap (en)*<br/>
Une poignée à un bitmap.

*nFlags*<br/>
Drapeaux qui spécifient le type d’image et l’état. Voir [DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) dans le Windows SDK pour les types et les états *nFlags* possibles.

*hBrush (en)*<br/>
Une poignée à un pinceau.

*pBitmap (en)*<br/>
Un pointeur sur un objet CBitmap.

*pBrush*<br/>
Un pointeur à un objet CBrush.

*hIcon (en)*<br/>
Handle d'une icône.

*lpszText*<br/>
Un pointeur à texter.

*bPrefixText*<br/>
Texte qui peut contenir un accélérateur mnémonique. Le *paramètre lData* spécifie l’adresse de la chaîne, et le *paramètre nTextLen* spécifie la longueur. Si *nTextLen* est 0, la chaîne est supposée être non terminée.

*nTextLen (en)*<br/>
Longueur de la chaîne de texte pointée par *lpszText*. Si *nTextLen* est 0, la chaîne est supposée être non terminée.

*lpDrawProc*<br/>
Un pointeur à une fonction de rappel utilisé pour rendre une image. Ce paramètre est nécessaire si le type d’image dans *nFlags* est DST_COMPLEX. Il est facultatif et peut être NULL si le type d’image est DST_TEXT. Pour tous les autres types d’images, ce paramètre est ignoré. Pour plus d’informations sur la fonction de rappel, consultez la fonction [DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc) dans le SDK Windows.

*lData (en)*<br/>
Spécifie les informations sur l’image. La signification de ce paramètre dépend du type d’image.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

## <a name="cdcdrawtext"></a><a name="drawtext"></a>CDC::DrawText

Appelez cette fonction de membre pour formater le texte dans le rectangle donné. Pour spécifier d’autres options de formatage, utilisez [CDC::DrawTextEx](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Paramètres

*lpszString (lpszString)*<br/>
Points à la corde à tirer. Si *nCount* est de -1, la chaîne doit être annulée.

*nCompte*<br/>
Spécifie le nombre d’ombles dans la chaîne. Si *nCount* est de -1, alors *lpszString* est supposé être `DrawText` un long pointeur à une chaîne non terminée et calcule le nombre de caractères automatiquement.

*lpRect*<br/>
Indique une structure [RECT](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui contient le rectangle (dans les coordonnées logiques) dans lequel le texte doit être formaté.

*Str*<br/>
Un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) qui contient les caractères spécifiés à dessiner.

*nFormat (en)*<br/>
Spécifie la méthode de formatage du texte. Il peut s’agir de n’importe quelle combinaison des valeurs décrites pour le *paramètre uFormat* dans [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) dans le SDK Windows. (combiner à l’aide de l’opérateur BITwise OU):

> [!NOTE]
> Certaines combinaisons de drapeau *uFormat* peuvent faire modifier la ficelle passée. L’utilisation de DT_MODIFYSTRING avec DT_END_ELLIPSIS ou DT_PATH_ELLIPSIS peut entraîner la modification de la chaîne, provoquant une affirmation dans le `CString` remplacement. Les valeurs DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP et DT_NOPREFIX ne peuvent pas être utilisées avec la valeur DT_TABSTOP.

### <a name="return-value"></a>Valeur de retour

La hauteur du texte si la fonction est réussie.

### <a name="remarks"></a>Notes

Il formate le texte en élargissant les onglets dans les espaces appropriés, alignant le texte vers la gauche, la droite ou le centre du rectangle donné, et en brisant le texte en lignes qui s’inscrivent dans le rectangle donné. Le type de formatage est spécifié par *nFormat*.

Cette fonction de membre utilise la police, la couleur de texte et la couleur de fond sélectionnées du contexte de l’appareil pour dessiner le texte. À moins que le format `DrawText` DT_NOCLIP soit utilisé, clips le texte de sorte que le texte n’apparaît pas en dehors du rectangle donné. Tout le formatage est supposé avoir plusieurs lignes à moins que le format DT_SINGLELINE est donné.

Si la police sélectionnée est trop grande `DrawText` pour le rectangle spécifié, la fonction membre ne tente pas de remplacer une police plus petite.

Si le drapeau DT_CALCRECT est spécifié, le rectangle spécifié par *lpRect* sera mis à jour pour refléter la largeur et la hauteur nécessaires pour dessiner le texte.

Si le TA_UPDATECP drapeau d’alignement de texte a été défini (voir [CDC::SetTextAlign](#settextalign)), `DrawText` affichera le texte à partir de la position actuelle, plutôt qu’à gauche du rectangle donné. `DrawText`ne pas envelopper le texte lorsque le drapeau TA_UPDATECP a été fixé (c’est-à-dire que le drapeau DT_WORDBREAK n’aura aucun effet).

La couleur du texte peut être définie par [CDC::SetTextColor](#settextcolor).

## <a name="cdcdrawtextex"></a><a name="drawtextex"></a>CDC::DrawTextEx

Formats texte dans le rectangle donné.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Paramètres

*lpszString (lpszString)*<br/>
Points à la corde à tirer. Si *nCount* est de -1, la chaîne doit être annulée.

*nCompte*<br/>
Spécifie le nombre d’ombles dans la chaîne. Si *nCount* est de -1, alors *lpszString* est supposé être `DrawText` un long pointeur à une chaîne non terminée et calcule le nombre de caractères automatiquement.

*lpRect*<br/>
Indique une structure [RECT](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui contient le rectangle (dans les coordonnées logiques) dans lequel le texte doit être formaté.

*Str*<br/>
Un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) qui contient les caractères spécifiés à dessiner.

*nFormat (en)*<br/>
Spécifie la méthode de formatage du texte. Il peut s’agir de n’importe quelle combinaison des valeurs décrites pour le *paramètre uFormat* dans [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) dans le SDK Windows. (Combiner à l’aide de l’opérateur **BITwise OU):**

> [!NOTE]
> Certaines combinaisons de drapeau *uFormat* peuvent faire modifier la ficelle passée. L’utilisation de DT_MODIFYSTRING avec DT_END_ELLIPSIS ou DT_PATH_ELLIPSIS peut entraîner la modification de la chaîne, provoquant une affirmation dans le `CString` remplacement. Les valeurs DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP et DT_NOPREFIX ne peuvent pas être utilisées avec la valeur DT_TABSTOP.

*lpDTParams*<br/>
Pointeur vers une structure [DRAWTEXTPARAMS](/windows/win32/api/winuser/ns-winuser-drawtextparams) qui spécifie des options de formatage supplémentaires. Ce paramètre peut être NULL.

### <a name="remarks"></a>Notes

Il formate le texte en élargissant les onglets dans les espaces appropriés, alignant le texte vers la gauche, la droite ou le centre du rectangle donné, et en brisant le texte en lignes qui s’inscrivent dans le rectangle donné. Le type de formatage est spécifié par *nFormat* et *lpDTParams*. Pour plus d’informations, voir [CDC::DrawText](#drawtext) et [DrawTextEx](/windows/win32/api/winuser/nf-winuser-drawtextexw) dans le SDK Windows.

La couleur du texte peut être définie par [CDC::SetTextColor](#settextcolor).

## <a name="cdcellipse"></a><a name="ellipse"></a>CDC::Ellipse

Dessine une ellipse.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la logique x-coordonner le coin supérieur gauche du rectangle de délimitation de l’ellipse.

*y1 (en)*<br/>
Spécifie la logique y-coordinate du coin supérieur gauche du rectangle de délimitation de l’ellipse.

*x2*<br/>
Spécifie la logique x-coordonner le coin inférieur droit du rectangle de délimitation de l’ellipse.

*y2*<br/>
Spécifie la logique y-coordinate du coin inférieur droit du rectangle de délimitation de l’ellipse.

*lpRect*<br/>
Spécifie le rectangle de délimitation de l’ellipse. Vous pouvez également passer un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le centre de l’ellipse est le centre du rectangle de délimitation spécifié par *x1*, *y1*, *x2*, et *y2*, ou *lpRect*. L’ellipse est dessinée avec le stylo actuel, et son intérieur est rempli de la brosse actuelle.

La figure dessinée par cette fonction s’étend jusqu’à, mais ne comprend pas, les coordonnées droite et inférieure. Cela signifie que la hauteur de la figure est *y2* - *y1* et la largeur de la figure est *x2* - *x1*.

Si la largeur ou la hauteur du rectangle de délimitation est de 0, aucune ellipse n’est dessinée.

## <a name="cdcenddoc"></a><a name="enddoc"></a>CDC::EndDoc

Termine un travail d’impression commencé par un appel à la fonction membre [StartDoc.](#startdoc)

```
int EndDoc();
```

### <a name="return-value"></a>Valeur de retour

Plus ou égal à 0 si la fonction est réussie, ou une valeur négative en cas d’erreur.

### <a name="remarks"></a>Notes

Cette fonction de membre remplace l’échappement d’imprimante ENDDOC, et doit être appelée immédiatement après avoir terminé un travail d’impression réussi.

Si une application rencontre une erreur d’impression ou une opération d’impression `EndDoc` annulée, elle ne doit pas tenter de mettre fin à l’opération en utilisant l’un ou l’autre ou [AbortDoc](#abortdoc). GDI met automatiquement fin à l’opération avant de retourner la valeur d’erreur.

Cette fonction ne doit pas être utilisée à l’intérieur des métafiles.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CDC::StartDoc](#startdoc).

## <a name="cdcendpage"></a><a name="endpage"></a>CDC::EndPage

Informe l’appareil que l’application a fini d’écrire sur une page.

```
int EndPage();
```

### <a name="return-value"></a>Valeur de retour

Plus ou égal à 0 si la fonction est réussie, ou une valeur négative en cas d’erreur.

### <a name="remarks"></a>Notes

Cette fonction de membre est généralement utilisée pour diriger le pilote de l’appareil à avancer vers une nouvelle page.

Cette fonction de membre remplace l’échappement de l’imprimante NEWFRAME. Contrairement à NEWFRAME, cette fonction est toujours appelée après l’impression d’une page.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CDC::StartDoc](#startdoc).

## <a name="cdcendpath"></a><a name="endpath"></a>CDC::EndPath

Ferme un support de chemin et sélectionne le chemin défini par le support dans le contexte de l’appareil.

```
BOOL EndPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CDC:BeginPath](#beginpath).

## <a name="cdcenumobjects"></a><a name="enumobjects"></a>CDC::EnumObjects

Énumère les stylos et les pinceaux disponibles dans un contexte d’appareil.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Paramètres

*nObjectType*<br/>
Spécifie le type d’objet. Il peut avoir les valeurs OBJ_BRUSH ou OBJ_PEN.

*lpfn lpfn*<br/>
Est-ce l’adresse d’instance de la fonction de rappel fournie par l’application. Voir la section "Remarques" ci-dessous.

*lpData (lpData)*<br/>
Indique les données fournies par l’application. Les données sont transmises à la fonction de rappel ainsi que les informations de l’objet.

### <a name="return-value"></a>Valeur de retour

Spécifie la dernière valeur retournée par la [fonction de rappel](callback-functions-used-by-mfc.md#enum_objects). Son sens est défini par l’utilisateur.

### <a name="remarks"></a>Notes

Pour chaque objet d’un type donné, la fonction de rappel que vous passez est appelée avec les informations pour cet objet. Le système appelle la fonction de rappel jusqu’à ce qu’il n’y ait plus d’objets ou que la fonction de rappel retourne 0.

Notez que les nouvelles fonctionnalités de Microsoft Visual CMD `EnumObjects`vous permettent d’utiliser une fonction ordinaire au fur et à mesure que la fonction passait à . L’adresse `EnumObjects` passée est un pointeur à une fonction exportée avec **EXPORT** et avec la convention d’appel Pascal. Dans les applications en mode protection, vous n’avez pas à créer cette fonction avec la fonction Windows MakeProcInstance ou à libérer la fonction après utilisation avec la fonction FreeProcInstance Windows.

Vous n’avez pas non plus à exporter le nom de la fonction dans un relevé **EXPORTS** dans le fichier module-définition de votre application. Vous pouvez plutôt utiliser le modificateur de fonction **EXPORT,** comme dans

**int CALLBACK EXPORT** AFunction **(LPSTR**, **LPSTR);**

pour faire en sorte que le compilateur émete le dossier d’exportation approprié pour l’exportation par son nom sans aliasing. Cela fonctionne pour la plupart des besoins. Pour certains cas particuliers, comme l’exportation d’une fonction par l’exportation ordinaire ou l’enregistrement de l’exportation, vous devez toujours utiliser un relevé **EXPORTS** dans un fichier de définition de module.

Pour la compilation des programmes de la Fondation Microsoft, vous utiliserez normalement les options de compilation /GA et /GEs. L’option compilateur /Gw n’est pas utilisée avec les classes de la Fondation Microsoft. (Si vous utilisez la `MakeProcInstance`fonction Windows, vous devrez lancer explicitement le pointeur de fonction retourné de FARPROC au type nécessaire dans cette API.) Les interfaces d’enregistrement de rappel sont maintenant sans danger de type (vous devez passer dans un pointeur de fonction qui indique le bon type de fonction pour le rappel spécifique).

Notez également que toutes les fonctions de rappel doivent piéger les exceptions de la Fondation Microsoft avant de revenir à Windows, puisque les exceptions ne peuvent pas être jetées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, voir l’article [Exceptions](../../mfc/exception-handling-in-mfc.md).

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

## <a name="cdcescape"></a><a name="escape"></a>CDC::Escape

Cette fonction de membre est pratiquement obsolète pour la programmation Win32.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Paramètres

*nEscape (en anglais)*<br/>
Spécifie la fonction d’évasion à effectuer.

Pour une liste complète des fonctions d’évasion, voir [Escape](/windows/win32/api/wingdi/nf-wingdi-escape) in the Windows SDK.

*nCompte*<br/>
Spécifie le nombre d’octets de données pointées par *lpszInData*.

*lpszInData*<br/>
Indique la structure de données d’entrée requise pour cette évasion.

*lpOutData*<br/>
Points à la structure qui est de recevoir la sortie de cette évasion. Le *paramètre lpOutData* est NULL si aucune donnée n’est retournée.

*nInputSize*<br/>
Spécifie le nombre d’octets de données indiqués par le paramètre *lpszInputData.*

*lpszInputData*<br/>
Indique la structure d’entrée requise pour l’évasion spécifiée.

*nOutputSize*<br/>
Spécifie le nombre d’octets de données indiquées par le paramètre *lpszOutputData.*

*lpszOutputData*<br/>
Indique la structure qui reçoit la sortie de cette évasion. Ce paramètre doit être NULL si aucune donnée n’est retournée.

### <a name="return-value"></a>Valeur de retour

Une valeur positive est retournée si la fonction est réussie, à l’exception de l’évasion QUERYESCSUPPORT, qui ne vérifie que pour la mise en œuvre. Zéro est retourné si l’évasion n’est pas mise en œuvre. Une valeur négative est retournée en cas d’erreur. Voici les valeurs d’erreur courantes :

- SP_ERROR erreur générale.

- SP_OUTOFDISK Pas assez d’espace de disque est actuellement disponible pour le covoiturage, et plus d’espace ne sera disponible.

- SP_OUTOFMEMORY Pas assez de mémoire est disponible pour le covoiturage.

- SP_USERABORT’utilisateur a terminé le travail par l’intermédiaire du gestionnaire d’impression.

### <a name="remarks"></a>Notes

De l’imprimante d’origine s’échappe, seul QUERYESCSUPPORT est pris en charge pour les applications Win32. Toutes les autres imprimantes échappent sont obsolètes et ne sont prises en charge que pour la compatibilité avec des applications 16 bits.

Pour la programmation `CDC` Win32, fournit maintenant six fonctions de membre qui remplacent leurs évasions d’imprimante correspondantes :

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

En outre, [CDC::GetDeviceCaps](#getdevicecaps) prend en charge les index Win32 qui remplacent les autres évasions d’imprimantes. Voir [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) dans le Windows SDK pour plus d’informations.

Cette fonction membre permet aux applications d’accéder aux installations d’un appareil particulier qui ne sont pas directement disponibles via GDI.

Utilisez la première version si votre application utilise des valeurs d’échappement prédéfinises. Utilisez la deuxième version si votre application définit les valeurs d’évasion privées. Voir [ExtEscape](/windows/win32/api/wingdi/nf-wingdi-extescape) dans le Windows SDK pour plus d’informations sur la deuxième version.

## <a name="cdcexcludecliprect"></a><a name="excludecliprect"></a>CDC::ExcludeClipRect

Crée une nouvelle région de coupure qui se compose de la région de coupure existante moins le rectangle spécifié.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la logique x-coordonner le coin supérieur gauche du rectangle.

*y1 (en)*<br/>
Spécifie la logique y-coordinate du coin supérieur gauche du rectangle.

*x2*<br/>
Spécifie la logique x-coordonner le coin inférieur droit du rectangle.

*y2*<br/>
Spécifie la logique y-coordinate du coin inférieur droit du rectangle.

*lpRect*<br/>
Spécifie le rectangle. Peut également `CRect` être un objet.

### <a name="return-value"></a>Valeur de retour

Spécifie le nouveau type de région de coupure. Il peut s’agir de l’une des valeurs suivantes :

- COMPLEXREGION La région a des frontières qui se chevauchent.

- ERROR Aucune région n’a été créée.

- NULLREGION La région est vide.

- SIMPLEREGION La région n’a pas de frontières qui se chevauchent.

### <a name="remarks"></a>Notes

La largeur du rectangle, spécifiée par la valeur absolue de *x2* - *x1*, ne doit pas dépasser 32 767 unités. Cette limite s’applique également à la hauteur du rectangle.

## <a name="cdcexcludeupdatergn"></a><a name="excludeupdatergn"></a>CDC::ExcludeUpdateRgn

Empêche de dessiner dans les zones non valides d’une fenêtre en `CDC` excluant une région mise à jour dans la fenêtre de la région de coupure associée à l’objet.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Paramètres

*Pwnd*<br/>
Indique l’objet de fenêtre dont la fenêtre est mise à jour.

### <a name="return-value"></a>Valeur de retour

Le type de région exclue. Il peut s’agir de l’une des valeurs suivantes :

- COMPLEXREGION La région a des frontières qui se chevauchent.

- ERROR Aucune région n’a été créée.

- NULLREGION La région est vide.

- SIMPLEREGION La région n’a pas de frontières qui se chevauchent.

## <a name="cdcextfloodfill"></a><a name="extfloodfill"></a>CDC::ExtFloodFill

Remplit une zone de la surface d’affichage avec la brosse actuelle.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordonnées logique du point où le remplissage commence.

*y*<br/>
Spécifie la logique y-coordinate du point où le remplissage commence.

*crColor (en)*<br/>
Spécifie la couleur de la limite ou de la zone à remplir. L’interprétation de *crColor* dépend de la valeur de *nFillType*.

*nFillType (en)*<br/>
Spécifie le type de remplissage des inondations à effectuer. Il doit s’agir de l’une ou l’autre des valeurs suivantes :

- FLOODFILLBORDER La zone de remplissage est délimitée par la couleur spécifiée par *crColor*. Ce style est identique à `FloodFill`la garniture effectuée par .

- FLOODFILLSURFACE La zone de remplissage est définie par la couleur spécifiée par *crColor*. Le remplissage se poursuit vers l’extérieur dans toutes les directions tant que la couleur est rencontrée. Ce style est utile pour remplir les zones avec des limites multicolores.

### <a name="return-value"></a>Valeur de retour

Nonzero si la fonction est réussie; autrement 0 si le remplissage ne pouvait pas être complété, si le point donné a la couleur limite spécifiée par *crColor* (si FLOODFILLBORDER a été demandé), si le point donné n’a pas la couleur spécifiée par *crColor* (si FLOODFILLSURFACE a été demandé), ou si le point est en dehors de la région de coupure.

### <a name="remarks"></a>Notes

Cette fonction de membre `FloodFill` offre plus de flexibilité que parce que vous pouvez spécifier un type de remplissage dans *nFillType*.

Si *nFillType* est réglé à FLOODFILLBORDER, la zone est supposée être complètement délimitée par la couleur spécifiée par *crColor*. La fonction commence au point spécifié par *x* et *y* et remplit dans toutes les directions à la limite de couleur.

Si *nFillType* est réglé sur FLOODFILLSURFACE, la fonction commence au point spécifié par *x* et *y* et se poursuit dans toutes les directions, remplissant toutes les zones adjacentes contenant la couleur spécifiée par *crColor*.

Seuls les contextes et les appareils de `ExtFloodFill`dispositif de mémoire qui prennent en charge le support technologique raster-display . Pour plus d’informations, consultez la fonction membre [GetDeviceCaps.](#getdevicecaps)

## <a name="cdcexttextout"></a><a name="exttextout"></a>CDC::ExtTextOut

Appelez cette fonction de membre pour écrire une chaîne de caractère dans une région rectangulaire en utilisant la police actuellement sélectionnée.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordonnées logique de la cellule de caractère pour le premier personnage de la chaîne spécifiée.

*y*<br/>
Spécifie la logique y-coordinate du haut de la cellule de caractère pour le premier personnage de la chaîne spécifiée.

*nOptions*<br/>
Spécifie le type de rectangle. Ce paramètre peut être l’une, les deux, ou ni l’une ni l’autre des valeurs suivantes :

- ETO_CLIPPED précise que le texte est coupé au rectangle.

- ETO_OPAQUE précise que la couleur de fond actuelle remplit le rectangle. (Vous pouvez définir et interroger la couleur de fond actuelle avec les fonctions des membres [SetBkColor](#setbkcolor) et [GetBkColor.)](#getbkcolor)

*lpRect*<br/>
Indique une structure [RECT](/windows/win32/api/windef/ns-windef-rect) qui détermine les dimensions du rectangle. Ce paramètre peut être NULL. Vous pouvez également passer un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

*lpszString (lpszString)*<br/>
Points à la chaîne de caractère spécifié à dessiner. Vous pouvez également passer un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) pour ce paramètre.

*nCompte*<br/>
Spécifie le nombre de caractères de la chaîne.

*lpDxWidths*<br/>
Indique un éventail de valeurs qui indiquent la distance entre les origines des cellules de caractère adjacentes. Par exemple, *lpDxWidths* *[i*] unités logiques sépareront les origines de la cellule de caractère *i* et de la cellule de caractère *i* 1. Si *lpDxWidths* est `ExtTextOut` NULL, utilise l’espacement par défaut entre les caractères.

*Str*<br/>
Un `CString` objet qui contient les caractères spécifiés à dessiner.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

La région rectangulaire peut être opaque (remplie de la couleur de fond actuelle), et il peut être une région de coupure.

Si *nOptions* est de 0 et *lpRect* est NULL, la fonction écrit le texte au contexte de l’appareil sans utiliser une région rectangulaire. Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction. Si une application doit mettre à `ExtTextOut`jour la position `CDC` actuelle lorsqu’elle appelle, l’application peut appeler la fonction [membre SetTextAlign](#settextalign) avec *nFlags* configuré à TA_UPDATECP. Lorsque ce drapeau est défini, Windows ignore *x* et *y* sur les appels ultérieurs à `ExtTextOut` la place et utilise la position actuelle. Lorsqu’une application utilise TA_UPDATECP pour mettre `ExtTextOut` à jour la position actuelle, définit la position actuelle soit à la fin de la ligne de texte précédente, soit à la position spécifiée par le dernier élément du tableau pointé par *lpDxWidths*, selon le plus grand.

## <a name="cdcfillpath"></a><a name="fillpath"></a>CDC::FillPath

Ferme toutes les figures ouvertes dans le chemin actuel et remplit l’intérieur du chemin en utilisant la brosse actuelle et le mode de remplissage du polygone.

```
BOOL FillPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Une fois son intérieur rempli, le chemin est écarté du contexte de l’appareil.

## <a name="cdcfillrect"></a><a name="fillrect"></a>CDC::FillRect

Appelez cette fonction de membre pour remplir un rectangle donné à l’aide de la brosse spécifiée.

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Points à une structure [RECT](/windows/win32/api/windef/ns-windef-rect) qui contient les coordonnées logiques du rectangle à remplir. Vous pouvez également passer un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

*pBrush*<br/>
Identifie la brosse utilisée pour remplir le rectangle.

### <a name="remarks"></a>Notes

La fonction remplit le rectangle complet, y compris les bordures gauche et supérieure, mais elle ne remplit pas les bordures droite et inférieure.

Le pinceau doit être créé en utilisant les fonctions membres [CBrush](../../mfc/reference/cbrush-class.md) [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush) `GetStockObject` , et [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush), ou récupéré par la fonction Windows.

Lors du remplissage `FillRect` du rectangle spécifié, n’inclut pas les côtés droit et inférieur du rectangle. GDI remplit un rectangle jusqu’à, mais ne comprend pas, la colonne droite et la rangée inférieure, quel que soit le mode de cartographie actuel. `FillRect`compare les valeurs `top`du `bottom` `left`rectangle `right` spécifié, et les membres du rectangle spécifié. S’il `bottom` est inférieur `top`ou égal `right` à, ou s’il est inférieur ou égal à, `left`le rectangle n’est pas dessiné.

`FillRect`est similaire à [CDC::FillSolidRect;](#fillsolidrect) cependant, `FillRect` prend un pinceau et peut donc être utilisé pour remplir un rectangle avec une couleur solide, une couleur tergiversée, brosses éclos, ou un motif. `FillSolidRect`utilise uniquement des couleurs solides (indiquées par un paramètre COLORREF). `FillRect`est généralement `FillSolidRect`plus lent que .

## <a name="cdcfillrgn"></a><a name="fillrgn"></a>CDC::FillRgn

Remplit la région spécifiée par *pRgn* avec la brosse spécifiée par *pBrush*.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Paramètres

*pRgn (en)*<br/>
Un pointeur pour la région à remplir. Les coordonnées de la région donnée sont spécifiées dans des unités logiques.

*pBrush*<br/>
Identifie le pinceau à utiliser pour remplir la région.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le pinceau doit être `CBrush` créé en `CreateHatchBrush` `CreatePatternBrush`utilisant `CreateSolidBrush`les fonctions `GetStockObject`du membre, , , , ou être récupéré par .

### <a name="example"></a>Exemple

  Voir l’exemple pour [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

## <a name="cdcfillsolidrect"></a><a name="fillsolidrect"></a>CDC::FillSolidRect

Appelez cette fonction de membre pour remplir le rectangle donné avec la couleur solide spécifiée.

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Spécifie le rectangle de délimitation (en unités logiques). Vous pouvez passer soit un pointeur à `CRect` une structure de données [RECT](/windows/win32/api/windef/ns-windef-rect) ou un objet pour ce paramètre.

*clr* Spécifie la couleur à utiliser pour remplir le rectangle.

*x*<br/>
Spécifie la logique x-coordonner le coin supérieur gauche du rectangle.

*y*<br/>
Spécifie la logique y-coordinate du coin supérieur gauche du rectangle de destination.

*Cx*<br/>
Spécifie la largeur du rectangle.

*Cy*<br/>
Spécifie la hauteur du rectangle.

### <a name="remarks"></a>Notes

`FillSolidRect`est très similaire à [CDC::FillRect](#fillrect); cependant, `FillSolidRect` utilise uniquement des couleurs solides (indiqué `FillRect` par le paramètre COLORREF), tandis que prend un pinceau et peut donc être utilisé pour remplir un rectangle avec une couleur solide, une couleur dithered, brosses éclos, ou un motif. `FillSolidRect`est généralement `FillRect`plus rapide que .

> [!NOTE]
> Lorsque vous `FillSolidRect`appelez, la couleur de fond, qui a été précédemment réglé en utilisant [SetBkColor](#setbkcolor), est réglé à la couleur indiquée par *clr*.

## <a name="cdcflattenpath"></a><a name="flattenpath"></a>CDC::FlattenPath

Transforme toutes les courbes du chemin choisi dans le contexte actuel de l’appareil et transforme chaque courbe en une séquence de lignes.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

## <a name="cdcfloodfill"></a><a name="floodfill"></a>CDC::FloodFill

Remplit une zone de la surface d’affichage avec la brosse actuelle.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordonnées logique du point où le remplissage commence.

*y*<br/>
Spécifie la logique y-coordinate du point où le remplissage commence.

*crColor (en)*<br/>
Spécifie la couleur de la limite.

### <a name="return-value"></a>Valeur de retour

Nonzero si la fonction est réussie; sinon 0 est retourné si le remplissage ne pouvait pas être complété, le point donné a la couleur limite spécifiée par *crColor*, ou le point est en dehors de la région de coupure.

### <a name="remarks"></a>Notes

La zone est supposée être délimitée comme spécifié par *crColor*. La `FloodFill` fonction commence au point spécifié par *x* et *y* et continue dans toutes les directions à la limite de couleur.

Seuls les contextes et les appareils de mémoire-dispositif qui prennent en charge la technologie d’affichage raster prennent en charge la `FloodFill` fonction membre. Pour obtenir de l’information sur `GetDeviceCaps` RC_BITBLT capacité, consultez la fonction du membre.

La `ExtFloodFill` fonction offre une capacité similaire, mais une plus grande flexibilité.

## <a name="cdcframerect"></a><a name="framerect"></a>CDC::FrameRect

Dessine une bordure autour du rectangle spécifié par *lpRect*.

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Indique une structure [RECT](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui contient les coordonnées logiques des coins supérieurs gauche et inférieur-droit du rectangle. Vous pouvez également `CRect` passer un objet pour ce paramètre.

*pBrush*<br/>
Identifie le pinceau à utiliser pour encadrer le rectangle.

### <a name="remarks"></a>Notes

La fonction utilise le pinceau donné pour dessiner la bordure. La largeur et la hauteur de la bordure est toujours 1 unité logique.

Si la coordonnées `bottom` du rectangle est inférieure `top`ou `right` égale à, ou `left`si elle est inférieure ou égale à, le rectangle n’est pas dessiné.

La bordure `FrameRect` tracée par est dans la `Rectangle` même position qu’une bordure `Rectangle` dessinée par la fonction membre en utilisant les mêmes coordonnées (si elle utilise un stylo qui est 1 unité logique de large). L’intérieur du rectangle n’est pas rempli par `FrameRect`.

## <a name="cdcframergn"></a><a name="framergn"></a>CDC::FrameRgn

Dessine une bordure autour de la région spécifiée par *pRgn* à l’aide de la brosse spécifiée par *pBrush*.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Paramètres

*pRgn (en)*<br/>
Indique l’objet `CRgn` qui identifie la région à enfermer dans une frontière. Les coordonnées de la région donnée sont spécifiées dans des unités logiques.

*pBrush*<br/>
Indique l’objet `CBrush` qui identifie la brosse à utiliser pour dessiner la bordure.

*nWidth (en)*<br/>
Spécifie la largeur de la bordure en coups de pinceau verticaux dans les unités de périphériques.

*nHeight (en)*<br/>
Specifie la hauteur de la bordure en traits de brosse horizontale dans les unités de périphérique.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

## <a name="cdcfromhandle"></a><a name="fromhandle"></a>CDC::DeHandle

Renvoie un `CDC` pointeur à un objet lorsqu’on lui donne une poignée dans un contexte d’appareil.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Paramètres

*Hdc*<br/>
Contient une poignée dans le contexte d’un appareil Windows.

### <a name="return-value"></a>Valeur de retour

Le pointeur peut être temporaire et ne doit pas être stocké au-delà de l’utilisation immédiate.

### <a name="remarks"></a>Notes

Si aucun objet `CDC` n'est attaché au handle, un objet `CDC` temporaire est créé et attaché.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CPrintDialog:GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcgetarcdirection"></a><a name="getarcdirection"></a>CDC::GetArcDirection

Retourne la direction actuelle de l’arc pour le contexte de l’appareil.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Valeur de retour

Spécifie la direction actuelle de l’arc, si elle réussit. Voici les valeurs de rendement valides :

- AD_COUNTERCLOCKWISE Arcs et rectangles dessinés dans le sens inverse des aiguilles d’une montre.

- AD_CLOCKWISE Arcs et rectangles dessinés dans le sens des aiguilles d’une montre.

En cas d’erreur, la valeur de retour est nulle.

### <a name="remarks"></a>Notes

Les fonctions Arc et rectangle utilisent la direction de l’arc.

## <a name="cdcgetaspectratiofilter"></a><a name="getaspectratiofilter"></a>CDC::GetAspectRatioFilter

Récupère le paramètre pour le filtre actuel de rapport d’aspect.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Valeur de retour

Un `CSize` objet représentant le rapport d’aspect utilisé par le filtre de rapport d’aspect actuel.

### <a name="remarks"></a>Notes

Le rapport d’aspect est le rapport formé par la largeur et la hauteur des pixels d’un appareil. Les informations sur le rapport d’aspect d’un appareil sont utilisées dans la création, la sélection et l’affichage des polices. Windows fournit un filtre spécial, le filtre aspect-ratio, pour sélectionner les polices conçues pour un rapport d’aspect particulier de toutes les polices disponibles. Le filtre utilise le rapport `SetMapperFlags` d’aspect spécifié par la fonction membre.

## <a name="cdcgetbkcolor"></a><a name="getbkcolor"></a>CDC::GetBkColor

Retourne la couleur de fond actuelle.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Valeur de retour

Une valeur de couleur RGB.

### <a name="remarks"></a>Notes

Si le mode arrière-plan est OPAQUE, le système utilise la couleur de fond pour combler les lacunes dans les lignes stylées, les lacunes entre les lignes écloses dans les brosses, et l’arrière-plan dans les cellules de caractère. Le système utilise également la couleur de fond lors de la conversion des bitmaps entre les contextes de couleur et de périphérique monochrome.

## <a name="cdcgetbkmode"></a><a name="getbkmode"></a>CDC::GetBkMode

Retourne le mode arrière-plan.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Valeur de retour

Le mode d’arrière-plan actuel, qui peut être OPAQUE ou TRANSPARENT.

### <a name="remarks"></a>Notes

Le mode arrière-plan définit si le système supprime les couleurs de fond existantes sur la surface de dessin avant de dessiner du texte, des brosses écloses, ou tout style de stylo qui n’est pas une ligne solide.

## <a name="cdcgetboundsrect"></a><a name="getboundsrect"></a>CDC::GetBoundsRect

Retourne le rectangle de délimitation accumulé en cours pour le contexte spécifié de l’appareil.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Paramètres

*lpRectBounds*<br/>
Points à un tampon qui recevra le rectangle de délimitation actuel. Le rectangle est retourné dans des coordonnées logiques.

*Drapeaux*<br/>
Précise si le rectangle de délimitation doit être effacé après son retour. Ce paramètre doit être nul ou réglé à la valeur suivante :

- DCB_RESET Force le rectangle de délimitation à effacer après son retour.

### <a name="return-value"></a>Valeur de retour

Spécifie l’état actuel du rectangle de délimitation si la fonction est réussie. Il peut s’agir d’une combinaison des valeurs suivantes :

- DCB_ACCUMULATE l’accumulation de rectangles de délimitation se produit.

- DCB_RESET rectangle de délimitation est vide.

- DCB_SET rectangle de délimitation n’est pas vide.

- DCB_ENABLE l’accumulation de Bonding est en cours.

- DCB_DISABLE l’accumulation de Bonding est éteinte.

## <a name="cdcgetbrushorg"></a><a name="getbrushorg"></a>CDC::GetBrushOrg

Récupère l’origine (dans les unités d’appareils) de la brosse actuellement sélectionnée pour le contexte de l’appareil.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Valeur de retour

L’origine actuelle de la brosse (dans les unités de périphérique) comme objet [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

### <a name="remarks"></a>Notes

L’origine initiale du pinceau est à (0,0) de la zone client. La valeur de retour spécifie ce point dans les unités d’appareils par rapport à l’origine de la fenêtre de bureau.

## <a name="cdcgetcharacterplacement"></a><a name="getcharacterplacement"></a>CDC::GetCharacterPlacement

Récupère différents types d’informations sur une chaîne de caractères.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Paramètres

*lpString (lpString)*<br/>
Un pointeur à la chaîne de caractère à traiter.

*nCompte*<br/>
Spécifie la longueur de la ficelle. Pour la version ANSI, il s’agit d’un compte BYTE et pour la fonction Unicode c’est un compte WORD. Pour plus d’informations, voir [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw).

*nMaxExtent*<br/>
Spécifie l’étendue maximale (dans les unités logiques) à laquelle la chaîne est traitée. Les caractères qui, s’ils sont traités, dépasseraient cette étendue sont ignorés. Les calculs pour toute commande requise ou tableaux de glyphes ne s’appliquent qu’aux caractères inclus. Ce paramètre n’est utilisé que si la valeur GCP_MAXEXTENT est spécifiée dans le paramètre *dwFlags.* Au fur et à mesure que la fonction traite la chaîne d’entrée, chaque personnage et son étendue ne sont ajoutés à la sortie, à l’étendue et à d’autres tableaux que si l’étendue totale n’a pas encore dépassé le maximum. Une fois la limite atteinte, le traitement s’arrête.

*lpResults*<br/>
Pointeur vers une structure [GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw) qui reçoit les résultats de la fonction.

*dwFlags*<br/>
Précise comment traiter la chaîne dans les tableaux requis. Ce paramètre peut être une ou plusieurs des valeurs énumérées dans la section *dwFlags* du sujet [GetCharacterPlacement.](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)

*Str*<br/>
Un pointeur à un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) à traiter.

### <a name="return-value"></a>Valeur de retour

Si la fonction réussit, la valeur de retour est la largeur et la hauteur de la chaîne dans les unités logiques.

Si la fonction échoue, la valeur de retour est égale à zéro.

### <a name="remarks"></a>Notes

Cette fonction de membre imite la fonctionnalité de la fonction [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw), telle que décrite dans le SDK Windows.

## <a name="cdcgetcharabcwidths"></a><a name="getcharabcwidths"></a>CDC::GetCharABCWidths

Récupère les largeurs des caractères consécutifs dans une plage spécifiée de la police TrueType actuelle.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Paramètres

*nFirstChar (en)*<br/>
Spécifie le premier personnage de la gamme de caractères de la police actuelle pour laquelle les largeurs de caractère sont retournées.

*nLastChar (en)*<br/>
Spécifie le dernier personnage de la gamme de caractères de la police actuelle pour laquelle les largeurs de caractère sont retournées.

*lpabc (lpabc)*<br/>
Points à un tableau de structures [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) qui reçoivent les largeurs de caractère lorsque la fonction revient. Ce tableau doit contenir `ABC` au moins autant de structures qu’il y a de caractères dans la plage spécifiée par les paramètres *nFirstChar* et *nLastChar.*

*lpABCF*<br/>
Indique un tampon fourni par l’application avec un tableau de structures [ABCFLOAT](/windows/win32/api/wingdi/ns-wingdi-abcfloat) pour recevoir les largeurs de caractère lorsque la fonction revient. Les largeurs retournées par cette fonction sont dans le format de point flottant IEEE.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Les largeurs sont retournées en unités logiques. Cette fonction ne réussit qu’avec des polices TrueType.

Le rasterizer TrueType offre "ABC" espacement de caractère après une taille de point spécifique a été sélectionné. L’espacement « A » est la distance qui est ajoutée à la position actuelle avant de placer le glyphe. L’espacement "B" est la largeur de la partie noire du glyphe. L’espacement "C" est ajouté à la position actuelle pour tenir compte de l’espace blanc à droite du glyphe. La largeur avancée totale est donnée par A et C.

Lorsque `GetCharABCWidths` la fonction membre récupère des largeurs négatives de « A » ou de « C » pour un personnage, ce personnage comprend des sous-hangs ou des surplombs.

Pour convertir les largeurs ABC en unités de conception de polices, `lfHeight` une application doit créer une police dont la `ntmSizeEM` hauteur (comme spécifié dans le membre de la structure [LOGFONT)](/windows/win32/api/wingdi/ns-wingdi-logfontw) est égale à la valeur stockée dans le membre de la structure [NEWTEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw) (La valeur `ntmSizeEM` du membre peut être récupérée en appelant la fonction [EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) Windows.)

Les largeurs ABC du caractère par défaut sont utilisées pour les caractères qui sont en dehors de la plage de la police actuellement sélectionnée.

Pour récupérer les largeurs des caractères dans les polices non-TrueType, les applications doivent utiliser la fonction [GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) Windows.

## <a name="cdcgetcharabcwidthsi"></a><a name="getcharabcwidthsi"></a>CDC::GetCharABCWidthsI

Récupère les largeurs, en unités logiques, d’indices glyphes consécutifs dans une plage spécifiée de la police TrueType actuelle.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Paramètres

*giFirst*<br/>
Spécifie le premier indice glyphe du groupe des indices glyphes consécutifs de la police actuelle. Ce paramètre n’est utilisé que si le paramètre *pgi* est NULL.

*Cgi*<br/>
Spécifie le nombre d’indices glyphes.

*Igp*<br/>
Un pointeur à un tableau contenant des indices glyphes. Si la valeur est NULL, le *paramètre giFirst* est utilisé à la place. Le paramètre *cgi* spécifie le nombre d’indices glyphes dans ce tableau.

*lpabc (lpabc)*<br/>
Pointeur vers un tableau de structures [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) recevant les largeurs de caractère. Ce tableau doit contenir `ABC` au moins autant de structures qu’il y a d’indices de glyphe spécifiés par le paramètre *cgi.*

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction de membre imite la fonctionnalité de la fonction [GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi), telle que décrite dans le SDK Windows.

## <a name="cdcgetcharwidth"></a><a name="getcharwidth"></a>CDC::GetCharWidth

Récupère les largeurs des caractères individuels dans un groupe `m_hAttribDC`consécutif de caractères de la police actuelle, en utilisant , le contexte du périphérique d’entrée.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Paramètres

*nFirstChar (en)*<br/>
Spécifie le premier personnage d’un groupe consécutif de personnages dans la police actuelle.

*nLastChar (en)*<br/>
Spécifie le dernier personnage d’un groupe consécutif de personnages de la police actuelle.

*lpBuffer*<br/>
Indique un tampon qui recevra les valeurs de largeur pour un groupe consécutif de caractères dans la police actuelle.

*lpFloatBuffer*<br/>
Points à un tampon pour recevoir les largeurs de caractère. Les largeurs retournées sont dans le format 32 bits IEEE point flottant. (Les largeurs sont mesurées le long de la ligne de base des personnages.)

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Par exemple, si *nFirstChar* identifie la lettre 'a' et *nLastChar* identifie la lettre 'z', la fonction récupère les largeurs de tous les caractères minuscules.

La fonction stocke les valeurs dans le tampon indiqué par *lpBuffer*. Ce tampon doit être assez grand pour contenir toutes les largeurs. Autrement dit, il doit y avoir au moins 26 entrées dans l’exemple donné.

Si un personnage du groupe de caractères consécutif n’existe pas dans une police particulière, on lui attribuera la valeur de largeur du caractère par défaut.

## <a name="cdcgetcharwidthi"></a><a name="getcharwidthi"></a>CDC::GetCharWidthI

Récupère les largeurs, dans les coordonnées logiques, des indices glyphes consécutifs dans une plage spécifiée de la police actuelle.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Paramètres

*giFirst*<br/>
Spécifie le premier indice glyphe du groupe des indices glyphes consécutifs de la police actuelle. Ce paramètre n’est utilisé que si le paramètre *pgi* est NULL.

*Cgi*<br/>
Spécifie le nombre d’indices glyphes.

*Igp*<br/>
Un pointeur à un tableau contenant des indices glyphes. Si la valeur est NULL, le *paramètre giFirst* est utilisé à la place. Le paramètre *cgi* spécifie le nombre d’indices glyphes dans ce tableau.

*lpBuffer*<br/>
Un pointeur vers un tampon qui reçoit les largeurs.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction de membre imite la fonctionnalité de la fonction [GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi), telle que décrite dans le SDK Windows.

## <a name="cdcgetclipbox"></a><a name="getclipbox"></a>CDC::GetClipBox

Récupère les dimensions du rectangle de délimitation le plus serré autour de la limite de coupure actuelle.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Points à la structure [RECT](/windows/win32/api/windef/ns-windef-rect) ou objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui doit recevoir les dimensions du rectangle.

### <a name="return-value"></a>Valeur de retour

Le type de la région de coupure. Il peut s’agir de l’une des valeurs suivantes :

- COMPLEXREGION La région de coupure a des frontières qui se chevauchent.

- Le contexte de l’appareil ERROR n’est pas valide.

- NULLREGION La région de clip est vide.

- LA région de clip DE SIMPLEREGION n’a pas de frontières qui se chevauchent.

### <a name="remarks"></a>Notes

Les dimensions sont copiées à la mémoire tampon pointée par *lpRect*.

## <a name="cdcgetcoloradjustment"></a><a name="getcoloradjustment"></a>CDC::GetColorAdjustment

Récupère les valeurs d’ajustement des couleurs pour le contexte de l’appareil.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Paramètres

*lpColorAdjust*<br/>
Indique une structure de données [COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) pour recevoir les valeurs d’ajustement des couleurs.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

## <a name="cdcgetcurrentbitmap"></a><a name="getcurrentbitmap"></a>CDC::GetCurrentBitmap

Retourne un pointeur `CBitmap` à l’objet actuellement sélectionné.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Valeur de retour

Pointeur `CBitmap` vers un objet, en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

Cette fonction de membre peut retourner des objets temporaires.

## <a name="cdcgetcurrentbrush"></a><a name="getcurrentbrush"></a>CDC::GetCurrentBrush

Retourne un pointeur `CBrush` à l’objet actuellement sélectionné.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Valeur de retour

Pointeur `CBrush` vers un objet, en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

Cette fonction de membre peut retourner des objets temporaires.

## <a name="cdcgetcurrentfont"></a><a name="getcurrentfont"></a>CDC::GetCurrentFont

Retourne un pointeur `CFont` à l’objet actuellement sélectionné.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Valeur de retour

Pointeur `CFont` vers un objet, en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

Cette fonction de membre peut retourner des objets temporaires.

## <a name="cdcgetcurrentpalette"></a><a name="getcurrentpalette"></a>CDC::GetCurrentPalette

Retourne un pointeur `CPalette` à l’objet actuellement sélectionné.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Valeur de retour

Pointeur `CPalette` vers un objet, en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

Cette fonction de membre peut retourner des objets temporaires.

## <a name="cdcgetcurrentpen"></a><a name="getcurrentpen"></a>CDC::GetCurrentPen

Retourne un pointeur `CPen` à l’objet actuellement sélectionné.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Valeur de retour

Pointeur `CPen` vers un objet, en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

Cette fonction de membre peut retourner des objets temporaires.

## <a name="cdcgetcurrentposition"></a><a name="getcurrentposition"></a>CDC::GetCurrentPosition

Récupère la position actuelle (dans les coordonnées logiques).

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Valeur de retour

La position actuelle `CPoint` comme objet.

### <a name="remarks"></a>Notes

La position actuelle peut `MoveTo` être définie avec la fonction membre.

## <a name="cdcgetdcbrushcolor"></a><a name="getdcbrushcolor"></a>CDC::GetDCBrushColor

Récupère la couleur actuelle du pinceau.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Valeur de retour

Si la fonction réussit, la valeur de retour est la valeur [COLORREF](/windows/win32/gdi/colorref) pour la couleur de brosse actuelle.

Si la fonction échoue, la valeur de retour sera CLR_INVALID.

### <a name="remarks"></a>Notes

Cette fonction de membre imite la fonctionnalité de la fonction [GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor), telle que décrite dans le SDK Windows.

## <a name="cdcgetdcpencolor"></a><a name="getdcpencolor"></a>CDC::GetDCPenColor

Récupère la couleur actuelle du stylet.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Valeur de retour

Si la fonction réussit, la valeur de retour est la valeur [COLORREF](/windows/win32/gdi/colorref) pour la couleur actuelle du stylo.

Si la fonction échoue, la valeur de retour sera CLR_INVALID.

### <a name="remarks"></a>Notes

Cette fonction de membre utilise la fonction Win32 [GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor), telle que décrite dans le SDK Windows.

## <a name="cdcgetdevicecaps"></a><a name="getdevicecaps"></a>CDC::GetDeviceCaps

Récupère un large éventail d’informations spécifiques à l’appareil sur l’appareil d’affichage.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
Spécifie le type d’information à retourner. Consultez [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) dans le Windows SDK pour une liste de valeurs.

### <a name="return-value"></a>Valeur de retour

La valeur de la capacité demandée si la fonction est réussie.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CPrintDialog:GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

## <a name="cdcgetfontdata"></a><a name="getfontdata"></a>CDC::GetFontData

Récupère les informations de police-métriques à partir d’un fichier de police évolutif.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Paramètres

*dwTable (en)*<br/>
Spécifie le nom de la table métrique à retourner. Ce paramètre peut être l’un des tableaux métriques documentés dans la spécification TrueType Font Files publiée par Microsoft Corporation. Si ce paramètre est 0, l’information est récupérée à partir du début du fichier de police.

*dwOffset (en anglais)*<br/>
Spécifie le décalage dès le début de la table pour commencer à récupérer des informations. Si ce paramètre est 0, l’information est récupérée à partir du début de la table spécifiée par le *paramètre dwTable.* Si cette valeur est supérieure ou égale à `GetFontData` la taille de la table, retourne 0.

*lpData (lpData)*<br/>
Indique un tampon qui recevra les informations de police. Si cette valeur est NULL, la fonction renvoie la taille du tampon requis pour les données de police spécifiées dans le *paramètre dwTable.*

*cbData*<br/>
Spécifie la longueur, dans les octets, des informations à récupérer. Si ce paramètre `GetFontData` est de 0, retourne la taille des données spécifiées dans le *paramètre dwTable.*

### <a name="return-value"></a>Valeur de retour

Spécifie le nombre d’octets retournés dans le tampon indiqué par *lpData* si la fonction est réussie; sinon -1.

### <a name="remarks"></a>Notes

Les informations à récupérer sont identifiées en spécifiant un décalage dans le fichier de police et la durée des informations à retourner.

Une application peut `GetFontData` parfois utiliser la fonction membre pour enregistrer une police TrueType avec un document. Pour ce faire, l’application détermine si la police peut être intégrée, puis récupère l’ensemble du fichier de police, en spécifiant 0 pour le *dwTable*, *dwOffset*, et les paramètres *cbData.*

Les applications peuvent déterminer si une `otmfsType` police peut être intégrée en vérifiant le membre de la structure [OUTLINETEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) Si le bit `otmfsType` 1 est réglé, l’intégration n’est pas autorisée pour la police. Si le bit 1 est clair, la police peut être intégrée. Si le bit 2 est réglé, l’intégration est lue seulement.

Si une application tente d’utiliser cette fonction pour récupérer des `GetFontData` informations pour une police non-TrueType, la fonction membre renvoie -1.

## <a name="cdcgetfontlanguageinfo"></a><a name="getfontlanguageinfo"></a>CDC::GetFontLanguageInfo

Renvoie des informations sur la police actuellement sélectionnée pour le contexte d’affichage spécifié.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Valeur de retour

La valeur de retour identifie les caractéristiques de la police actuellement sélectionnée. Pour une liste complète des valeurs possibles, voir [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Notes

Cette fonction de membre imite la fonctionnalité de la fonction [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo), telle que décrite dans le SDK Windows.

## <a name="cdcgetglyphoutline"></a><a name="getglyphoutline"></a>CDC::GetGlyphOutline

Récupère la courbe de contour ou le bitmap pour un personnage de contour dans la police actuelle.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Paramètres

*Nchar*<br/>
Spécifie le caractère pour lequel l’information doit être retournée.

*nFormat (en)*<br/>
Spécifie le format dans lequel la fonction est de retourner l’information. Il peut s’agir d’une des valeurs suivantes, ou 0 :

|Valeur|Signification|
|-----------|-------------|
|GGO_BITMAP|Retourne le bitmap de glyph. Lorsque la fonction revient, le tampon indiqué par *lpBuffer* contient un bit-par-pixel bit-par-pixel bitmap dont les lignes commencent sur les limites de double mot.|
|GGO_NATIVE|Retourne les points de données de courbe dans le format natif du rasterizer, à l’aide d’unités d’appareils. Lorsque cette valeur est spécifiée, toute transformation spécifiée dans *lpmat2* est ignorée.|

Lorsque la valeur de *nFormat* est de 0, la fonction remplit une structure [GLYPHMETRICS,](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics) mais ne retourne pas les données glyph-outline.

*lpgm*<br/>
Indique une structure GLYPHMETRICS qui décrit le placement du glyphe dans la cellule de caractère.

*cbBuffer (cbBuffer)*<br/>
Spécifie la taille du tampon dans lequel la fonction copie des informations sur le caractère de contour. Si cette valeur est de 0 et que le *paramètre nFormat* est soit la GGO_BITMAP ou GGO_NATIVE valeurs, la fonction retourne la taille requise du tampon.

*lpBuffer*<br/>
Indique un tampon dans lequel la fonction copie des informations sur le caractère de contour. Si *nFormat* spécifie la valeur GGO_NATIVE, l’information est copiée sous la forme de structures TTPOLYGONHEADER et TTPOLYCURVE. Si cette valeur est NULL et *nFormat* est soit la valeur GGO_BITMAP ou GGO_NATIVE, la fonction retourne la taille requise de la mémoire tampon.

*lpmat2*<br/>
Indique une structure [MAT2](/windows/win32/api/wingdi/ns-wingdi-mat2) qui contient une matrice de transformation pour le personnage. Ce paramètre ne peut pas être NULL, même lorsque la valeur GGO_NATIVE est spécifiée pour *nFormat*.

### <a name="return-value"></a>Valeur de retour

La taille, dans les octets, du tampon requis pour les informations récupérées si *cbBuffer* est 0 ou *lpBuffer* est NULL. Sinon, c’est une valeur positive si la fonction est réussie, ou -1 s’il y a une erreur.

### <a name="remarks"></a>Notes

Une application peut faire pivoter les caractères récupérés en format bitmap en spécifiant une matrice de transformation 2 par 2 dans la structure pointée par *lpmat2*.

Un contour de glyphe est retourné comme une série de contours. Chaque contour est défini par une structure [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) suivie d’autant de `TTPOLYCURVE` structures que nécessaire pour la décrire. Tous les points sont retournés en tant que structures [POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx) et représentent des positions absolues, pas des mouvements relatifs. Le point de `pfxStart` départ donné par le membre de la structure [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) est le point où commence le contour d’un contour. Les structures [TTPOLYCURVE](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve) qui suivent peuvent être soit des enregistrements polylines, soit des enregistrements de spline. Les enregistrements de polyline sont une série de points; les lignes tracées entre les points décrivent le contour du personnage. Les enregistrements de Spline représentent les courbes quadratiques utilisées par TrueType (c’est-à-dire les b-splines quadratiques).

## <a name="cdcgetgraphicsmode"></a><a name="getgraphicsmode"></a>CDC::GetGraphicsMode

Récupère le mode graphique actuel pour le contexte de l’appareil spécifié.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Valeur de retour

Retourne le mode graphique actuel sur le succès. Pour une liste des valeurs que cette méthode peut revenir, voir [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

Retourne 0 sur l’échec.

Pour obtenir des informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Notes

Cette méthode enveloppe la fonction Windows GDI [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

## <a name="cdcgethalftonebrush"></a><a name="gethalftonebrush"></a>CDC::GetHalftoneBrush

Appelez cette fonction de membre pour récupérer une brosse à demi-teinte.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Valeur de retour

Un pointeur `CBrush` à un objet en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

Un pinceau en demi-teinte montre des pixels qui sont tour à tour au premier plan et les couleurs de fond pour créer un motif dithered. Ce qui suit est un exemple d’un motif dithered créé par une brosse à demi-teinte.

![Détail d'un stylet tramé](../../mfc/reference/media/vc318s1.gif "Détail d'un stylet tramé")

## <a name="cdcgetkerningpairs"></a><a name="getkerningpairs"></a>CDC::GetKerningPairs

Récupère les paires de kerning de caractère pour la police qui est actuellement sélectionnée dans le contexte spécifié de l’appareil.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Paramètres

*nPairs (en)*<br/>
Précise le nombre de structures [KERNINGPAIR](/windows/win32/api/wingdi/ns-wingdi-kerningpair) indiquées par *lpkrnpair*. La fonction ne copiera pas plus de paires de kerning que spécifié par *nPairs*.

*lpkrnpair*<br/>
Indique un éventail `KERNINGPAIR` de structures qui reçoivent les paires de kerning lorsque la fonction revient. Ce tableau doit contenir au moins autant de structures que spécifié par *nPairs*. Si ce paramètre est NULL, la fonction renvoie le nombre total de paires de kerning pour la police.

### <a name="return-value"></a>Valeur de retour

Spécifie le nombre de paires de kerning récupérées ou le nombre total de paires de kerning dans la police, si la fonction est réussie. Zéro est retourné si la fonction échoue ou qu’il n’y a pas de paires de kerning pour la police.

## <a name="cdcgetlayout"></a><a name="getlayout"></a>CDC::GetLayout

Appelez cette fonction de membre pour déterminer la disposition du texte et des graphiques pour un contexte d’appareil, tel qu’une imprimante ou un métaafile.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Valeur de retour

En cas de succès, la mise en page indique le contexte actuel de l’appareil. Sinon, GDI_ERROR. Pour obtenir des informations d’erreur prolongées, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror). Pour une liste des drapeaux de mise en page, voir [CDC::SetLayout](#setlayout).

### <a name="remarks"></a>Notes

La disposition par défaut est de gauche à droite.

## <a name="cdcgetmapmode"></a><a name="getmapmode"></a>CDC::GetMapMode

Récupère le mode de cartographie actuel.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Valeur de retour

Le mode de cartographie.

### <a name="remarks"></a>Notes

Pour une description des modes `SetMapMode` de cartographie, consultez la fonction du membre.

> [!NOTE]
> Si vous appelez [SetLayout](#setlayout) pour changer le CD `SetLayout` à la mise en page de droite à gauche, modifie automatiquement le mode de cartographie pour MM_ISOTROPIC. Par conséquent, tout `GetMapMode` appel ultérieur à retourner MM_ISOTROPIC.

## <a name="cdcgetmiterlimit"></a><a name="getmiterlimit"></a>CDC::GetMiterLimit

Retourne la limite d’attrage pour le contexte de l’appareil.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

La limite d’attule est utilisée lors du dessin de lignes géométriques qui ont des jointures miter.

## <a name="cdcgetnearestcolor"></a><a name="getnearestcolor"></a>CDC::GetNearestColor

Retourne la couleur solide qui correspond le mieux à une couleur logique spécifiée.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Paramètres

*crColor (en)*<br/>
Spécifie la couleur à apparier.

### <a name="return-value"></a>Valeur de retour

Une valeur de couleur RGB (rouge, vert, bleu) qui définit la couleur solide la plus proche de la valeur *crColor* que l’appareil peut représenter.

### <a name="remarks"></a>Notes

L’appareil donné doit être capable de représenter cette couleur.

## <a name="cdcgetoutlinetextmetrics"></a><a name="getoutlinetextmetrics"></a>CDC::GetOutlineTextMetrics

Récupère des informations métriques pour les polices TrueType.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Paramètres

*lpotm lpotm*<br/>
Indique un éventail de structures [OUTLINETEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) Si ce paramètre est NULL, la fonction renvoie la taille du tampon requis pour les données métriques récupérées.

*cbData*<br/>
Spécifie la taille, dans les octets, du tampon auquel l’information est retournée.

*lpotm lpotm*<br/>
Indique une `OUTLINETEXTMETRIC` structure. Si ce paramètre est NULL, la fonction renvoie la taille du tampon requis pour les informations métriques récupérées.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

La structure [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) contient la plupart des informations métriques de police fournies avec le format TrueType, y compris une structure [TEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-textmetricw) Les quatre derniers `OUTLINETEXTMETRIC` membres de la structure sont des pointeurs aux cordes. Les applications doivent allouer de l’espace pour ces chaînes en plus de l’espace requis pour les autres membres. Étant donné qu’il n’y a pas de limite imposée par le système à la taille des cordes, la méthode la `GetOutlineTextMetrics` plus simple pour allouer la mémoire est de récupérer la taille requise en spécifiant NULL pour *le lpotm* dans le premier appel à la fonction.

## <a name="cdcgetoutputcharwidth"></a><a name="getoutputcharwidth"></a>CDC::GetOutputCharWidth

Utilise le contexte `m_hDC`de l’appareil de sortie, , et récupère les largeurs des caractères individuels dans un groupe consécutif de caractères de la police actuelle.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Paramètres

*nFirstChar (en)*<br/>
Spécifie le premier personnage d’un groupe consécutif de personnages dans la police actuelle.

*nLastChar (en)*<br/>
Spécifie le dernier personnage d’un groupe consécutif de personnages de la police actuelle.

*lpBuffer*<br/>
Indique un tampon qui recevra les valeurs de largeur pour un groupe consécutif de caractères dans la police actuelle.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Par exemple, si *nFirstChar* identifie la lettre 'a' et *nLastChar* identifie la lettre 'z', la fonction récupère les largeurs de tous les caractères minuscules.

La fonction stocke les valeurs dans le tampon indiqué par *lpBuffer*. Ce tampon doit être assez grand pour contenir toutes les largeurs; c’est-à-dire qu’il doit y avoir au moins 26 entrées dans l’exemple donné.

Si un personnage du groupe de caractères consécutif n’existe pas dans une police particulière, on lui attribuera la valeur de largeur du caractère par défaut.

## <a name="cdcgetoutputtabbedtextextent"></a><a name="getoutputtabbedtextextent"></a>CDC::GetOutputTabbedTextExtent

Appelez cette fonction de membre pour calculer la largeur et la hauteur d’une chaîne de caractères à [l’aide de m_hDC,](#m_hdc)le contexte du périphérique de sortie.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Paramètres

*lpszString (lpszString)*<br/>
Points à une chaîne de caractère à mesurer. Vous pouvez également passer un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) pour ce paramètre.

*nCompte*<br/>
Spécifie la [longueur de la chaîne](/windows/win32/gdi/specifying-length-of-text-output-string) pointée par *lpszString*.

*nTabPositions*<br/>
Spécifie le nombre de positions d’onglet-arrêt dans le tableau indiqué par *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Indique un éventail d’intégrants contenant les positions d’onglet-arrêt dans les unités logiques. Les arrêts d’onglet doivent être triés dans l’ordre croissant; la plus petite valeur x devrait être le premier élément du tableau. Les onglets arrière ne sont pas autorisés.

*Str*<br/>
Un `CString` objet qui contient les caractères spécifiés à mesurer.

### <a name="return-value"></a>Valeur de retour

Les dimensions de la chaîne (en unités logiques) dans un objet [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Notes

Si la chaîne contient un ou plusieurs caractères d’onglet, la largeur de la chaîne est basée sur les arrêts *d’onglet spécifiés par lpnTabStopPositions*. La fonction utilise la police actuellement sélectionnée pour calculer les dimensions de la chaîne.

La région de coupure actuelle ne compense pas `GetOutputTabbedTextExtent` la largeur et la hauteur retournées par la fonction.

Étant donné que certains appareils ne placent pas les caractères dans les tableaux cellulaires réguliers (c’est-à-dire qu’ils kern les caractères), la somme des étendues des caractères dans une chaîne peut ne pas être égale à l’étendue de la chaîne.

Si *nTabPositions* est de 0 et *lpnTabStopPositions* est NULL, onglets sont étendus à huit largeurs de caractère moyenne. Si *nTabPositions* est 1, les arrêts d’onglet seront séparés par la distance spécifiée par la première valeur dans le tableau auquel *lpnTabStopPositions* points. Si *lpnTabStopPositions* indique plus d’une valeur unique, un arrêt d’onglet est réglé pour chaque valeur dans le tableau, jusqu’au nombre spécifié par *nTabPositions*.

## <a name="cdcgetoutputtextextent"></a><a name="getoutputtextextent"></a>CDC::GetOutputTextExtent

Appelez cette fonction de membre pour utiliser le contexte du périphérique de sortie, [m_hDC,](#m_hdc)et calculer la largeur et la hauteur d’une ligne de texte, en utilisant la police actuelle.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Paramètres

*lpszString (lpszString)*<br/>
Points à une chaîne de personnages. Vous pouvez également passer un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) pour ce paramètre.

*nCompte*<br/>
Spécifie la [longueur de la chaîne](/windows/win32/gdi/specifying-length-of-text-output-string) pointée par *lpszString*.

*Str*<br/>
Un `CString` objet qui contient les caractères spécifiés à mesurer.

### <a name="return-value"></a>Valeur de retour

Les dimensions de la chaîne (en unités logiques) sont revenues dans un objet [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Notes

La région de coupure actuelle n’affecte `GetOutputTextExtent`pas la largeur et la hauteur retournées par .

Étant donné que certains appareils ne placent pas les caractères dans les tableaux cellulaires réguliers (c’est-à-dire qu’ils effectuent des grains), la somme des étendues des caractères d’une chaîne peut ne pas être égale à l’étendue de la chaîne.

## <a name="cdcgetoutputtextmetrics"></a><a name="getoutputtextmetrics"></a>CDC::GetOutputTextMetrics

Récupère les mesures pour la `m_hDC`police actuelle à l’aide du contexte du périphérique de sortie.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Paramètres

*lpMétrie*<br/>
Indique la structure [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) qui reçoit les mesures.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

## <a name="cdcgetpath"></a><a name="getpath"></a>CDC::GetPath

Récupère les coordonnées définissant les points de terminaison des lignes et les points de contrôle des courbes trouvées dans le chemin qui est sélectionné dans le contexte de l’appareil.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Paramètres

*lpPoints (en)*<br/>
Indique un éventail [POINT](/windows/win32/api/windef/ns-windef-point) de structures `CPoint` de données POINT ou d’objets où les points de terminaison de ligne et les points de contrôle des courbes sont placés.

*lpTypes (lpTypes)*<br/>
Points à un tableau d’octets où les types de vertéx sont placés. Les valeurs sont l’une des suivantes :

- PT_MOVETO précise que le point correspondant dans *lpPoints* commence une figure disjointe.

- PT_LINETO précise que le point précédent et le point correspondant dans *les lpPoints* sont les paramètres d’une ligne.

- PT_BEZIERTO précise que le point correspondant dans *lpPoints* est un point de contrôle ou un point de terminaison pour une courbe Bzier.

PT_BEZIERTO types se produisent toujours dans des ensembles de trois. Le point dans le chemin qui les précède immédiatement définit le point de départ de la courbe de Bzier. Les deux premiers points PT_BEZIERTO sont les points de contrôle, et le troisième point PT_BEZIERTO est le point final (si hard-coded).

   Un type PT_LINETO ou PT_BEZIERTO peut être combiné avec le drapeau suivant (en utilisant l’opérateur bitwise **OU**) pour indiquer que le point correspondant est le dernier point d’un chiffre et que le chiffre doit être fermé :

- PT_CLOSEFIGURE précise que le chiffre est automatiquement fermé après le tracé de la ligne ou de la courbe correspondante. Le chiffre est fermé en tirant une ligne de la ligne ou le point de terminaison de courbe au point correspondant à la dernière PT_MOVETO.

*nCompte*<br/>
Spécifie le nombre total de structures de données [POINT](/windows/win32/api/windef/ns-windef-point) qui peuvent être placées dans le tableau *lpPoints.* Cette valeur doit être la même que le nombre d’octets qui peuvent être placés dans le tableau *lpTypes.*

### <a name="return-value"></a>Valeur de retour

Si le *paramètre nCount n’est* paszero, le nombre de points énumérés. Si *nCount* est de 0, le nombre `GetPath` total de points dans le chemin (et n’écrit rien aux tampons). Si *nCount* est nonzero et est inférieur au nombre de points dans le chemin, la valeur de retour est de -1.

### <a name="remarks"></a>Notes

Le contexte de l’appareil doit contenir un chemin fermé. Les points du chemin sont retournés dans des coordonnées logiques. Les points sont stockés dans le `GetPath` chemin dans les coordonnées de l’appareil, change ainsi les points des coordonnées de l’appareil aux coordonnées logiques en utilisant l’inverse de la transformation actuelle. La `FlattenPath` fonction membre peut `GetPath`être appelée avant, pour convertir toutes les courbes dans le chemin en segments de ligne.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CDC:BeginPath](#beginpath).

## <a name="cdcgetpixel"></a><a name="getpixel"></a>CDC::GetPixel

Récupère la valeur couleur RGB du pixel au point spécifié par *x* et *y*.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordination logique du point à examiner.

*y*<br/>
Spécifie la logique y-coordinate du point à examiner.

*Point*<br/>
Spécifie les coordonnées logiques x et y du point à examiner.

### <a name="return-value"></a>Valeur de retour

Pour l’une ou l’autre version de la fonction, une valeur de couleur RGB pour la couleur du point donné. Il est de -1 si les coordonnées ne précisent pas un point dans la région de coupure.

### <a name="remarks"></a>Notes

Le point doit être dans la région de coupure. Si le point n’est pas dans la région de coupure, la fonction n’a aucun effet et retourne -1.

La fonction `GetPixel` n'est pas prise en charge par tous les périphériques. Pour plus d’informations, consultez la capacité de raster RC_BITBLT sous la fonction membre [GetDeviceCaps.](#getdevicecaps)

La `GetPixel` fonction membre comporte deux formulaires. La première prend deux valeurs de coordonnées; le second prend soit une structure [POINT,](/windows/win32/api/windef/ns-windef-point) soit un objet [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

## <a name="cdcgetpolyfillmode"></a><a name="getpolyfillmode"></a>CDC::GetPolyFillMode

Récupère le mode de remplissage actuel du polygone.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Valeur de retour

Le mode actuel rempli de polygones, ALTERNATE ou WINDING, si la fonction est réussie.

### <a name="remarks"></a>Notes

Consultez `SetPolyFillMode` la fonction de membre pour une description des modes de remplissage du polygone.

## <a name="cdcgetrop2"></a><a name="getrop2"></a>CDC::GetROP2

Récupère le mode de dessin actuel.

```
int GetROP2() const;
```

### <a name="return-value"></a>Valeur de retour

Le mode dessin. Pour une liste des valeurs du `SetROP2` mode de dessin, consultez la fonction membre.

### <a name="remarks"></a>Notes

Le mode de dessin précise comment les couleurs du stylo et l’intérieur des objets remplis sont combinés avec la couleur déjà sur la surface d’affichage.

## <a name="cdcgetsafehdc"></a><a name="getsafehdc"></a>CDC::GetSafeHdc

Appelez cette fonction de membre pour obtenir [m_hDC](#m_hdc), le contexte du périphérique de sortie.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Valeur de retour

Une poignée de contexte de l’appareil.

### <a name="remarks"></a>Notes

Cette fonction de membre fonctionne également avec des pointeurs nuls.

## <a name="cdcgetstretchbltmode"></a><a name="getstretchbltmode"></a>CDC::GetStretchBltMode

Récupère le mode d’étirement de la bitmap actuelle.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Valeur de retour

La valeur de retour spécifie le mode d’étirement de la bitmap actuelle — STRETCH_ANDSCANS, STRETCH_DELETESCANS ou STRETCH_ORSCANS — si la fonction est réussie.

### <a name="remarks"></a>Notes

Le mode d’étirement des bitmap définit la façon dont l’information `StretchBlt` est supprimée des bitmaps qui sont étirés ou comprimés par la fonction du membre.

Les modes STRETCH_ANDSCANS et STRETCH_ORSCANS sont généralement utilisés pour préserver les pixels de premier plan dans les bitmaps monochromes. Le mode STRETCH_DELETESCANS est généralement utilisé pour préserver la couleur dans les bitmaps de couleur.

## <a name="cdcgettabbedtextextent"></a><a name="gettabbedtextextent"></a>CDC::GetTabbedTextExtent

Appelez cette fonction de membre pour calculer la largeur et la hauteur d’une chaîne de caractères à [l’aide de m_hAttribDC,](#m_hattribdc)le contexte de l’appareil d’attribut.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Paramètres

*lpszString (lpszString)*<br/>
Points à une chaîne de caractère. Vous pouvez également passer un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) pour ce paramètre.

*nCompte*<br/>
Spécifie la [longueur de la chaîne](/windows/win32/gdi/specifying-length-of-text-output-string) pointée par *lpszString*.

*nTabPositions*<br/>
Spécifie le nombre de positions d’onglet-arrêt dans le tableau indiqué par *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Indique un éventail d’intégrants contenant les positions d’onglet-arrêt dans les unités logiques. Les arrêts d’onglet doivent être triés dans l’ordre croissant; la plus petite valeur x devrait être le premier élément du tableau. Les onglets arrière ne sont pas autorisés.

*Str*<br/>
Un `CString` objet qui contient les caractères spécifiés à dessiner.

### <a name="return-value"></a>Valeur de retour

Les dimensions de la chaîne (en unités logiques) dans un objet [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Notes

Si la chaîne contient un ou plusieurs caractères d’onglet, la largeur de la chaîne est basée sur les arrêts *d’onglet spécifiés par lpnTabStopPositions*. La fonction utilise la police actuellement sélectionnée pour calculer les dimensions de la chaîne.

La région de coupure actuelle ne compense pas `GetTabbedTextExtent` la largeur et la hauteur retournées par la fonction.

Étant donné que certains appareils ne placent pas les caractères dans les tableaux cellulaires réguliers (c’est-à-dire qu’ils kern les caractères), la somme des étendues des caractères dans une chaîne peut ne pas être égale à l’étendue de la chaîne.

Si *nTabPositions* est de 0 et *lpnTabStopPositions* est NULL, onglets sont étendus à huit fois la largeur moyenne du caractère. Si *nTabPositions* est 1, les arrêts d’onglet seront séparés par la distance spécifiée par la première valeur dans le tableau auquel *lpnTabStopPositions* points. Si *lpnTabStopPositions* indique plus d’une valeur unique, un arrêt d’onglet est réglé pour chaque valeur dans le tableau, jusqu’au nombre spécifié par *nTabPositions*.

## <a name="cdcgettextalign"></a><a name="gettextalign"></a>CDC::GetTextAlign

Récupère l’état des drapeaux d’alignement de texte pour le contexte de l’appareil.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Valeur de retour

L’état des drapeaux d’alignement de texte. La valeur de rendement est une ou plusieurs des valeurs suivantes :

- TA_BASELINE précise l’alignement de l’axe x et la ligne de base de la police choisie dans le rectangle de délimitation.

- TA_BOTTOM précise l’alignement de l’axe x et du bas du rectangle de délimitation.

- TA_CENTER précise l’alignement de l’axe y et du centre du rectangle de délimitation.

- TA_LEFT précise l’alignement de l’axe y et du côté gauche du rectangle de délimitation.

- TA_NOUPDATECP précise que la position actuelle n’est pas mise à jour.

- TA_RIGHT précise l’alignement de l’axe y et du côté droit du rectangle de délimitation.

- TA_TOP précise l’alignement de l’axe x et du haut du rectangle de délimitation.

- TA_UPDATECP précise que la position actuelle est mise à jour.

### <a name="remarks"></a>Notes

Les drapeaux d’alignement `TextOut` du `ExtTextOut` texte déterminent comment les fonctions et les fonctions du membre alignent une chaîne de texte par rapport au point de départ de la chaîne. Les drapeaux d’alignement de texte ne sont pas nécessairement des drapeaux à un seul bit et peuvent être égaux à 0. Pour vérifier si un drapeau est défini, une application doit suivre ces étapes :

1. Appliquer l’opérateur BITwise OU sur le drapeau et ses drapeaux connexes, regroupés comme suit:

   - TA_LEFT, TA_CENTER et TA_RIGHT

   - TA_BASELINE, TA_BOTTOM et TA_TOP

   - TA_NOUPDATECP et TA_UPDATECP

1. Appliquer l’opérateur bitwise-AND au résultat `GetTextAlign`et la valeur de retour de .

1. Test pour l’égalité de ce résultat et le drapeau.

## <a name="cdcgettextcharacterextra"></a><a name="gettextcharacterextra"></a>CDC::GetTextCharacterExtra

Récupère le paramètre actuel pour la quantité d’espacement intercharacter.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Valeur de retour

La quantité de l’espacement intercharacter.

### <a name="remarks"></a>Notes

GDI ajoute cet espacement à chaque personnage, y compris les caractères de rupture, quand il écrit une ligne de texte au contexte de l’appareil.

La valeur par défaut pour la quantité d’espacement intercharacter est de 0.

## <a name="cdcgettextcolor"></a><a name="gettextcolor"></a>CDC::GetTextColor

Récupère la couleur actuelle du texte.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Valeur de retour

La couleur de texte actuelle comme une valeur de couleur RGB.

### <a name="remarks"></a>Notes

La couleur du texte est la couleur de premier plan des caractères dessinés en utilisant les fonctions de membre de texte GDI [TextOut](#textout), [ExtTextOut](#exttextout), et [TabbedTextOut](#tabbedtextout).

## <a name="cdcgettextextent"></a><a name="gettextextent"></a>CDC::GetTextExtent

Appelez cette fonction de membre pour calculer la largeur et la hauteur d’une ligne de texte à l’aide de la police actuelle pour déterminer les dimensions.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Paramètres

*lpszString (lpszString)*<br/>
Points à une chaîne de personnages. Vous pouvez également passer un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) pour ce paramètre.

*nCompte*<br/>
Spécifie le nombre de caractères de la chaîne.

*Str*<br/>
Un `CString` objet qui contient les caractères spécifiés.

### <a name="return-value"></a>Valeur de retour

Les dimensions de la chaîne (en unités logiques) dans un objet [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Notes

Les informations sont récupérées à partir de [m_hAttribDC](#m_hattribdc), le contexte de l’appareil d’attribut.

Par défaut, `GetTextExtent` suppose le texte pour lequel il récupère la dimension est fixé le long d’une ligne horizontale (c’est-à-dire, l’échappement est de 0). Si vous créez une police spécifiant un échappement non nul, vous devez convertir explicitement l’angle du texte pour obtenir les dimensions de la chaîne.

La région de coupure actuelle n’affecte `GetTextExtent`pas la largeur et la hauteur retournées par .

Étant donné que certains appareils ne placent pas les caractères dans les tableaux cellulaires réguliers (c’est-à-dire qu’ils effectuent des grains), la somme des étendues des caractères d’une chaîne peut ne pas être égale à l’étendue de la chaîne.

## <a name="cdcgettextextentexpointi"></a><a name="gettextextentexpointi"></a>CDC::GetTextExtentExPointI

Récupère le nombre de caractères dans une chaîne spécifiée qui s’adaptera dans un espace spécifié et remplit un tableau avec l’étendue du texte pour chacun de ces personnages.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*pgiIn*<br/>
Un pointeur à un tableau d’indices glyphes pour quelles étendues doivent être récupérés.

*Cgi*<br/>
Spécifie le nombre de glyphes dans le tableau pointé par *pgiIn*.

*nMaxExtent*<br/>
Spécifie la largeur maximale autorisée, en unités logiques, de la chaîne formatée.

*lpnFit (lpnFit)*<br/>
Un pointeur à un intégreur qui reçoit un compte du nombre maximum de caractères qui s’inscriront dans l’espace spécifié par *nMaxExtent*. Lorsque *lpnFit* est NULL, *nMaxExtent* est ignoré.

*alpDx alpDx*<br/>
Un pointeur à un tableau d’intégrants qui reçoit des étendues partielles de glyphe. Chaque élément dans le tableau donne la distance, en unités logiques, entre le début de la grille d’indices glyphes et l’un des glyphes qui s’adapte dans l’espace spécifié par *nMaxExtent*. Bien que ce tableau devrait avoir au moins autant d’éléments que les indices de glyphe spécifiés par *cgi*, la fonction remplit le tableau avec des étendues seulement pour autant d’indices de glyphe que sont spécifiés par *lpnFit*. Si *lpnDx* est NULL, la fonction ne calcule pas les largeurs partielles des cordes.

*lpSize*<br/>
Pointeur vers une structure [SIZE](/windows/win32/api/windef/ns-windef-size) qui reçoit les dimensions du tableau des indices glyphes, dans les unités logiques. Cette valeur ne peut pas être NULL.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction de membre imite la fonctionnalité de la fonction [GetTextExtentExPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi), telle que décrite dans le SDK Windows.

## <a name="cdcgettextextentpointi"></a><a name="gettextextentpointi"></a>CDC::GetTextExtentPointI

Récupère la largeur et la hauteur de la gamme spécifiée d’indices glyphes.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*pgiIn*<br/>
Un pointeur à un tableau d’indices glyphes pour quelles étendues doivent être récupérés.

*Cgi*<br/>
Spécifie le nombre de glyphes dans le tableau pointé par *pgiIn*.

*lpSize*<br/>
Pointeur vers une structure [SIZE](/windows/win32/api/windef/ns-windef-size) qui reçoit les dimensions du tableau des indices glyphes, dans les unités logiques. Cette valeur ne peut pas être NULL.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction de membre imite la fonctionnalité de la fonction [GetTextExtentPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi), telle que décrite dans le SDK Windows.

## <a name="cdcgettextface"></a><a name="gettextface"></a>CDC::GetTextFace

Appelez cette fonction de membre pour copier le nom de police de la police actuelle dans un tampon.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Paramètres

*nCompte*<br/>
Spécifie la taille du tampon (dans les octets). Si le nom de la police est plus long que le nombre d’octets spécifiés par ce paramètre, le nom est tronqué.

*lpszFacename*<br/>
Points vers le tampon pour le nom de police.

*rString (en)*<br/>
Une référence à un objet [CString.](../../atl-mfc-shared/reference/cstringt-class.md)

### <a name="return-value"></a>Valeur de retour

Le nombre d’octets copiés au tampon, sans compter le caractère nul de fin. C’est 0 si une erreur se produit.

### <a name="remarks"></a>Notes

Le nom de la police est copié comme une corde non terminée.

## <a name="cdcgettextmetrics"></a><a name="gettextmetrics"></a>CDC::GetTextMetrics

Récupère les mesures de la police actuelle à l’aide du contexte de l’appareil d’attribut.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Paramètres

*lpMétrie*<br/>
Indique la structure [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) qui reçoit les mesures.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

## <a name="cdcgetviewportext"></a><a name="getviewportext"></a>CDC::GetViewportExt

Récupère les x- et y-étendues du viewport du contexte de l’appareil.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Valeur de retour

Les x- et y-extents (dans `CSize` les unités d’appareil) comme objet.

## <a name="cdcgetviewportorg"></a><a name="getviewportorg"></a>CDC::GetViewportOrg

Récupère les coordonnées x et y de l’origine du viewport associé au contexte de l’appareil.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Valeur de retour

L’origine du viewport (dans les `CPoint` coordonnées de l’appareil) en tant qu’objet.

## <a name="cdcgetwindow"></a><a name="getwindow"></a>CDC::GetWindow

Retourne la fenêtre associée au contexte de l’appareil d’affichage.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Valeur de retour

Pointer vers `CWnd` un objet en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

Il s’agit d’une fonction avancée. Par exemple, cette fonction de membre ne peut pas retourner la fenêtre de vue lors de l’impression ou dans l’aperçu d’impression. Il renvoie toujours la fenêtre associée à la sortie. Fonctions de sortie qui utilisent le tirage DC donné dans cette fenêtre.

## <a name="cdcgetwindowext"></a><a name="getwindowext"></a>CDC::GetWindowExt

Récupère les x- et y-extents de la fenêtre associée au contexte de l’appareil.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Valeur de retour

Les x- et y-extents (en `CSize` unités logiques) comme objet.

## <a name="cdcgetwindoworg"></a><a name="getwindoworg"></a>CDC::GetWindowOrg

Récupère les coordonnées x et y de l’origine de la fenêtre associée au contexte de l’appareil.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Valeur de retour

L’origine de la fenêtre (dans `CPoint` les coordonnées logiques) comme objet.

## <a name="cdcgetworldtransform"></a><a name="getworldtransform"></a>CDC::GetWorldTransform

Récupère la transformation actuelle de l’espace mondial en espace de page.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Paramètres

*rXforme*<br/>
Référence à une structure [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) qui reçoit l’espace mondial actuel à la transformation de l’espace de page.

### <a name="return-value"></a>Valeur de retour

Retourne une valeur non zéro sur le succès.

Retourne 0 sur l’échec.

Pour obtenir des informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Notes

Cette méthode enveloppe la fonction Windows GDI [GetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform).

## <a name="cdcgradientfill"></a><a name="gradientfill"></a>CDC::GradientFill

Appelez cette fonction de membre pour remplir les structures de rectangle et de triangle avec la couleur qui s’estompe en douceur d’un côté à l’autre.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Paramètres

*pVertices (pVertices)*<br/>
Pointeur vers un tableau de structures [TRIVERTEX](/windows/win32/api/wingdi/ns-wingdi-trivertex) qui définissent chacune un vertx triangle.

*nVertices (nVertices)*<br/>
Le nombre de vertices.

*pMesh (en)*<br/>
Array de structures [GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle) en mode triangle, ou une gamme de structures [GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect) en mode rectangle.

*nMeshElements*<br/>
Le nombre d’éléments (triangles ou rectangles) dans *pMesh*.

*dwMode dwMode*<br/>
Spécifie le mode de remplissage de gradient. Pour une liste de valeurs possibles, voir [GradientFill](/windows/win32/api/wingdi/nf-wingdi-gradientfill) dans le SDK Windows.

### <a name="return-value"></a>Valeur de retour

TRUE en cas de réussite, sinon FALSE.

### <a name="remarks"></a>Notes

Pour plus d’informations, voir `GradientFill` dans le SDK Windows.

## <a name="cdcgraystring"></a><a name="graystring"></a>CDC::GrayString

Dessine le texte tamisé (gris) à l’endroit donné en écrivant le texte dans une bitmap de mémoire, en graduant la bitmap, puis en copiant la bitmap à l’écran.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Paramètres

*pBrush*<br/>
Identifie la brosse à utiliser pour la gradation (grisonnant).

*lpfnOutput*<br/>
Spécifie l’adresse d’instance de procédure de la fonction de rappel fournie par l’application qui tirera la chaîne. Pour plus d’informations, voir `OutputFunc` la description de la fonction de [rappel](callback-functions-used-by-mfc.md#graystring)Windows . Si ce paramètre est NULL, `TextOut` le système utilise la fonction Windows pour dessiner la chaîne, et *lpData* est supposé être un long pointeur à la chaîne de caractère pour être la sortie.

*lpData (lpData)*<br/>
Spécifie un pointeur lointain sur les données à transmettre à la fonction de sortie. Si *lpfnOutput* est NULL, *lpData* doit être un long pointeur à la chaîne pour être la sortie.

*nCompte*<br/>
Spécifie le nombre de caractères à produire. Si ce paramètre `GrayString` est de 0, calcule la longueur de la chaîne (en supposant que *lpData* est un pointeur à la chaîne). Si *nCount* est 1 et la fonction indiquée par *lpfnOutput* retourne 0, l’image est montrée mais pas tamisée.

*x*<br/>
Spécifie la x-coordonnées logique de la position de départ du rectangle qui entoure la chaîne.

*y*<br/>
Spécifie la logique y-coordinate de la position de départ du rectangle qui entoure la chaîne.

*nWidth (en)*<br/>
Spécifie la largeur (en unités logiques) du rectangle qui entoure la chaîne. Si *nWidth* est `GrayString` 0, calcule la largeur de la zone, en supposant *lpData* est un pointeur à la chaîne.

*nHeight (en)*<br/>
Spécifie la hauteur (en unités logiques) du rectangle qui entoure la chaîne. Si *nHeight* est `GrayString` 0, calcule la hauteur de la zone, en supposant *lpData* est un pointeur à la chaîne.

### <a name="return-value"></a>Valeur de retour

Nonzero si la chaîne est dessinée, `TextOut` ou 0 si la fonction ou la fonction de sortie fournie par l’application retourné 0, ou s’il n’y avait pas suffisamment de mémoire pour créer un bitmap mémoire pour gradation.

### <a name="remarks"></a>Notes

La fonction assombrit le texte indépendamment de la brosse et de l’arrière-plan sélectionnés. La `GrayString` fonction membre utilise la police actuellement sélectionnée. Le mode de cartographie MM_TEXT doit être sélectionné avant d’utiliser cette fonction.

Une application peut dessiner des chaînes tamisées (grisées) sur des `GrayString` appareils qui prennent en charge une couleur grise solide sans appeler la fonction du membre. La couleur du système COLOR_GRAYTEXT est la couleur du système gris-solide utilisé pour dessiner du texte désactivé. L’application peut `GetSysColor` appeler la fonction Windows pour récupérer la valeur de couleur de COLOR_GRAYTEXT. Si la couleur est autre que 0 (noir), l’application peut appeler la `SetTextColor` fonction membre pour définir la couleur du texte à la valeur de couleur, puis dessiner la chaîne directement. Si la couleur récupérée est noire, l’application doit appeler `GrayString` pour assombrir (gris) le texte.

Si *lpfnOutput* est NULL, GDI utilise la fonction [TextOut](/windows/win32/api/wingdi/nf-wingdi-textoutw) Windows, et *lpData* est supposé être un pointeur lointain pour le personnage d’être la sortie. Si les caractères à produire ne `TextOut` peuvent pas être manipulés par la fonction membre (par exemple, la chaîne est stockée sous forme de bitmap), l’application doit fournir sa propre fonction de sortie.

Notez également que toutes les fonctions de rappel doivent piéger les exceptions de la Fondation Microsoft avant de revenir à Windows, puisque les exceptions ne peuvent pas être jetées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, voir l’article [Exceptions](../../mfc/exception-handling-in-mfc.md).

La fonction de `GrayString` rappel adoptée `__stdcall` doit utiliser la `__declspec`convention d’appel et doit être exportée avec .

Lorsque le cadre est en mode `GrayString` aperçu, un appel `TextOut` à la fonction membre est traduit en appel, et la fonction de rappel n’est pas appelée.

## <a name="cdchimetrictodp"></a><a name="himetrictodp"></a>CDC::HIMETRICtoDP

Utilisez cette fonction lorsque vous convertissez les tailles HIMETRIC d’OLE en pixels.

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*lpSize*<br/>
Indique une structure [SIZE](/windows/win32/api/windef/ns-windef-size) ou un objet [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Notes

Si le mode de cartographie de l’objet contextuelle de l’appareil est MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC ou MM_HIMETRIC, la conversion est basée sur le nombre de pixels dans le pouce physique. Si le mode de cartographie est l’un des autres modes non contraints (par exemple, MM_TEXT), la conversion est basée sur le nombre de pixels dans le pouce logique.

## <a name="cdchimetrictolp"></a><a name="himetrictolp"></a>CDC::HIMETRICtoLP

Appelez cette fonction pour convertir les unités HIMETRIC en unités logiques.

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*lpSize*<br/>
Indique une structure [SIZE](/windows/win32/api/windef/ns-windef-size) ou un objet [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Notes

Utilisez cette fonction lorsque vous obtenez des tailles HIMETRIC à partir d’OLE et souhaitez les convertir en mode de cartographie naturelle de votre application.

La conversion est effectuée en convertissant d’abord les unités HIMETRIC en pixels, puis en convertissant ces unités en unités logiques à l’aide des unités de cartographie actuelles du contexte de l’appareil. Notez que les étendues de la fenêtre et du viewport de l’appareil auront une incidence sur le résultat.

## <a name="cdcintersectcliprect"></a><a name="intersectcliprect"></a>CDC::IntersectClipRect

Crée une nouvelle région de coupure en formant l’intersection de la région actuelle et le rectangle spécifié par *x1*, *y1*, *x2*, et *y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la logique x-coordonner le coin supérieur gauche du rectangle.

*y1 (en)*<br/>
Spécifie la logique y-coordinate du coin supérieur gauche du rectangle.

*x2*<br/>
Spécifie la logique x-coordonner le coin inférieur droit du rectangle.

*y2*<br/>
Spécifie la logique y-coordinate du coin inférieur droit du rectangle.

*lpRect*<br/>
Spécifie le rectangle. Vous pouvez passer `CRect` soit un objet `RECT` ou un pointeur à une structure pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Le nouveau type de région de coupure. Il peut s’agir de l’une des valeurs suivantes :

- COMPLEXREGION Nouvelle région de coupure a des frontières qui se chevauchent.

- Le contexte de l’appareil ERROR n’est pas valide.

- NULLREGION Nouvelle région de coupure est vide.

- SIMPLEREGION La nouvelle région de coupure n’a pas de frontières qui se chevauchent.

### <a name="remarks"></a>Notes

GDI clips toute sortie ultérieure pour s’adapter à l’intérieur de la nouvelle limite. La largeur et la hauteur ne doivent pas dépasser 32 767.

## <a name="cdcinvertrect"></a><a name="invertrect"></a>CDC::InvertRect

Inverse le contenu du rectangle donné.

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Points à `RECT` un qui contient les coordonnées logiques du rectangle à inverser. Vous pouvez également `CRect` passer un objet pour ce paramètre.

### <a name="remarks"></a>Notes

L’inversion est une opération logique PAS et retourne les bits de chaque pixel. Sur les écrans monochromes, la fonction rend les pixels blancs en noir et noir en blanc. Sur les affichages de couleur, l’inversion dépend de la façon dont les couleurs sont générées pour l’affichage. Appeler `InvertRect` deux fois avec le même rectangle restaure l’affichage à ses couleurs précédentes.

Si le rectangle est vide, rien n’est dessiné.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

## <a name="cdcinvertrgn"></a><a name="invertrgn"></a>CDC::InvertRgn

Invertit les couleurs de la région spécifiées par *pRgn*.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Paramètres

*pRgn (en)*<br/>
Identifie la région à inverser. Les coordonnées de la région sont spécifiées dans des unités logiques.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Sur les écrans monochromes, la fonction rend les pixels blancs en noir et noir en blanc. Sur les affichages de couleur, l’inversion dépend de la façon dont les couleurs sont générées pour l’affichage.

## <a name="cdcisprinting"></a><a name="isprinting"></a>CDC::IsPrinting

Détermine si le contexte de l’appareil est utilisé pour l’impression.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Valeur de retour

Nonzero si `CDC` l’objet est une imprimante DC; sinon 0.

## <a name="cdclineto"></a><a name="lineto"></a>CDC::LineTo

Trace une ligne de la position actuelle jusqu’à, mais sans inclure, le point spécifié par *x* et *y* (ou *point*).

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordonnées logique du point de terminaison de la ligne.

*y*<br/>
Spécifie la logique y-coordinate du point de terminaison pour la ligne.

*Point*<br/>
Spécifie le point de terminaison de la ligne. Vous pouvez passer `POINT` une structure `CPoint` ou un objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Nonzero si la ligne est tracée; sinon 0.

### <a name="remarks"></a>Notes

La ligne est tracée avec le stylo sélectionné. La position actuelle est définie à *x*, *y* ou au *point*.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdclptodp"></a><a name="lptodp"></a>CDC::LPtoDP

Convertit les unités logiques en unités d’appareils.

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*lpPoints (en)*<br/>
Points à un éventail de points. Chaque point du tableau est une structure [POINT](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*nCompte*<br/>
Le nombre de points dans le tableau.

*lpRect*<br/>
Indique une structure [RECT](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect.](../../atl-mfc-shared/reference/crect-class.md) Ce paramètre est utilisé pour le cas commun de cartographier un rectangle de logique à des unités d’appareil.

*lpSize*<br/>
Indique une structure [SIZE](/windows/win32/api/windef/ns-windef-size) ou un objet [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Notes

La fonction cartographie les coordonnées de chaque point, ou dimensions d’une taille, du système de coordonnées logiques de GDI dans un système de coordonnées de périphérique. La conversion dépend du mode de cartographie actuel et des paramètres des origines et des étendues de la fenêtre et du viewport de l’appareil.

Les x- et y-coordonnées des points sont des intégrants signés à 2 byte dans la gamme -32 768 à 32 767. Dans les cas où le mode de cartographie se traduirait par des valeurs plus grandes que ces limites, le système fixe les valeurs à -32 768 et 32 767, respectivement.

## <a name="cdclptohimetric"></a><a name="lptohimetric"></a>CDC::LPtoHIMETRIC

Appelez cette fonction pour convertir les unités logiques en unités HIMETRIC.

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*lpSize*<br/>
Indique une `SIZE` structure `CSize` ou un objet.

### <a name="remarks"></a>Notes

Utilisez cette fonction lorsque vous donnez des tailles HIMETRIC à OLE, en convertissant à partir du mode de cartographie naturelle de votre application. Notez que les étendues de la fenêtre et du viewport de l’appareil auront une incidence sur le résultat.

La conversion est effectuée en convertissant d’abord les unités logiques en pixels à l’aide des unités de cartographie actuelles du contexte de l’appareil, puis en convertissant ces unités en unités HIMETRIC.

## <a name="cdcm_hattribdc"></a><a name="m_hattribdc"></a>CDC::m_hAttribDC

Le contexte du `CDC` dispositif d’attribut pour cet objet.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Notes

Par défaut, ce contexte `m_hDC`de périphérique est égal à . En général, `CDC` les appels GDI qui demandent `m_hAttribDC`des informations à partir du contexte de l’appareil sont dirigés vers . Consultez la description de la classe [CDC](../../mfc/reference/cdc-class.md) pour en savoir plus sur l’utilisation de ces deux contextes d’appareils.

## <a name="cdcm_hdc"></a><a name="m_hdc"></a>CDC::m_hDC

Le contexte du `CDC` périphérique de sortie pour cet objet.

```
HDC m_hDC;
```

### <a name="remarks"></a>Notes

Par défaut, `m_hDC` est `m_hAttribDC`égal à , `CDC`l’autre contexte de périphérique enveloppé par . En général, `CDC` les appels GDI `m_hDC` qui créent la sortie vont au contexte de l’appareil. Vous pouvez `m_hDC` initialiser et `m_hAttribDC` pointer vers différents appareils. Consultez la description de la classe [CDC](../../mfc/reference/cdc-class.md) pour en savoir plus sur l’utilisation de ces deux contextes d’appareils.

## <a name="cdcmaskblt"></a><a name="maskblt"></a>CDC::MaskBlt

Combine les données de couleur pour les bitmaps source et destination à l’aide du masque donné et de l’opération raster.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la logique x-coordonner le coin supérieur gauche du rectangle de destination.

*y*<br/>
Spécifie la logique y-coordinate du coin supérieur gauche du rectangle de destination.

*nWidth (en)*<br/>
Spécifie la largeur, en unités logiques, du rectangle de destination et de la bitmap source.

*nHeight (en)*<br/>
Spécifie la hauteur, en unités logiques, du rectangle de destination et de la bitmap source.

*pSrcDC (en)*<br/>
Identifie le contexte de l’appareil à partir duquel la bitmap doit être copiée. Il doit être nul si le paramètre *dwRop* spécifie une opération de raster qui n’inclut pas de source.

*xSrc (en)*<br/>
Spécifie la logique x-coordonner le coin supérieur gauche de la bitmap source.

*ySrc (en)*<br/>
Specifie la logique y-coordinate du coin supérieur gauche de la bitmap source.

*masqueBitmap*<br/>
Identifie le bitmap masque monochrome combiné avec la bitmap couleur dans le contexte de l’appareil source.

*xMask xMask*<br/>
Spécifie le décalage horizontal de pixel pour le bitmap de masque spécifié par le *paramètre maskBitmap.*

*yMask yMask*<br/>
Spécifie le décalage verticaux pour le bitmap masque spécifié par le *paramètre maskBitmap.*

*dwRop*<br/>
Spécifie à la fois les codes d’opération de raster ternaires au premier plan et de fond, que la fonction utilise pour contrôler la combinaison des données de source et de destination. Le code d’opération raster de fond est stocké dans le haut-byte du mot élevé de cette valeur ; le code d’opération raster au premier plan est stocké dans le faible byte du mot élevé de cette valeur; le mot faible de cette valeur est ignoré, et devrait être nul. La macro MAKEROP4 crée de telles combinaisons de codes d’opération de raster de premier plan et de fond. Consultez la section Remarques pour une discussion sur le premier plan et le contexte dans le contexte de cette fonction. Consultez `BitBlt` la fonction de membre pour une liste des codes d’opération de raster communs.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Une valeur de 1 dans le masque spécifié par *maskBitmap* indique que le code d’opération raster au premier plan spécifié par *dwRop* doit être appliqué à cet endroit. Une valeur de 0 dans le masque indique que le code d’opération de raster de fond spécifié par *dwRop* doit être appliqué à cet endroit. Si les opérations de raster nécessitent une source, le rectangle de masque doit couvrir le rectangle source. Si ce n’est pas le cas, la fonction échouera. Si les opérations de raster ne nécessitent pas de source, le rectangle de masque doit couvrir le rectangle de destination. Si ce n’est pas le cas, la fonction échouera.

Si une rotation ou une transformation de cisaillement est en vigueur pour le contexte de l’appareil source lorsque cette fonction est appelée, une erreur se produit. Cependant, d’autres types de transformations sont autorisés.

Si les formats de couleur de la source, du modèle et des bitmaps de destination diffèrent, cette fonction convertit le modèle ou le format source, ou les deux, pour correspondre au format de destination. Si le bitmap masque n’est pas une bitmap monochrome, une erreur se produit. Lorsqu’un métaafile amélioré est enregistré, une erreur se produit (et la fonction renvoie 0) si le contexte de l’appareil source identifie un contexte de périphérique amélioré. Pas tous `MaskBlt`les appareils de prise en charge . Une application `GetDeviceCaps` doit appeler pour déterminer si un appareil prend en charge cette fonction. Si aucun bitmap de masque n’est `BitBlt`fourni, cette fonction se comporte exactement comme, en utilisant le code d’opération raster de premier plan. Le pixel compense dans la carte de bitmap masque au point (0,0) dans le bitmap du contexte de l’appareil source. Ceci est utile pour les cas où un bitmap masque contient un ensemble de masques; une application peut facilement appliquer n’importe lequel d’entre eux à une tâche de `MaskBlt`masque-blitting en ajustant les décalages de pixel et les tailles de rectangle envoyé à .

## <a name="cdcmodifyworldtransform"></a><a name="modifyworldtransform"></a>CDC::ModifierWorldTransform

Modifications de la transformation du monde pour un contexte d’appareil en utilisant le mode spécifié.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Paramètres

*rXforme*<br/>
Référence à une structure [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) utilisée pour modifier la transformation du monde pour le contexte donné de l’appareil.

*Imode*<br/>
Précise comment les données de transformation modifient la transformation mondiale actuelle. Pour une liste des valeurs que ce paramètre peut prendre, voir [ModifierWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Valeur de retour

Retourne une valeur non zéro sur le succès.

Retourne 0 sur l’échec.

Pour obtenir des informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Notes

Cette méthode enveloppe la fonction GDI Windows [ModifierWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

## <a name="cdcmoveto"></a><a name="moveto"></a>CDC::MoveTo

Déplace la position actuelle au point spécifié par *x* et *y* (ou par *point*).

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordination logique de la nouvelle position.

*y*<br/>
Spécifie la logique y-coordinate de la nouvelle position.

*Point*<br/>
Spécifie la nouvelle position. Vous pouvez passer `POINT` une structure `CPoint` ou un objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Les coordonnées x et y de la `CPoint` position précédente en tant qu’objet.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdcoffsetcliprgn"></a><a name="offsetcliprgn"></a>CDC::OffsetClipRgn

Déplace la région de coupure du contexte de l’appareil par les décalages spécifiés.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie le nombre d’unités logiques pour se déplacer à gauche ou à droite.

*y*<br/>
Spécifie le nombre d’unités logiques à déplacer vers le haut ou vers le bas.

*Taille*<br/>
Spécifie le montant à compenser.

### <a name="return-value"></a>Valeur de retour

Le type de la nouvelle région. Il peut s’agir de l’une des valeurs suivantes :

- COMPLEXREGION La région de coupure a des frontières qui se chevauchent.

- Le contexte de l’appareil ERROR n’est pas valide.

- NULLREGION La région de clip est vide.

- LA région de clip DE SIMPLEREGION n’a pas de frontières qui se chevauchent.

### <a name="remarks"></a>Notes

La fonction déplace la région *x* unités le long de l’axe x et *y* unités le long de l’axe y.

## <a name="cdcoffsetviewportorg"></a><a name="offsetviewportorg"></a>CDC::OffsetViewportOrg

Modifie les coordonnées de l’origine du viewport par rapport aux coordonnées de l’origine actuelle du port de vue.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Paramètres

*nWidth (en)*<br/>
Spécifie le nombre d’unités d’appareils à ajouter à la x-coordonnées de l’origine actuelle.

*nHeight (en)*<br/>
Spécifie le nombre d’unités d’appareils à ajouter à la y-coordinate de l’origine actuelle.

### <a name="return-value"></a>Valeur de retour

L’origine précédente du port de vue `CPoint` (dans les coordonnées de l’appareil) en tant qu’objet.

## <a name="cdcoffsetwindoworg"></a><a name="offsetwindoworg"></a>CDC::OffsetWindowOrg

Modifie les coordonnées de l’origine de la fenêtre par rapport aux coordonnées de l’origine actuelle de la fenêtre.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Paramètres

*nWidth (en)*<br/>
Spécifie le nombre d’unités logiques à ajouter à la x-coordonnées de l’origine actuelle.

*nHeight (en)*<br/>
Spécifie le nombre d’unités logiques à ajouter à la y-coordinate de l’origine actuelle.

### <a name="return-value"></a>Valeur de retour

L’origine de fenêtre précédente (dans `CPoint` les coordonnées logiques) comme objet.

## <a name="cdcoperator-hdc"></a><a name="operator_hdc"></a>CDC::opérateur HDC

Utilisez cet opérateur pour récupérer la `CDC` poignée de contexte de l’objet.

```
operator HDC() const;
```

### <a name="return-value"></a>Valeur de retour

En cas de succès, la poignée de l’objet contextuelle de l’appareil; autrement, NULL.

### <a name="remarks"></a>Notes

Vous pouvez utiliser la poignée pour appeler directement les API Windows.

## <a name="cdcpaintrgn"></a><a name="paintrgn"></a>CDC::PaintRgn

Remplit la région spécifiée par *pRgn* à l’aide de la brosse actuelle.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Paramètres

*pRgn (en)*<br/>
Identifie la région à remplir. Les coordonnées de la région donnée sont spécifiées dans des unités logiques.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

## <a name="cdcpatblt"></a><a name="patblt"></a>CDC::PatBlt

Crée un peu de motif sur l’appareil.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la logique x-coordonner le coin supérieur gauche du rectangle qui doit recevoir le motif.

*y*<br/>
Spécifie la logique y-coordinate du coin supérieur gauche du rectangle qui doit recevoir le motif.

*nWidth (en)*<br/>
Spécifie la largeur (en unités logiques) du rectangle qui doit recevoir le motif.

*nHeight (en)*<br/>
Spécifie la hauteur (dans les unités logiques) du rectangle qui doit recevoir le motif.

*dwRop*<br/>
Spécifie le code d’opération raster. Les codes d’exploitation raster (ROP) définissent comment GDI combine des couleurs dans les opérations de sortie qui impliquent un pinceau actuel, une source possible de bitmap et une bitmap de destination. Ce paramètre peut être l’une des valeurs suivantes :

- PATCOPY Copies modèle à destination bitmap.

- PATINVERT Combine la bitmap de destination avec le modèle utilisant l’opérateur Boolean XOR.

- DSTINVERT inverse la bitmap de destination.

- BLACKNESS Tourne tout le produit noir.

- WHITENESS Tourne tous les blancs de sortie.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le modèle est une combinaison de la brosse sélectionnée et le modèle déjà sur l’appareil. Le code raster-opération spécifié par *dwRop* définit comment les modèles doivent être combinés. Les opérations de raster énumérées pour cette fonction sont un sous-ensemble limité des 256 codes d’exploitation de rasters ternaires complets ; en particulier, un code d’exploitation raster qui se réfère à une source ne peut pas être utilisé.

Tous les contextes `PatBlt` de périphérique ne prennent pas en charge la fonction. Pour déterminer si le `PatBlt`contexte `GetDeviceCaps` de l’appareil prend en charge, appelez la fonction membre avec l’index RASTERCAPS et vérifiez la valeur de retour pour le drapeau RC_BITBLT.

## <a name="cdcpie"></a><a name="pie"></a>CDC::Pie

Dessine un coin en forme de tarte en dessinant un arc elliptique dont le centre et deux points de terminaison sont rejoints par des lignes.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la x-coordonnées du coin supérieur gauche du rectangle de délimitation (dans les unités logiques).

*y1 (en)*<br/>
Spécifie la y-coordonnées du coin supérieur gauche du rectangle de délimitation (dans les unités logiques).

*x2*<br/>
Spécifie la x-coordonnées du coin inférieur droit du rectangle de délimitation (en unités logiques).

*y2*<br/>
Spécifie la y-coordonnées du coin inférieur droit du rectangle de délimitation (en unités logiques).

*x3*<br/>
Spécifie la x-coordonner le point de départ de l’arc (en unités logiques). Ce point n’a pas à se trouver exactement sur l’arc.

*y3 (en)*<br/>
Spécifie la y-coordinate du point de départ de l’arc (dans les unités logiques). Ce point n’a pas à se trouver exactement sur l’arc.

*x4*<br/>
Spécifie la x-coordonner le point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se trouver exactement sur l’arc.

*y4*<br/>
Spécifie la y-coordinate du point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se trouver exactement sur l’arc.

*lpRect*<br/>
Spécifie le rectangle de délimitation. Vous pouvez passer `CRect` soit un objet `RECT` ou un pointeur à une structure pour ce paramètre.

*ptStart (en)*<br/>
Spécifie le point de départ de l’arc. Ce point n’a pas à se trouver exactement sur l’arc. Vous pouvez passer une structure [POINT](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) pour ce paramètre.

*ptEnd*<br/>
Spécifie le point final de l’arc. Ce point n’a pas à se trouver exactement sur l’arc. Vous pouvez passer `POINT` une structure `CPoint` ou un objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le centre de l’arc est le centre du rectangle de délimitation spécifié par *x1*, *y1*, *x2*, et *y2* (ou par *lpRect*). Les points de départ et de fin de l’arc sont spécifiés par *x3*, *y3*, *x4*, et *y4* (ou par *ptStart* et *ptEnd*).

L’arc est dessiné avec le stylo sélectionné, se déplaçant dans une direction dans le sens inverse des aiguilles d’une montre. Deux lignes supplémentaires sont tirées de chaque point de terminaison au centre de l’arc. La zone en forme de tarte est remplie de la brosse actuelle. Si *x3* égale *x4* et *y3* égale *y4*, le résultat est une ellipse avec une seule ligne du centre de l’ellipse au point ( *x3*, *y3*) ou ( *x4*, *y4*).

La figure dessinée par cette fonction s’étend jusqu’à mais n’inclut pas les coordonnées droite et inférieure. Cela signifie que la hauteur de la figure est *y2* - *y1* et la largeur de la figure est *x2* - *x1*. La largeur et la hauteur du rectangle de délimitation doivent être supérieures à 2 unités et moins de 32 767 unités.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

## <a name="cdcplaymetafile"></a><a name="playmetafile"></a>CDC::PlayMetaFile

Joue le contenu du métaafile spécifié sur le contexte de l’appareil.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Paramètres

*Hmf*<br/>
Identifie le metafile à jouer.

*hEnhMetaFile*<br/>
Identifie le métaafile amélioré.

*lpBounds (lpBounds)*<br/>
Indique une `RECT` structure `CRect` ou un objet qui contient les coordonnées du rectangle de délimitation utilisé pour afficher l’image. Les coordonnées sont spécifiées dans des unités logiques.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le metafile peut être joué n’importe quel nombre de fois.

La deuxième `PlayMetaFile` version de l’image affiche l’image stockée dans le métaafile de format amélioré donné. Lorsqu’une application appelle `PlayMetaFile`la deuxième version de , Windows utilise le cadre d’image dans l’en-tête amélioré-metafile pour cartographier l’image sur le rectangle pointé par le paramètre *lpBounds.* (Cette image peut être cisaillement ou tournée en définissant `PlayMetaFile`le monde transformer dans le dispositif de sortie avant d’appeler .) Les points le long des bords du rectangle sont inclus dans l’image. Une image améliorée-metafile peut être coupée en définissant la région de coupure dans le dispositif de sortie avant de jouer le metafile amélioré.

Si un métaafile amélioré contient une palette facultative, une application peut atteindre des couleurs `PlayMetaFile`cohérentes en mettant en place une palette de couleurs sur le périphérique de sortie avant d’appeler la deuxième version de . Pour récupérer la palette `GetEnhMetaFilePaletteEntries` facultative, utilisez la fonction Windows. Un métaafile amélioré peut être intégré dans un métaafile `PlayMetaFile` amélioré nouvellement créé en appelant la deuxième version et en jouant la source améliorée metafile dans le contexte de l’appareil pour le nouveau metafile amélioré.

Les états du contexte du périphérique de sortie sont préservés par cette fonction. Tout objet créé mais non supprimé dans le métadafile amélioré est supprimé par cette fonction. Pour arrêter cette fonction, une `CancelDC` application peut appeler la fonction Windows à partir d’un autre thread pour mettre fin à l’opération. Dans ce cas, la fonction renvoie zéro.

## <a name="cdcplgblt"></a><a name="plgblt"></a>CDC::PlgBlt

Effectue un transfert de bit-bloc des bits de données de couleur à partir du rectangle spécifié dans le contexte de l’appareil source au parallélogramme spécifié dans le contexte du périphérique donné.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Paramètres

*lpPoint (en)*<br/>
Points à un tableau de trois points dans l’espace logique qui identifie trois coins du parallélogramme de destination. Le coin supérieur gauche du rectangle source est cartographié au premier point de ce tableau, le coin supérieur droit au deuxième point de ce tableau, et le coin inférieur gauche au troisième point. Le coin inférieur droit du rectangle source est cartographié au quatrième point implicite du parallélogramme.

*pSrcDC (en)*<br/>
Identifie le contexte de l’appareil source.

*xSrc (en)*<br/>
Spécifie le x-coordonner, dans les unités logiques, du coin supérieur gauche du rectangle source.

*ySrc (en)*<br/>
Spécifie le y-coordinate, dans les unités logiques, du coin supérieur gauche du rectangle source.

*nWidth (en)*<br/>
Spécifie la largeur, en unités logiques, du rectangle source.

*nHeight (en)*<br/>
Spécifie la hauteur, en unités logiques, du rectangle source.

*masqueBitmap*<br/>
Identifie une bitmap monochrome en option qui est utilisée pour masquer les couleurs du rectangle source.

*xMask xMask*<br/>
Spécifie la x-coordonner le coin supérieur gauche de la bitmap monochrome.

*yMask yMask*<br/>
Spécifie la y-coordinate du coin supérieur gauche de la bitmap monochrome.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Si la poignée de bitmask donnée identifie une bitmap monochrome valide, la fonction utilise cette bitmap pour masquer les bits de données de couleur du rectangle source.

Le quatrième vertéx du parallélogramme (D) est défini en traitant les trois premiers points (A, B et C) comme des vecteurs et l’informatique D - B - C - A.

Si le bitmask existe, une valeur de 1 dans le masque indique que la couleur de pixel source doit être copiée à la destination. Une valeur de 0 dans le masque indique que la couleur pixel de destination ne doit pas être changée.

Si le rectangle de masque est plus petit que les rectangles de source et de destination, la fonction reproduit le modèle de masque.

L’échelle, la traduction et les transformations de réflexion sont autorisées dans le contexte de l’appareil source; cependant, les transformations de rotation et de cisaillement ne le sont pas. Si le bitmap masque n’est pas une bitmap monochrome, une erreur se produit. Le mode d’étirement du contexte de l’appareil de destination est utilisé pour déterminer comment étirer ou comprimer les pixels, si cela est nécessaire. Lorsqu’un métaafile amélioré est enregistré, une erreur se produit si le contexte de l’appareil source identifie un contexte d’appareil amélioré.

Les coordonnées de destination sont transformées en fonction du contexte du périphérique de destination ; les coordonnées sources sont transformées en fonction du contexte du périphérique source. Si la transformation de la source a une rotation ou une cisaillement, une erreur est retournée. Si les rectangles de destination et de `PlgBlt` source n’ont pas le même format de couleur, convertit le rectangle source pour correspondre au rectangle de destination. Pas tous `PlgBlt`les appareils de prise en charge . Pour plus d’informations, consultez la description de la `CDC::GetDeviceCaps` capacité RC_BITBLT raster dans la fonction membre.

Si les contextes de l’appareil `PlgBlt` source et de destination représentent des périphériques incompatibles, renvoie une erreur.

## <a name="cdcpolybezier"></a><a name="polybezier"></a>CDC::PolyBezier

Dessine un ou plusieurs éclats de Bzier.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints (en)*<br/>
Indique un éventail de structures de données [POINT](/windows/win32/api/windef/ns-windef-point) qui contiennent les points de terminaison et les points de contrôle du spline(s).

*nCompte*<br/>
Spécifie le nombre de points dans le tableau *lpPoints.* Cette valeur doit être plus de trois fois le nombre de splines à tirer, parce que chaque spline Bzier nécessite deux points de contrôle et un point de terminaison, et le spline initial nécessite un point de départ supplémentaire.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction dessine des éclats cubiques de Bzier en utilisant les points de terminaison et les points de contrôle spécifiés par le *paramètre lpPoints.* Le premier spline est tiré du premier point au quatrième point en utilisant les deuxième et troisième points comme points de contrôle. Chaque spline ultérieure dans la séquence a besoin exactement de trois points de plus: le point final de la spline précédente est utilisé comme point de départ, les deux points suivants dans la séquence sont des points de contrôle, et le troisième est le point final.

La position actuelle n’est `PolyBezier` ni utilisée ni mise à jour par la fonction. Le chiffre n’est pas rempli. Cette fonction dessine des lignes à l’aide du stylo actuel.

## <a name="cdcpolybezierto"></a><a name="polybezierto"></a>CDC::PolyBezierTo

Dessine un ou plusieurs éclats de Bzier.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints (en)*<br/>
Indique un éventail de structures de données [POINT](/windows/win32/api/windef/ns-windef-point) qui contiennent les points de terminaison et les points de contrôle.

*nCompte*<br/>
Spécifie le nombre de points dans le tableau *lpPoints.* Cette valeur doit être trois fois plus nombre de splines à tirer, car chaque spline Bzier nécessite deux points de contrôle et un point final.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction dessine des éclats cubiques de Bzier en utilisant les points de contrôle spécifiés par le *paramètre lpPoints.* Le premier spline est tiré de la position actuelle au troisième point en utilisant les deux premiers points comme points de contrôle. Pour chaque spline ultérieure, la fonction a besoin exactement de trois points de plus, et utilise le point final de la spline précédente comme point de départ pour le prochain. `PolyBezierTo`déplace la position actuelle au point final du dernier éclat de Bzier. Le chiffre n’est pas rempli. Cette fonction dessine des lignes à l’aide du stylo actuel.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CDC:BeginPath](#beginpath).

## <a name="cdcpolydraw"></a><a name="polydraw"></a>CDC::PolyDraw

Dessine un ensemble de segments de ligne et de splines Bzier.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints (en)*<br/>
Points à un tableau de structures de données [POINT](/windows/win32/api/windef/ns-windef-point) qui contient les points de terminaison pour chaque segment de ligne et les points de terminaison et les points de contrôle pour chaque spline Bzier.

*lpTypes (lpTypes)*<br/>
Points à un tableau qui spécifie comment chaque point dans le tableau *lpPoints* est utilisé. Il peut s'agir de l'une des valeurs suivantes :

- PT_MOVETO précise que ce point commence une figure disjointe. Ce point devient la nouvelle position actuelle.

- PT_LINETO précise qu’une ligne doit être tracée de la position actuelle jusqu’à ce point, qui devient alors la nouvelle position actuelle.

- PT_BEZIERTO précise que ce point est un point de contrôle ou un point de fin pour un éclat de Bzier.

PT_BEZIERTO types se produisent toujours dans des ensembles de trois. La position actuelle définit le point de départ du spline Bzier. Les deux premiers points PT_BEZIERTO sont les points de contrôle, et le troisième PT_BEZIERTO point est le point de fin. Le point de fin devient la nouvelle position actuelle. S’il n’y a pas trois points PT_BEZIERTO consécutifs, une erreur résulte.

   Un type PT_LINETO ou PT_BEZIERTO peut être combiné avec la constante suivante en utilisant l’opérateur bitwise OU pour indiquer que le point correspondant est le dernier point d’un chiffre et le chiffre est fermé:

- PT_CLOSEFIGURE précise que le chiffre est automatiquement fermé après que le type PT_LINETO ou PT_BEZIERTO pour ce point est fait. Une ligne est tracée à partir de ce `MoveTo` point à la plus récente PT_MOVETO ou point.

   Ce drapeau est combiné avec le type PT_LINETO pour une ligne, ou avec le type PT_BEZIERTO de point de fin pour un spline Bzier, en utilisant l’opérateur **bitwise OU.** La position actuelle est réglée au point de fin de la ligne de clôture.

*nCompte*<br/>
Spécifie le nombre total de points dans le tableau *lpPoints,* le même que le nombre d’octets dans le tableau *lpTypes.*

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction peut être utilisée pour dessiner des chiffres `CDC::MoveTo` `CDC::LineTo`disjoints à la place d’appels consécutifs à , , et `CDC::PolyBezierTo` les fonctions des membres. Les lignes et les splines sont dessinées à l’aide du stylo actuel, et les chiffres ne sont pas remplis. S’il ya un chemin `CDC::BeginPath` actif commencé `PolyDraw` par appeler la fonction membre, ajoute au chemin. Les points contenus dans le tableau *lpPoints* et dans *lpTypes* indiquent si chaque point fait partie d’un `CDC::MoveTo`, un `CDC::LineTo`, ou une `CDC::BezierTo` opération. Il est également possible de fermer des chiffres. Cette fonction met à jour la position actuelle.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CDC:BeginPath](#beginpath).

## <a name="cdcpolygon"></a><a name="polygon"></a>CDC::Polygon

Dessine un polygone composé de deux points ou plus (vertices) reliés par des lignes, à l’aide du stylo actuel.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints (en)*<br/>
Points à un éventail de points qui spécifie les vertices du polygone. Chaque point du tableau `POINT` est `CPoint` une structure ou un objet.

*nCompte*<br/>
Spécifie le nombre de vertices dans le tableau.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le système ferme automatiquement le polygone, si nécessaire, en traçant une ligne du dernier vertex au premier.

Le mode de remplissage polygone actuel peut `GetPolyFillMode` être `SetPolyFillMode` récupéré ou réglé en utilisant les fonctions et les fonctions des membres.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

## <a name="cdcpolyline"></a><a name="polyline"></a>CDC::Polyline

Dessine un ensemble de segments de ligne reliant les points spécifiés par *lpPoints*.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints (en)*<br/>
Indique un éventail `POINT` de `CPoint` structures ou d’objets à connecter.

*nCompte*<br/>
Spécifie le nombre de points dans le tableau. Cette valeur doit être d’au moins 2.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Les lignes sont dessinées à partir du premier point à travers les points suivants à l’aide du stylo actuel. Contrairement `LineTo` à la `Polyline` fonction membre, la fonction n’utilise ni ne met à jour la position actuelle.

Pour plus d’informations, voir [PolyLine](/windows/win32/api/wingdi/nf-wingdi-polyline) dans windows SDK.

## <a name="cdcpolylineto"></a><a name="polylineto"></a>CDC::PolylineTo

Dessine une ou plusieurs lignes droites.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints (en)*<br/>
Indique un éventail de structures de données [POINT](/windows/win32/api/windef/ns-windef-point) qui contient les vertices de la ligne.

*nCompte*<br/>
Spécifie le nombre de points dans le tableau.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Une ligne est tracée de la position actuelle au premier point spécifié par le *paramètre lpPoints* à l’aide du stylo actuel. Pour chaque ligne supplémentaire, la fonction puise du point de fin de la ligne précédente au point suivant spécifié par *lpPoints*. `PolylineTo`déplace la position actuelle jusqu’au point de fin de la dernière ligne. Si les segments de ligne dessinés par cette fonction forment une figure fermée, le chiffre n’est pas rempli.

## <a name="cdcpolypolygon"></a><a name="polypolygon"></a>CDC::PolyPolygon

Crée deux polygones ou plus qui sont remplis en utilisant le mode de remplissage actuel du polygone.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints (en)*<br/>
Indique un éventail `POINT` de `CPoint` structures ou d’objets qui définissent les vertices des polygones.

*lpPolyComptes*<br/>
Points à un tableau d’intégrateurs, chacun s’ifie le nombre de points dans l’un des polygones dans le tableau *lpPoints.*

*nCompte*<br/>
Le nombre d’entrées dans le tableau *lpPolyCounts.* Ce nombre précise le nombre de polygones à tirer. Cette valeur doit être d’au moins 2.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Les polygones peuvent être disjoints ou se chevauchent.

Chaque polygon spécifié dans `PolyPolygon` un appel à la fonction doit être fermé. Contrairement aux polygones `Polygon` créés par la fonction `PolyPolygon` membre, les polygones créés par ne sont pas fermés automatiquement.

La fonction crée deux polygones ou plus. Pour créer un seul polygone, `Polygon` une application doit utiliser la fonction membre.

Le mode de remplissage polygone actuel peut `GetPolyFillMode` être `SetPolyFillMode` récupéré ou réglé en utilisant les fonctions et les fonctions des membres.

## <a name="cdcpolypolyline"></a><a name="polypolyline"></a>CDC::PolyPolyline

Dessine plusieurs séries de segments de lignes connectées.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints (en)*<br/>
Points à un tableau de structures qui contient les vertices des polylines. Les polylines sont spécifiées consécutivement.

*lpPolyPoints (en)*<br/>
Indique un éventail de variables spécifiant le nombre de points dans le tableau *lpPoints* pour le polygone correspondant. Chaque entrée doit être supérieure ou égale à 2.

*nCompte*<br/>
Spécifie le nombre total de comptages dans le tableau *lpPolyPoints.*

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Les segments de ligne sont dessinés à l’aide du stylo actuel. Les chiffres formés par les segments ne sont pas remplis. La position actuelle n’est ni utilisée ni mise à jour par cette fonction.

## <a name="cdcptvisible"></a><a name="ptvisible"></a>CDC::PtVisible

Détermine si le point donné se trouve dans la région de coupure du contexte de l’appareil.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordonner logique du point.

*y*<br/>
Spécifie la logique y-coordinate du point.

*Point*<br/>
Spécifie le point d’enregistrement des coordonnées logiques. Vous pouvez passer `POINT` une structure `CPoint` ou un objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Nonzero si le point spécifié se trouve dans la région de coupure; sinon 0.

## <a name="cdcqueryabort"></a><a name="queryabort"></a>CDC::QueryAbort

Appelle la fonction d’interruption installée par la fonction membre [SetAbortProc](#setabortproc) pour une application d’impression et demande si l’impression doit être terminée.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Valeur de retour

La valeur de retour est non zéro si l’impression doit continuer ou s’il n’y a pas de procédure d’interruption. Il est 0 si le travail d’impression doit être résilié. La valeur de retour est fournie par la fonction d’interruption.

## <a name="cdcrealizepalette"></a><a name="realizepalette"></a>CDC::RealizePalette

Cartes entrées de la palette logique actuelle à la palette du système.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Valeur de retour

Indique combien d’entrées dans la palette logique ont été cartographiées à différentes entrées dans la palette du système. Cela représente le nombre d’entrées que cette fonction a remapped pour tenir compte des changements dans la palette du système depuis la dernière palette logique a été réalisé.

### <a name="remarks"></a>Notes

Une palette de couleurs logique agit comme un tampon entre les applications à forte intensité de couleur et le système, permettant à une application d’utiliser autant de couleurs que nécessaire sans interférer avec ses propres couleurs affichées ou avec des couleurs affichées par d’autres fenêtres.

Lorsqu’une fenêtre a la `RealizePalette`mise au point d’entrée et les appels, Windows s’assure que la fenêtre affichera toutes les couleurs demandées, jusqu’au nombre maximum disponible simultanément sur l’écran. Windows affiche également des couleurs que l’on ne trouve pas dans la palette de la fenêtre en les faisant correspondre aux couleurs disponibles.

En outre, Windows correspond aux couleurs demandées par les fenêtres inactives qui appellent la fonction aussi étroitement que possible pour les couleurs disponibles. Cela réduit considérablement les changements indésirables dans les couleurs affichées dans les fenêtres inactives.

## <a name="cdcrectangle"></a><a name="rectangle"></a>CDC::Rectangle

Dessine un rectangle à l’aide du stylo actuel.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la x-coordonnées du coin supérieur gauche du rectangle (dans les unités logiques).

*y1 (en)*<br/>
Spécifie la y-coordonnées du coin supérieur gauche du rectangle (dans les unités logiques).

*x2*<br/>
Spécifie la x-coordonnées du coin inférieur droit du rectangle (en unités logiques).

*y2*<br/>
Spécifie la y-coordonnées du coin inférieur droit du rectangle (en unités logiques).

*lpRect*<br/>
Spécifie le rectangle dans des unités logiques. Vous pouvez passer `CRect` soit un objet `RECT` ou un pointeur à une structure pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

L’intérieur du rectangle est rempli à l’aide de la brosse actuelle.

Le rectangle s’étend jusqu’à, mais ne comprend pas, les coordonnées droite et inférieure. Cela signifie que la hauteur du rectangle est *y2* - *y1* et la largeur du rectangle est *x2* - *x1*. La largeur et la hauteur d’un rectangle doivent être supérieures à 2 unités et moins de 32 767 unités.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

## <a name="cdcrectvisible"></a><a name="rectvisible"></a>CDC::RectVisible

Détermine si une partie du rectangle donné se trouve dans la région de coupure du contexte de l’affichage.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Indique une `RECT` structure `CRect` ou un objet qui contient les coordonnées logiques du rectangle spécifié.

### <a name="return-value"></a>Valeur de retour

Nonzero si une partie du rectangle donné se trouve dans la région de coupure; sinon 0.

## <a name="cdcreleaseattribdc"></a><a name="releaseattribdc"></a>CDC::ReleaseAttribDC

Appelez cette fonction `m_hAttribDC` de membre pour définir à NULL.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Notes

Cela ne provoque `Detach` pas un se produire. Seul le contexte du périphérique `CDC` de sortie est fixé à l’objet, et seul il peut être détaché.

## <a name="cdcreleaseoutputdc"></a><a name="releaseoutputdc"></a>CDC::ReleaseOutputDC

Appelez cette fonction de `m_hDC` membre pour définir le membre à NULL.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Notes

Cette fonction de membre ne peut pas être `CDC` appelée lorsque le contexte du périphérique de sortie est attaché à l’objet. Utilisez `Detach` la fonction membre pour détacher le contexte du périphérique de sortie.

## <a name="cdcresetdc"></a><a name="resetdc"></a>CDC::ResetDC

Appelez cette fonction de membre pour `CDC` mettre à jour le contexte de l’appareil enveloppé par l’objet.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Paramètres

*lpDevMode*<br/>
Un pointeur `DEVMODE` vers une structure Windows.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le contexte de l’appareil est `DEVMODE` mis à jour à partir des informations spécifiées dans la structure Windows. Cette fonction de membre ne réinitialise que le contexte de l’appareil d’attribut.

Une application utilise `ResetDC` généralement la fonction membre `WM_DEVMODECHANGE` lorsqu’une fenêtre traite un message. Vous pouvez également utiliser cette fonction de membre pour modifier l’orientation papier ou les bacs en papier lors de l’impression d’un document.

Vous ne pouvez pas utiliser cette fonction de membre pour modifier le nom du conducteur, le nom de l’appareil ou le port de sortie. Lorsque l’utilisateur modifie la connexion portuaire ou le nom de l’appareil, vous devez supprimer le contexte de l’appareil d’origine et créer un nouveau contexte d’appareil avec les nouvelles informations.

Avant d’appeler cette fonction de membre, vous devez vous assurer que tous les objets (autres que les objets en stock) qui avaient été sélectionnés dans le contexte de l’appareil ont été sélectionnés.

## <a name="cdcrestoredc"></a><a name="restoredc"></a>CDC::RestoreDC

Restaure le contexte de l’appareil à l’état précédent identifié par *nSavedDC*.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Paramètres

*nSavedDC (en)*<br/>
Spécifie le contexte de l’appareil à restaurer. Il peut s’agir d’une valeur retournée par un appel de fonction précédent. `SaveDC` Si *nSavedDC* est de -1, le contexte de l’appareil le plus récemment enregistré est restauré.

### <a name="return-value"></a>Valeur de retour

Nonzero si le contexte spécifié a été restauré; sinon 0.

### <a name="remarks"></a>Notes

`RestoreDC`restaure le contexte de l’appareil en faisant `SaveDC` éclater les informations d’état d’une pile créée par des appels antérieurs à la fonction membre.

La pile peut contenir les informations d’état pour plusieurs contextes d’appareils. Si le contexte spécifié par *nSavedDC* n’est `RestoreDC` pas en haut de la pile, supprime toutes les informations d’état entre le contexte de l’appareil spécifié par *nSavedDC* et le haut de la pile. Les informations supprimées sont perdues.

## <a name="cdcroundrect"></a><a name="roundrect"></a>CDC::RoundRect

Dessine un rectangle avec des coins arrondis à l’aide du stylo actuel.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la x-coordonnées du coin supérieur gauche du rectangle (dans les unités logiques).

*y1 (en)*<br/>
Spécifie la y-coordonnées du coin supérieur gauche du rectangle (dans les unités logiques).

*x2*<br/>
Spécifie la x-coordonnées du coin inférieur droit du rectangle (en unités logiques).

*y2*<br/>
Spécifie la y-coordonnées du coin inférieur droit du rectangle (en unités logiques).

*x3*<br/>
Spécifie la largeur de l’ellipse utilisée pour dessiner les coins arrondis (en unités logiques).

*y3 (en)*<br/>
Spécifie la hauteur de l’ellipse utilisée pour dessiner les coins arrondis (en unités logiques).

*lpRect*<br/>
Spécifie le rectangle de délimitation dans les unités logiques. Vous pouvez passer `CRect` soit un objet `RECT` ou un pointeur à une structure pour ce paramètre.

*Point*<br/>
La x-coordonnatrice du *point* spécifie la largeur de l’ellipse pour dessiner les coins arrondis (en unités logiques). La y-coordinate du *point* spécifie la hauteur de l’ellipse pour dessiner les coins arrondis (dans les unités logiques). Vous pouvez passer `POINT` une structure `CPoint` ou un objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

L’intérieur du rectangle est rempli à l’aide de la brosse actuelle.

La figure que cette fonction dessine s’étend jusqu’à mais n’inclut pas les coordonnées droite et inférieure. Cela signifie que la hauteur de la figure est *y2* - *y1* et la largeur de la figure est *x2* - *x1*. La hauteur et la largeur du rectangle de délimitation doivent être supérieures à 2 unités et moins de 32 767 unités.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

## <a name="cdcsavedc"></a><a name="savedc"></a>CDC::SaveDC

Enregistre l’état actuel du contexte de l’appareil en copiant les informations d’état (telles que la région de coupure, les objets sélectionnés et le mode de cartographie) dans une pile de contexte maintenue par Windows.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Valeur de retour

Un integer identifiant le contexte de l’appareil enregistré. C’est 0 si une erreur se produit. Cette valeur de retour peut être utilisée `RestoreDC`pour restaurer le contexte de l’appareil en appelant .

### <a name="remarks"></a>Notes

Le contexte de l’appareil `RestoreDC`enregistré peut plus tard être restauré en utilisant .

`SaveDC`peut être utilisé n’importe quel nombre de fois pour enregistrer n’importe quel nombre d’états de contexte d’appareil.

## <a name="cdcscaleviewportext"></a><a name="scaleviewportext"></a>CDC::ScaleViewportExt

Modifie les étendues du port de vue par rapport aux valeurs actuelles.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Paramètres

*xNum (en)*<br/>
Spécifie la quantité par laquelle multiplier l’étendue x actuelle.

*xDenom (en)*<br/>
Spécifie le montant par lequel diviser le résultat de la multiplication de l’étendue x actuelle par la valeur du paramètre *xNum.*

*yNum (en)*<br/>
Spécifie la quantité par laquelle multiplier l’étendue y actuelle.

*yDenom yDenom yDenom yDen*<br/>
Spécifie le montant par lequel diviser le résultat de la multiplication de l’étendue y actuelle par la valeur du paramètre *yNum.*

### <a name="return-value"></a>Valeur de retour

Les étendues précédentes du port de `CSize` vue (dans les unités de périphérique) en tant qu’objet.

### <a name="remarks"></a>Notes

Les formules sont écrites comme suit :

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

Les nouvelles étendues de viewport sont calculées en multipliant les étendues actuelles par le numérateur donné, puis en divisant par le dénominateur donné.

## <a name="cdcscalewindowext"></a><a name="scalewindowext"></a>CDC::ScaleWindowExt

Modifie les étendues de fenêtre par rapport aux valeurs actuelles.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Paramètres

*xNum (en)*<br/>
Spécifie la quantité par laquelle multiplier l’étendue x actuelle.

*xDenom (en)*<br/>
Spécifie le montant par lequel diviser le résultat de la multiplication de l’étendue x actuelle par la valeur du paramètre *xNum.*

*yNum (en)*<br/>
Spécifie la quantité par laquelle multiplier l’étendue y actuelle.

*yDenom yDenom yDenom yDen*<br/>
Spécifie le montant par lequel diviser le résultat de la multiplication de l’étendue y actuelle par la valeur du paramètre *yNum.*

### <a name="return-value"></a>Valeur de retour

Les étendues de fenêtre précédentes `CSize` (dans les unités logiques) comme objet.

### <a name="remarks"></a>Notes

Les formules sont écrites comme suit :

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

Les nouvelles étendues de fenêtre sont calculées en multipliant les étendues actuelles par le numérateur donné, puis en divisant par le dénominateur donné.

## <a name="cdcscrolldc"></a><a name="scrolldc"></a>CDC::ScrollDC

Faites défiler un rectangle de bits horizontalement et verticalement.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Paramètres

*Dx*<br/>
Spécifie le nombre d’unités de défilement horizontal.

*Dy*<br/>
Spécifie le nombre d’unités de défilement verticaux.

*lpRectScroll*<br/>
Points à `RECT` la `CRect` structure ou à l’objet qui contient les coordonnées du rectangle de défilement.

*lpRectClip*<br/>
Points à `RECT` la `CRect` structure ou à l’objet qui contient les coordonnées du rectangle de coupure. Lorsque ce rectangle est plus petit que celui d’origine pointé du doigt par *lpRectScroll,* le défilement ne se produit que dans le rectangle plus petit.

*pRgnUpdate (en)*<br/>
Identifie la région découverte par le processus de défilement. La `ScrollDC` fonction définit cette région; ce n’est pas nécessairement un rectangle.

*lpRectUpdate*<br/>
Indique la `RECT` structure `CRect` ou l’objet qui reçoit les coordonnées du rectangle qui limite la région de mise à jour défilante. Il s’agit de la plus grande zone rectangulaire qui nécessite la repeindre. Les valeurs de la structure ou de l’objet lorsque la fonction retourne sont dans les coordonnées du client, quel que soit le mode de cartographie du contexte de l’appareil donné.

### <a name="return-value"></a>Valeur de retour

Nonzero si le défilement est exécuté; sinon 0.

### <a name="remarks"></a>Notes

Si *lpRectUpdate* est NULL, Windows ne calcule pas le rectangle de mise à jour. Si *pRgnUpdate* et *lpRectUpdate* sont NULL, Windows ne calcule pas la région de mise à jour. Si *pRgnUpdate* n’est pas NULL, Windows suppose qu’il contient un pointeur valide `ScrollDC` à la région découverte par le processus de défilement (défini par la fonction membre). La région de mise à jour retournée dans `CWnd::InvalidateRgn` *lpRectUpdate* peut être transmise si nécessaire.

Une application doit `ScrollWindow` utiliser la `CWnd` fonction membre de la classe lorsqu’il est nécessaire de faire défiler toute la zone client d’une fenêtre. Sinon, il `ScrollDC`devrait utiliser .

## <a name="cdcselectclippath"></a><a name="selectclippath"></a>CDC::SelectClipPath

Sélectionne le chemin actuel comme une région de coupure pour le contexte de l’appareil, combinant la nouvelle région avec n’importe quelle région de coupure existante en utilisant le mode spécifié.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Paramètres

*nMode*<br/>
Spécifie la façon d’utiliser le chemin. Les valeurs autorisées sont les suivantes :

- RGN_AND La nouvelle région de coupure comprend l’intersection (zones qui se chevauchent) de la région de coupure actuelle et le chemin actuel.

- RGN_COPY La nouvelle région de coupure est la voie actuelle.

- RGN_DIFF La nouvelle région de coupure comprend les zones de la région de coupure actuelle, et celles de la voie actuelle sont exclues.

- RGN_OR La nouvelle région de coupure comprend l’union (zones combinées) de la région de coupure actuelle et la voie actuelle.

- RGN_XOR La nouvelle région de coupure comprend l’union de la région de coupure actuelle et la voie actuelle, mais sans les zones qui se chevauchent.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le contexte de l’appareil identifié doit contenir un chemin fermé.

## <a name="cdcselectcliprgn"></a><a name="selectcliprgn"></a>CDC::SelectClipRgn

Sélectionne la région donnée comme région de coupure actuelle pour le contexte de l’appareil.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Paramètres

*pRgn (en)*<br/>
Identifie la région à sélectionner.

- Pour la première version de cette fonction, si cette valeur est NULL, toute la zone client est sélectionnée et la sortie est toujours coupée à la fenêtre.

- Pour la deuxième version de cette fonction, cette poignée ne peut être NULL que lorsque le mode RGN_COPY est spécifié.

*nMode*<br/>
Indique l'opération à effectuer. Il doit être l’une des valeurs suivantes :

- RGN_AND La nouvelle région de coupure combine les zones qui se chevauchent de la région de coupure actuelle et la région identifiée par *pRgn*.

- RGN_COPY La nouvelle région de coupure est une copie de la région identifiée par *pRgn*. C’est la fonctionnalité est identique `SelectClipRgn`à la première version de . Si la région identifiée par *pRgn* est NULL, la nouvelle région de coupure devient la région de coupure par défaut (une région nulle).

- RGN_DIFF La nouvelle région de coupure combine les zones de la région de coupure actuelle avec les zones exclues de la région identifiée par *pRgn*.

- RGN_OR La nouvelle région de coupure combine la région de coupure actuelle et la région identifiée par *pRgn*.

- RGN_XOR La nouvelle région de coupure combine la région de coupure actuelle et la région identifiée par *pRgn,* mais exclut tout chevauchement des zones.

### <a name="return-value"></a>Valeur de retour

Le type de région. Il peut s’agir de l’une des valeurs suivantes :

- COMPLEXREGION Nouvelle région de coupure a des frontières qui se chevauchent.

- Le contexte ou la région de l’appareil ERROR n’est pas valide.

- NULLREGION Nouvelle région de coupure est vide.

- SIMPLEREGION La nouvelle région de coupure n’a pas de frontières qui se chevauchent.

### <a name="remarks"></a>Notes

Seule une copie de la région sélectionnée est utilisée. La région elle-même peut être sélectionnée pour n’importe quel nombre d’autres contextes d’appareils, ou elle peut être supprimée.

La fonction suppose que les coordonnées de la région donnée sont spécifiées dans les unités de périphériques. Certains périphériques d’imprimante prennent en charge la sortie de texte à une résolution supérieure à la sortie graphique afin de conserver la précision nécessaire pour exprimer les paramètres de texte. Ces appareils signalent les unités de périphérique à la résolution supérieure, c’est-à-dire dans les unités de texte. Ces appareils ont ensuite mis à l’échelle les coordonnées des graphiques de sorte que plusieurs unités d’appareils signalées carte à seulement 1 unité graphique. Vous devez toujours `SelectClipRgn` appeler la fonction à l’aide d’unités de texte.

Les applications qui doivent prendre la mise à l’échelle des objets graphiques dans le GDI peuvent utiliser l’évasion d’imprimante GETSCALINGFACTOR pour déterminer le facteur de mise à l’échelle. Ce facteur d’échelle affecte la coupure. Si une région est utilisée pour couper des graphiques, GDI divise les coordonnées par le facteur de mise à l’échelle. Si la région est utilisée pour couper du texte, GDI ne fait aucun ajustement de mise à l’échelle. Un facteur d’échelle de 1 fait diviser les coordonnées par 2; un facteur d’échelle de 2 fait diviser les coordonnées par 4; et ainsi de suite.

## <a name="cdcselectobject"></a><a name="selectobject"></a>CDC::SelectObject

Sélectionne un objet dans le contexte de l’appareil.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Paramètres

*pPen (en anglais)*<br/>
Un pointeur à un objet [CPen](../../mfc/reference/cpen-class.md) à sélectionner.

*pBrush*<br/>
Un pointeur à un objet [CBrush](../../mfc/reference/cbrush-class.md) à sélectionner.

*pFont*<br/>
Un pointeur à un objet [CFont](../../mfc/reference/cfont-class.md) à sélectionner.

*pBitmap (en)*<br/>
Un pointeur à un objet [CBitmap](../../mfc/reference/cbitmap-class.md) à sélectionner.

*pRgn (en)*<br/>
Un pointeur à un objet [CRgn](../../mfc/reference/crgn-class.md) à sélectionner.

*pObject*<br/>
Un pointeur à un objet [CGdiObject](../../mfc/reference/cgdiobject-class.md) à sélectionner.

### <a name="return-value"></a>Valeur de retour

Un pointeur sur l’objet remplacé. Il s’agit d’un pointeur à `CGdiObject`un `CPen`objet de l’une des classes dérivées de , tels que , selon la version de la fonction est utilisée. La valeur de retour est NULL en cas d’erreur. Cette fonction peut renvoyer un pointeur à un objet temporaire. Cet objet temporaire n’est valable que pendant le traitement d’un message Windows. Pour plus d’informations, consultez `CGdiObject::FromHandle`.

La version de la fonction membre qui prend un `SelectClipRgn` paramètre de région effectue la même tâche que la fonction de membre. Sa valeur de retour peut être l’une des suivantes :

- COMPLEXREGION Nouvelle région de coupure a des frontières qui se chevauchent.

- Le contexte ou la région de l’appareil ERROR n’est pas valide.

- NULLREGION Nouvelle région de coupure est vide.

- SIMPLEREGION La nouvelle région de coupure n’a pas de frontières qui se chevauchent.

### <a name="remarks"></a>Notes

Class `CDC` propose cinq versions spécialisées pour certains types d’objets GDI, y compris des stylos, des pinceaux, des polices, des bitmaps et des régions. L’objet nouvellement sélectionné remplace l’objet précédent du même type. Par exemple, si *pObject* de `SelectObject` la version générale des points à un objet [CPen,](../../mfc/reference/cpen-class.md) la fonction remplace le stylo actuel avec le stylo spécifié par *pObject*.

Une application peut sélectionner un bitmap dans les contextes de dispositif de mémoire seulement et dans un seul contexte de dispositif de mémoire à la fois. Le format de la bitmap doit être monochrome ou compatible avec le contexte de l’appareil; si ce n’est pas le cas, `SelectObject` renvoie une erreur.

Pour Windows 3.1 et `SelectObject` plus tard, la fonction renvoie la même valeur qu’elle soit utilisée dans un métaafile ou non. Sous les versions `SelectObject` précédentes de Windows, retourné une valeur nonzero pour le succès et 0 pour l’échec quand il a été utilisé dans un métaafile.

## <a name="cdcselectpalette"></a><a name="selectpalette"></a>CDC::SelectPalette

Sélectionne la palette logique qui est spécifiée par *pPalette* comme l’objet de palette sélectionné du contexte de l’appareil.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Paramètres

*pPalette (pPalette)*<br/>
Identifie la palette logique à sélectionner. Cette palette doit déjà avoir `CPalette` été créée avec la fonction membre [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).

*bForceBackground (en)*<br/>
Précise si la palette logique est forcée d’être une palette de fond. Si *bForceBackground* est nonzero, la palette sélectionnée est toujours une palette de fond, peu importe si la fenêtre a la mise au point d’entrée. Si *bForceBackground* est 0 et que le contexte de l’appareil est fixé à une fenêtre, la palette logique est une palette de premier plan lorsque la fenêtre a la mise au point d’entrée.

### <a name="return-value"></a>Valeur de retour

Pointeur d’un `CPalette` objet identifiant la palette logique remplacée par la palette spécifiée par *pPalette.* C’est NULL s’il y a une erreur.

### <a name="remarks"></a>Notes

La nouvelle palette devient l’objet de palette utilisé par GDI pour contrôler les couleurs affichées dans le contexte de l’appareil et remplace la palette précédente.

Une application peut sélectionner une palette logique dans plus d’un contexte d’appareil. Cependant, les modifications apportées à une palette logique affecteront tous les contextes de périphériques pour lesquels il est sélectionné. Si une application sélectionne une palette dans plus d’un contexte d’appareil, les contextes de l’appareil doivent tous appartenir au même appareil physique.

## <a name="cdcselectstockobject"></a><a name="selectstockobject"></a>CDC::SelectStockObject

Sélectionne un objet [CGdiObject](../../mfc/reference/cgdiobject-class.md) qui correspond à l’un des stylos de stock prédéfinis, des brosses ou des polices.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
Spécifie le type d’objet de stock désiré. Ce peut être l’une des valeurs suivantes :

- BLACK_BRUSH brosse noire.

- DKGRAY_BRUSH brosse gris foncé.

- GRAY_BRUSH brosse Grise.

- HOLLOW_BRUSH brosse Hollow.

- LTGRAY_BRUSH brosse gris clair.

- NULL_BRUSH brosse Null.

- WHITE_BRUSH brosse blanche.

- BLACK_PEN stylo noir.

- NULL_PEN stylo Null.

- WHITE_PEN stylo blanc.

- ANSI_FIXED_FONT police du système fixe ANSI.

- ANSI_VAR_FONT police du système variable ANSI.

- DEVICE_DEFAULT_FONT police dépendante de l’appareil.

- OEM_FIXED_FONT police fixe dépendante de l’OEM.

- SYSTEM_FONT La police du système. Par défaut, Windows utilise la police du système pour dessiner des menus, des contrôles de boîte de dialogue et d’autres textes. Il est préférable, cependant, de ne pas compter sur SYSTEM_FONT pour obtenir la police utilisée par les dialogues et les fenêtres. Utilisez plutôt `SystemParametersInfo` la fonction avec le paramètre SPI_GETNONCLIENTMETRICS pour récupérer la police actuelle. `SystemParametersInfo`prend en compte le thème actuel et fournit des informations de police pour les légendes, les menus et les dialogues de messages.

- SYSTEM_FIXED_FONT La police système à largeur fixe utilisée dans Windows avant la version 3.0. Cet objet est disponible pour la compatibilité avec les versions antérieures de Windows.

- DEFAULT_PALETTE palette de couleurs par défaut. Cette palette se compose des 20 couleurs statiques de la palette du système.

### <a name="return-value"></a>Valeur de retour

Un pointeur `CGdiObject` sur l’objet qui a été remplacé si la fonction est réussie. L’objet réel indiqué est un [objet CPen,](../../mfc/reference/cpen-class.md) [CBrush](../../mfc/reference/cbrush-class.md), ou [CFont.](../../mfc/reference/cfont-class.md) Si l’appel est infructueux, la valeur de déclaration est NULL.

## <a name="cdcsetabortproc"></a><a name="setabortproc"></a>CDC::SetAbortProc

Installe la procédure d’interruption pour le travail d’impression.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Paramètres

*lpfn lpfn*<br/>
Un pointeur à la fonction d’interruption d’installer comme procédure d’interruption. Pour en savoir plus sur la fonction de rappel, voir [Callback Function pour CDC::SetAbortProc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Valeur de retour

Spécifie le `SetAbortProc` résultat de la fonction. Certaines des valeurs suivantes sont plus probables que d’autres, mais toutes sont possibles.

- SP_ERROR erreur générale.

- SP_OUTOFDISK Pas assez d’espace de disque est actuellement disponible pour le covoiturage, et plus d’espace ne sera disponible.

- SP_OUTOFMEMORY Pas assez de mémoire est disponible pour le covoiturage.

- SP_USERABORT’utilisateur a terminé le travail par l’intermédiaire du gestionnaire d’impression.

### <a name="remarks"></a>Notes

Si une application doit permettre l’annulation du travail d’impression lors du covoiturage, elle doit définir la fonction d’interruption avant que le travail d’impression ne soit commencé avec la fonction membre [StartDoc.](#startdoc) Le gestionnaire d’impression appelle la fonction d’interruption pendant le covoiturage pour permettre à l’application d’annuler le travail d’impression ou de traiter des conditions hors-disque-espace. Si aucune fonction d’interruption n’est définie, le travail d’impression échouera s’il n’y a pas assez d’espace de disque pour le covoiturage.

Notez que les fonctionnalités de Microsoft Visual C ' `SetAbortProc`simplifier la création de la fonction de rappel passé à . L’adresse transmise `EnumObjects` à la fonction membre est `__declspec(dllexport)` un `__stdcall` pointeur d’une fonction exportée avec et avec la convention d’appel.

Vous n’avez pas non plus à exporter le nom de la fonction dans un relevé **EXPORTS** dans le fichier module-définition de votre application. Vous pouvez plutôt utiliser le modificateur de fonction **EXPORT,** comme dans

**BOOL CALLBACK EXPORT** AFunction **(CDH),** `int` **);**

pour faire en sorte que le compilateur émete le dossier d’exportation approprié pour l’exportation par son nom sans aliasing. Cela fonctionne pour la plupart des besoins. Pour certains cas particuliers, comme l’exportation d’une fonction par l’exportation ordinaire ou l’enregistrement de l’exportation, vous devez toujours utiliser un relevé **EXPORTS** dans un fichier de définition de module.

Les interfaces d’enregistrement de rappel sont maintenant sans danger de type (vous devez passer dans un pointeur de fonction qui indique le bon type de fonction pour le rappel spécifique).

Notez également que toutes les fonctions de rappel doivent piéger les exceptions de la Fondation Microsoft avant de revenir à Windows, puisque les exceptions ne peuvent pas être jetées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, voir l’article [Exceptions](../../mfc/exception-handling-in-mfc.md).

## <a name="cdcsetarcdirection"></a><a name="setarcdirection"></a>CDC::SetArcDirection

Définit la direction de dessin à utiliser pour les fonctions d’arc et de rectangle.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Paramètres

*nArcDirection (en anglais seulement)*<br/>
Spécifie la nouvelle direction de l’arc. Ce paramètre peut être l’une ou l’autre des valeurs suivantes :

- AD_COUNTERCLOCKWISE Figures dessinées dans le sens contraire des aiguilles d’une montre.

- AD_CLOCKWISE Figures dessinées dans le sens des aiguilles d’une montre.

### <a name="return-value"></a>Valeur de retour

Spécifie l’ancienne direction de l’arc, si elle réussit; sinon 0.

### <a name="remarks"></a>Notes

La direction par défaut est dans le sens inverse des aiguilles d’une montre. La `SetArcDirection` fonction spécifie la direction dans laquelle les fonctions suivantes dessinent :

|Arc|Secteurs|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

## <a name="cdcsetattribdc"></a><a name="setattribdc"></a>CDC::SetAttribDC

Appelez cette fonction pour définir `m_hAttribDC`le contexte de l’appareil d’attribut, .

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Paramètres

*Hdc*<br/>
Un contexte d’appareil Windows.

### <a name="remarks"></a>Notes

Cette fonction de membre n’attache `CDC` pas le contexte de l’appareil à l’objet. Seul le contexte du périphérique `CDC` de sortie est attaché à un objet.

## <a name="cdcsetbkcolor"></a><a name="setbkcolor"></a>CDC::SetBkColor

Définit la couleur de fond actuelle à la couleur spécifiée.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*crColor (en)*<br/>
Spécifie la nouvelle couleur de fond.

### <a name="return-value"></a>Valeur de retour

La couleur de fond précédente comme une valeur de couleur RGB. En cas d’erreur, la valeur de retour est de 0x80000000000.

### <a name="remarks"></a>Notes

Si le mode arrière-plan est OPAQUE, le système utilise la couleur de fond pour combler les lacunes dans les lignes stylées, les lacunes entre les lignes écloses dans les brosses, et l’arrière-plan dans les cellules de caractère. Le système utilise également la couleur de fond lors de la conversion des bitmaps entre les contextes de couleur et de périphérique monochrome.

Si l’appareil ne peut pas afficher la couleur spécifiée, le système définit la couleur de fond à la couleur physique la plus proche.

## <a name="cdcsetbkmode"></a><a name="setbkmode"></a>CDC::SetBkMode

Définit le mode arrière-plan.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Paramètres

*nBkMode*<br/>
Spécifie le mode à définir. Ce paramètre peut être l’une ou l’autre des valeurs suivantes :

- OPAQUE Background est rempli de la couleur de fond actuelle avant que le texte, brosse éclose, ou stylo est dessiné. Il s’agit du mode arrière-plan par défaut.

- Transparent Background n’est pas modifié avant le dessin.

### <a name="return-value"></a>Valeur de retour

Le mode d’arrière-plan précédent.

### <a name="remarks"></a>Notes

Le mode arrière-plan définit si le système supprime les couleurs de fond existantes sur la surface de dessin avant de dessiner du texte, des brosses écloses, ou tout style de stylo qui n’est pas une ligne solide.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsetboundsrect"></a><a name="setboundsrect"></a>CDC::SetBoundsRect

Contrôle l’accumulation d’informations de délimitation-rectangle pour le contexte spécifié de l’appareil.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Paramètres

*lpRectBounds*<br/>
Points à `RECT` une `CRect` structure ou un objet qui est utilisé pour régler le rectangle de délimitation. Les dimensions de rectangle sont données dans les coordonnées logiques. Ce paramètre peut être NULL.

*Drapeaux*<br/>
Précise comment le nouveau rectangle sera combiné avec le rectangle accumulé. Ce paramètre peut être une combinaison des valeurs suivantes :

- DCB_ACCUMULATE Ajouter le rectangle spécifié par *lpRectBounds* au rectangle de délimitation (à l’aide d’une opération rectangle-union).

- DCB_DISABLE Éteignez l’accumulation des limites.

- DCB_ENABLE Allumez l’accumulation des limites. (Le paramètre par défaut pour l’accumulation de limites est désactivé.)

### <a name="return-value"></a>Valeur de retour

L’état actuel du rectangle de délimitation, si la fonction est réussie. Comme *les drapeaux,* la valeur de retour peut être une combinaison de **valeurs DCB_:**

- DCB_ACCUMULATE Le rectangle de délimitation n’est pas vide. Cette valeur sera toujours définie.

- DCB_DISABLE l’accumulation de Bounds est éteinte.

- DCB_ENABLE l’accumulation de Bounds est en cours.

### <a name="remarks"></a>Notes

Windows peut maintenir un rectangle de délimitation pour toutes les opérations de dessin. Ce rectangle peut être interrogé et réinitialisé par l’application. Les limites de dessin sont utiles pour invalider les caches de bitmap.

## <a name="cdcsetbrushorg"></a><a name="setbrushorg"></a>CDC::SetBrushOrg

Spécifie l’origine que GDI attribuera au pinceau suivant que l’application sélectionne dans le contexte de l’appareil.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordonner (dans les unités de périphérique) de la nouvelle origine. Cette valeur doit être dans la gamme 0-7.

*y*<br/>
Spécifie la y-coordinate (dans les unités de périphérique) de la nouvelle origine. Cette valeur doit être dans la gamme 0-7.

*Point*<br/>
Spécifie les coordonnées x et y de la nouvelle origine. Chaque valeur doit être dans la gamme 0-7. Vous pouvez passer `POINT` une structure `CPoint` ou un objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

L’origine précédente de la brosse dans les unités de périphérique.

### <a name="remarks"></a>Notes

Les coordonnées par défaut pour l’origine du pinceau sont (0, 0). Pour modifier l’origine d’un pinceau, appelez la `UnrealizeObject` fonction de l’objet, `CBrush` appelez, `SetBrushOrg`puis appelez la `SelectObject` fonction membre pour sélectionner la brosse dans le contexte de l’appareil.

Ne pas `SetBrushOrg` utiliser `CBrush` avec des objets en stock.

## <a name="cdcsetcoloradjustment"></a><a name="setcoloradjustment"></a>CDC::SetColorAdjustment

Définit les valeurs d’ajustement des couleurs pour le contexte de l’appareil à l’aide des valeurs spécifiées.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Paramètres

*lpColorAdjust*<br/>
Indique une structure de données [COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) contenant les valeurs d’ajustement des couleurs.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Les valeurs d’ajustement des couleurs sont utilisées pour ajuster la `CDC::StretchBlt` couleur d’entrée de la bitmap source pour les appels à la fonction membre lorsque le mode HALFTONE est défini.

## <a name="cdcsetdcbrushcolor"></a><a name="setdcbrushcolor"></a>CDC::SetDCBrushColor

Définit la couleur actuelle du pinceau (DC) du contexte de l’appareil à la valeur de couleur spécifiée.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*crColor (en)*<br/>
Spécifie la nouvelle couleur de pinceau.

### <a name="return-value"></a>Valeur de retour

Si la fonction réussit, la valeur de retour spécifie la couleur de brosse DC précédente comme une valeur COLORREF.

Si la fonction échoue, la valeur de retour sera CLR_INVALID.

### <a name="remarks"></a>Notes

Cette méthode imite la fonctionnalité de la fonction [SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor), telle que décrite dans le SDK Windows.

## <a name="cdcsetdcpencolor"></a><a name="setdcpencolor"></a>CDC::SetDCPenColor

Définit la couleur actuelle du stylet (DC) du contexte de l’appareil à la valeur de couleur spécifiée.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*crColor (en)*<br/>
Spécifie la nouvelle couleur du stylo.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction de membre utilise la fonction Win32 [SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor), telle que décrite dans le SDK Windows.

## <a name="cdcsetgraphicsmode"></a><a name="setgraphicsmode"></a>CDC::SetGraphicsMode

Définit le mode graphique pour le contexte de l’appareil spécifié.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Paramètres

*Imode*<br/>
Spécifie le mode graphique. Pour une liste des valeurs que ce paramètre peut prendre, voir [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Valeur de retour

Retourne l’ancien mode graphique sur le succès.

Retourne 0 sur l’échec. Pour obtenir des informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Notes

Cette méthode enveloppe la fonction Windows GDI [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

## <a name="cdcsetlayout"></a><a name="setlayout"></a>CDC::SetLayout

Appelez cette fonction de membre pour changer la disposition du texte et des graphiques pour un contexte d’appareil à droite à gauche, la disposition standard pour des cultures telles que l’arabe et l’hébreu.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Paramètres

*dwLayout dwLayout*<br/>
Disposition du contexte de l’appareil et drapeaux de contrôle de bitmap. Il peut s’agir d’une combinaison des valeurs suivantes.

|Valeur|Signification|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Désactive toute réflexion pour les appels à [la CDC::BitBlt](#bitblt) et [CDC::StretchBlt](#stretchblt).|
|LAYOUT_RTL|Définit la disposition horizontale par défaut pour être de droite à gauche.|
|LAYOUT_LTR|Définit la disposition par défaut pour être laissée à droite.|

### <a name="return-value"></a>Valeur de retour

En cas de succès, la disposition précédente du contexte de l’appareil.

En cas d’échec, GDI_ERROR. Pour obtenir des informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Notes

Normalement, vous n’appelleriez `SetLayout` pas pour une fenêtre. Au contraire, vous contrôlez la disposition de droite à gauche dans une fenêtre en définissant les [styles de fenêtre étendus](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) tels que WS_EX_RTLREADING. Un contexte d’appareil, tel qu’une imprimante ou un métaafile, n’hérite pas de cette mise en page. La seule façon de définir le contexte de l’appareil `SetLayout`pour une mise en page droite à gauche est d’appeler .

Si vous appelez **SetLayout (LAYOUT_RTL),** `SetLayout` modifie automatiquement le mode de cartographie pour MM_ISOTROPIC. Par conséquent, un appel ultérieur à [GetMapMode](#getmapmode) reviendra MM_ISOTROPIC au lieu de MM_TEXT.

Dans certains cas, comme avec de nombreux bitmaps, vous pouvez préserver la disposition de gauche à droite. Dans ces cas, rendre `BitBlt` l’image en appelant ou, `StretchBlt`puis régler le drapeau de contrôle bitmap pour *dwLayout* à LAYOUT_BITMAPORIENTATIONPRESERVED.

Une fois que vous modifiez la mise en page avec le drapeau LAYOUT_RTL, les drapeaux spécifiant normalement à droite ou à gauche sont inversés. Pour éviter toute confusion, vous pouvez définir d’autres noms pour les drapeaux standard. Pour une liste de noms de drapeaux alternatifs suggérés, voir [SetLayout](/windows/win32/api/wingdi/nf-wingdi-setlayout) dans le SDK Windows.

## <a name="cdcsetmapmode"></a><a name="setmapmode"></a>CDC::SetMapMode

Définit le mode de cartographie.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Paramètres

*nMapMode*<br/>
Spécifie le nouveau mode de cartographie. Il peut s’agir de l’une des valeurs suivantes :

- MM_ANISOTROPIC les unités logiques sont converties en unités arbitraires avec des axes arbitrairement à l’échelle. La configuration du mode de cartographie pour MM_ANISOTROPIC ne modifie pas les paramètres actuels de la fenêtre ou du viewport. Pour modifier les unités, l’orientation et la mise à l’échelle, appelez les fonctions des membres [SetWindowExt](#setwindowext) et [SetViewportExt.](#setviewportext)

- MM_HIENGLISH Chaque unité logique est convertie en 0,001 pouce. Positive x est à droite; positive y est en place.

- MM_HIMETRIC Chaque unité logique est convertie en 0,01 millimètre. Positive x est à droite; positive y est en place.

- MM_ISOTROPIC les unités logiques sont converties en unités arbitraires avec des axes à échelle égale; c’est-à-dire, 1 unité le long de l’axe x est égale à 1 unité le long de l’axe y. Utilisez `SetWindowExt` les `SetViewportExt` fonctions et les fonctions des membres pour spécifier les unités désirées et l’orientation des axes. GDI effectue des ajustements au besoin pour s’assurer que les unités x et y restent de la même taille.

- MM_LOENGLISH Chaque unité logique est convertie en 0,01 pouce. Positive x est à droite; positive y est en place.

- MM_LOMETRIC Chaque unité logique est convertie en 0,1 millimètre. Positive x est à droite; positive y est en place.

- MM_TEXT Chaque unité logique est convertie en 1 pixel d’appareil. Positive x est à droite; positive y est en baisse.

- MM_TWIPS Chaque unité logique est convertie en 1/20 d’un point. (Parce qu’un point est de 1/72 pouce, un twip est 1/1440 pouce.) Positive x est à droite; positive y est en place.

### <a name="return-value"></a>Valeur de retour

Le mode de cartographie précédent.

### <a name="remarks"></a>Notes

Le mode de cartographie définit l’unité de mesure utilisée pour convertir les unités logiques en unités d’appareils; il définit également l’orientation des x- et y-axes de l’appareil. GDI utilise le mode de cartographie pour convertir les coordonnées logiques en coordonnées appropriées. Le mode MM_TEXT permet aux applications de fonctionner en pixels de l’appareil, où 1 unité est égale à 1 pixel. La taille physique d’un pixel varie d’un appareil à l’autre.

Les modes MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC et MM_TWIPS sont utiles pour les applications qui doivent attirer des unités physiquement significatives (comme des pouces ou des millimètres). Le mode MM_ISOTROPIC assure un rapport d’aspect 1:1, ce qui est utile lorsqu’il est important de préserver la forme exacte d’une image. Le mode MM_ANISOTROPIC permet d’ajuster les coordonnées x et y de manière indépendante.

> [!NOTE]
> Si vous appelez [SetLayout](#setlayout) pour modifier le CD (contexte de `SetLayout` l’appareil) en version droite à gauche, modifiez automatiquement le mode de cartographie pour MM_ISOTROPIC.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CView:OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetmapperflags"></a><a name="setmapperflags"></a>CDC::SetMapperFlags

Change la méthode utilisée par le mapper de police lorsqu’elle convertit une police logique en police physique.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Paramètres

*dwFlag dwFlag*<br/>
Précise si le mapper de police tente de faire correspondre la hauteur et la largeur d’aspect d’une police à l’appareil. Lorsque cette valeur est ASPECT_FILTERING, le mapper ne sélectionne que les polices dont le x-aspect et le y-aspect correspondent exactement à celles de l’appareil spécifié.

### <a name="return-value"></a>Valeur de retour

La valeur précédente du drapeau police-mapper.

### <a name="remarks"></a>Notes

Une application `SetMapperFlags` peut utiliser pour provoquer le mapper police de tenter de choisir seulement une police physique qui correspond exactement au rapport d’aspect de l’appareil spécifié.

Une application qui n’utilise que `SetMapperFlags` des polices de raster peut utiliser la fonction pour s’assurer que la police sélectionnée par le mapper de police est attrayante et lisible sur l’appareil spécifié. Les applications qui utilisent des polices évolutives `SetMapperFlags`(TrueType) n’utilisent généralement pas .

Si aucune police physique n’a un rapport d’aspect qui correspond à la spécification dans la police logique, GDI choisit un nouveau rapport d’aspect et sélectionne une police qui correspond à ce nouveau rapport d’aspect.

## <a name="cdcsetmiterlimit"></a><a name="setmiterlimit"></a>CDC::SetMiterLimit

Définit la limite pour la longueur des jointures miter pour le contexte de l’appareil.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Paramètres

*fMiterLimit*<br/>
Spécifie la nouvelle limite d’adère pour le contexte de l’appareil.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

La longueur de l’atténuant est définie comme la distance de l’intersection des murs de la ligne à l’intérieur de la jointure jusqu’à l’intersection des murs de la ligne à l’extérieur de la jointure. La limite d’attière est le rapport maximal autorisé de la longueur de l’atténuer à la largeur de la ligne. La limite d’adère par défaut est de 10,0.

## <a name="cdcsetoutputdc"></a><a name="setoutputdc"></a>CDC::SetOutputDC

Appelez cette fonction de membre pour `m_hDC`définir le contexte du périphérique de sortie, .

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Paramètres

*Hdc*<br/>
Un contexte d’appareil Windows.

### <a name="remarks"></a>Notes

Cette fonction de membre ne peut être appelée que `CDC` lorsqu’un contexte d’appareil n’a pas été fixé à l’objet. Cette fonction `m_hDC` de membre définit mais n’attache pas le contexte de l’appareil à l’objet. `CDC`

## <a name="cdcsetpixel"></a><a name="setpixel"></a>CDC::SetPixel

Définit le pixel au point spécifié à l’approximation la plus proche de la couleur spécifiée par *crColor*.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordonnées logique du point à définir.

*y*<br/>
Spécifie la logique y-coordinate du point à définir.

*crColor (en)*<br/>
Une valeur COLORREF RGB qui spécifie la couleur utilisée pour peindre le point. Voir [COLORREF](/windows/win32/gdi/colorref) dans le Windows SDK pour une description de cette valeur.

*Point*<br/>
Spécifie les coordonnées logiques x et y du point à définir. Vous pouvez passer `POINT` une structure `CPoint` ou un objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur RGB pour la couleur que le point est effectivement peint. Cette valeur peut être différente de celle spécifiée par *crColor* si une approximation de cette couleur est utilisée. Si la fonction échoue (si le point est en dehors de la région de coupure), la valeur de retour est de -1.

### <a name="remarks"></a>Notes

Le point doit être dans la région de coupure. Si le point n’est pas dans la région de coupure, la fonction ne fait rien.

La fonction `SetPixel` n'est pas prise en charge par tous les périphériques. Pour déterminer si `SetPixel`un appareil `GetDeviceCaps` prend en charge, appelez la fonction membre avec l’index RASTERCAPS et vérifiez la valeur de retour pour le drapeau RC_BITBLT.

## <a name="cdcsetpixelv"></a><a name="setpixelv"></a>CDC::SetPixelV

Définit le pixel aux coordonnées spécifiées à l’approximation la plus proche de la couleur spécifiée.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie le x-coordonner, dans les unités logiques, du point à définir.

*y*<br/>
Spécifie le y-coordinate, dans les unités logiques, du point à définir.

*crColor (en)*<br/>
Spécifie la couleur à utiliser pour peindre le point.

*Point*<br/>
Spécifie les coordonnées logiques x et y du point à définir. Vous pouvez passer une structure de données [POINT](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le point doit être à la fois dans la région de coupure et la partie visible de la surface de l’appareil. Tous les appareils ne prennent pas en charge la fonction de membre. Pour plus d’informations, consultez la `CDC::GetDeviceCaps` RC_BITBLT capacité de la fonction membre. `SetPixelV`est plus `SetPixel` rapide que parce qu’il n’a pas besoin de retourner la valeur de couleur du point effectivement peint.

## <a name="cdcsetpolyfillmode"></a><a name="setpolyfillmode"></a>CDC::SetPolyFillMode

Définit le mode de remplissage du polygone.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Paramètres

*nPolyFillMode*<br/>
Spécifie le nouveau mode de remplissage. Cette valeur peut être ALTERNATIVE ou WINDING. Le mode par défaut défini dans Windows est ALTERNATE.

### <a name="return-value"></a>Valeur de retour

Le mode de remplissage précédent, en cas de succès; sinon 0.

### <a name="remarks"></a>Notes

Lorsque le mode de remplissage du polygone est ALTERNATE, le système remplit la zone entre les côtés polygones impairs et numérotés sur chaque ligne d’analyse. Autrement dit, le système remplit la zone entre le premier et le deuxième côté, entre le troisième et le quatrième côté, et ainsi de suite. Il s’agit du mode par défaut.

Lorsque le mode de remplissage du polygone est WINDING, le système utilise la direction dans laquelle un chiffre a été établi pour déterminer s’il faut remplir une zone. Chaque segment de ligne dans un polygone est dessiné dans le sens des aiguilles d’une montre ou dans le sens inverse des aiguilles d’une montre. Chaque fois qu’une ligne imaginaire dessinée d’une zone fermée à l’extérieur d’une figure passe par un segment de ligne dans le sens des aiguilles d’une montre, un compte est incrémenté. Lorsque la ligne passe à travers un segment de ligne dans le sens inverse des aiguilles d’une montre, le nombre est décrète. La zone est remplie si le nombre est nonzero lorsque la ligne atteint l’extérieur de la figure.

## <a name="cdcsetrop2"></a><a name="setrop2"></a>CDC::SetROP2

Définit le mode de dessin actuel.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Paramètres

*nDrawMode (en anglais seulement)*<br/>
Spécifie le nouveau mode de dessin. Il peut s’agir de l’une des valeurs suivantes :

- R2_BLACK Pixel est toujours noir.

- R2_WHITE Pixel est toujours blanc.

- R2_NOP Pixel reste inchangé.

- R2_NOT Pixel est l’inverse de la couleur de l’écran.

- R2_COPYPEN Pixel est la couleur du stylo.

- R2_NOTCOPYPEN Pixel est l’inverse de la couleur du stylo.

- R2_MERGEPENNOT Pixel est une combinaison de la couleur du stylo et de l’inverse de la couleur de l’écran (pixel final (PAS de pixel d’écran) ou de stylo).

- R2_MASKPENNOT Pixel est une combinaison des couleurs communes à la fois au stylo et à l’inverse de l’écran (pixel final (PAS de pixel d’écran) ET de stylo).

- R2_MERGENOTPEN Pixel est une combinaison de la couleur de l’écran et de l’inverse de la couleur du stylo (pixel final (PAS de stylo) ou pixel d’écran).

- R2_MASKNOTPEN Pixel est une combinaison des couleurs communes à l’écran et à l’inverse du stylo (pixel final (PAS de stylo) et pixel d’écran).

- R2_MERGEPEN Pixel est une combinaison de la couleur du stylo et de la couleur de l’écran (pixel final - stylo ou pixel d’écran).

- R2_NOTMERGEPEN Pixel est l’inverse de la couleur R2_MERGEPEN (pixel final - PAS (pen OU pixel d’écran)).

- R2_MASKPEN Pixel est une combinaison des couleurs communes à la fois au stylo et à l’écran (pixel final et stylo et pixel d’écran).

- R2_NOTMASKPEN Pixel est l’inverse de la couleur R2_MASKPEN (pixel final - PAS (pen et pixel d’écran)).

- R2_XORPEN Pixel est une combinaison des couleurs qui sont dans le stylo ou dans l’écran, mais pas dans les deux (pixel final - stylo XOR pixel d’écran).

- R2_NOTXORPEN Pixel est l’inverse de la couleur R2_XORPEN (pixel final - PAS (pixel d’écran XOR de stylo)).

### <a name="return-value"></a>Valeur de retour

Le mode de dessin précédent.

Il peut être l’une des valeurs données dans le SDK Windows.

### <a name="remarks"></a>Notes

Le mode de dessin précise comment les couleurs du stylo et l’intérieur des objets remplis sont combinés avec la couleur déjà sur la surface d’affichage.

Le mode de dessin est pour les appareils raster seulement; il ne s’applique pas aux dispositifs vectoriels. Les modes de dessin sont des codes de raster-operation binaires représentant toutes les combinaisons possibles de Boolean de deux variables, en utilisant les opérateurs binaires ET, OU, et XOR (OR exclusif), et l’opération unary NOT.

## <a name="cdcsetstretchbltmode"></a><a name="setstretchbltmode"></a>CDC::SetStretchBltMode

Définit le mode bitmap-étirement pour la `StretchBlt` fonction membre.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Paramètres

*nStretchMode*<br/>
Spécifie le mode d’étirement. Il peut s’agir de l’une des valeurs suivantes :

|Valeur|Description|
|-----------|-----------------|
|BLACKONWHITE BLACKONWHITE|Effectue une opération Boolean ET en utilisant les valeurs de couleur pour les pixels éliminés et existants. Si la bitmap est une bitmap monochrome, ce mode conserve les pixels noirs au détriment des pixels blancs.|
|COLORONCOLOR|Supprime les pixels. Ce mode supprime toutes les lignes de pixels éliminées sans essayer de préserver leurs informations.|
|Demi-teintes|Cartes pixels à partir du rectangle source en blocs de pixels dans le rectangle de destination. La couleur moyenne sur le bloc de destination des pixels se rapproche de la couleur des pixels source.|
||Après avoir défini le mode d’étirement HALFTONE, une application doit appeler la fonction Win32 [SetBrushOrgEx](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex) pour définir l’origine du pinceau. S’il ne le fait pas, le désalignement des brosses se produit.|
|STRETCH_ANDSCANS|**Windows 95/98**: Même que BLACKONWHITE|
|STRETCH_DELETESCANS|**Windows 95/98**: Même que COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: Même que HALFTONE.|
|STRETCH_ORSCANS|**Windows 95/98**: Même que WHITEONBLACK|
|WHITEONBLACK (EN)|Effectue une opération Boolean OU en utilisant les valeurs de couleur pour les pixels éliminés et existants. Si la bitmap est une bitmap monochrome, ce mode conserve les pixels blancs au détriment des pixels noirs.|

### <a name="return-value"></a>Valeur de retour

Le mode d’étirement précédent. Il peut être STRETCH_ANDSCANS, STRETCH_DELETESCANS, ou STRETCH_ORSCANS.

### <a name="remarks"></a>Notes

Le mode d’étirement des bitmap définit la façon dont l’information est supprimée des bitmaps qui sont comprimés à l’aide de la fonction.

Les modes BLACKONWHITE (STRETCH_ANDSCANS) et WHITEONBLACK (STRETCH_ORSCANS) sont généralement utilisés pour préserver les pixels de premier plan dans les bitmaps monochromes. Le mode COLORONCOLOR (STRETCH_DELETESCANS) est généralement utilisé pour préserver la couleur dans les bitmaps de couleur.

Le mode HALFTONE nécessite plus de traitement de l’image source que les trois autres modes; il est plus lent que les autres, mais produit des images de meilleure qualité. Notez `SetBrushOrgEx` également que doit être appelé après la mise en place du mode HALFTONE pour éviter le mauvais alignement des brosses.

D’autres modes d’étirement peuvent également être disponibles en fonction des capacités du pilote de l’appareil.

## <a name="cdcsettextalign"></a><a name="settextalign"></a>CDC::SetTextAlign

Définit les drapeaux d’alignement de texte.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Paramètres

*nFlags*<br/>
Spécifie les drapeaux d’alignement de texte. Les drapeaux spécifient la relation entre un point et un rectangle qui limite le texte. Le point peut être soit la position actuelle ou les coordonnées spécifiées par une fonction de sortie de texte. Le rectangle qui limite le texte est défini par les cellules de caractère adjacentes dans la chaîne de texte. Le *paramètre nFlags* peut être un ou plusieurs drapeaux des trois catégories suivantes. Choisissez un seul drapeau de chaque catégorie. La première catégorie affecte l’alignement du texte dans la direction X :

- TA_CENTER aligne le point avec le centre horizontal du rectangle de délimitation.

- TA_LEFT aligne le point avec le côté gauche du rectangle de délimitation. Il s'agit du paramètre par défaut.

- TA_RIGHT aligne le point avec le côté droit du rectangle de délimitation.

La deuxième catégorie affecte l’alignement du texte dans la direction y :

- TA_BASELINE aligne le point avec la ligne de base de la police choisie.

- TA_BOTTOM aligne le point avec le bas du rectangle de délimitation.

- TA_TOP aligne le point avec le haut du rectangle de délimitation. Il s'agit du paramètre par défaut.

La troisième catégorie détermine si la position actuelle est mise à jour lorsque le texte est écrit :

- TA_NOUPDATECP Ne met pas à jour la position actuelle après chaque appel à une fonction de sortie de texte. Il s'agit du paramètre par défaut.

- TA_UPDATECP Mises à jour de la position X actuelle après chaque appel à une fonction de sortie de texte. La nouvelle position se trouve sur le côté droit du rectangle de délimitation du texte. Lorsque ce drapeau est défini, les coordonnées `TextOut` spécifiées dans les appels à la fonction membre sont ignorées.

### <a name="return-value"></a>Valeur de retour

Le paramètre texte-alignement précédent, en cas de succès. Le byte à faible commande contient le réglage horizontal et le haut-ordre byte contient le réglage vertical; sinon 0.

### <a name="remarks"></a>Notes

Les `TextOut` `ExtTextOut` fonctions et les fonctions des membres utilisent ces drapeaux lors du positionnement d’une chaîne de texte sur un écran ou un appareil. Les drapeaux spécifient la relation entre un point spécifique et un rectangle qui limite le texte. Les coordonnées de ce point sont transmises comme paramètres de la `TextOut` fonction membre. Le rectangle qui limite le texte est formé par les cellules de caractère adjacentes dans la chaîne de texte.

## <a name="cdcsettextcharacterextra"></a><a name="settextcharacterextra"></a>CDC::SetTextCharacterExtra

Définit la quantité d’espacement intercharacter.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Paramètres

*nCharExtra (en anglais seulement)*<br/>
Spécifie la quantité d’espace supplémentaire (dans les unités logiques) à ajouter à chaque personnage. Si le mode de `MM_TEXT`cartographie actuel n’est pas, *nCharExtra* est transformé et arrondi au pixel le plus proche.

### <a name="return-value"></a>Valeur de retour

Le montant de l’espacement intercharacter précédent.

### <a name="remarks"></a>Notes

GDI ajoute cet espacement à chaque personnage, y compris les caractères de rupture, quand il écrit une ligne de texte au contexte de l’appareil. La valeur par défaut pour la quantité d’espacement intercharacter est de 0.

## <a name="cdcsettextcolor"></a><a name="settextcolor"></a>CDC::SetTextColor

Définit la couleur du texte à la couleur spécifiée.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*crColor (en)*<br/>
Spécifie la couleur du texte comme une valeur de couleur RGB.

### <a name="return-value"></a>Valeur de retour

Une valeur RGB pour la couleur de texte précédente.

### <a name="remarks"></a>Notes

Le système utilisera cette couleur de texte lors de l’écriture de texte dans ce contexte de l’appareil et aussi lors de la conversion des bitmaps entre les contextes de couleur et de périphérique monochrome.

Si l’appareil ne peut pas représenter la couleur spécifiée, le système définit la couleur du texte à la couleur physique la plus proche. La couleur de fond d’un `SetBkMode` personnage est spécifiée par les fonctions et les `SetBkColor` fonctions des membres.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsettextjustification"></a><a name="settextjustification"></a>CDC::SetTextJustification

Ajoute de l’espace aux personnages de rupture dans une chaîne.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Paramètres

*nBreakExtra (en anglais seulement)*<br/>
Spécifie l’espace supplémentaire total à ajouter à la ligne de texte (en unités logiques). Si le mode de `MM_TEXT`cartographie actuel n’est pas, la valeur donnée par ce paramètre est convertie au mode de cartographie actuel et arrondie à l’unité d’appareil la plus proche.

*nBreakCount (en)*<br/>
Spécifie le nombre de caractères de rupture dans la ligne.

### <a name="return-value"></a>Valeur de retour

Un si la fonction est réussie; sinon 0.

### <a name="remarks"></a>Notes

Une application peut `GetTextMetrics` utiliser les fonctions du membre pour récupérer le caractère de rupture d’une police.

Une `SetTextJustification` fois que la fonction du membre est appelée, `TextOut`un appel à une fonction de sortie de texte (comme ) distribue l’espace supplémentaire spécifié uniformément entre le nombre spécifié de caractères de rupture. Le personnage de rupture est généralement le caractère de l’espace (ASCII 32), mais peut être défini par une police comme un autre personnage.

La fonction `GetTextExtent` membre est `SetTextJustification`généralement utilisée avec . `GetTextExtent`calcule la largeur d’une ligne donnée avant l’alignement. Une application peut déterminer combien d’espace pour spécifier dans le `GetTextExtent` paramètre *nBreakExtra* en soustrayant la valeur retournée par la largeur de la chaîne après l’alignement.

La `SetTextJustification` fonction peut être utilisée pour aligner une ligne qui contient plusieurs exécutions dans différentes polices. Dans ce cas, la ligne doit être créée fragmentaire en alignant et en écrivant chaque exécution séparément.

Étant donné que des erreurs d’arrondissement peuvent se produire pendant l’alignement, le système conserve un terme d’erreur en cours d’exécution qui définit l’erreur actuelle. Lors de l’alignement d’une ligne qui contient plusieurs exécutions, `GetTextExtent` utilise automatiquement ce terme d’erreur lorsqu’il calcule l’étendue de la prochaine exécution. Cela permet à la fonction de sortie de texte de mélanger l’erreur dans la nouvelle exécution.

Une fois que chaque ligne a été alignée, ce terme d’erreur doit être effacé pour éviter qu’elle ne soit incorporée dans la ligne suivante. Le terme peut être `SetTextJustification` effacé en appelant avec *nBreakExtra* réglé à 0.

## <a name="cdcsetviewportext"></a><a name="setviewportext"></a>CDC::SetViewportExt

Définit les x- et y-étendues du viewport du contexte de l’appareil.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Paramètres

*Cx*<br/>
Spécifie l’étendue x du viewport (dans les unités de périphérique).

*Cy*<br/>
Spécifie l’étendue y du viewport (dans les unités de périphérique).

*Taille*<br/>
Spécifie les x- et y-étendues du viewport (dans les unités de périphérique).

### <a name="return-value"></a>Valeur de retour

Les étendues précédentes du viewport en tant [qu’objet CSize.](../../atl-mfc-shared/reference/csize-class.md) Lorsqu’une erreur se produit, les coordonnées x `CSize` et y de l’objet retourné sont toutes deux réglées à 0.

### <a name="remarks"></a>Notes

Le viewport, ainsi que la fenêtre de l’appareil-contexte, définit comment GDI cartographie les points dans le système de coordonnées logiques aux points dans le système de coordonnées de l’appareil réel. En d’autres termes, ils définissent la façon dont GDI convertit les coordonnées logiques en coordonnées d’appareils.

Lorsque les modes de cartographie `SetWindowExt` suivants `SetViewportExt` sont définis, les appels vers et sont ignorés :

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

Lorsque MM_ISOTROPIC mode est défini, une application `SetWindowExt` doit appeler `SetViewportExt`la fonction membre avant qu’elle n’appelle .

### <a name="example"></a>Exemple

  Voir l’exemple pour [CView:OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetviewportorg"></a><a name="setviewportorg"></a>CDC::SetViewportOrg

Définit l’origine du viewport du contexte de l’appareil.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordonner (dans les unités de périphérique) de l’origine du viewport. La valeur doit se situer dans la plage du système de coordination de l’appareil.

*y*<br/>
Spécifie la y-coordinate (dans les unités de périphérique) de l’origine du viewport. La valeur doit se situer dans la plage du système de coordination de l’appareil.

*Point*<br/>
Spécifie l’origine du viewport. Les valeurs doivent se situer dans la plage du système de coordination de l’appareil. Vous pouvez passer `POINT` une structure `CPoint` ou un objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

L’origine précédente du viewport (dans les `CPoint` coordonnées de l’appareil) en tant qu’objet.

### <a name="remarks"></a>Notes

Le viewport, ainsi que la fenêtre de l’appareil-contexte, définit comment GDI cartographie les points dans le système de coordonnées logiques aux points dans le système de coordonnées de l’appareil réel. En d’autres termes, ils définissent la façon dont GDI convertit les coordonnées logiques en coordonnées d’appareils.

L’origine du viewport indique le point dans le système de coordonnées de l’appareil `SetWindowOrg` auquel GDI cartographie l’origine de la fenêtre, un point dans le système de coordonnées logiques spécifié par la fonction membre. GDI cartographie tous les autres points en suivant le même processus requis pour cartographier l’origine de la fenêtre à l’origine du viewport. Par exemple, tous les points d’un cercle autour du point à l’origine de la fenêtre seront en cercle autour du point à l’origine du viewport. De même, tous les points d’une ligne qui passe par l’origine de la fenêtre seront dans une ligne qui passe par l’origine du viewport.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CView:OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindowext"></a><a name="setwindowext"></a>CDC::SetWindowExt

Définit les x- et y-étendues de la fenêtre associée au contexte de l’appareil.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Paramètres

*Cx*<br/>
Spécifie l’étendue x (dans les unités logiques) de la fenêtre.

*Cy*<br/>
Spécifie l’étendue y (dans les unités logiques) de la fenêtre.

*Taille*<br/>
Spécifie les x- et y-extents (en unités logiques) de la fenêtre.

### <a name="return-value"></a>Valeur de retour

Les étendues précédentes de la fenêtre `CSize` (en unités logiques) comme objet. En cas d’erreur, les coordonnées x et `CSize` y de l’objet retourné sont toutes deux réglées à 0.

### <a name="remarks"></a>Notes

La fenêtre, ainsi que le viewport de contexte de l’appareil, définit comment GDI cartographie les points dans le système de coordonnées logiques aux points dans le système de coordonnées de l’appareil.

Lorsque les modes de cartographie `SetWindowExt` suivants `SetViewportExt` sont définis, les appels et les fonctions sont ignorés :

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

Lorsque MM_ISOTROPIC mode est défini, une application `SetWindowExt` doit appeler `SetViewportExt`la fonction membre avant d’appeler .

### <a name="example"></a>Exemple

  Voir l’exemple pour [CView:OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindoworg"></a><a name="setwindoworg"></a>CDC::SetWindowOrg

Définit l’origine de la fenêtre du contexte de l’appareil.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordonner logique de la nouvelle origine de la fenêtre.

*y*<br/>
Spécifie la logique y-coordinate de la nouvelle origine de la fenêtre.

*Point*<br/>
Spécifie les coordonnées logiques de la nouvelle origine de la fenêtre. Vous pouvez passer `POINT` une structure `CPoint` ou un objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

L’origine précédente de `CPoint` la fenêtre comme objet.

### <a name="remarks"></a>Notes

La fenêtre, ainsi que le viewport de contexte de l’appareil, définit comment GDI cartographie les points dans le système de coordonnées logiques aux points dans le système de coordonnées de l’appareil.

L’origine de la fenêtre marque le point dans le système de coordonnées logiques à `SetWindowOrg` partir duquel GDI cartographie l’origine du viewport, un point dans le système de coordonnées de l’appareil spécifié par la fonction. GDI cartographie tous les autres points en suivant le même processus requis pour cartographier l’origine de la fenêtre à l’origine du viewport. Par exemple, tous les points d’un cercle autour du point à l’origine de la fenêtre seront en cercle autour du point à l’origine du viewport. De même, tous les points d’une ligne qui passe par l’origine de la fenêtre seront dans une ligne qui passe par l’origine du viewport.

## <a name="cdcsetworldtransform"></a><a name="setworldtransform"></a>CDC::SetWorldTransform

Définit une transformation linéaire bidimensionnelle entre l’espace du monde et l’espace de page pour le contexte spécifié de l’appareil. Cette transformation peut être utilisée pour écheller, tourner, cisailler ou traduire la sortie graphique.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Paramètres

*rXforme*<br/>
Référence à une structure [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) qui contient les données de transformation.

### <a name="return-value"></a>Valeur de retour

Retourne une valeur non zéro sur le succès.

Retourne 0 sur l’échec.

Pour obtenir des informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Notes

Cette méthode enveloppe la fonction Windows GDI [SetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform).

## <a name="cdcstartdoc"></a><a name="startdoc"></a>CDC::StartDoc

Informe le conducteur de l’appareil qu’un `StartPage` `EndPage` nouveau travail d’impression commence et `EndDoc` que tous les appels et appels suivants doivent être enroulés sous le même travail jusqu’à ce qu’un appel se produise.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Paramètres

*lpDocInfo*<br/>
Indique une structure [DOCINFO](/windows/win32/api/wingdi/ns-wingdi-docinfow) contenant le nom du fichier document et le nom du fichier de sortie.

*lpszDocName*<br/>
Pointeur vers une chaîne contenant le nom du fichier document.

### <a name="return-value"></a>Valeur de retour

Si la fonction réussit, la valeur de rendement est supérieure à zéro. Cette valeur est l’identifiant d’emploi d’impression pour le document.

Si la fonction échoue, la valeur de retour est inférieure ou égale à zéro.

### <a name="remarks"></a>Notes

Cela garantit que les documents de plus d’une page ne seront pas entrecoupés d’autres emplois.

Pour les versions Windows 3.1 et plus tard, cette fonction remplace l’évasion de l’imprimante STARTDOC. L’utilisation de cette fonction garantit que les documents contenant plus d’une page ne sont pas entrecoupés d’autres travaux d’impression.

`StartDoc`ne doit pas être utilisé à l’intérieur des métafiles.

### <a name="example"></a>Exemple

Ce fragment de code obtient l’imprimante par défaut, ouvre un travail d’impression, et enroule une page avec "Bonjour, Monde!" sur elle. Étant donné que le texte imprimé par ce code n’est pas mis à l’échelle sur les unités logiques de l’imprimante, le texte de sortie peut se faire en si petites lettres que le résultat est illisible. Les fonctions de mise à `SetMapMode` `SetViewportOrg`l’échelle CDC, telles que , , et `SetWindowExt`, peut être utilisé pour fixer la mise à l’échelle.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

## <a name="cdcstartpage"></a><a name="startpage"></a>CDC::StartPage

Appelez cette fonction de membre pour préparer le pilote d’imprimante à recevoir des données.

```
int StartPage();
```

### <a name="return-value"></a>Valeur de retour

Plus ou égal à 0 si la fonction est réussie, ou une valeur négative en cas d’erreur.

### <a name="remarks"></a>Notes

`StartPage`remplace les évasions NEWFRAME et BANDINFO.

Pour un aperçu de la séquence des appels d’impression, consultez la fonction membre [StartDoc.](#startdoc)

Le système désactive la `ResetDC` fonction `StartPage` `EndPage`membre entre les appels vers et .

### <a name="example"></a>Exemple

  Voir l’exemple pour [CDC::StartDoc](#startdoc).

## <a name="cdcstretchblt"></a><a name="stretchblt"></a>CDC::StretchBlt

Copie une image bitmap depuis un rectangle source vers un rectangle de destination, en étirant ou en compressant le bitmap si nécessaire pour l'adapter aux dimensions du rectangle de destination.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x (en unités logiques) de l'angle supérieur gauche du rectangle de destination.

*y*<br/>
Spécifie la coordonnée y (en unités logiques) de l'angle supérieur gauche du rectangle de destination.

*nWidth (en)*<br/>
Spécifie la largeur (en unités logiques) du rectangle de destination.

*nHeight (en)*<br/>
Spécifie la hauteur (en unités logiques) du rectangle de destination.

*pSrcDC (en)*<br/>
Spécifie le contexte du périphérique source.

*xSrc (en)*<br/>
Spécifie la coordonnée x (en unités logiques) de l'angle supérieur gauche du rectangle source.

*ySrc (en)*<br/>
Spécifie la coordonnée y (en unités logiques) de l'angle supérieur gauche du rectangle source.

*nSrcWidth (en)*<br/>
Spécifie la largeur (en unités logiques) du rectangle source.

*nSrcHeight (en)*<br/>
Spécifie la hauteur (en unités logiques) du rectangle source.

*dwRop*<br/>
Spécifie l'opération de rastérisation à effectuer. Le code d'une opération de rastérisation définit la façon dont GDI associe les couleurs dans les opérations de sortie qui impliquent le pinceau actuel, un éventuel bitmap source et un bitmap de destination. Ce paramètre peut avoir l'une des valeurs suivantes :

- BLACKNESS Tourne tout le produit noir.

- DSTINVERT inverse la bitmap de destination.

- MERGECOPY Combine le motif et la bitmap source à l’aide de l’opérateur Boolean ET.

- MERGEPAINT Combine le bitmap source inversée avec la bitmap de destination à l’aide de l’opérateur Boolean OR.

- NOTSRCCOPY Copie la source inversée bitmap à la destination.

- NOTSRCERASE inverse le résultat de la combinaison de la destination et des bitmaps source à l’aide de l’opérateur Boolean OU.

- PATCOPY Copie le motif à la bitmap de destination.

- PATINVERT combine le bitmap de destination avec le modèle à l’aide de l’opérateur Boolean XOR.

- PATPAINT combine la bitmap source inversée avec le modèle à l’aide de l’opérateur Boolean OU. Associe le résultat de cette opération au bitmap de destination à l'aide de l'opérateur booléen OR.

- SRCAND Combine les pixels de la destination et les bitmaps source à l’aide de l’opérateur Boolean ET.

- SRCCOPY Copie la bitmap source à la bitmap de destination.

- SRCERASE inverse la bitmap de destination et combine le résultat avec la bitmap source à l’aide de l’opérateur Boolean ET.

- SRCINVERT combine les pixels de la destination et les bitmaps source à l’aide de l’opérateur Boolean XOR.

- SRCPAINT Combine les pixels de la destination et les bitmaps source à l’aide de l’opérateur Boolean OR.

- WHITENESS Tourne tous les blancs de sortie.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si le bitmap est dessiné ; sinon, 0.

### <a name="remarks"></a>Notes

La fonction utilise le mode d'étirement du contexte du périphérique de destination (défini par `SetStretchBltMode`) afin de savoir comment étirer ou compresser le bitmap.

La `StretchBlt` fonction déplace la bitmap du dispositif source donné par *pSrcDC* au dispositif de destination représenté par l’objet de contexte de l’appareil dont la fonction de membre est appelée. Les paramètres *xSrc*, *ySrc*, *nSrcWidth*et *nSrcHeight* définissent le coin supérieur gauche et les dimensions du rectangle source. Les paramètres *x*, *y*, *nWidth*et *nHeight* donnent le coin supérieur gauche et les dimensions du rectangle de destination. L’opération de raster spécifiée par *dwRop* définit comment la bitmap source et les bits déjà sur l’appareil de destination sont combinés.

La `StretchBlt` fonction crée une image miroir d’un bitmap si les signes de la *nSrcWidth* et *nWidth* ou *nSrcHeight* et *nHeight* paramètres diffèrent. Si *nSrcWidth* et *nWidth* ont des signes différents, la fonction crée une image miroir de la bitmap le long de l’axe x. Si *nSrcHeight* et *nHeight* ont des signes différents, la fonction crée une image miroir de la bitmap le long de l’axe y.

La fonction `StretchBlt` étire ou compresse le bitmap source en mémoire, puis copie le résultat vers la destination. Si un modèle doit être fusionné avec le résultat, il ne le sera pas tant que le bitmap source étiré n'est pas copié vers la destination. Si un pinceau est utilisé, il s'agira du pinceau sélectionné dans le contexte de périphérique de destination. Les coordonnées de destination sont transformées en fonction du contexte du périphérique de destination ; les coordonnées sources sont transformées en fonction du contexte du périphérique source.

Si les bitmaps sources, les bitmaps de destination et les bitmaps de modèle n'ont pas le même format de couleur, `StretchBlt` convertit les bitmaps sources et les bitmaps de modèle pour qu'ils correspondent aux bitmaps de destination. Les couleurs de premier plan et d'arrière-plan du contexte du périphérique de destination sont utilisées dans la conversion.

Si `StretchBlt` doit convertir un bitmap monochrome en bitmap de couleur, il définit les bits blancs (1) sur la couleur d'arrière-plan et les bits noirs (0) sur la couleur de premier plan. Pour convertir la couleur en monochrome, il définit les pixels qui correspondent à la couleur d'arrière-plan sur blanc (1) et définit tous les autres pixels sur noir (0). Les couleurs de premier plan et d'arrière-plan du contexte du périphérique coloré sont utilisées.

La fonction `StretchBlt` n'est pas prise en charge par tous les périphériques. Pour déterminer si `StretchBlt`un appareil `GetDeviceCaps` prend en charge, appelez la fonction membre avec l’index RASTERCAPS et vérifiez la valeur de retour pour le drapeau RC_STRETCHBLT.

## <a name="cdcstrokeandfillpath"></a><a name="strokeandfillpath"></a>CDC::StrokeAndFillPath

Ferme toutes les figures ouvertes sur un chemin, caresse le contour du chemin en utilisant le stylo actuel, et remplit son intérieur en utilisant la brosse actuelle.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le contexte de l’appareil doit contenir un chemin fermé. La `StrokeAndFillPath` fonction membre a le même effet que de fermer toutes les figures ouvertes sur le chemin, et de caresser et de remplir le chemin séparément, sauf que la région remplie ne chevauchera pas la région caressée même si le stylo est large.

## <a name="cdcstrokepath"></a><a name="strokepath"></a>CDC::StrokePath

Rend le chemin spécifié à l’aide du stylo actuel.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le contexte de l’appareil doit contenir un chemin fermé.

## <a name="cdctabbedtextout"></a><a name="tabbedtextout"></a>CDC::TabbedTextOut

Appelez cette fonction de membre pour écrire une chaîne de caractère à l’emplacement spécifié, en élargissant les onglets aux valeurs spécifiées dans la gamme de positions d’onglet-arrêt.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la x-coordonner logique du point de départ de la chaîne.

*y*<br/>
Spécifie la logique y-coordinate du point de départ de la chaîne.

*lpszString (lpszString)*<br/>
Points à la chaîne de caractère à dessiner. Vous pouvez passer soit un pointeur à un tableau de caractères ou un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) pour ce paramètre.

*nCompte*<br/>
Spécifie la [longueur de la chaîne](/windows/win32/gdi/specifying-length-of-text-output-string) pointée par *lpszString*.

*nTabPositions*<br/>
Spécifie le nombre de valeurs dans la gamme de positions d’onglet-arrêt.

*lpnTabStopPositions*<br/>
Points à un tableau contenant les positions d’onglet-arrêt (dans les unités logiques). Les arrêts d’onglet doivent être triés dans l’ordre croissant; la plus petite valeur x devrait être le premier élément du tableau.

*nTabOrigin*<br/>
Spécifie la x-coordonner la position de départ à partir de laquelle les onglets sont élargis (en unités logiques).

*Str*<br/>
Un `CString` objet qui contient les caractères spécifiés.

### <a name="return-value"></a>Valeur de retour

Les dimensions de la chaîne (en `CSize` unités logiques) comme objet.

### <a name="remarks"></a>Notes

Le texte est écrit dans la police actuellement sélectionnée. Si *nTabPositions* est de 0 et *lpnTabStopPositions* est NULL, onglets sont étendus à huit fois la largeur moyenne du caractère.

Si *nTabPositions* est 1, les arrêts d’onglet sont séparés par la distance spécifiée par la première valeur dans le tableau *lpnTabStopPositions.* Si le tableau *lpnTabStopPositions* contient plus d’une valeur, un arrêt d’onglet est réglé pour chaque valeur du tableau, jusqu’au nombre spécifié par *nTabPositions*. Le *paramètre nTabOrigin* permet `TabbedTextOut` à une application d’appeler la fonction plusieurs fois pour une seule ligne. Si l’application appelle la fonction plus d’une fois avec le *nTabOrigin* réglé à la même valeur à chaque fois, la fonction élargit tous les onglets par rapport à la position spécifiée par *nTabOrigin*.

Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction. Si une application doit mettre à jour la position actuelle lorsqu’elle appelle la fonction, l’application peut appeler la fonction [membre SetTextAlign](#settextalign) avec *nFlags* configuré à TA_UPDATECP. Lorsque ce drapeau est défini, Windows ignore les paramètres `TabbedTextOut` *x* et *y* sur les appels suivants à , en utilisant la position actuelle à la place.

## <a name="cdctextout"></a><a name="textout"></a>CDC::TextOut

Écrit une chaîne de caractères à l'emplacement spécifié à l'aide de la police sélectionnée.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique du point de départ du texte.

*y*<br/>
Spécifie la coordonnée y logique du point de départ du texte.

*lpszString (lpszString)*<br/>
Pointe vers la chaîne de caractères à ajouter.

*nCompte*<br/>
Spécifie le nombre de caractères de la chaîne.

*Str*<br/>
Objet `CString` qui contient les caractères à ajouter.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

L'origine des caractères se trouve dans l'angle supérieur gauche de la cellule de caractère. Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction.

Si une application doit mettre à `TextOut`jour la position `SetTextAlign` actuelle lorsqu’elle appelle, l’application peut appeler la fonction membre avec *nFlags* réglé pour TA_UPDATECP. Lorsque ce drapeau est défini, Windows ignore les paramètres `TextOut` *x* et *y* sur les appels suivants à , en utilisant la position actuelle à la place.

### <a name="example"></a>Exemple

  Voir l’exemple pour [CDC:BeginPath](#beginpath).

## <a name="cdctransparentblt"></a><a name="transparentblt"></a>CDC::TransparentBlt

Appelez cette fonction de membre pour transférer un bit-bloc des données de couleur, qui correspond à un rectangle de pixels à partir du contexte de l’appareil source spécifié, dans un contexte de périphérique de destination.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Paramètres

*xDest*<br/>
Spécifie le x-coordonner, dans les unités logiques, du coin supérieur gauche du rectangle de destination.

*yDest*<br/>
Spécifie le y-coordinate, dans les unités logiques, du coin supérieur gauche du rectangle de destination.

*nDestWidth (en)*<br/>
Spécifie la largeur, en unités logiques, du rectangle de destination.

*nDestHeight*<br/>
Spécifie la hauteur, en unités logiques, du rectangle de destination.

*pSrcDC (en)*<br/>
Pointeur sur le contexte de l’appareil source.

*xSrc (en)*<br/>
Spécifie le x-coordonner, en unités logiques, du rectangle source.

*ySrc (en)*<br/>
Spécifie le y-coordinate, dans les unités logiques, du rectangle source.

*nSrcWidth (en)*<br/>
Spécifie la largeur, en unités logiques, du rectangle source.

*nSrcHeight (en)*<br/>
Spécifie la hauteur, en unités logiques, du rectangle source.

*clrTransparent*<br/>
La couleur RGB dans la bitmap source pour traiter comme transparent.

### <a name="return-value"></a>Valeur de retour

TRUE en cas de réussite, sinon FALSE.

### <a name="remarks"></a>Notes

`TransparentBlt`permet la transparence; c’est-à-dire, la couleur RGB indiquée par *clrTransparent* est rendue transparente pour le transfert.

Pour plus d’informations, voir [TransparentBlt](/windows/win32/api/wingdi/nf-wingdi-transparentblt) dans windows SDK.

## <a name="cdcupdatecolors"></a><a name="updatecolors"></a>CDC::Mise à jourColors

Mise à jour de la zone cliente du contexte de l’appareil en faisant correspondre les couleurs actuelles de la zone client à la palette du système pixel par pixel.

```
void UpdateColors();
```

### <a name="remarks"></a>Notes

Une fenêtre inactive avec une `UpdateColors` palette logique réalisée peut appeler comme une alternative à redessiner sa zone client lorsque la palette du système change.

Pour plus d’informations sur l’utilisation des palettes de couleurs, voir [UpdateColors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) in the Windows SDK.

La `UpdateColors` fonction membre met généralement à jour une zone cliente plus rapidement que le redessinage de la zone. Cependant, parce que la fonction effectue la traduction de couleur basée sur la couleur de chaque pixel avant que la palette du système change, chaque appel à cette fonction entraîne la perte d’une certaine précision de couleur.

## <a name="cdcwidenpath"></a><a name="widenpath"></a>CDC::WidenPath

Redéfinit le chemin actuel comme la zone qui serait peinte si le chemin était caressé à l’aide du stylo actuellement sélectionné dans le contexte de l’appareil.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction n’est réussie que si le stylo actuel `CreatePen` est un stylo géométrique créé par la `CreatePen` deuxième version de la fonction membre, ou si le stylo est créé avec la première version de et a une largeur, dans les unités de périphérique, de plus de 1. Le contexte de l’appareil doit contenir un chemin fermé. Toutes les courbes Bzier dans le chemin sont converties en séquences de lignes droites approximant les courbes élargies. En tant que tel, aucune courbe `WidenPath` de Bzier ne reste dans le chemin après est appelé.

## <a name="see-also"></a>Voir aussi

[Classe CObject](../../mfc/reference/cobject-class.md)<br/>
[Graphique hiérarchique](../../mfc/hierarchy-chart.md)<br/>
[Classe CPaintDC](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC, classe](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC, classe](../../mfc/reference/cclientdc-class.md)<br/>
[Classe CMetaFileDC](../../mfc/reference/cmetafiledc-class.md)
