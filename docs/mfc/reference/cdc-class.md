---
title: CDC (classe) | Documents Microsoft
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: reference
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
dev_langs:
- C++
helpviewer_keywords:
- Windows [C++], device contexts
- Windows 95 [C++], screen coordinates
- device contexts [C++], CDC class
- screen coordinates in device contexts
- coordinates in Windows 95/98 [C++]
- Windows 98 [C++], screen coordinates
- CDC class
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
caps.latest.revision: 21
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: 0e0c08ddc57d437c51872b5186ae3fc983bb0199
ms.openlocfilehash: 80ccd3f8bed6bd74e22d4db5e176ee50528d3187
ms.lasthandoff: 02/24/2017

---
# <a name="cdc-class"></a>CDC (classe)
Définit une classe d’objets de contexte de périphérique.  
  
## <a name="syntax"></a>Syntaxe  
  
```  
class CDC : public CObject  
```  
  
## <a name="members"></a>Membres  
  
### <a name="public-constructors"></a>Constructeurs publics  
  
|Nom|Description|  
|----------|-----------------|  
|[CDC::CDC](#cdc)|Construit un objet `CDC`.|  
  
### <a name="public-methods"></a>M&#233;thodes publiques  
  
|Nom|Description|  
|----------|-----------------|  
|[CDC::AbortDoc](#abortdoc)|Met fin à l’impression en cours, effacez tout ce que l’application a écrit sur le périphérique depuis le dernier appel de la `StartDoc` fonction membre.|  
|[CDC::AbortPath](#abortpath)|Ferme et ignore les chemins d’accès dans le contexte de périphérique.|  
|[CDC::AddMetaFileComment](#addmetafilecomment)|Copie le commentaire d’une mémoire tampon dans un métafichier amélioré au format spécifié.|  
|[CDC::AlphaBlend](#alphablend)|Affiche les bitmaps qui ont des pixels transparents ou semi-transparent.|  
|[CDC::AngleArc](#anglearc)|Dessine un segment de ligne et un arc et déplace la position actuelle vers le point de fin de l’arc.|  
|[CDC::arc](#arc)|Dessine un arc elliptique.|  
|[CDC::ArcTo](#arcto)|Dessine un arc elliptique. Cette fonction est similaire à `Arc`, sauf que la position actuelle est mise à jour.|  
|[CDC::Attach](#attach)|Attache un contexte de périphérique Windows à ce `CDC` objet.|  
|[CDC::BeginPath](#beginpath)|Ouvre un crochet de chemin d’accès dans le contexte de périphérique.|  
|[CDC::BitBlt](#bitblt)|Copie une image bitmap à partir d’un contexte de périphérique spécifié.|  
|[CDC::Chord](#chord)|Dessine un segment (figure fermée délimitée par l’intersection d’une ellipse et un segment de ligne).|  
|[CDC::CloseFigure](#closefigure)|Ferme une figure ouverte dans un chemin d’accès.|  
|[CDC::CreateCompatibleDC](#createcompatibledc)|Crée un contexte de périphérique mémoire compatible avec un autre contexte de périphérique. Vous pouvez l’utiliser pour préparer des images en mémoire.|  
|[CDC::CreateDC](#createdc)|Crée un contexte de périphérique pour un périphérique spécifique.|  
|[CDC::CreateIC](#createic)|Crée un contexte d’informations pour un périphérique spécifique. Cela fournit un moyen rapide d’obtenir des informations sur le périphérique sans créer un contexte de périphérique.|  
|[CDC::DeleteDC](#deletedc)|Supprime le contexte de périphérique Windows associé à ce `CDC` objet.|  
|[CDC::DeleteTempMap](#deletetempmap)|Appelée par le `CWinApp` Gestionnaire de durée d’inactivité pour supprimer un fichier temporaire `CDC` objet créé par `FromHandle`. Détache également le contexte de périphérique.|  
|[CDC::Detach](#detach)|Détache le contexte de périphérique Windows à partir de ce `CDC` objet.|  
|[CDC::DPtoHIMETRIC](#dptohimetric)|Convertit des unités de périphérique dans **HIMETRIC** unités.|  
|[CDC::DPtoLP](#dptolp)|Convertit des unités de périphérique en unités logiques.|  
|[CDC::Draw3dRect](#draw3drect)|Dessine un rectangle en trois dimensions.|  
|[CDC::DrawDragRect](#drawdragrect)|Efface et redessine un rectangle comme il est glissé.|  
|[CDC::DrawEdge](#drawedge)|Dessine les bords d’un rectangle.|  
|[CDC::DrawEscape](#drawescape)|Accès aux fonctions qui ne sont pas directement disponibles via l’interface graphique (GDI) d’un affichage vidéo de dessin.|  
|[CDC::DrawFocusRect](#drawfocusrect)|Dessine un rectangle dans le style utilisé pour indiquer le focus.|  
|[CDC::DrawFrameControl](#drawframecontrol)|Dessiner un contrôle frame.|  
|[CDC::DrawIcon](#drawicon)|Dessine une icône.|  
|[CDC::DrawState](#drawstate)|Affiche une image et applique un effet visuel pour indiquer un état.|  
|[CDC::DrawText](#drawtext)|Dessine mis en forme le texte dans le rectangle spécifié.|  
|[CDC::DrawTextEx](#drawtextex)|Dessine mis en forme le texte dans le rectangle spécifié à l’aide des formats supplémentaires.|  
|[CDC::ellipse](#ellipse)|Dessine une ellipse.|  
|[CDC::EndDoc](#enddoc)|Met fin à un travail d’impression est démarré par le `StartDoc` fonction membre.|  
|[CDC::EndPage](#endpage)|Indique au pilote de périphérique une page se termine.|  
|[CDC::EndPath](#endpath)|Ferme un crochet de chemin d’accès et sélectionne le chemin d’accès défini par le support dans le contexte de périphérique.|  
|[CDC::EnumObjects](#enumobjects)|Énumère les stylets et pinceaux disponibles dans un contexte de périphérique.|  
|[CDC::escape](#escape)|Permet aux applications d’accéder à des fonctionnalités qui ne sont pas directement disponibles à partir d’un périphérique particulier via GDI. Autorise également l’accès aux fonctions d’échappement de Windows. Appels d’échappement par une application sont traduites et envoyées au pilote de périphérique.|  
|[CDC::ExcludeClipRect](#excludecliprect)|Crée une nouvelle zone de découpage qui se compose de la zone de découpage existant moins le rectangle spécifié.|  
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Empêche le dessin dans les zones non valides d’une fenêtre en excluant une région mis à jour dans la fenêtre à partir d’une zone de découpage.|  
|[CDC::ExtFloodFill](#extfloodfill)|Remplit une zone avec le pinceau actuel. Fournit davantage de flexibilité que la [CDC::FloodFill](#floodfill) fonction membre.|  
|[CDC::ExtTextOut](#exttextout)|Écrit une chaîne de caractères dans une zone rectangulaire à l’aide de la police actuellement sélectionnée.|  
|[CDC::FillPath](#fillpath)|Ferme des figures ouvertes dans le chemin d’accès actuel et remplit l’intérieur du tracé en utilisant le pinceau actuel et le mode de remplissage de polygones.|  
|[CDC::FillRect](#fillrect)|Remplit un rectangle à l’aide d’un pinceau spécifique.|  
|[CDC::FillRgn](#fillrgn)|Remplit une région spécifique avec le pinceau spécifié.|  
|[CDC::FillSolidRect](#fillsolidrect)|Remplit un rectangle avec une couleur unie.|  
|[CDC::FlattenPath](#flattenpath)|Transforme les courbes dans le chemin d’accès sélectionné dans le contexte de périphérique en cours et transforme chaque courbe en une séquence de lignes.|  
|[CDC::FloodFill](#floodfill)|Remplit une zone avec le pinceau actuel.|  
|[CDC::frameRect n'](#framerect)|Dessine une bordure autour d’un rectangle.|  
|[CDC::FrameRgn](#framergn)|Dessine une bordure autour d’une région spécifique à l’aide d’un pinceau.|  
|[CDC::FromHandle](#fromhandle)|Retourne un pointeur vers un `CDC` lorsqu’un handle vers un contexte de périphérique de l’objet. Si aucun objet `CDC` n'est attaché au handle, un objet `CDC` temporaire est créé et attaché.|  
|[CDC::GetArcDirection](#getarcdirection)|Renvoie la direction d’arc de cercle en cours pour le contexte de périphérique.|  
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Récupère le paramètre pour le filtre de l’aspect en cours.|  
|[CDC::GetBkColor](#getbkcolor)|Récupère la couleur d’arrière-plan actuelle.|  
|[CDC::GetBkMode](#getbkmode)|Récupère le mode d’arrière-plan.|  
|[CDC::GetBoundsRect](#getboundsrect)|Retourne le rectangle englobant cumulé actuel pour le contexte de périphérique spécifié.|  
|[CDC::GetBrushOrg](#getbrushorg)|Extrait l’origine du pinceau actif.|  
|[CDC::GetCharABCWidths](#getcharabcwidths)|Récupère les largeurs, en unités logiques, de caractères consécutifs dans une plage donnée à partir de la police actuelle.|  
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Récupère les largeurs, en unités logiques, des indices de glyphe consécutives dans une plage spécifiée de la police TrueType en cours.|  
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Récupère les différents types d’informations sur une chaîne de caractères.|  
|[CDC::GetCharWidth](#getcharwidth)|Récupère les largeurs fractionnaires de caractères consécutifs dans une plage donnée à partir de la police actuelle.|  
|[CDC::GetCharWidthI](#getcharwidthi)|Récupère les largeurs, en coordonnées logiques, des indices de glyphe consécutives dans une plage spécifiée de la police actuelle.|  
|[CDC::GetClipBox](#getclipbox)|Récupère les dimensions du rectangle englobant plus étroite autour de la limite de découpage en cours.|  
|[CDC::GetColorAdjustment](#getcoloradjustment)|Récupère les valeurs de réglage des couleurs pour le contexte de périphérique.|  
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Retourne un pointeur vers le sélectionné `CBitmap` objet.|  
|[CDC::GetCurrentBrush](#getcurrentbrush)|Retourne un pointeur vers le sélectionné `CBrush` objet.|  
|[CDC::GetCurrentFont](#getcurrentfont)|Retourne un pointeur vers le sélectionné `CFont` objet.|  
|[CDC::GetCurrentPalette](#getcurrentpalette)|Retourne un pointeur vers le sélectionné `CPalette` objet.|  
|[CDC::GetCurrentPen](#getcurrentpen)|Retourne un pointeur vers le sélectionné `CPen` objet.|  
|[CDC::GetCurrentPosition](#getcurrentposition)|Récupère la position actuelle du stylet (en coordonnées logiques).|  
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Récupère la couleur actuelle du pinceau.|  
|[CDC::GetDCPenColor](#getdcpencolor)|Récupère la couleur actuelle du stylet.|  
|[CDC::GetDeviceCaps](#getdevicecaps)|Récupère un type spécifié des informations spécifiques au périphérique sur les fonctionnalités d’un périphérique d’affichage donné.|  
|[CDC::GetFontData](#getfontdata)|Récupère les informations sur les métriques de police à partir d’un fichier de polices évolutives. Les informations à récupérer sont identifiées en spécifiant un décalage dans le fichier de police et la longueur de l’information à retourner.|  
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Retourne des informations sur la police actuellement sélectionnée pour le contexte d’affichage spécifié.|  
|[CDC::GetGlyphOutline](#getglyphoutline)|Récupère la courbe du plan ou le bitmap pour un caractère avec contour dans la police actuelle.|  
|[CDC::GetGraphicsMode](#getgraphicsmode)|Récupère le mode graphique actuel pour le contexte de périphérique spécifié.|  
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Récupère un pinceau de demi-teintes.|  
|[CDC::GetKerningPairs](#getkerningpairs)|Récupère le caractère le crénage paires pour la police actuellement sélectionnée dans le contexte de périphérique spécifié.|  
|[CDC::GetLayout](#getlayout)|Récupère la disposition d’un contexte de périphérique (DC). La mise en page peut être soit de gauche à droite (par défaut) ou de droite à gauche (en miroir).|  
|[CDC::GetMapMode](#getmapmode)|Récupère le mode de mappage en cours.|  
|[CDC::GetMiterLimit](#getmiterlimit)|Retourne la limite de pointe pour le contexte de périphérique.|  
|[CDC::GetNearestColor](#getnearestcolor)|Récupère la couleur le plus proche logique à une couleur spécifique logique représentant le périphérique donné.|  
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Récupère des informations de métriques de police pour les polices TrueType.|  
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Récupère la largeur des caractères individuels dans un groupe de caractères consécutifs de la police actuelle en utilisant le contexte de périphérique de sortie.|  
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Calcule la largeur et la hauteur d’une chaîne de caractères dans le contexte de périphérique de sortie.|  
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Calcule la largeur et la hauteur d’une ligne de texte dans le contexte de périphérique de sortie à l’aide de la police actuelle pour déterminer les dimensions.|  
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Récupère les mesures pour la police actuelle à partir du contexte de périphérique de sortie.|  
|[CDC::getPath](#getpath)|Récupère les coordonnées définissant les extrémités des lignes et les points de contrôle des courbes dans le chemin d’accès qui est sélectionné dans le contexte de périphérique.|  
|[CDC::getPixel](#getpixel)|Récupère la valeur de couleur RVB du pixel au point spécifié.|  
|[CDC::GetPolyFillMode](#getpolyfillmode)|Récupère le mode de remplissage de polygones en cours.|  
|[CDC::GetROP2](#getrop2)|Récupère le mode de dessin en cours.|  
|[CDC::GetSafeHdc](#getsafehdc)|Retourne [CDC::m_hDC](#m_hdc), le contexte de périphérique de sortie.|  
|[CDC::GetStretchBltMode](#getstretchbltmode)|Récupère le mode d’étirement de bitmap actuel.|  
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Calcule la largeur et la hauteur d’une chaîne de caractères dans le contexte de l’attribut.|  
|[CDC::GetTextAlign](#gettextalign)|Récupère les indicateurs d’alignement de texte.|  
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Récupère la valeur actuelle de la quantité de l’espacement entre les caractères.|  
|[CDC::GetTextColor](#gettextcolor)|Récupère la couleur de texte actuelle.|  
|[CDC::GetTextExtent](#gettextextent)|Calcule la largeur et la hauteur d’une ligne de texte dans le contexte de l’attribut à l’aide de la police actuelle pour déterminer les dimensions.|  
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|Récupère le nombre de caractères dans une chaîne spécifiée qui occupent un espace spécifié et remplit un tableau avec l’étendue de texte pour chacun de ces caractères.|  
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Récupère la largeur et la hauteur du tableau spécifié d’indices de glyphe.|  
|[CDC::GetTextFace](#gettextface)|Copie le nom de la police actuelle dans une mémoire tampon sous forme de chaîne se terminant par null.|  
|[CDC::GetTextMetrics](#gettextmetrics)|Récupère les mesures pour la police actuelle à partir du contexte de périphérique d’attribut.|  
|[CDC::GetViewportExt](#getviewportext)|Récupère les étendues x et y de la fenêtre d’affichage.|  
|[CDC::GetViewportOrg](#getviewportorg)|Récupère les coordonnées x et y de l’origine de la fenêtre d’affichage.|  
|[CDC::GetWindow](#getwindow)|Retourne la fenêtre associée au contexte de périphérique d’affichage.|  
|[CDC::GetWindowExt](#getwindowext)|Récupère les étendues x et y de la fenêtre associée.|  
|[CDC::GetWindowOrg](#getwindoworg)|Récupère les coordonnées x et y de l’origine de la fenêtre associée.|  
|[CDC::GetWorldTransform](#getworldtransform)|Récupère l’espace de monde actuel pour la transformation de l’espace de page.|  
|[CDC::GradientFill](#gradientfill)|Remplit le rectangle et triangle structures avec une couleur gradating.|  
|[CDC::GrayString](#graystring)|Dessine estompé (grisé) de texte à l’emplacement spécifié.|  
|[CDC::HIMETRICtoDP](#himetrictodp)|Convertit **HIMETRIC** unités en unités de périphérique.|  
|[CDC::HIMETRICtoLP](#himetrictolp)|Convertit **HIMETRIC** unités en unités logiques.|  
|[CDC::IntersectClipRect](#intersectcliprect)|Crée une nouvelle zone de découpage par l’intersection de la zone en cours et un rectangle.|  
|[CDC::InvertRect](#invertrect)|Inverse le contenu d’un rectangle.|  
|[CDC::InvertRgn](#invertrgn)|Inverse les couleurs dans une région.|  
|[CDC::IsPrinting](#isprinting)|Détermine si le contexte de périphérique est utilisé pour l’impression.|  
|[CDC::LineTo](#lineto)|Dessine une ligne à partir de la position actuelle jusqu'à, non compris, un point.|  
|[CDC::LPtoDP](#lptodp)|Convertit des unités logiques en unités de périphérique.|  
|[CDC::LPtoHIMETRIC](#lptohimetric)|Convertit des unités logiques dans **HIMETRIC** unités.|  
|[CDC::MaskBlt](#maskblt)|Combine les données de couleur pour les bitmaps source et de destination à l’aide du masque donné et opération.|  
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Modifie la transformation universelle pour un contexte de périphérique en utilisant le mode spécifié.|  
|[CDC::MoveTo](#moveto)|Déplace la position actuelle.|  
|[CDC::OffsetClipRgn](#offsetcliprgn)|Déplace la zone de découpage de l’appareil donné.|  
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Modifie l’origine de la fenêtre d’affichage par rapport aux coordonnées de l’origine de la fenêtre d’affichage en cours.|  
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Modifie l’origine de la fenêtre par rapport aux coordonnées de l’origine de la fenêtre en cours.|  
|[CDC::PaintRgn](#paintrgn)|Remplit une zone avec un pinceau sélectionné.|  
|[CDC::PatBlt](#patblt)|Crée un modèle binaire.|  
|[CDC::Pie](#pie)|Dessine un secteur.|  
|[CDC::PlayMetaFile](#playmetafile)|Lit le contenu du métafichier spécifié sur le périphérique donné. La version améliorée de `PlayMetaFile` affiche l’image stockée dans le métafichier de format amélioré donné. Le métafichier peut être lu un nombre de fois.|  
|[CDC::PlgBlt](#plgblt)|Effectue un transfert de bloc de bits des bits de données de couleur du rectangle spécifié dans le contexte du périphérique source au parallélogramme spécifié dans le contexte de périphérique donné.|  
|[CDC::PolyBezier](#polybezier)|Dessine une ou plusieurs splines Bzier. La position actuelle n’est ni utilisée ni mis à jour.|  
|[CDC::PolyBezierTo](#polybezierto)|Dessine une ou plusieurs splines Bzier et déplace la position actuelle vers le point de fin de la dernière Bzier.|  
|[CDC::PolyDraw](#polydraw)|Dessine un ensemble de segments de ligne et Bzier splines. Cette fonction met à jour la position actuelle.|  
|[CDC::Polygon](#polygon)|Dessine un polygone composé de deux ou plusieurs points (sommets) reliés par des lignes.|  
|[CDC::Polyline](#polyline)|Dessine un ensemble de segments de ligne reliant les points spécifiés.|  
|[CDC::PolylineTo](#polylineto)|Dessine une ou plusieurs lignes droites et déplace la position actuelle vers le point de fin de la dernière ligne.|  
|[CDC::PolyPolygon](#polypolygon)|Crée deux ou plusieurs polygones qui sont remplis à l’aide du mode de remplissage de polygones actuel. Les polygones peuvent être disjoints ou ils peuvent se chevaucher.|  
|[CDC::PolyPolyline](#polypolyline)|Trace de plusieurs séries de segments de ligne connectés. La position actuelle n’est ni utilisée ni mis à jour par cette fonction.|  
|[CDC::PtVisible](#ptvisible)|Spécifie si le point donné se trouve dans la zone de découpage.|  
|[CDC::RealizePalette](#realizepalette)|Mappe des entrées dans la palette logique en cours de la palette à la palette système.|  
|[CDC::rectangle](#rectangle)|Dessine un rectangle en utilisant le stylet actuel et le remplit à l’aide de la brosse courante.|  
|[CDC::RectVisible](#rectvisible)|Détermine si une partie du rectangle donné se trouve dans la zone de découpage.|  
|[CDC::ReleaseAttribDC](#releaseattribdc)|Les versions `m_hAttribDC`, le contexte de l’attribut.|  
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Les versions `m_hDC`, le contexte de périphérique de sortie.|  
|[CDC::ResetDC](#resetdc)|Mises à jour le `m_hAttribDC` contexte de périphérique.|  
|[CDC::RestoreDC](#restoredc)|Restaure le contexte de périphérique à un état précédent enregistré avec `SaveDC`.|  
|[CDC::RoundRect](#roundrect)|Dessine un rectangle à angles arrondis à l’aide du stylet courant et rempli à l’aide de la brosse courante.|  
|[CDC::SaveDC](#savedc)|Enregistre l’état actuel du contexte de périphérique.|  
|[CDC::ScaleViewportExt](#scaleviewportext)|Modifie l’étendue de la fenêtre d’affichage par rapport aux valeurs actuelles.|  
|[CDC::ScaleWindowExt](#scalewindowext)|Modifie l’étendue de la fenêtre par rapport aux valeurs actuelles.|  
|[CDC::ScrollDC](#scrolldc)|Fait défiler un rectangle de bits horizontalement et verticalement.|  
|[CDC::SelectClipPath](#selectclippath)|Sélectionne le chemin d’accès actuel comme une zone de découpage pour le contexte de périphérique, en combinant la nouvelle région avec n’importe quelle région de découpage existant en utilisant le mode spécifié.|  
|[CDC::SelectClipRgn](#selectcliprgn)|Combine la région donnée avec la zone de découpage actuelle en utilisant le mode spécifié.|  
|[CDC::SelectObject](#selectobject)|Sélectionne un objet de dessin GDI telles que d’un stylet.|  
|[CDC::SelectPalette](#selectpalette)|Sélectionne la palette logique.|  
|[CDC::SelectStockObject](#selectstockobject)|Sélectionne un des stylets stocks prédéfinis, pinceaux, polices fournies par Windows.|  
|[CDC::SETABORTPROC](#setabortproc)|Définit une fonction de rappel fourni par le programmeur Windows appelle si un travail d’impression doit être annulé.|  
|[CDC::SetArcDirection](#setarcdirection)|Définit le sens de dessin à utiliser pour les fonctions d’arc de cercle et rectangle.|  
|[CDC::SetAttribDC](#setattribdc)|Jeux de `m_hAttribDC`, le contexte de l’attribut.|  
|[CDC::SetBkColor](#setbkcolor)|Définit la couleur d’arrière-plan actuelle.|  
|[CDC::SetBkMode](#setbkmode)|Définit le mode d’arrière-plan.|  
|[CDC::SetBoundsRect](#setboundsrect)|Contrôle l’accumulation des informations du rectangle englobant pour le contexte de périphérique spécifié.|  
|[CDC::SetBrushOrg](#setbrushorg)|Spécifie l’origine de la forme suivante sélectionnée dans un contexte de périphérique.|  
|[CDC::SetColorAdjustment](#setcoloradjustment)|Définit les valeurs de réglage des couleurs pour le contexte de périphérique en utilisant les valeurs spécifiées.|  
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Définit la couleur actuelle du pinceau.|  
|[CDC::SetDCPenColor](#setdcpencolor)|Définit la couleur actuelle du stylet.|  
|[CDC::SetGraphicsMode](#setgraphicsmode)|Définit le mode graphique actuel pour le contexte de périphérique spécifié.|  
|[CDC::SetLayout](#setlayout)|Modifie la disposition d’un contexte de périphérique (DC).|  
|[CDC::SetMapMode](#setmapmode)|Définit le mode de mappage en cours.|  
|[CDC::SetMapperFlags](#setmapperflags)|Modifie l’algorithme utilisé par le mappeur de polices lorsqu’il mappe les polices logiques aux polices physiques.|  
|[CDC::SetMiterLimit](#setmiterlimit)|Définit la limite de la longueur des jointures de pointe pour le contexte de périphérique.|  
|[CDC::SetOutputDC](#setoutputdc)|Jeux de `m_hDC`, le contexte de périphérique de sortie.|  
|[CDC::SetPixel](#setpixel)|Définit le pixel au point spécifié à la plus proche de la couleur spécifiée.|  
|[CDC::SetPixelV](#setpixelv)|Définit le pixel situé aux coordonnées spécifiées pour l’approximation plus proche de la couleur spécifiée. `SetPixelV`est plus rapide que `SetPixel` car il n’a pas besoin de retourner la valeur de couleur du point réellement peinte.|  
|[CDC::SetPolyFillMode](#setpolyfillmode)|Définit le mode de remplissage de polygones.|  
|[CDC::SetROP2](#setrop2)|Définit le mode de dessin en cours.|  
|[CDC::SetStretchBltMode](#setstretchbltmode)|Définit le mode d’étirement de bitmap.|  
|[CDC::SetTextAlign](#settextalign)|Définit les indicateurs d’alignement de texte.|  
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Définit l’espacement entre les caractères.|  
|[CDC::SetTextColor](#settextcolor)|Définit la couleur du texte.|  
|[CDC::SetTextJustification](#settextjustification)|Ajoute un espace pour les caractères de saut dans une chaîne.|  
|[CDC::SetViewportExt](#setviewportext)|Définit les extensions x et y de la fenêtre d’affichage.|  
|[CDC::SetViewportOrg](#setviewportorg)|Définit l’origine de la fenêtre d’affichage.|  
|[CDC::SetWindowExt](#setwindowext)|Définit les extensions x et y de la fenêtre associée.|  
|[CDC::SetWindowOrg](#setwindoworg)|Définit l’origine de la fenêtre du contexte de périphérique.|  
|[CDC::SetWorldTransform](#setworldtransform)|Définit l’espace universel actuel pour la transformation de l’espace de page.|  
|[CDC::StartDoc](#startdoc)|Indique au pilote de périphérique qui démarre un nouveau travail d’impression.|  
|[CDC::StartPage](#startpage)|Indique au pilote de périphérique qui démarre une nouvelle page.|  
|[CDC::StretchBlt](#stretchblt)|Déplace une bitmap à partir d’un rectangle source et un périphérique dans un rectangle de destination, étirant ou en compressant le bitmap si nécessaire pour l’adapter aux dimensions du rectangle de destination.|  
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Ferme des figures ouvertes dans un chemin d’accès et établit le contour du chemin d’accès en utilisant le stylet actuel remplit son intérieur en utilisant le pinceau actuel.|  
|[CDC::StrokePath](#strokepath)|Affiche le chemin d’accès spécifié en utilisant le stylet actuel.|  
|[CDC::TabbedTextOut](#tabbedtextout)|Écrit une chaîne de caractères à un emplacement spécifié, en développant des onglets pour les valeurs spécifiées dans le tableau de positions de taquet de tabulation.|  
|[CDC::TextOut](#textout)|Écrit une chaîne de caractères à un emplacement spécifié à l’aide de la police actuellement sélectionnée.|  
|[CDC::TransparentBlt](#transparentblt)|Transfère un bloc de bits des données de couleur à partir du contexte de périphérique source spécifiée dans un contexte de périphérique de destination, rendu transparent dans le transfert d’une couleur spécifiée.|  
|[CDC::UpdateColors](#updatecolors)|Mises à jour les couleurs de la zone cliente du contexte de périphérique en mettant en correspondance actuel dans la zone cliente de la palette système sur un pixel par pixel.|  
|[CDC::WidenPath](#widenpath)|Redéfinit le chemin d’accès actuel comme la zone serait être peinte si le chemin d’accès ont été dessiné avec le stylet actuellement sélectionné dans le contexte de périphérique.|  
  
### <a name="public-operators"></a>Op&#233;rateurs publics  
  
|Nom|Description|  
|----------|-----------------|  
|[CDC::operator HDC](#operator_hdc)|Récupère le handle du contexte de périphérique.|  
  
### <a name="public-data-members"></a>Membres de données publics  
  
|Nom|Description|  
|----------|-----------------|  
|[CDC::m_hAttribDC](#m_hattribdc)|Le contexte de périphérique d’attribut utilisé par ce `CDC` objet.|  
|[CDC::m_hDC](#m_hdc)|Le contexte de périphérique de sortie utilisé par ce `CDC` objet.|  
  
## <a name="remarks"></a>Notes  
 Le `CDC` objet propose des fonctions membres pour travailler avec un contexte de périphérique, comme un écran ou imprimante, ainsi que les membres pour travailler avec un contexte d’affichage associé à la zone cliente d’une fenêtre.  
  
 Exécuter des fonctions de tout le dessin via le membre une `CDC` objet. La classe fournit des fonctions membres pour les opérations de contexte de périphérique, utilisation des outils, sélection d’objets graphiques de type sécurisé device interface (GDI), de dessin et utilisation des couleurs et palettes. Il fournit également des fonctions membres pour obtenir et définir des attributs, de dessin de mappage, l’utilisation de la fenêtre d’affichage, utilisation de l’étendue de la fenêtre, convertir des coordonnées, utilisation de régions, de découpage, tracer des lignes et polygones, des ellipses et des formes simples de dessin. Les fonctions membres sont également fournies pour dessiner du texte, travailler avec des polices, à l’aide de séquences d’échappement imprimante, le défilement et la lecture des métafichiers.  
  
 Pour utiliser un `CDC` de l’objet, construire et ensuite appeler ses fonctions membres parallèles des fonctions de Windows qui utilisent des contextes de périphérique.  
  
> [!NOTE]
>  Sous Windows 95/98, toutes les coordonnées d’écran sont limitées à 16 bits. Par conséquent, un `int` transmis à un `CDC` fonction membre doit se trouver dans la plage –32768 à 32767.  
  
 Pour des utilisations spécifiques, la bibliothèque Microsoft Foundation Class fournit plusieurs classes dérivées de `CDC` . `CPaintDC`encapsule les appels à `BeginPaint` et `EndPaint`. `CClientDC`gère un contexte d’affichage associé à la zone cliente d’une fenêtre. `CWindowDC`gère un contexte d’affichage associé à une fenêtre entière, y compris son image et les contrôles. `CMetaFileDC`associe un contexte de périphérique de métafichier.  
  
 `CDC`fournit deux fonctions membres, [GetLayout](#getlayout) et [SetLayout](#setlayout), pour inverser la disposition d’un contexte de périphérique, qui n’hérite pas sa disposition à partir d’une fenêtre. Cette orientation de droite à gauche est nécessaire pour les applications écrites pour les cultures, telles que l’arabe ou l’hébreu, où la disposition des caractères n’est pas la norme européenne.  
  
 `CDC`contient deux contextes de périphérique, [m_hDC](#m_hdc) et [m_hAttribDC](#m_hattribdc), qui, lors de la création d’un `CDC` de l’objet, reportez-vous à la même unité. `CDC`Indique tous les appels GDI de sortie à `m_hDC` et la plupart des attributs GDI appelle `m_hAttribDC`. (Un exemple d’un appel d’attribut est `GetTextColor`, tandis que `SetTextColor` est un appel de sortie.)  
  
 Par exemple, le framework utilise ces contextes de deux périphérique pour implémenter un `CMetaFileDC` objet qui enverra sortie dans un métafichier lors de la lecture des attributs à partir d’un périphérique physique. Aperçu avant impression est implémenté dans le cadre de la même manière. Vous pouvez également utiliser les contextes de deux périphérique de la même façon dans votre code spécifique à l’application.  
  
 Parfois, vous devez parfois des informations de mesure de texte à partir du `m_hDC` et `m_hAttribDC` contextes de périphérique. Les paires de fonctions suivantes fournissent cette fonctionnalité :  
  
|Utilise m_hAttribDC|Utilise m_hDC|  
|-----------------------|-----------------|  
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|  
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|  
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|  
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|  
  
 Pour plus d’informations sur `CDC`, consultez [contextes de périphérique](../../mfc/device-contexts.md).  
  
## <a name="inheritance-hierarchy"></a>Hiérarchie d’héritage  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 `CDC`  
  
## <a name="requirements"></a>Spécifications  
 **En-tête :** afxwin.h  
  
##  <a name="abortdoc"></a>CDC::AbortDoc  
 Met fin à l’impression en cours et supprime tout ce que l’application a écrit sur le périphérique depuis le dernier appel à la [StartDoc](#startdoc) fonction membre.  
  
```  
int AbortDoc();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur supérieure ou égale à 0 en cas de réussite, ou une valeur négative si une erreur s’est produite. La liste suivante affiche les valeurs d’erreur courants et leur signification :  
  
- **SP_ERROR** erreur générale.  
  
- **SP_OUTOFDISK** pas suffisamment d’espace disque est actuellement disponible pour la mise en attente, et davantage d’espace est disponible.  
  
- **SP_OUTOFMEMORY** pas assez de mémoire est disponible pour la mise en attente.  
  
- **SP_USERABORT** l’utilisateur a arrêté la tâche via le Gestionnaire d’impression.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre remplace le `ABORTDOC` échappement d’imprimante.  
  
 **AbortDoc** doit être utilisé pour mettre fin à ce qui suit :  
  
-   Les opérations d’impression qui ne spécifient pas une fonction abort avec [SetAbortProc](#setabortproc).  
  
-   Les opérations d’impression qui n’ont pas encore atteint le premier **NEWFRAME** ou **NEXTBAND** d’échappement d’appel.  
  
 Si une application rencontre une erreur d’impression ou une opération d’impression annulée, il ne devez pas tenter de terminer l’opération en utilisant la [EndDoc](#enddoc) ou **AbortDoc** fonctions membres de classe `CDC`. GDI termine automatiquement l’opération avant de retourner la valeur d’erreur.  
  
 Si l’application affiche une boîte de dialogue pour permettre à l’utilisateur d’annuler l’opération d’impression, il doit appeler **AbortDoc** avant la destruction de la boîte de dialogue.  
  
 Si le Gestionnaire d’impression a été utilisé pour démarrer le travail d’impression, l’appel **AbortDoc** supprime la tâche de spool ensemble, l’imprimante reçoit rien. Si le Gestionnaire d’impression n’a pas été utilisé pour démarrer le travail d’impression, les données peuvent ont été envoyées à l’imprimante avant **AbortDoc** a été appelée. Dans ce cas, le pilote d’imprimante ont réinitialisera l’imprimante (si possible) et fermé le travail d’impression.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::StartDoc](#startdoc).  
  
##  <a name="abortpath"></a>CDC::AbortPath  
 Ferme et ignore les chemins d’accès dans le contexte de périphérique.  
  
```  
BOOL AbortPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 S’il existe un crochet tracé ouvert dans le contexte de périphérique, le crochet de chemin d’accès est fermé et le chemin d’accès est ignoré. S’il existe une trajectoire fermée dans le contexte de périphérique, le chemin d’accès est ignoré.  
  
##  <a name="addmetafilecomment"></a>CDC::AddMetaFileComment  
 Copie le commentaire d’une mémoire tampon dans un métafichier amélioré au format spécifié.  
  
```  
BOOL AddMetaFileComment(
    UINT nDataSize,  
    const BYTE* pCommentData);
```  
  
### <a name="parameters"></a>Paramètres  
 *nDataSize*  
 Spécifie la longueur de la mémoire tampon de commentaire, en octets.  
  
 *pCommentData*  
 Pointe vers la mémoire tampon qui contient le commentaire.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Un commentaire peut inclure des informations confidentielles, par exemple, la source de l’image et la date de création. Un commentaire doit commencer par une signature d’application, suivie des données. Les commentaires ne doivent pas contenir les données spécifiques à la position. Les données spécifiques à la position indique l’emplacement d’enregistrement, et ne doit pas être inclus, car un métafichier peut être incorporé dans un autre métafichier. Cette fonction peut être utilisée uniquement avec les métafichiers améliorés.  
  
##  <a name="alphablend"></a>CDC::AlphaBlend  
 Appelez cette fonction membre pour afficher des bitmaps qui ont des pixels transparents ou semi-transparent.  
  
```  
BOOL AlphaBlend(
    int xDest,  
    int yDest,  
    int nDestWidth,  
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    BLENDFUNCTION blend);
```  
  
### <a name="parameters"></a>Paramètres  
 `xDest`  
 Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle de destination.  
  
 `yDest`  
 Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle de destination.  
  
 `nDestWidth`  
 Spécifie la largeur, en unités logiques, du rectangle de destination.  
  
 `nDestHeight`  
 Spécifie la hauteur, en unités logiques, du rectangle de destination.  
  
 `pSrcDC`  
 Pointeur vers le contexte du périphérique source.  
  
 `xSrc`  
 Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle source.  
  
 `ySrc`  
 Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle source.  
  
 `nSrcWidth`  
 Spécifie la largeur, en unités logiques, du rectangle source.  
  
 `nSrcHeight`  
 Spécifie la hauteur, en unités logiques, du rectangle source.  
  
 *Blend*  
 Spécifie un [BLENDFUNCTION](http://msdn.microsoft.com/library/windows/desktop/dd183393) structure.  
  
### <a name="return-value"></a>Valeur de retour  
 **TRUE** cas de réussite ; sinon **FALSE**.  
  
### <a name="remarks"></a>Remarques  
 Consultez la page [AlphaBlend](http://msdn.microsoft.com/library/windows/desktop/dd183351) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour plus d’informations.  
  
##  <a name="anglearc"></a>CDC::AngleArc  
 Dessine un arc et un segment de ligne.  
  
```  
BOOL AngleArc(
    int x,  
    int y,  
    int nRadius,  
    float fStartAngle,  
    float fSweepAngle);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du centre du cercle.  
  
 *y*  
 Spécifie la coordonnée y logique du centre du cercle.  
  
 *nRadius*  
 Spécifie le rayon du cercle en unités logiques. Cette valeur doit être positive.  
  
 *fStartAngle*  
 Spécifie l’angle de départ en degrés par rapport à l’axe des abscisses.  
  
 *fSweepAngle*  
 Spécifie l’angle de balayage en degrés par rapport à l’angle de départ.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le segment de ligne est dessiné à partir de la position actuelle vers le début de l’arc. L’arc est dessiné le long du périmètre d’un cercle avec le centre et le rayon donné. La longueur de l’arc est définie par les angles de début et de balayage données.  
  
 `AngleArc`Déplace la position actuelle vers le point de fin de l’arc. L’arc dessiné par cette fonction peut sembler être elliptique, selon le mode de mappage et de transformation en cours. Avant de dessiner l’arc, cette fonction Dessine le segment de ligne à partir de la position actuelle vers le début de l’arc. L’arc est dessiné à l’aide d’un cercle imaginaire rayon donné autour du point central spécifié. Le point de départ de l’arc est déterminé par la mesure dans le sens inverse de l’axe x du cercle par le nombre de degrés de l’angle de départ. Le point de fin se trouve de la même façon en mesurant dans le sens inverse à partir du point de départ le nombre de degrés de l’angle de balayage.  
  
 Si l’angle de balayage est supérieur à 360 degrés l’arc est balayé plusieurs fois. Cette fonction dessine des lignes en utilisant le stylet actuel. La figure n’est pas remplie.  
  
##  <a name="arc"></a>CDC::arc  
 Dessine un arc elliptique.  
  
```  
BOOL Arc(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Arc(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x de l’angle supérieur gauche du rectangle englobant (en unités logiques).  
  
 `y1`  
 Spécifie la coordonnée y de l’angle supérieur gauche du rectangle englobant (en unités logiques).  
  
 `x2`  
 Spécifie la coordonnée x de l’angle inférieur droit du rectangle englobant (en unités logiques).  
  
 `y2`  
 Spécifie la coordonnée y du coin inférieur droit du rectangle englobant (en unités logiques).  
  
 *x3*  
 Spécifie la coordonnée x du point qui définit l’arc de départ point (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc.  
  
 `y3`  
 Spécifie la coordonnée y du point qui définit l’arc de départ point (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc.  
  
 `x4`  
 Spécifie la coordonnée x du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc.  
  
 `y4`  
 Spécifie la coordonnée y du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc.  
  
 `lpRect`  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer soit un `LPRECT` ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 `ptStart`  
 Spécifie les coordonnées x et y du point qui définit l’arc de départ point (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
 `ptEnd`  
 Spécifie les coordonnées x et y du point qui définit le point de fin de l’arc (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 L’arc dessiné à l’aide de la fonction est un segment de l’ellipse est définie par le rectangle englobant spécifié.  
  
 Point de début de l’arc est le point auquel un rayon dessiné à partir du centre du rectangle englobant via le point de départ spécifié entre en intersection avec l’ellipse. Le point de fin réels de l’arc est le point auquel un rayon dessiné à partir du centre du rectangle englobant via le point de fin spécifié entre en intersection avec l’ellipse. L’arc est dessiné dans une direction vers la gauche. Un arc n’étant pas une figure fermée, il n’est pas rempli. La largeur et la hauteur du rectangle doivent être supérieures à 2 unités et inférieure à 32 767.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView&#29;](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]  
  
##  <a name="arcto"></a>CDC::ArcTo  
 Dessine un arc elliptique.  
  
```  
BOOL ArcTo(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL ArcTo(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x de l’angle supérieur gauche du rectangle englobant (en unités logiques).  
  
 `y1`  
 Spécifie la coordonnée y de l’angle supérieur gauche du rectangle englobant (en unités logiques).  
  
 `x2`  
 Spécifie la coordonnée x de l’angle inférieur droit du rectangle englobant (en unités logiques).  
  
 `y2`  
 Spécifie la coordonnée y du coin inférieur droit du rectangle englobant (en unités logiques).  
  
 *x3*  
 Spécifie la coordonnée x du point qui définit l’arc de départ point (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc.  
  
 `y3`  
 Spécifie la coordonnée y du point qui définit l’arc de départ point (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc.  
  
 `x4`  
 Spécifie la coordonnée x du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc.  
  
 `y4`  
 Spécifie la coordonnée y du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc.  
  
 `lpRect`  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer un pointeur vers un [RECT](../../mfc/reference/rect-structure1.md) structure de données ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 `ptStart`  
 Spécifie les coordonnées x et y du point qui définit l’arc de départ point (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure de données ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
 `ptEnd`  
 Spécifie les coordonnées x et y du point qui définit le point de fin de l’arc (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc. Vous pouvez passer soit un **POINT** structure de données ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction est similaire à `CDC::Arc`, sauf que la position actuelle est mise à jour. Les points ( `x1`, `y1`) et ( `x2`, `y2`) définissent le rectangle englobant. Une ellipse formée par le rectangle englobant donné définit la courbe de l’arc. L’arc s’étend dans le sens inverse (la direction par défaut d’arc de cercle) à partir du point où il entre en intersection avec la ligne à partir du centre du rectangle englobant pour radiale ( *x3*, `y3`). Les extrémités de l’arc où il entre en intersection avec la ligne radiale à partir du centre du rectangle englobant pour ( `x4`, `y4`). Si le point de départ et le point de fin sont identiques, une ellipse complète est dessinée.  
  
 Une ligne est tracée à partir de la position actuelle vers le point de départ de l’arc. Si aucune erreur ne se produit, la position actuelle est définie pour le point de fin de l’arc. L’arc est dessiné en utilisant le stylet actuel ; Il n’est pas rempli.  
  
##  <a name="attach"></a>CDC::Attach  
 Cette fonction membre permet de joindre un `hDC` à le `CDC` objet.  
  
```  
BOOL Attach(HDC hDC);
```  
  
### <a name="parameters"></a>Paramètres  
 `hDC`  
 Un contexte de périphérique Windows.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le `hDC` sont stockées dans les deux `m_hDC`, le contexte de périphérique de sortie et dans `m_hAttribDC`, le contexte de l’attribut.  
  
##  <a name="beginpath"></a>CDC::BeginPath  
 Ouvre un crochet de chemin d’accès dans le contexte de périphérique.  
  
```  
BOOL BeginPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Après avoir ouvert un crochet de chemin d’accès, une application peut commencer l’appel de dessin GDI fonctions permettant de définir les points qui se trouvent dans le chemin d’accès. Une application peut fermer un crochet tracé ouvert en appelant le `EndPath` fonction membre. Lorsqu’une application appelle `BeginPath`, les chemins d’accès précédentes sont ignorées.  
  
 Consultez la page [BeginPath](http://msdn.microsoft.com/library/windows/desktop/dd183363) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour obtenir la liste des fonctions de dessin qui définissent les points dans un chemin d’accès.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[30 NVC_MFCDocView](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]  
  
##  <a name="bitblt"></a>CDC::BitBlt  
 Copie une image bitmap à partir du contexte de périphérique source vers ce contexte de périphérique en cours.  
  
```  
BOOL BitBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle de destination.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle de destination.  
  
 `nWidth`  
 Spécifie la largeur (en unités logiques) de la bitmap de destination rectangle et source.  
  
 `nHeight`  
 Spécifie la hauteur (en unités logiques) de la bitmap de destination rectangle et source.  
  
 `pSrcDC`  
 Pointeur vers un `CDC` objet qui identifie le contexte de périphérique à partir duquel la bitmap est copiée. Il doit être **NULL** si *dwRop* spécifie une opération qui n’inclut pas d’une source.  
  
 `xSrc`  
 Spécifie la coordonnée x logique de l’angle supérieur gauche de la bitmap source.  
  
 `ySrc`  
 Spécifie la coordonnée y logique de l’angle supérieur gauche de la bitmap source.  
  
 *dwRop*  
 Spécifie l'opération de rastérisation à effectuer. Codes d’opération de rastérisation définissent la façon dont GDI associe les couleurs dans les opérations de sortie qui impliquent le pinceau actuel, un éventuel bitmap source et une image bitmap de destination. Consultez la page [BitBlt](http://msdn.microsoft.com/library/windows/desktop/dd183370) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour obtenir la liste des codes d’opération de rastérisation pour *dwRop* et leurs descriptions  
  
 Pour obtenir une liste complète des codes d’opération de rastérisation, consultez [sur les Codes d’opération Raster](http://msdn.microsoft.com/library/windows/desktop/dd162892) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 L’application peut aligner les fenêtres ou les zones clientes sur les limites d’octets pour garantir que la `BitBlt` opérations ont lieu dans les rectangles aligné sur un octet. (Définir le **CS_BYTEALIGNWINDOW** ou **CS_BYTEALIGNCLIENT** indicateurs lorsque vous inscrivez les classes de fenêtre.)  
  
 `BitBlt`opérations sur les rectangles aligné sur un octet sont beaucoup plus rapides que `BitBlt` opérations sur les rectangles qui ne sont pas alignées sur octets. Si vous souhaitez spécifier des styles de classe telles que l’alignement en octets pour votre propre contexte de périphérique, vous devez enregistrer une classe fenêtre plutôt que d’utiliser les classes Microsoft Foundation à faire pour vous. Utilisez la fonction globale [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).  
  
 GDI transforme `nWidth` et `nHeight`, une fois à l’aide du contexte de périphérique de destination et qu’une seule fois à l’aide du contexte du périphérique source. Si les étendues qui en résulte ne correspondent pas, GDI utilise Windows `StretchBlt` fonction de compresser ou étirer le bitmap source si nécessaire.  
  
 Si les bitmaps de modèle, source et de destination n’ont pas le même format de couleur, la `BitBlt` fonction convertit les bitmaps source et le modèle pour correspondre à la destination. Les couleurs de premier plan et d’arrière-plan de la bitmap de destination sont utilisées dans la conversion.  
  
 Lorsque le `BitBlt` fonction convertit un bitmap monochrome en couleur, il définit les bits blancs (1) pour la couleur d’arrière-plan et les bits noirs (0) à la couleur de premier plan. Les couleurs de premier plan et d’arrière-plan du contexte de périphérique de destination sont utilisées. Pour convertir la couleur en monochrome, `BitBlt` définit les pixels qui correspondent à la couleur d’arrière-plan en blanc et tous les autres pixels à noir. `BitBlt`utilise les couleurs de premier plan et d’arrière-plan du contexte de périphérique de couleur pour convertir la couleur en monochrome.  
  
 Notez que la prise en charge pas tous les contextes de périphérique `BitBlt`. Pour vérifier si un contexte de périphérique spécifié ne prend pas en charge `BitBlt`, utiliser le `GetDeviceCaps` membre de fonction et spécifiez le **RASTERCAPS** index.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::CreateCompatibleDC](#createcompatibledc).  
  
##  <a name="cdc"></a>CDC::CDC  
 Construit un objet `CDC`.  
  
```  
CDC();
```  
  
##  <a name="chord"></a>CDC::Chord  
 Dessine un segment (figure fermée délimitée par l’intersection d’une ellipse et un segment de ligne).  
  
```  
BOOL Chord(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Chord(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie que la coordonnée x du coin supérieur gauche de la pression simultanée de délimitation de rectangle (en unités logiques).  
  
 `y1`  
 Spécifie que la coordonnée y du coin supérieur gauche de la pression simultanée de délimitation de rectangle (en unités logiques).  
  
 `x2`  
 Spécifie que la coordonnée x du coin inférieur droit de la pression simultanée de délimitation de rectangle (en unités logiques).  
  
 `y2`  
 Spécifie que la coordonnée y du coin inférieur droit de la pression simultanée de délimitation de rectangle (en unités logiques).  
  
 *x3*  
 Spécifie la coordonnée x du point qui définit la pression simultanée de départ point (en unités logiques).  
  
 `y3`  
 Spécifie la coordonnée y du point qui définit la pression simultanée de départ point (en unités logiques).  
  
 `x4`  
 Spécifie la coordonnée x du point qui définit le point de terminaison de la pression simultanée (en unités logiques).  
  
 `y4`  
 Spécifie la coordonnée y du point qui définit le point de terminaison de la pression simultanée (en unités logiques).  
  
 `lpRect`  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer soit un `LPRECT` ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 `ptStart`  
 Spécifie les coordonnées x et y du point qui définit la pression simultanée de départ point (en unités logiques). Ce point ne devra pas se situer exactement sur le segment. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
 `ptEnd`  
 Spécifie les coordonnées x et y du point qui définit le point de fin de la pression simultanée (en unités logiques). Ce point ne devra pas se situer exactement sur le segment. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La ( `x1`, `y1`) et ( `x2`, `y2`) les paramètres spécifient les angles supérieur gauche et à droite, respectivement, d’un rectangle englobant de l’ellipse qui fait partie de la pression simultanée. La ( *x3*, `y3`) et ( `x4`, `y4`) les paramètres spécifient les points de terminaison d’une ligne qui coupe l’ellipse. Le segment est dessiné à l’aide du stylet sélectionné et rempli à l’aide du pinceau sélectionné.  
  
 La figure dessinée par le `Chord` fonction étend jusqu'à, mais n’inclut pas les coordonnées de droite et inférieure. Cela signifie que la hauteur de la figure est `y2` – `y1` et la largeur de la figure est `x2` – `x1`.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView&#31;](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]  
  
##  <a name="closefigure"></a>CDC::CloseFigure  
 Ferme une figure ouverte dans un chemin d’accès.  
  
```  
BOOL CloseFigure();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 La fonction termine la figure en dessinant une ligne à partir de la position actuelle et le premier point de la figure (en règle générale, le point spécifié par le dernier appel à la `MoveTo` fonction membre) et connecte les lignes en utilisant le style de ligne de jointure. Si une figure est fermée à l’aide de la `LineTo` fonction membre au lieu de `CloseFigure`, majuscules sont utilisées pour créer l’angle au lieu d’une jointure. `CloseFigure`doit être appelée uniquement s’il existe un crochet tracé ouvert dans le contexte de périphérique.  
  
 Figure dans un chemin d’accès est ouverte, sauf si elle est fermée explicitement à l’aide de cette fonction. (Figure peut être ouverte même si le point actuel et le point de départ de la figure sont les mêmes.) Tout ou ajouté le chemin d’accès après une courbe `CloseFigure` crée une nouvelle figure.  
  
##  <a name="createcompatibledc"></a>CDC::CreateCompatibleDC  
 Crée un contexte de périphérique mémoire compatible avec le périphérique spécifié par `pDC`.  
  
```  
BOOL CreateCompatibleDC(CDC* pDC);
```  
  
### <a name="parameters"></a>Paramètres  
 `pDC`  
 Pointeur vers un contexte de périphérique. Si `pDC` est **NULL**, la fonction crée un contexte de périphérique mémoire compatible avec l’affichage du système.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Un contexte de périphérique mémoire est un bloc de mémoire qui représente une surface d’affichage. Il peut être utilisé pour préparer des images en mémoire avant de les copier vers l’aire de périphérique réel du périphérique compatible.  
  
 Création d’un contexte de périphérique mémoire, GDI sélectionne automatiquement un bitmap de stock monochrome 1-par-1 pour lui. Fonctions de sortie GDI peuvent être utilisées avec un contexte de périphérique mémoire uniquement si une image bitmap a été créée et sélectionnée dans ce contexte.  
  
 Cette fonction peut uniquement être utilisée pour créer des contextes de périphérique compatible pour les périphériques qui prennent en charge les opérations de trame. Consultez le [CDC::BitBlt](#bitblt) fonction membre pour plus d’informations concernant les transferts de blocs de bits entre les contextes de périphérique. Pour déterminer si un contexte de périphérique prend en charge les opérations de rastérisation, consultez le **RC_BITBLT** fonctionnalité raster dans la fonction membre `CDC::GetDeviceCaps`.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView n°&32;](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]  
  
##  <a name="createdc"></a>CDC::CreateDC  
 Crée un contexte de périphérique pour le périphérique spécifié.  
  
```  
BOOL CreateDC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszDriverName`  
 Pointe vers une chaîne terminée par le caractère null qui spécifie le nom de fichier (sans extension) du pilote de périphérique (par exemple, « EPSON »). Vous pouvez également transmettre un `CString` objet pour ce paramètre.  
  
 `lpszDeviceName`  
 Pointe vers une chaîne terminée par le caractère null qui spécifie le nom du périphérique pris en charge (par exemple, « EPSON FX-80 »). Le `lpszDeviceName` paramètre est utilisé si le module prend en charge plusieurs périphériques. Vous pouvez également transmettre un `CString` objet pour ce paramètre.  
  
 `lpszOutput`  
 Pointe vers une chaîne terminée par le caractère null qui spécifie le nom de fichier ou un périphérique pour la sortie physique du port de sortie ou fichier. Vous pouvez également transmettre un `CString` objet pour ce paramètre.  
  
 `lpInitData`  
 Pointe vers une `DEVMODE` structure contenant des données d’initialisation spécifique au périphérique pour le pilote de périphérique. Les fenêtres **DocumentProperties** fonction récupère cette structure renseignée pour un périphérique donné. Le `lpInitData` le paramètre doit être **NULL** si le pilote de périphérique est d’utiliser l’initialisation par défaut (le cas échéant) spécifiée par l’utilisateur via le panneau de configuration.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 L’impression. Fichier d’en-tête H est requis si le [DEVMODE](http://msdn.microsoft.com/library/windows/desktop/dd183565) structure est utilisée.  
  
 Noms de périphériques conformes aux conventions : une fin (deux-points) est recommandé mais facultatif. Windows supprime les deux points de terminaison afin qu’un nom de périphérique se terminant par un signe deux-points est mappé vers le même port que le même nom sans les deux-points. Les noms de pilote et le port ne doivent pas contenir des espaces de début ou de fin. Fonctions de sortie GDI ne peut pas être utilisées avec des contextes d’informations.  
  
##  <a name="createic"></a>CDC::CreateIC  
 Crée un contexte d’information pour le périphérique spécifié.  
  
```  
BOOL CreateIC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszDriverName`  
 Pointe vers une chaîne terminée par le caractère null qui spécifie le nom de fichier (sans extension) du pilote de périphérique (par exemple, « EPSON »). Vous pouvez passer un `CString` objet pour ce paramètre.  
  
 `lpszDeviceName`  
 Pointe vers une chaîne terminée par le caractère null qui spécifie le nom du périphérique pris en charge (par exemple, « EPSON FX-80 »). Le `lpszDeviceName` paramètre est utilisé si le module prend en charge plusieurs périphériques. Vous pouvez passer un `CString` objet pour ce paramètre.  
  
 `lpszOutput`  
 Pointe vers une chaîne terminée par le caractère null qui spécifie le nom de fichier ou un périphérique pour le support de sortie physique (fichier ou port). Vous pouvez passer un `CString` objet pour ce paramètre.  
  
 `lpInitData`  
 Points de données d’initialisation spécifique au périphérique pour le pilote de périphérique. Le `lpInitData` le paramètre doit être **NULL** si le pilote de périphérique est d’utiliser l’initialisation par défaut (le cas échéant) spécifiée par l’utilisateur via le panneau de configuration. Consultez `CreateDC` pour le format de données pour l’initialisation spécifique au périphérique.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le contexte d’information fournit un moyen rapide d’obtenir des informations sur le périphérique sans créer un contexte de périphérique.  
  
 Noms de périphériques conformes aux conventions : une fin (deux-points) est recommandé mais facultatif. Windows supprime les deux points de terminaison afin qu’un nom de périphérique se terminant par un signe deux-points est mappé vers le même port que le même nom sans les deux-points. Les noms de pilote et le port ne doivent pas contenir des espaces de début ou de fin. Fonctions de sortie GDI ne peut pas être utilisées avec des contextes d’informations.  
  
##  <a name="deletedc"></a>CDC::DeleteDC  
 En général, n’appelez pas cette fonction ; le destructeur fera pour vous.  
  
```  
BOOL DeleteDC();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la fonction a été effectuée avec succès ; sinon 0.  
  
### <a name="remarks"></a>Remarques  
 Le `DeleteDC` fonction membre supprime les contextes de périphérique Windows qui sont associés aux `m_hDC` en cours `CDC` objet. Si cette `CDC` objet est le dernier contexte de périphérique active pour un périphérique donné, le périphérique est notifié et toutes les ressources système et de stockage utilisés par l’appareil sont libérées.  
  
 Une application ne doit pas appeler `DeleteDC` si les objets ont été sélectionnés dans le contexte de périphérique. Objets doivent être sélectionnés en premier hors du contexte de périphérique avant d’être supprimé.  
  
 Une application ne doit pas supprimer un contexte de périphérique dont le handle a été obtenu en appelant [CWnd::GetDC](../../mfc/reference/cwnd-class.md#getdc). Au lieu de cela, il doit appeler [CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) pour libérer le contexte de périphérique. Le [CClientDC](../../mfc/reference/cclientdc-class.md) et [CWindowDC](../../mfc/reference/cwindowdc-class.md) classes sont fournies pour encapsuler ces fonctionnalités.  
  
 Le `DeleteDC` fonction est généralement utilisée pour supprimer des contextes de périphérique créés avec [CreateDC](#createdc), [CreateIC](#createic), ou [CreateCompatibleDC](#createcompatibledc).  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).  
  
##  <a name="deletetempmap"></a>CDC::DeleteTempMap  
 Appelée automatiquement par le `CWinApp` Gestionnaire de durée d’inactivité, `DeleteTempMap` supprime tout fichier temporaire `CDC` objets créés par `FromHandle`, mais ne détruit ne pas les handles de contexte de périphérique ( `hDC`s) associé temporairement le `CDC` objets.  
  
```  
static void PASCAL DeleteTempMap();
```  
  
##  <a name="detach"></a>CDC::Detach  
 Appelez cette fonction pour détacher `m_hDC` (le contexte de périphérique de sortie) à partir de la `CDC` et définissez les deux `m_hDC` et `m_hAttribDC` à **NULL**.  
  
```  
HDC Detach();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un contexte de périphérique Windows.  
  
##  <a name="dptohimetric"></a>CDC::DPtoHIMETRIC  
 Utilisez cette fonction lorsque vous donnez **HIMETRIC** tailles à OLE, conversion de pixels à **HIMETRIC**.  
  
```  
void DPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpSize`  
 Pointe vers une [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 Si le mode de mappage de l’objet de contexte de périphérique est `MM_LOENGLISH`, `MM_HIENGLISH`, `MM_LOMETRIC`, ou `MM_HIMETRIC`, la conversion est basée sur le nombre de pixels de pouce physique. Si le mode de mappage est un des autres modes non limité (par exemple, `MM_TEXT`), la conversion est basée sur le nombre de pixels de pouce logique.  
  
##  <a name="dptolp"></a>CDC::DPtoLP  
 Convertit des unités de périphérique en unités logiques.  
  
```  
void DPtoLP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) structures ou [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objets.  
  
 `nCount`  
 Le nombre de points dans le tableau.  
  
 `lpRect`  
 Pointe vers une [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet. Ce paramètre est utilisé dans le cas simple de la conversion d’un rectangle à partir de points de périphérique en points logiques.  
  
 `lpSize`  
 Pointe vers une [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 La fonction mappe les coordonnées de chaque point, ou une dimension de taille, dans le système de coordonnées de périphérique dans le système de coordonnées logiques du GDI. La conversion dépend du mode de mappage en cours et les paramètres de l’origine et les extensions de fenêtre et de la fenêtre d’affichage du périphérique.  
  
##  <a name="draw3drect"></a>CDC::Draw3dRect  
 Appelez cette fonction membre pour dessiner un rectangle en trois dimensions.  
  
```  
void Draw3dRect(
    LPCRECT lpRect,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);

 
void Draw3dRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer un pointeur vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 *clrTopLeft*  
 Spécifie la couleur des côtés haut et gauche du rectangle en trois dimensions.  
  
 `clrBottomRight`  
 Spécifie la couleur du fond et le côté droit du rectangle en trois dimensions.  
  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle en trois dimensions.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle en trois dimensions.  
  
 CX  
 Spécifie la largeur du rectangle en trois dimensions.  
  
 CY  
 Spécifie la hauteur du rectangle en trois dimensions.  
  
### <a name="remarks"></a>Remarques  
 Le rectangle sera dessiné avec les bords supérieur et gauche de la couleur spécifiée par *clrTopLeft* et le bas et à droite dans la couleur spécifiée par `clrBottomRight`.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView&#33;](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]  
  
##  <a name="drawdragrect"></a>CDC::DrawDragRect  
 Appelez cette fonction membre à plusieurs reprises pour redessiner un rectangle de glissement.  
  
```  
void DrawDragRect(
    LPCRECT lpRect,  
    SIZE size,  
    LPCRECT lpRectLast,  
    SIZE sizeLast,  
    CBrush* pBrush = NULL,  
    CBrush* pBrushLast = NULL);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers une [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui spécifie les coordonnées logiques d’un rectangle, dans ce cas, la position de fin du rectangle est redessiné.  
  
 `size`  
 Spécifie le déplacement à partir du coin supérieur gauche de la bordure externe de l’angle supérieur gauche de la bordure interne (autrement dit, l’épaisseur de la bordure) d’un rectangle.  
  
 `lpRectLast`  
 Pointe vers une [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui spécifie les coordonnées logiques de la position d’un rectangle, dans ce cas, la position d’origine du rectangle est redessiné.  
  
 *sizeLast*  
 Spécifie le déplacement à partir du coin supérieur gauche de la bordure externe de l’angle supérieur gauche de la bordure interne (autrement dit, l’épaisseur de la bordure) du rectangle d’origine est redessiné.  
  
 `pBrush`  
 Pointeur vers un objet brush. La valeur **NULL** pour utiliser le pinceau de demi-teintes par défaut.  
  
 *pBrushLast*  
 Pointeur vers l’objet brush dernier utilisé. La valeur **NULL** pour utiliser le pinceau de demi-teintes par défaut.  
  
### <a name="remarks"></a>Notes  
 Appelez dans une boucle que des exemples de la position de la souris, pour fournir une rétroaction visuelle. Lorsque vous appelez la méthode `DrawDragRect`, le rectangle précédent est effacé et un nouveau est dessiné. Par exemple, en tant que l’utilisateur fait glisser un rectangle sur l’écran, `DrawDragRect` supprime le rectangle d’origine et redessiner une dans son nouvel emplacement. Par défaut, `DrawDragRect` Dessine le rectangle à l’aide d’un pinceau de demi-teintes pour éliminer le scintillement et créer l’apparence d’un rectangle sans heurts de Mobile.  
  
 La première fois que vous appelez `DrawDragRect`, le `lpRectLast` paramètre doit être **NULL**.  
  
##  <a name="drawedge"></a>CDC::DrawEdge  
 Appelez cette fonction membre pour dessiner les bords d’un rectangle du type spécifié et le style.  
  
```  
BOOL DrawEdge(
    LPRECT lpRect,  
    UINT nEdge,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Un pointeur vers un **RECT** structure qui contient les coordonnées du rectangle logiques.  
  
 *nEdge*  
 Spécifie le type de bordure interne et externe à dessiner. Ce paramètre doit être une combinaison d’un indicateur de la bordure interne et un indicateur de la bordure externe. Consultez la page [DrawEdge](http://msdn.microsoft.com/library/windows/desktop/dd162477) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour un tableau de types du paramètre.  
  
 `nFlags`  
 Indicateurs qui spécifient le type de bordure à dessiner. Consultez la page `DrawEdge` dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] une table les valeurs du paramètre. Pour les lignes en diagonale, les **BF_RECT** indicateurs spécifient le point de terminaison du vecteur limité par le paramètre de rectangle.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
##  <a name="drawescape"></a>CDC::DrawEscape  
 Accès aux fonctions qui ne sont pas directement disponibles via l’interface graphique (GDI) d’un affichage vidéo de dessin.  
  
```  
int DrawEscape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData);
```  
  
### <a name="parameters"></a>Paramètres  
 `nEscape`  
 Spécifie la fonction d’échappement doit être effectuée.  
  
 `nInputSize`  
 Spécifie le nombre d’octets de données vers laquelle pointées le `lpszInputData` paramètre.  
  
 `lpszInputData`  
 Pointe vers la structure d’entrée requis pour la séquence d’échappement spécifiée.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le résultat de la fonction. Supérieure à zéro si l’opération réussit, à l’exception de la **QUERYESCSUPPORT** dessiner le caractère d’échappement, qui recherche la mise en œuvre uniquement ; ou zéro si la séquence d’échappement n’est pas implémentée ; ou inférieure à zéro si une erreur s’est produite.  
  
### <a name="remarks"></a>Notes  
 Lorsqu’une application appelle `DrawEscape`, les données identifiées par `nInputSize` et `lpszInputData` est transmise directement au pilote d’affichage spécifié.  
  
##  <a name="drawfocusrect"></a>CDC::DrawFocusRect  
 Dessine un rectangle dans le style utilisé pour indiquer que le rectangle a le focus.  
  
```  
void DrawFocusRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers une [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui spécifie les coordonnées logiques du rectangle à dessiner.  
  
### <a name="remarks"></a>Remarques  
 Dans la mesure où il s’agit d’une fonction booléenne XOR, appeler cette fonction une seconde fois avec le même rectangle supprime le rectangle de l’écran. Impossible de faire défiler le rectangle dessiné par cette fonction. Pour faire défiler une zone qui contient un rectangle dessiné par cette fonction, appelez d’abord `DrawFocusRect` pour supprimer l’affichage du rectangle, puis faites défiler la zone, puis appelez `DrawFocusRect` pour dessiner le rectangle à la nouvelle position.  
  
> [!CAUTION]
> `DrawFocusRect`fonctionne uniquement dans `MM_TEXT` mode. Dans d’autres modes, cette fonction ne consomme pas correctement le rectangle de focus, mais elle ne retourne pas de valeurs d’erreur.  
  
##  <a name="drawframecontrol"></a>CDC::DrawFrameControl  
 Appelez cette fonction membre pour dessiner un contrôle frame, le type spécifié et le style.  
  
```  
BOOL DrawFrameControl(
    LPRECT lpRect,  
    UINT nType,  
    UINT nState);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Un pointeur vers un **RECT** structure qui contient les coordonnées du rectangle logiques.  
  
 `nType`  
 Spécifie le type de contrôle image à dessiner. Consultez le *uType* paramètre [DrawFrameControl](http://msdn.microsoft.com/library/windows/desktop/dd162480) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour obtenir la liste des valeurs possibles de ce paramètre.  
  
 `nState`  
 Spécifie l’état initial du contrôle frame. Peut être une ou plusieurs des valeurs décrites pour le *uState* paramètre `DrawFrameControl` dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. Utilisez le `nState` valeur **DFCS_ADJUSTRECT** pour ajuster le rectangle englobant pour exclure le bord du bouton push s’y rapportant.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Dans certains cas, `nState` dépend de le `nType` paramètre. La liste suivante montre la relation entre les quatre `nType` valeurs et `nState`:  
  
- **DFC_BUTTON**  
  
    - **DFCS_BUTTON3STATE** bouton à trois États  
  
    - **DFCS_BUTTONCHECK** case à cocher  
  
    - **DFCS_BUTTONPUSH** bouton de commande  
  
    - **DFCS_BUTTONRADIO** case d’option  
  
    - **DFCS_BUTTONRADIOIMAGE** Image pour le bouton radio (carrés doit image)  
  
    - **DFCS_BUTTONRADIOMASK** masque de case d’option (carrés doit masque)  
  
- **DFC_CAPTION**  
  
    - **DFCS_CAPTIONCLOSE** bouton Fermer  
  
    - **DFCS_CAPTIONHELP** bouton aide  
  
    - **DFCS_CAPTIONMAX** bouton d’agrandissement  
  
    - **DFCS_CAPTIONMIN** bouton réduire  
  
    - **DFCS_CAPTIONRESTORE** bouton Restaurer  
  
- **DFC_MENU**  
  
    - **DFCS_MENUARROW** flèche de sous-menu  
  
    - **DFCS_MENUBULLET** puce  
  
    - **DFCS_MENUCHECK** case à cocher  
  
- **DFC_SCROLL**  
  
    - **DFCS_SCROLLCOMBOBOX** barre de défilement de la liste déroulante  
  
    - **DFCS_SCROLLDOWN** bas de la barre de défilement  
  
    - **DFCS_SCROLLLEFT** flèche vers la gauche de la barre de défilement  
  
    - **DFCS_SCROLLRIGHT** flèche droite de la barre de défilement  
  
    - **DFCS_SCROLLSIZEGRIP** poignée de dimensionnement dans le coin inférieur droit de la fenêtre  
  
    - **DFCS_SCROLLUP** haut de la barre de défilement  
  
### <a name="example"></a>Exemple  
 Ce code dessine la barre de redimensionnement de taille dans le coin inférieur droit de la fenêtre. Il est approprié pour le `OnPaint` Gestionnaire de boîte de dialogue, sans styles et normalement ne contiennent d’autres contrôles (comme une barre d’état) qui peuvent lui donner une barre de redimensionnement de taille.  
  
 [!code-cpp[NVC_MFCDocView&#34;](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]  
  
##  <a name="drawicon"></a>CDC::DrawIcon  
 Dessine une icône sur le périphérique représenté par les `CDC` objet.  
  
```  
BOOL DrawIcon(
    int x,  
    int y,  
    HICON hIcon);

 
BOOL DrawIcon(
    POINT point,  
    HICON hIcon);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche de l’icône.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche de l’icône.  
  
 `hIcon`  
 Identifie le handle de l’icône à dessiner.  
  
 `point`  
 Spécifie la logique et y coordonnées x de l’angle supérieur gauche de l’icône. Vous pouvez passer un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la fonction a été effectuée avec succès ; sinon 0.  
  
### <a name="remarks"></a>Remarques  
 La fonction place le coin supérieur gauche de l’icône à l’emplacement spécifié par *x* et *y*. L’emplacement est soumis à la mode de mappage en cours du contexte de périphérique.  
  
 La ressource icône doit avoir été précédemment chargée à l’aide de fonctions `CWinApp::LoadIcon`, `CWinApp::LoadStandardIcon`, ou `CWinApp::LoadOEMIcon`. La `MM_TEXT` mode de mappage doit être sélectionné avant d’utiliser cette fonction.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).  
  
##  <a name="drawstate"></a>CDC::DrawState  
 Appelez cette fonction membre pour afficher une image et applique un effet visuel pour indiquer un état, par exemple un désactivé ou un état par défaut.  
  
> [!NOTE]
>  Pour toutes les `nFlag` indique à l’exception de **DSS_NORMAL**, l’image est convertie en monochrome avant que l’effet visuel est appliqué.  
  
```  
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HBITMAP hBitmap,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    CBitmap* pBitmap,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    CBrush* pBrush = NULL);
```  
  
### <a name="parameters"></a>Paramètres  
 `pt`  
 Spécifie l’emplacement de l’image.  
  
 `size`  
 Spécifie la taille de l’image.  
  
 `hBitmap`  
 Un handle vers une bitmap.  
  
 `nFlags`  
 Indicateurs qui spécifient le type d’image et l’état. Consultez [DrawState](http://msdn.microsoft.com/library/windows/desktop/dd162496) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour maximum `nFlags` types et les États.  
  
 `hBrush`  
 Handle d’un pinceau.  
  
 `pBitmap`  
 Pointeur vers un objet CBitmap.  
  
 `pBrush`  
 Pointeur vers un objet CBrush.  
  
 `hIcon`  
 Un handle d’une icône.  
  
 `lpszText`  
 Un pointeur de texte.  
  
 *bPrefixText*  
 Texte qui peut contenir un mnémonique de l’accélérateur. Le `lData` paramètre spécifie l’adresse de la chaîne et le `nTextLen` paramètre spécifie la longueur. Si `nTextLen` est 0, la chaîne est supposée pour être nul.  
  
 `nTextLen`  
 Longueur de la chaîne pointée par `lpszText`. Si `nTextLen` est 0, la chaîne est supposée pour être nul.  
  
 *lpDrawProc*  
 Pointeur vers une fonction de rappel utilisé pour afficher une image. Ce paramètre est obligatoire si le type de l’image dans `nFlags` est **DST_COMPLEX**. Il est facultatif et peut être **NULL** si le type d’image est **DST_TEXT**. Pour tous les autres types d’image, ce paramètre est ignoré. Pour plus d’informations sur la fonction de rappel, consultez la [DrawStateProc](http://msdn.microsoft.com/library/windows/desktop/dd162497) de fonction dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
 `lData`  
 Spécifie des informations sur l’image. La signification de ce paramètre varie selon le type d’image.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
##  <a name="drawtext"></a>CDC::DrawText  
 Appelez cette fonction membre pour mettre en forme le texte dans le rectangle spécifié. Pour spécifier les options de mise en forme supplémentaires, utilisez [CDC::DrawTextEx](#drawtextex).  
  
```  
virtual int DrawText(
    LPCTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat);

 
int DrawText(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszString`  
 Pointe vers la chaîne à dessiner. Si `nCount` est –&1;, la chaîne doit être nul.  
  
 `nCount`  
 Spécifie le nombre de caractères dans la chaîne. Si `nCount` est –&1;, puis `lpszString` est supposé pour être un pointeur long vers une chaîne terminée par null et `DrawText` calcule le nombre de caractères automatiquement.  
  
 `lpRect`  
 Pointe vers une [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui contient le rectangle (en coordonnées logiques) dans lequel le texte doit être mis en forme.  
  
 `str`  
 A [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet qui contient les caractères spécifiés à dessiner.  
  
 `nFormat`  
 Spécifie la méthode de mise en forme du texte. Il peut être n’importe quelle combinaison des valeurs décrites pour le `uFormat` paramètre [DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. (combiner à l’aide de l’opérateur OR) :  
  
> [!NOTE]
>  Certains `uFormat` combinaisons d’indicateurs peuvent provoquer la chaîne passée à modifier. À l’aide de **DT_MODIFYSTRING** soit **DT_END_ELLIPSIS** ou **DT_PATH_ELLIPSIS** peut entraîner une chaîne à modifier, à l’origine d’une assertion dans le `CString` remplacer. Les valeurs `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, et `DT_NOPREFIX` ne peut pas être utilisé avec le `DT_TABSTOP` valeur.  
  
### <a name="return-value"></a>Valeur de retour  
 La hauteur du texte si la fonction réussit.  
  
### <a name="remarks"></a>Remarques  
 Il met le texte en développant les tabulations en espaces appropriés, aligner le texte à gauche, à droite ou au centre du rectangle donné et la rupture de texte dans les lignes du rectangle spécifié. Le type de mise en forme est spécifié par `nFormat`.  
  
 Cette fonction membre utilise la police sélectionnée le contexte de périphérique, couleur du texte et la couleur d’arrière-plan pour dessiner le texte. À moins que le `DT_NOCLIP` format est utilisé, `DrawText` découpe le texte afin que le texte n’apparaît pas en dehors du rectangle spécifié. Toute mise en forme est supposée pour avoir plusieurs lignes à moins que le `DT_SINGLELINE` format est indiqué.  
  
 Si la police sélectionnée est trop grande pour le rectangle spécifié, le `DrawText` fonction membre ne tente pas de remplacer une police plus petite.  
  
 Si le `DT_CALCRECT` indicateur est spécifié, le rectangle spécifié par `lpRect` sera mis à jour pour refléter la largeur et la hauteur nécessaire pour dessiner le texte.  
  
 Si le **TA_UPDATECP** indicateur d’alignement de texte a été défini (voir [CDC::SetTextAlign](#settextalign)), `DrawText` affichera le texte commençant à la position actuelle, plutôt qu’à gauche du rectangle donné. `DrawText`encapsule pas texte lorsque le **TA_UPDATECP** indicateur a été défini (autrement dit, le `DT_WORDBREAK` indicateur n’a aucun effet).  
  
 La couleur du texte peut être définie par [CDC::SetTextColor](#settextcolor).  
  
##  <a name="drawtextex"></a>CDC::DrawTextEx  
 Mettre en forme le texte dans le rectangle spécifié.  
  
```  
virtual int DrawTextEx(
    LPTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

 
int DrawTextEx(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszString`  
 Pointe vers la chaîne à dessiner. Si `nCount` est –&1;, la chaîne doit se terminer par null.  
  
 `nCount`  
 Spécifie le nombre de caractères dans la chaîne. Si `nCount` est –&1;, puis `lpszString` est supposé pour être un pointeur long vers une chaîne terminée par null et `DrawText` calcule le nombre de caractères automatiquement.  
  
 `lpRect`  
 Pointe vers une [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui contient le rectangle (en coordonnées logiques) dans lequel le texte doit être mis en forme.  
  
 `str`  
 A [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet qui contient les caractères spécifiés à dessiner.  
  
 `nFormat`  
 Spécifie la méthode de mise en forme du texte. Il peut être n’importe quelle combinaison des valeurs décrites pour le `uFormat` paramètre [DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. (Combiner à l’aide de l’opérateur de bits `OR` opérateur) :  
  
> [!NOTE]
>  Certains `uFormat` combinaisons d’indicateurs peuvent provoquer la chaîne passée à modifier. À l’aide de **DT_MODIFYSTRING** soit **DT_END_ELLIPSIS** ou **DT_PATH_ELLIPSIS** peut entraîner une chaîne à modifier, à l’origine d’une assertion dans le `CString` remplacer. Les valeurs `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, et `DT_NOPREFIX` ne peut pas être utilisé avec le `DT_TABSTOP` valeur.  
  
 `lpDTParams`  
 Pointeur vers un [DRAWTEXTPARAMS](http://msdn.microsoft.com/library/windows/desktop/dd162500) options de structure qui spécifie la mise en forme supplémentaires. Ce paramètre peut être **NULL**.  
  
### <a name="remarks"></a>Remarques  
 Il met le texte en développant les tabulations en espaces appropriés, aligner le texte à gauche, à droite ou au centre du rectangle donné et la rupture de texte dans les lignes du rectangle spécifié. Le type de mise en forme est spécifié par `nFormat` et `lpDTParams`. Pour plus d’informations, consultez [CDC::DrawText](#drawtext) et [DrawTextEx](http://msdn.microsoft.com/library/windows/desktop/dd162499) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
 La couleur du texte peut être définie par [CDC::SetTextColor](#settextcolor).  
  
##  <a name="ellipse"></a>CDC::ellipse  
 Dessine une ellipse.  
  
```  
BOOL Ellipse(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Ellipse(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle englobant de l’ellipse.  
  
 `y1`  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle englobant de l’ellipse.  
  
 `x2`  
 Spécifie la coordonnée x logique du coin inférieur droit du rectangle englobant de l’ellipse.  
  
 `y2`  
 Spécifie la coordonnée y logique du coin inférieur droit du rectangle englobant de l’ellipse.  
  
 `lpRect`  
 Spécifie que les points de suspension du rectangle englobant. Vous pouvez également transmettre un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le centre de l’ellipse est le centre du rectangle englobant spécifié par `x1`, `y1`, `x2`, et `y2`, ou `lpRect`. L’ellipse est dessinée avec le stylet actuel, et son intérieur est rempli avec le pinceau actuel.  
  
 La figure dessinée par cette fonction s’étend jusqu'à, mais n’inclut pas les coordonnées de droite et inférieure. Cela signifie que la hauteur de la figure est `y2` – `y1` et la largeur de la figure est `x2` – `x1`.  
  
 Si la largeur ou la hauteur du rectangle englobant est 0, aucun ellipse n’est dessinée.  
  
##  <a name="enddoc"></a>CDC::EndDoc  
 Met fin à un travail d’impression est démarré par un appel à la [StartDoc](#startdoc) fonction membre.  
  
```  
int EndDoc();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Supérieur ou égal à 0 si la fonction réussit, ou une valeur négative si une erreur s’est produite.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre remplace le **ENDDOC** échappement d’imprimante et doit être appelée immédiatement après la fin d’un travail d’impression.  
  
 Si une application rencontre une erreur d’impression ou une opération d’impression annulée, il ne devez pas tenter de terminer l’opération en utilisant `EndDoc` ou [AbortDoc](#abortdoc). GDI termine automatiquement l’opération avant de retourner la valeur d’erreur.  
  
 Cette fonction ne doit pas être utilisée à l’intérieur des métafichiers.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::StartDoc](#startdoc).  
  
##  <a name="endpage"></a>CDC::EndPage  
 Informe le périphérique que l’application a terminé l’écriture dans une page.  
  
```  
int EndPage();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Supérieur ou égal à 0 si la fonction réussit, ou une valeur négative si une erreur s’est produite.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre est généralement utilisée pour diriger le pilote de périphérique pour passer à une nouvelle page.  
  
 Cette fonction membre remplace le **NEWFRAME** échappement d’imprimante. Contrairement aux **NEWFRAME**, cette fonction est toujours appelée après l’impression d’une page.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::StartDoc](#startdoc).  
  
##  <a name="endpath"></a>CDC::EndPath  
 Ferme un crochet de chemin d’accès et sélectionne le chemin d’accès défini par le support dans le contexte de périphérique.  
  
```  
BOOL EndPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="enumobjects"></a>CDC::EnumObjects  
 Énumère les stylets et pinceaux disponibles dans un contexte de périphérique.  
  
```  
int EnumObjects(
    int nObjectType,  
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),  
    LPARAM lpData);
```  
  
### <a name="parameters"></a>Paramètres  
 *nObjectType*  
 Spécifie le type d’objet. Il peut prendre les valeurs **OBJ_BRUSH** ou **OBJ_PEN**.  
  
 `lpfn`  
 Est l’adresse de l’instance de la procédure de la fonction de rappel fournie par l’application. Consultez la section « Remarques » ci-dessous.  
  
 `lpData`  
 Points de données fourni par l’application. Les données sont transmises à la fonction de rappel ainsi que des informations sur l’objet.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie la dernière valeur retournée par le [fonction de rappel](../../mfc/reference/callback-function-for-cdc-enumobjects.md). Sa signification est définie par l’utilisateur.  
  
### <a name="remarks"></a>Notes  
 Pour chaque objet d’un type donné, la fonction de rappel que vous passez est appelée avec les informations de cet objet. Le système appelle la fonction de rappel jusqu'à ce qu’il n’existe plus aucun objet ou la fonction de rappel renvoie la valeur 0.  
  
 Notez que les fonctionnalités nouvelles de Microsoft Visual C++ vous permettent d’utiliser une fonction ordinaire comme la fonction transmise à `EnumObjects`. L’adresse passée à `EnumObjects` est un pointeur vers une fonction exportée avec **exporter** et avec la convention d’appel Pascal. Dans les applications en mode protégé, vous n’avez pas à créer cette fonction avec la fonction Windows MakeProcInstance ou de libérer de la fonction après la fonction FreeProcInstance Windows.  
  
 Aussi inutile exporter le nom de fonction dans une **exportations** instruction dans le fichier de définition de module de votre application. Vous pouvez utiliser la **exportation** fonction modificateur, comme dans  
  
 **int rappel exporter** AFunction **(LPSTR**, **LPSTR) ;**  
  
 Pour que le compilateur émet l’enregistrement d’exportation correcte pour l’exportation par nom sans alias. Cela fonctionne pour la plupart des besoins. Pour certains cas spéciaux, tels que l’exportation d’une fonction par ordinal ou alias de l’exportation, vous devez toujours utiliser un **exportations** instruction dans un fichier de définition de module.  
  
 Pour compiler les programmes de Microsoft Foundation, vous utiliserez normalement le /GA et les options de compilateur /GEs. L’option de compilateur /Gw n’est pas utilisée avec Microsoft Foundation classes. (Si vous n’utilisez pas la fonction Windows **MakeProcInstance**, vous devez caster explicitement le pointeur de fonction retourné à partir de **FARPROC** au type nécessaire dans cette API.) Interfaces de l’inscription de rappel sont maintenant de type sécurisé (vous devez passer un pointeur de fonction qui pointe vers le bon type de fonction pour le rappel spécifique).  
  
 Notez également que toutes les fonctions de rappel doivent intercepter les exceptions de Microsoft Foundation avant de retourner à Windows, étant donné que les exceptions ne peuvent pas être levées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, consultez l’article [Exceptions](../../mfc/exception-handling-in-mfc.md).  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView&#35;](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]  
  
##  <a name="escape"></a>CDC::escape  
 Cette fonction membre est pratiquement obsolète de la programmation Win32.  
  
```  
virtual int Escape(
    int nEscape,  
    int nCount,  
    LPCSTR lpszInData,  
    LPVOID lpOutData);

 
int Escape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData,  
    int nOutputSize,  
    LPSTR lpszOutputData);
```  
  
### <a name="parameters"></a>Paramètres  
 `nEscape`  
 Spécifie la fonction d’échappement doit être effectuée.  
  
 Pour obtenir une liste complète des fonctions d’échappement, consultez [échappement](http://msdn.microsoft.com/library/windows/desktop/dd162701) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
 `nCount`  
 Spécifie le nombre d’octets de données vers laquelle pointées `lpszInData`.  
  
 `lpszInData`  
 Pointe vers la structure de données d’entrée requis pour cette d’échappement.  
  
 `lpOutData`  
 Pointe vers la structure qui doit recevoir la sortie de cette d’échappement. Le `lpOutData` paramètre est **NULL** si aucune donnée n’est retournée.  
  
 `nInputSize`  
 Spécifie le nombre d’octets de données vers laquelle pointées le `lpszInputData` paramètre.  
  
 `lpszInputData`  
 Pointe vers la structure d’entrée requis pour la séquence d’échappement spécifiée.  
  
 `nOutputSize`  
 Spécifie le nombre d’octets de données vers laquelle pointées le `lpszOutputData` paramètre.  
  
 `lpszOutputData`  
 Pointe vers la structure qui reçoit le résultat de cette d’échappement. Ce paramètre doit être **NULL** si aucune donnée n’est retournée.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur positive est renvoyée si la fonction réussite, à l’exception de la **QUERYESCSUPPORT** caractère d’échappement, qui contrôle uniquement pour l’implémentation. La valeur zéro est renvoyée si la séquence d’échappement n’est pas implémentée. Une valeur négative est retournée si une erreur s’est produite. Les valeurs d’erreur courantes sont les suivantes :  
  
- **SP_ERROR** erreur générale.  
  
- **SP_OUTOFDISK** pas suffisamment d’espace disque est actuellement disponible pour la mise en attente, et davantage d’espace est disponible.  
  
- **SP_OUTOFMEMORY** pas assez de mémoire est disponible pour la mise en attente.  
  
- **SP_USERABORT** utilisateur s’est terminé le travail via le Gestionnaire d’impression.  
  
### <a name="remarks"></a>Remarques  
 De l’échappement d’imprimante d’origine, uniquement **QUERYESCSUPPORT** est pris en charge pour les applications Win32. Toutes les autres séquences d’échappement imprimante sont obsolètes et sont pris en charge uniquement pour la compatibilité avec les applications 16 bits.  
  
 Pour la programmation Win32, `CDC` maintenant fournit six fonctions membres qui remplacent leurs séquences d’échappement imprimante correspondante :  
  
- [CDC::AbortDoc](#abortdoc)  
  
- [CDC::EndDoc](#enddoc)  
  
- [CDC::EndPage](#endpage)  
  
- [CDC::SETABORTPROC](#setabortproc)  
  
- [CDC::StartDoc](#startdoc)  
  
- [CDC::StartPage](#startpage)  
  
 En outre, [CDC::GetDeviceCaps](#getdevicecaps) prend en charge les index Win32 qui remplacent d’autres séquences d’échappement des imprimantes. Consultez la page [GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour plus d’informations.  
  
 Cette fonction membre permet aux applications accéder aux fonctionnalités d’un périphérique particulier qui ne sont pas directement disponibles via GDI.  
  
 Utilisez la première version, si votre application utilise les valeurs prédéfinies d’échappement. Utilisez la deuxième version, si votre application définit les valeurs d’échappement privé. Consultez la page [ExtEscape](http://msdn.microsoft.com/library/windows/desktop/dd162708) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour plus d’informations sur la deuxième version.  
  
##  <a name="excludecliprect"></a>CDC::ExcludeClipRect  
 Crée une nouvelle zone de découpage qui se compose de la zone de découpage existant moins le rectangle spécifié.  
  
```  
int ExcludeClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int ExcludeClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle.  
  
 `y1`  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle.  
  
 `x2`  
 Spécifie la coordonnée x logique de l’angle inférieur droit du rectangle.  
  
 `y2`  
 Spécifie la coordonnée y logique de l’angle inférieur droit du rectangle.  
  
 `lpRect`  
 Spécifie le rectangle. Peut également être un `CRect` objet.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le type de la nouvelle zone découpage. Il peut être une des valeurs suivantes :  
  
- **COMPLEXREGION** la région a chevauchement des bordures.  
  
- **ERREUR** aucune région n’a été créée.  
  
- **NULLREGION** la région est vide.  
  
- **SIMPLEREGION** la région n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Remarques  
 La largeur du rectangle, spécifié par la valeur absolue de `x2` – `x1`, ne doit pas dépasser 32 767 unités. Cette limite s’applique à la hauteur du rectangle ainsi.  
  
##  <a name="excludeupdatergn"></a>CDC::ExcludeUpdateRgn  
 Empêche le dessin dans les zones non valides d’une fenêtre en excluant une région mis à jour dans la fenêtre de la zone de découpage associée à le `CDC` objet.  
  
```  
int ExcludeUpdateRgn(CWnd* pWnd);
```  
  
### <a name="parameters"></a>Paramètres  
 `pWnd`  
 Pointe vers l’objet de fenêtre dont la fenêtre est mis à jour.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de région exclu. Il peut être l’une des valeurs suivantes :  
  
- **COMPLEXREGION** la région a chevauchement des bordures.  
  
- **ERREUR** aucune région n’a été créée.  
  
- **NULLREGION** la région est vide.  
  
- **SIMPLEREGION** la région n’a aucune bordure qui se chevauchent.  
  
##  <a name="extfloodfill"></a>CDC::ExtFloodFill  
 Remplit une zone de la surface d’affichage avec le pinceau actuel.  
  
```  
BOOL ExtFloodFill(
    int x,  
    int y,  
    COLORREF crColor,  
    UINT nFillType);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point où commence la remplir.  
  
 *y*  
 Spécifie la coordonnée y logique du point où commence la remplir.  
  
 `crColor`  
 Spécifie la couleur de la bordure ou de la zone à remplir. L’interprétation de `crColor` dépend de la valeur de `nFillType`.  
  
 `nFillType`  
 Spécifie le type de remplissage doit être effectuée. Il doit être une des valeurs suivantes :  
  
- **FLOODFILLBORDER** la zone de remplissage est limitée par la couleur spécifiée par `crColor`. Ce style est identique à remplir effectuée par `FloodFill`.  
  
- **FLOODFILLSURFACE** la zone de remplissage est définie par la couleur spécifiée par `crColor`. Remplissage continue vers l’extérieur dans toutes les directions, tant que la couleur est rencontrée. Ce style est utile pour remplir des zones avec des limites multicolores.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la fonction réussit ; Sinon, 0 si le remplissage a échoué, si le point de donnée a la limite de couleur spécifiée par `crColor` (si **FLOODFILLBORDER** a été demandée), si le point spécifié ne dispose pas de la couleur spécifiée par `crColor` (si **FLOODFILLSURFACE** a été demandée), ou si le point est en dehors de la zone de découpage.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre est plus souple que `FloodFill` car vous pouvez spécifier un type de remplissage dans `nFillType`.  
  
 Si `nFillType` a **FLOODFILLBORDER**, la zone est supposée être complètement limitée par la couleur spécifiée par `crColor`. La fonction commence au point spécifié par *x* et *y* et remplit toutes les directions à la limite de couleur.  
  
 Si `nFillType` a **FLOODFILLSURFACE**, la fonction commence au point spécifié par *x* et *y* et se poursuit dans toutes les directions, remplir toutes les zones adjacentes contenant la couleur spécifiée par `crColor`.  
  
 Seuls les contextes de périphérique de mémoire et les périphériques qui prennent en charge de la prise en charge de la technologie raster-affichage `ExtFloodFill`. Pour plus d’informations, consultez la [GetDeviceCaps](#getdevicecaps) fonction membre.  
  
##  <a name="exttextout"></a>CDC::ExtTextOut  
 Appelez cette fonction membre pour écrire une chaîne de caractères dans une zone rectangulaire à l’aide de la police actuellement sélectionnée.  
  
```  
virtual BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    LPCTSTR lpszString,  
    UINT nCount,  
    LPINT lpDxWidths);

 
BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    const CString& str,  
    LPINT lpDxWidths);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de la cellule de caractère pour le premier caractère dans la chaîne spécifiée.  
  
 *y*  
 Spécifie la coordonnée y logique du haut de la cellule de caractère pour le premier caractère dans la chaîne spécifiée.  
  
 `nOptions`  
 Spécifie le type de rectangle. Ce paramètre peut être une, deux ou aucune des valeurs suivantes :  
  
- **ETO_CLIPPED** Spécifie que le texte est coupé au rectangle.  
  
- **ETO_OPAQUE** indique que la couleur d’arrière-plan actuelle remplit le rectangle. (Vous pouvez définir et interroger la couleur d’arrière-plan actuelle avec la [SetBkColor](#setbkcolor) et [GetBkColor](#getbkcolor) les fonctions membres.)  
  
 `lpRect`  
 Pointe vers une [RECT](../../mfc/reference/rect-structure1.md) structure qui détermine les dimensions du rectangle. Ce paramètre peut être **NULL**. Vous pouvez également transmettre un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 `lpszString`  
 Pointe vers la chaîne de caractères spécifiée à dessiner. Vous pouvez également transmettre un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne.  
  
 `lpDxWidths`  
 Pointe vers un tableau de valeurs qui indiquent la distance entre les origines des cellules de caractères adjacents. Par exemple, `lpDxWidths`[ *i*] les origines de cellule de caractère pour séparer les unités logiques *i* et la cellule de caractère *i* + 1. Si `lpDxWidths` est **NULL**, `ExtTextOut` utilise l’espacement par défaut entre les caractères.  
  
 `str`  
 Un `CString` objet qui contient les caractères spécifiés à dessiner.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La zone rectangulaire peut être opaque (rempli avec la couleur d’arrière-plan actuelle), et il peut être une zone de découpage.  
  
 Si `nOptions` est égal à 0 et `lpRect` est **NULL**, la fonction écrit du texte dans le contexte de périphérique sans l’aide d’une zone rectangulaire. Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction. Si une application doit mettre à jour la position actuelle lorsqu’il appelle `ExtTextOut`, l’application peut appeler le `CDC` fonction membre [SetTextAlign](#settextalign) avec `nFlags` la valeur **TA_UPDATECP**. Lorsque cet indicateur est défini, Windows ignore *x* et *y* dans les appels ultérieurs à `ExtTextOut` et utilise à la place de la position actuelle. Lorsqu’une application utilise **TA_UPDATECP** pour mettre à jour la position actuelle, `ExtTextOut` définit la position actuelle jusqu'à la fin de la ligne précédente du texte ou à la position spécifiée par le dernier élément du tableau vers lequel pointé `lpDxWidths`, plus importante étant retenue.  
  
##  <a name="fillpath"></a>CDC::FillPath  
 Ferme des figures ouvertes dans le chemin d’accès actuel et remplit l’intérieur du tracé en utilisant le pinceau actuel et le mode de remplissage de polygones.  
  
```  
BOOL FillPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Après que son intérieur est rempli, le chemin d’accès est rejeté par le contexte de périphérique.  
  
##  <a name="fillrect"></a>CDC::FillRect  
 Appelez cette fonction membre pour remplir un rectangle à l’aide de la forme spécifiée.  
  
```  
void FillRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers une [RECT](../../mfc/reference/rect-structure1.md) structure qui contient les coordonnées logiques du rectangle à remplir. Vous pouvez également transmettre un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 `pBrush`  
 Identifie le pinceau utilisé pour remplir le rectangle.  
  
### <a name="remarks"></a>Notes  
 La fonction remplit le rectangle complète, y compris les bordures gauche et supérieure, mais elle ne remplit pas les bordures droite et inférieure.  
  
 Le pinceau doit soit être créé à l’aide de la [CBrush](../../mfc/reference/cbrush-class.md) les fonctions membres [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush), et [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush), ou récupéré par le `GetStockObject` fonction Windows.  
  
 Lorsque vous remplissez le rectangle spécifié, `FillRect` n’inclut pas les côtés droit et inférieur du rectangle. Remplit un rectangle à GDI, mais n’inclut pas la ligne de colonne et en bas à droite, quel que soit le mode de mappage en cours. `FillRect`Compare les valeurs de la **haut**, **bas**, **gauche**, et **droit** membres du rectangle spécifié. Si **bas** est inférieure ou égale à **haut**, ou si **droit** est inférieure ou égale à **gauche**, le rectangle n’est pas dessiné.  
  
 `FillRect`est semblable à [CDC::FillSolidRect](#fillsolidrect); Toutefois, `FillRect` prend un pinceau et par conséquent peut être utilisé pour remplir un rectangle avec une couleur unie, une couleur dégradée, pinceaux hachurée ou un modèle. `FillSolidRect`utilise uniquement des couleurs unies (indiqué par une **COLORREF** paramètre). `FillRect`est généralement plus lent que `FillSolidRect`.  
  
##  <a name="fillrgn"></a>CDC::FillRgn  
 Remplit la zone spécifiée par `pRgn` avec le pinceau spécifié par `pBrush`.  
  
```  
BOOL FillRgn(
    CRgn* pRgn,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>Paramètres  
 `pRgn`  
 Un pointeur vers la zone à remplir. Les coordonnées de la région donnée sont spécifiées en unités logiques.  
  
 `pBrush`  
 Identifie le pinceau à utiliser pour remplir la zone.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le pinceau doit être créé à l’aide de la `CBrush` les fonctions membres `CreateHatchBrush`, `CreatePatternBrush`, `CreateSolidBrush`, ou être récupéré par **GetStockObject**.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).  
  
##  <a name="fillsolidrect"></a>CDC::FillSolidRect  
 Appelez cette fonction membre pour remplir le rectangle spécifié avec la couleur unie spécifiée.  
  
```  
void FillSolidRect(
    LPCRECT lpRect,  
    COLORREF clr);

 
void FillSolidRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clr);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer un pointeur vers un [RECT](../../mfc/reference/rect-structure1.md) structure de données ou un `CRect` objet pour ce paramètre.  
  
 `clr`Spécifie la couleur à utiliser pour remplir le rectangle.  
  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle de destination.  
  
 `cx`  
 Spécifie la largeur du rectangle.  
  
 `cy`  
 Spécifie la hauteur du rectangle.  
  
### <a name="remarks"></a>Remarques  
 `FillSolidRect`est très similaire à [CDC::FillRect](#fillrect); Toutefois, `FillSolidRect` utilise uniquement des couleurs unies (indiqué par le **COLORREF** paramètre), tandis que `FillRect` prend un pinceau et par conséquent peut être utilisé pour remplir un rectangle avec une couleur unie, une couleur dégradée, pinceaux hachurée ou un modèle. `FillSolidRect`est généralement plus rapide que `FillRect`.  
  
> [!NOTE]
>  Lorsque vous appelez `FillSolidRect`, la couleur d’arrière-plan, qui a été précédemment définie à l’aide de [SetBkColor](#setbkcolor), est défini sur la couleur indiquée par `clr`.  
  
##  <a name="flattenpath"></a>CDC::FlattenPath  
 Transforme les courbes dans le chemin d’accès sélectionné dans le contexte de périphérique en cours et transforme chaque courbe en une séquence de lignes.  
  
```  
BOOL FlattenPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="floodfill"></a>CDC::FloodFill  
 Remplit une zone de la surface d’affichage avec le pinceau actuel.  
  
```  
BOOL FloodFill(
    int x,  
    int y,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point où commence la remplir.  
  
 *y*  
 Spécifie la coordonnée y logique du point où commence la remplir.  
  
 `crColor`  
 Spécifie la couleur de la limite.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la fonction réussit ; Sinon, 0 est retourné si le remplissage n’a pas pu être effectué, le point de donnée a la couleur de la limite spécifiée par `crColor`, ou si le point est en dehors de la zone de découpage.  
  
### <a name="remarks"></a>Notes  
 La zone est supposée être délimité comme spécifié par `crColor`. Le `FloodFill` fonction commence au point spécifié par *x* et *y* et se poursuit dans toutes les directions à la limite de couleur.  
  
 Seuls les contextes de périphérique de mémoire et les périphériques qui prennent en charge de la prise en charge de la technologie raster-affichage du `FloodFill` fonction membre. Pour plus d’informations sur les **RC_BITBLT** fonctionnalité, consultez le `GetDeviceCaps` fonction membre.  
  
 Le `ExtFloodFill` fonction fournit des fonctionnalités similaires mais une plus grande flexibilité.  
  
##  <a name="framerect"></a>CDC::frameRect n'  
 Dessine une bordure autour du rectangle spécifié par `lpRect`.  
  
```  
void FrameRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers une [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui contient les coordonnées logiques des angles supérieur gauche et inférieur droit du rectangle. Vous pouvez également transmettre un `CRect` objet pour ce paramètre.  
  
 `pBrush`  
 Identifie le pinceau à utiliser pour le rectangle de tramage.  
  
### <a name="remarks"></a>Remarques  
 La fonction utilise le pinceau donné pour dessiner la bordure. La largeur et la hauteur de la bordure est toujours 1 unité logique.  
  
 Si du rectangle **bas** coordonnée est inférieure ou égale à **haut**, ou si **droit** est inférieure ou égale à **gauche**, le rectangle n’est pas dessiné.  
  
 La bordure dessinée par `FrameRect` se trouve dans la même position une bordure dessinée par le **Rectangle** fonction membre à l’aide des mêmes coordonnées (si **Rectangle** utilise un stylet est 1 unité logique large). L’intérieur du rectangle n’est pas remplie par `FrameRect`.  
  
##  <a name="framergn"></a>CDC::FrameRgn  
 Dessine une bordure autour de la zone spécifiée par `pRgn` à l’aide de la forme spécifiée par `pBrush`.  
  
```  
BOOL FrameRgn(
    CRgn* pRgn,  
    CBrush* pBrush,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Paramètres  
 `pRgn`  
 Pointe vers le `CRgn` objet qui identifie la région pour être placés dans une bordure. Les coordonnées de la région donnée sont spécifiées en unités logiques.  
  
 `pBrush`  
 Pointe vers le `CBrush` objet qui identifie le pinceau à utiliser pour dessiner la bordure.  
  
 `nWidth`  
 Spécifie la largeur de la bordure de contours verticale en unités de périphérique.  
  
 `nHeight`  
 Spécifie la hauteur de la bordure en tracés horizontaux en unités de périphérique.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).  
  
##  <a name="fromhandle"></a>CDC::FromHandle  
 Retourne un pointeur vers un `CDC` lorsqu’un handle vers un contexte de périphérique de l’objet.  
  
```  
static CDC* PASCAL FromHandle(HDC hDC);
```  
  
### <a name="parameters"></a>Paramètres  
 `hDC`  
 Contient un handle vers un contexte de périphérique Windows.  
  
### <a name="return-value"></a>Valeur de retour  
 Le pointeur peut être temporaire et ne doit pas être stocké au-delà d’une utilisation immédiate.  
  
### <a name="remarks"></a>Remarques  
 Si aucun objet `CDC` n'est attaché au handle, un objet `CDC` temporaire est créé et attaché.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).  
  
##  <a name="getarcdirection"></a>CDC::GetArcDirection  
 Renvoie la direction d’arc de cercle en cours pour le contexte de périphérique.  
  
```  
int GetArcDirection() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie la direction d’arc de cercle en cours, en cas de réussite. Voici les valeurs de retournés valides :  
  
- **AD_COUNTERCLOCKWISE** Arcs et rectangles dessinés dans le sens inverse.  
  
- **AD_CLOCKWISE** Arcs et rectangles dessinés dans le sens horaire.  
  
 Si une erreur se produit, la valeur de retour est zéro.  
  
### <a name="remarks"></a>Remarques  
 Les fonctions d’arc de cercle et rectangle utilisent la direction de l’arc.  
  
##  <a name="getaspectratiofilter"></a>CDC::GetAspectRatioFilter  
 Récupère le paramètre pour le filtre de l’aspect en cours.  
  
```  
CSize GetAspectRatioFilter() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un `CSize` représentant les proportions utilisées par le filtre de rapport hauteur / largeur actuel.  
  
### <a name="remarks"></a>Notes  
 Les proportions est le ratio formé par la hauteur et de largeur en pixels d’un périphérique. Informations sur le rapport hauteur / largeur d’un périphérique sont utilisées dans la création, la sélection et affichage des polices. Windows fournit un filtre spécial, le filtre de l’aspect, pour sélectionner des polices conçues pour une proportion particulier à partir de toutes les polices disponibles. Le filtre utilise les proportions spécifiées par le `SetMapperFlags` fonction membre.  
  
##  <a name="getbkcolor"></a>CDC::GetBkColor  
 Retourne la couleur d’arrière-plan actuelle.  
  
```  
COLORREF GetBkColor() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur de couleur RVB.  
  
### <a name="remarks"></a>Remarques  
 Si le mode d’arrière-plan est **OPAQUE**, le système utilise la couleur d’arrière-plan pour remplir les vides dans les lignes de styles, les intervalles entre les lignes hachurées de pinceaux et de l’arrière-plan dans les cellules de caractères. Le système utilise également la couleur d’arrière-plan lors de la conversion de bitmaps entre la couleur et les contextes de périphérique monochrome.  
  
##  <a name="getbkmode"></a>CDC::GetBkMode  
 Renvoie le mode d’arrière-plan.  
  
```  
int GetBkMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode actuel en arrière-plan, ce qui peut être **OPAQUE** ou **TRANSPARENT**.  
  
### <a name="remarks"></a>Notes  
 Le mode d’arrière-plan définit si le système supprime les couleurs d’arrière-plan sur la surface de dessin avant de dessiner du texte, des pinceaux hachurées ou n’importe quel style de stylet n’est pas une ligne pleine.  
  
##  <a name="getboundsrect"></a>CDC::GetBoundsRect  
 Retourne le rectangle englobant cumulé actuel pour le contexte de périphérique spécifié.  
  
```  
UINT GetBoundsRect(
    LPRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRectBounds`  
 Pointe vers une mémoire tampon qui recevra le rectangle englobant actuel. Le rectangle est renvoyé en coordonnées logiques.  
  
 `flags`  
 Spécifie si le rectangle englobant doit être effacé après que qu’elle est retournée. Ce paramètre doit être égal à zéro ou la valeur suivante :  
  
- **DCB_RESET** force le rectangle englobant doit être effacé après qu’elle est retournée.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie l’état actuel du rectangle englobant, si la fonction réussit. Il peut être une combinaison des valeurs suivantes :  
  
- **DCB_ACCUMULATE** accumulation du rectangle de délimitation est en cours.  
  
- **DCB_RESET** rectangle englobant est vide.  
  
- **DCB_SET** rectangle englobant n’est pas vide.  
  
- **DCB_ENABLE** englobant accumulation se trouve sur.  
  
- **DCB_DISABLE** englobant accumulation est désactivée.  
  
##  <a name="getbrushorg"></a>CDC::GetBrushOrg  
 Récupère l’origine (en unités de périphérique) du pinceau sélectionné pour le contexte de périphérique.  
  
```  
CPoint GetBrushOrg() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine actuelle du pinceau (en unités de périphérique) comme un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 L’origine de la forme initiale est à (0,0) de la zone cliente. La valeur de retour spécifie ce point en unités de périphérique relatif à l’origine de la fenêtre du bureau.  
  
##  <a name="getcharacterplacement"></a>CDC::GetCharacterPlacement  
 Récupère les différents types d’informations sur une chaîne de caractères.  
  
```  
DWORD GetCharacterPlacement(
    LPCTSTR lpString,  
    int nCount,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
  
DWORD GetCharacterPlacement(
    CString& str,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpString`  
 Pointeur vers la chaîne de caractères à traiter.  
  
 `nCount`  
 Spécifie la longueur de la chaîne. Pour la version ANSI, il est un nombre d’octets et de la fonction Unicode, il est un comptage des mots. Pour plus d’informations, consultez [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx).  
  
 `nMaxExtent`  
 Spécifie l’étendue maximale (en unités logiques) à laquelle la chaîne est traitée. Les caractères qui, si traité, dépasserait cette extension sont ignorés. Calculs pour les tableaux de classement ou glyphe requises s’appliquent uniquement aux caractères inclus. Ce paramètre est utilisé uniquement si la valeur GCP_MAXEXTENT est spécifiée dans le `dwFlags` paramètre. La fonction traite la chaîne d’entrée, chaque caractère et son étendue est ajoutée à la sortie, étendue et autres tableaux uniquement si l’intégralité de l’étendue n’a pas encore dépassé le nombre maximal. Une fois que la limite est atteinte, le traitement s’arrête.  
  
 lpResults  
 Pointeur vers un [GCP_Results](http://msdn.microsoft.com/library/windows/desktop/dd144842\(v=vs.85\).aspx) structure qui reçoit les résultats de la fonction.  
  
 `dwFlags`  
 Spécifie comment traiter la chaîne dans les tableaux requis. Ce paramètre peut prendre l’une ou plusieurs des valeurs répertoriées dans le `dwFlags` section de la [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx) rubrique.  
  
 `str`  
 Un pointeur vers un [CString](../../atl-mfc-shared/reference/cstringt-class.md) au processus de l’objet.  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour est la largeur et la hauteur de la chaîne en unités logiques.  
  
 Si la fonction échoue, la valeur de retour est égale à zéro.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre émule les fonctionnalités de la fonction [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getcharabcwidths"></a>CDC::GetCharABCWidths  
 Récupère la largeur des caractères consécutifs dans une plage spécifiée de la police TrueType en cours.  
  
```  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABC lpabc) const;  
  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABCFLOAT lpABCF) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nFirstChar`  
 Spécifie le premier caractère dans la plage de caractères de la police en cours pour lequel la largeur des caractères sont retournés.  
  
 `nLastChar`  
 Spécifie le dernier caractère de la plage de caractères de la police en cours pour lequel la largeur des caractères sont retournés.  
  
 `lpabc`  
 Pointe vers un tableau de [ABC](../../mfc/reference/abc-structure.md) structures qui reçoivent la largeur des caractères lorsque la fonction retourne une valeur. Ce tableau doit contenir au moins autant **ABC** structures qu’il sont a des caractères dans la plage spécifiée par la `nFirstChar` et `nLastChar` paramètres.  
  
 *lpABCF*  
 Pointe vers un mémoire tampon de fournie par l’application avec un tableau de [ABCFLOAT](../../mfc/reference/abcfloat-structure.md) structures pour recevoir la largeur des caractères lorsque la fonction retourne une valeur. Les largeurs retournés par cette fonction sont au format à virgule flottante IEEE.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Les largeurs sont retournées en unités logiques. Cette fonction fonctionne uniquement avec les polices TrueType.  
  
 Le convertisseur TrueType fournit l’espacement des caractères « ABC » après la sélection d’une taille spécifique. Espacement de « A » est la distance qui est ajoutée à la position actuelle avant de placer le glyphe. Espacement de « B » est la largeur de la partie noire du glyphe. Espacement de « C » est ajouté à la position actuelle pour prendre en compte les espaces blancs à droite du glyphe. Le total avancé largeur est donné par un + B + C.  
  
 Lorsque le `GetCharABCWidths` fonction membre récupère négatif « A » ou « C » la largeur de caractère, ce caractère inclut underhangs ou déborder.  
  
 Pour convertir les largeurs ABC en unités de design de police, une application doit créer une police dont la hauteur (comme spécifié dans le **lfHeight** membre de la [LOGFONT](http://msdn.microsoft.com/library/windows/desktop/dd145037) structure) est égal à la valeur stockée dans le **ntmSizeEM** membre du [NEWTEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162741) structure. (La valeur de la **ntmSizeEM** membre peut être récupéré en appelant le [EnumFontFamilies](http://msdn.microsoft.com/library/windows/desktop/dd162619) fonction Windows.)  
  
 Les largeurs de ABC de caractère par défaut sont utilisées pour les caractères situés en dehors de la plage de la police actuellement sélectionnée.  
  
 Pour récupérer la largeur des caractères dans les polices non TrueType, les applications doivent utiliser le [GetCharWidth](http://msdn.microsoft.com/library/windows/desktop/dd144861) fonction Windows.  
  
##  <a name="getcharabcwidthsi"></a>CDC::GetCharABCWidthsI  
 Récupère les largeurs, en unités logiques, des indices de glyphe consécutives dans une plage spécifiée de la police TrueType en cours.  
  
```  
BOOL GetCharABCWidthsI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPABC lpabc) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `giFirst`  
 Spécifie le premier index de glyphe dans le groupe d’indices de glyphe consécutives à partir de la police actuelle. Ce paramètre est utilisé uniquement si la `pgi` paramètre est **NULL**.  
  
 `cgi`  
 Spécifie le nombre d’indices de glyphe.  
  
 `pgi`  
 Pointeur vers un tableau contenant les index de glyphes. Si la valeur est **NULL**, le `giFirst` paramètre est utilisé à la place. Le `cgi` paramètre spécifie le nombre d’indices de glyphe dans ce tableau.  
  
 `lpabc`  
 Pointeur vers un tableau de [ABC](http://msdn.microsoft.com/library/windows/desktop/dd162454) structures reçoit la largeur des caractères. Ce tableau doit contenir au moins autant **ABC** qu’il sont a des index de glyphes spécifiés par les structures du `cgi` paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre émule les fonctionnalités de la fonction [GetCharABCWidthsI](http://msdn.microsoft.com/library/windows/desktop/dd144859), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getcharwidth"></a>CDC::GetCharWidth  
 Récupère la largeur des caractères individuels dans un groupe de caractères consécutifs de la police en cours, à l’aide de `m_hAttribDC`, le contexte de périphérique d’entrée.  
  
```  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    float* lpFloatBuffer) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nFirstChar`  
 Spécifie le premier caractère dans un groupe de caractères de la police actuelle consécutifs.  
  
 `nLastChar`  
 Spécifie le dernier caractère dans un groupe de caractères de la police actuelle consécutifs.  
  
 `lpBuffer`  
 Pointe vers une mémoire tampon qui recevra les valeurs de largeur pour un groupe de caractères consécutifs dans la police actuelle.  
  
 *lpFloatBuffer*  
 Pointe vers une mémoire tampon pour recevoir la largeur des caractères. Les largeurs retournées sont au format à virgule flottante IEEE 32 bits. (La largeur est mesurée le long de la ligne de base des caractères).  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Par exemple, si `nFirstChar` identifie la lettre « a » et `nLastChar` identifie la lettre « z », la fonction extrait les largeurs de tous les caractères en minuscules.  
  
 La fonction stocke les valeurs dans la mémoire tampon pointée par `lpBuffer`. Cette mémoire tampon doit être suffisamment grand pour contenir toutes les largeurs. Autrement dit, au moins 26 entrées doit être dans l’exemple donné.  
  
 Si un caractère dans le groupe de caractères consécutifs n’existe pas dans une police particulière, il recevront la valeur de la largeur de caractère par défaut.  
  
##  <a name="getcharwidthi"></a>CDC::GetCharWidthI  
 Récupère les largeurs, en coordonnées logiques, des indices de glyphe consécutives dans une plage spécifiée de la police actuelle.  
  
```  
BOOL GetCharWidthI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `giFirst`  
 Spécifie le premier index de glyphe dans le groupe d’indices de glyphe consécutives à partir de la police actuelle. Ce paramètre est utilisé uniquement si la `pgi` paramètre est **NULL**.  
  
 `cgi`  
 Spécifie le nombre d’indices de glyphe.  
  
 `pgi`  
 Pointeur vers un tableau contenant les index de glyphes. Si la valeur est **NULL**, le `giFirst` paramètre est utilisé à la place. Le `cgi` paramètre spécifie le nombre d’indices de glyphe dans ce tableau.  
  
 `lpBuffer`  
 Pointeur vers une mémoire tampon qui reçoit les largeurs.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre émule les fonctionnalités de la fonction [GetCharWidthI](http://msdn.microsoft.com/library/windows/desktop/dd144864), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getclipbox"></a>CDC::GetClipBox  
 Récupère les dimensions du rectangle englobant plus étroite autour de la limite de découpage en cours.  
  
```  
virtual int GetClipBox(LPRECT lpRect) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers le [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui doit recevoir les dimensions du rectangle.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de la zone de découpage. Il peut être une des valeurs suivantes :  
  
- **COMPLEXREGION** zone de découpage a chevauchement des bordures.  
  
- **ERREUR** contexte de périphérique n’est pas valide.  
  
- **NULLREGION** zone de découpage est vide.  
  
- **SIMPLEREGION** zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Remarques  
 Les dimensions sont copiées dans la mémoire tampon pointée par `lpRect`.  
  
##  <a name="getcoloradjustment"></a>CDC::GetColorAdjustment  
 Récupère les valeurs de réglage des couleurs pour le contexte de périphérique.  
  
```  
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpColorAdjust`  
 Pointe vers une [COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md) structure de données pour recevoir les valeurs de réglage des couleurs.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="getcurrentbitmap"></a>CDC::GetCurrentBitmap  
 Retourne un pointeur vers le sélectionné `CBitmap` objet.  
  
```  
CBitmap* GetCurrentBitmap() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CBitmap` objet, en cas de réussite ; sinon **NULL**.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentbrush"></a>CDC::GetCurrentBrush  
 Retourne un pointeur vers le sélectionné `CBrush` objet.  
  
```  
CBrush* GetCurrentBrush() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CBrush` objet, en cas de réussite ; sinon **NULL**.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentfont"></a>CDC::GetCurrentFont  
 Retourne un pointeur vers le sélectionné `CFont` objet.  
  
```  
CFont* GetCurrentFont() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CFont` objet, en cas de réussite ; sinon **NULL**.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentpalette"></a>CDC::GetCurrentPalette  
 Retourne un pointeur vers le sélectionné `CPalette` objet.  
  
```  
CPalette* GetCurrentPalette() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CPalette` objet, en cas de réussite ; sinon **NULL**.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentpen"></a>CDC::GetCurrentPen  
 Retourne un pointeur vers le sélectionné `CPen` objet.  
  
```  
CPen* GetCurrentPen() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CPen` objet, en cas de réussite ; sinon **NULL**.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentposition"></a>CDC::GetCurrentPosition  
 Récupère la position actuelle (en coordonnées logiques).  
  
```  
CPoint GetCurrentPosition() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La position actuelle comme un `CPoint` objet.  
  
### <a name="remarks"></a>Notes  
 Vous pouvez définir la position actuelle du `MoveTo` fonction membre.  
  
##  <a name="getdcbrushcolor"></a>CDC::GetDCBrushColor  
 Récupère la couleur actuelle du pinceau.  
  
```  
COLORREF GetDCBrushColor() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour est la [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) valeur pour la couleur actuelle du pinceau.  
  
 Si la fonction échoue, la valeur de retour est **CLR_INVALID**.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre émule les fonctionnalités de la fonction [GetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd144872), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getdcpencolor"></a>CDC::GetDCPenColor  
 Récupère la couleur actuelle du stylet.  
  
```  
COLORREF GetDCPenColor() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour est la [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) valeur pour la couleur actuelle du stylet.  
  
 Si la fonction échoue, la valeur de retour est **CLR_INVALID**.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre utilise la fonction Win32 [GetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd144875), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getdevicecaps"></a>CDC::GetDeviceCaps  
 Récupère un large éventail d’informations spécifiques au périphérique pour le périphérique d’affichage.  
  
```  
int GetDeviceCaps(int nIndex) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nIndex`  
 Spécifie le type d’informations à retourner. Consultez la page [GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour une liste de valeurs.  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur de la fonction demandée si la fonction réussit.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).  
  
##  <a name="getfontdata"></a>CDC::GetFontData  
 Récupère les informations de mesure de la police à partir d’un fichier de polices évolutives.  
  
```  
DWORD GetFontData(
    DWORD dwTable,  
    DWORD dwOffset,  
    LPVOID lpData,  
    DWORD cbData) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `dwTable`  
 Spécifie le nom de la table de métriques à retourner. Ce paramètre peut être une des tables de métriques documentées dans la spécification de fichiers de polices TrueType publiée par Microsoft Corporation. Si ce paramètre est 0, les informations sont extraites commençant au début du fichier de police.  
  
 `dwOffset`  
 Spécifie l’offset à partir du début de la table à partir duquel commencer la récupération des informations. Si ce paramètre est 0, les informations sont extraites du début de la table spécifiée par le `dwTable` paramètre. Si cette valeur est supérieure ou égale à la taille de la table, `GetFontData` renvoie la valeur 0.  
  
 `lpData`  
 Pointe vers une mémoire tampon qui recevra les informations de police. Si cette valeur est **NULL**, la fonction retourne la taille de la mémoire tampon requise pour les données de police spécifiées dans le `dwTable` paramètre.  
  
 `cbData`  
 Spécifie la longueur, en octets, des informations à récupérer. Si ce paramètre est 0, `GetFontData` retourne la taille des données spécifiées dans le `dwTable` paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le nombre d’octets retournés dans la mémoire tampon vers laquelle pointée `lpData` si la fonction réussit ; sinon -1.  
  
### <a name="remarks"></a>Remarques  
 Les informations à récupérer sont identifiées en spécifiant un décalage dans le fichier de police et la longueur de l’information à retourner.  
  
 Une application peut parfois utiliser les `GetFontData` fonction membre pour enregistrer une police TrueType dans un document. Pour ce faire, l’application détermine si la police peut être incorporée et récupère ensuite le fichier de police dans son intégralité, en spécifiant 0 pour la `dwTable`, `dwOffset`, et `cbData` paramètres.  
  
 Si une police peut être incorporée en vérifiant les applications peuvent déterminer la **otmfsType** membre de la [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) structure. Si le bit 1 de **otmfsType** est défini, l’incorporation n’est pas autorisée pour la police. Si le bit 1 est désactivée, la police peut être incorporée. Si le bit 2 est défini, l’incorporation est en lecture seule.  
  
 Si une application tente d’utiliser cette fonction pour récupérer des informations pour une police non TrueType, les `GetFontData` fonction membre retourne –&1;.  
  
##  <a name="getfontlanguageinfo"></a>CDC::GetFontLanguageInfo  
 Retourne des informations sur la police actuellement sélectionnée pour le contexte d’affichage spécifié.  
  
```  
DWORD GetFontLanguageInfo() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur de retour identifie les caractéristiques de la police actuellement sélectionnée. Pour obtenir une liste complète des valeurs possibles, consultez la page [GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886).  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre émule les fonctionnalités de la fonction [GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getglyphoutline"></a>CDC::GetGlyphOutline  
 Récupère la courbe du plan ou le bitmap pour un caractère avec contour dans la police actuelle.  
  
```  
DWORD GetGlyphOutline(
    UINT nChar,  
    UINT nFormat,  
    LPGLYPHMETRICS lpgm,  
    DWORD cbBuffer,  
    LPVOID lpBuffer,  
    const MAT2* lpmat2) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nChar`  
 Spécifie le caractère pour lequel les informations sont à retourner.  
  
 `nFormat`  
 Spécifie le format dans lequel la fonction doit retourner des informations. Il peut être une des valeurs suivantes, ou 0 :  
  
|Valeur|Signification|  
|-----------|-------------|  
|**GGO_BITMAP**|Retourne le bitmap de glyphe. Lorsque la fonction est retournée, la mémoire tampon vers laquelle pointe `lpBuffer` contient un bitmap de 1 bit par pixel dont les lignes démarrer sur des limites de mot double.|  
|**GGO_NATIVE**|Retourne la courbe de points de données au format natif de rastériseur, à l’aide des unités de périphérique. Lorsque cette valeur est spécifiée, toutes les transformations spécifiées dans `lpmat2` est ignoré.|  
  
 Lorsque la valeur de `nFormat` est 0, la fonction insère un [GLYPHMETRICS](http://msdn.microsoft.com/library/windows/desktop/dd144955) structure mais ne retourne pas de données de plan de glyphe.  
  
 *lpgm*  
 Pointe vers une **GLYPHMETRICS** structure qui décrit l’emplacement du glyphe de la cellule de caractère.  
  
 `cbBuffer`  
 Spécifie la taille de la mémoire tampon dans laquelle la fonction copie des informations sur le plan de caractères. Si cette valeur est 0 et la `nFormat` paramètre est soit le **GGO_BITMAP** ou **GGO_NATIVE** valeurs, la fonction retourne la taille requise de la mémoire tampon.  
  
 `lpBuffer`  
 Pointe vers une mémoire tampon dans laquelle la fonction copie des informations sur le plan de caractères. Si `nFormat` Spécifie le **GGO_NATIVE** valeur, les informations est copiée sous la forme de **TTPOLYGONHEADER** et **TTPOLYCURVE** structures. Si cette valeur est **NULL** et `nFormat` est la **GGO_BITMAP** ou **GGO_NATIVE** valeur, la fonction retourne la taille requise de la mémoire tampon.  
  
 `lpmat2`  
 Pointe vers une [MAT2](http://msdn.microsoft.com/library/windows/desktop/dd145048) structure qui contient une matrice de transformation pour le caractère. Ce paramètre ne peut pas être **NULL**, même lorsque les **GGO_NATIVE** valeur est spécifiée pour `nFormat`.  
  
### <a name="return-value"></a>Valeur de retour  
 La taille, en octets, de la mémoire tampon requise pour les informations récupérées si `cbBuffer` est égal à 0 ou `lpBuffer` est **NULL**. Sinon, c’est une valeur positive si la fonction réussite, ou -1 si une erreur se produit.  
  
### <a name="remarks"></a>Remarques  
 Une application peut faire pivoter les caractères extraites au format bitmap en spécifiant une matrice de transformation de 2 x 2 dans la structure vers laquelle pointée `lpmat2`.  
  
 Un contour de glyphe est retourné comme une série de profils. Chaque profil est défini par une [TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158) structure suivie autant **TTPOLYCURVE** nécessaires pour décrire les structures. Tous les points sont renvoyés en tant que [POINTFX](http://msdn.microsoft.com/library/windows/desktop/dd162806) structures et représentent des positions absolues, se déplace pas relatif. Le point de départ spécifié par le **pfxStart** membre de la [TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158) structure est le point auquel le plan pour un profil commence. Le [TTPOLYCURVE](http://msdn.microsoft.com/library/windows/desktop/dd145157) les structures qui suivent peuvent être des enregistrements de la polyligne ou spline. Polyline enregistrements sont une série de points ; lignes tracées entre les points de décrivent le contour du caractère. Les enregistrements de spline représentent les courbes quadratiques utilisés par TrueType (autrement dit, quadratiques b-splines).  
  
##  <a name="getgraphicsmode"></a>CDC::GetGraphicsMode  
 Récupère le mode graphique actuel pour le contexte de périphérique spécifié.  
  
```  
int GetGraphicsMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne le mode graphique actuel. Pour obtenir la liste des valeurs que cette méthode peut retourner, consultez [GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892).  
  
 Retourne 0 en cas d’échec.  
  
 Pour obtenir des informations d’erreur étendu appeler [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Remarques  
 Cette méthode encapsule la fonction GDI de Windows [GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892).  
  
##  <a name="gethalftonebrush"></a>CDC::GetHalftoneBrush  
 Appelez cette fonction membre pour récupérer un pinceau de demi-teintes.  
  
```  
static CBrush* PASCAL GetHalftoneBrush();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un pointeur vers un `CBrush` objet en cas de réussite ; sinon **NULL**.  
  
### <a name="remarks"></a>Notes  
 Un pinceau demi-teintes montre les pixels qui sont également des couleurs de premier plan et d’arrière-plan pour créer un modèle de tramé. Voici un exemple de modèle de tramé créé par un pinceau de demi-teintes.  
  
 ![Détail d’un stylet tramé](../../mfc/reference/media/vc318s1.gif "vc318s1")  
  
##  <a name="getkerningpairs"></a>CDC::GetKerningPairs  
 Récupère le caractère le crénage paires pour la police actuellement sélectionnée dans le contexte de périphérique spécifié.  
  
```  
int GetKerningPairs(
    int nPairs,  
    LPKERNINGPAIR lpkrnpair) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nPairs`  
 Spécifie le nombre de [KERNINGPAIR](http://msdn.microsoft.com/library/windows/desktop/dd145024) pointe vers `lpkrnpair`. La fonction ne copie pas les paires de crénage plus que le nombre spécifié par `nPairs`.  
  
 `lpkrnpair`  
 Pointe vers un tableau de **KERNINGPAIR** lorsque la fonction retourne les paires de structures qui reçoivent le crénage. Ce tableau doit contenir au moins autant de structures tel que spécifié par `nPairs`. Si ce paramètre est **NULL**, la fonction retourne le nombre total de crénage paires pour la police.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le nombre de paires récupérées de crénage ou le nombre total de crénage paires dans la police, si la fonction réussit. La valeur zéro est renvoyée si la fonction échoue ou si aucune paire crénage pour la police.  
  
##  <a name="getlayout"></a>CDC::GetLayout  
 Appelez cette fonction membre pour déterminer la disposition du texte et des graphiques pour un contexte de périphérique, comme une imprimante ou un métafichier.  
  
```  
DWORD GetLayout() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Si l’opération réussit, la disposition des indicateurs pour le contexte de périphérique en cours. Dans le cas contraire, **GDI_ERROR**. Pour plus d’informations d’erreur étendues, appelez [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360). Pour obtenir la liste des indicateurs de mise en page, consultez [CDC::SetLayout](#setlayout).  
  
### <a name="remarks"></a>Remarques  
 La disposition par défaut de gauche à droite.  
  
##  <a name="getmapmode"></a>CDC::GetMapMode  
 Récupère le mode de mappage en cours.  
  
```  
int GetMapMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de mappage.  
  
### <a name="remarks"></a>Notes  
 Pour obtenir une description des modes de mappage, consultez le `SetMapMode` fonction membre.  
  
> [!NOTE]
>  Si vous appelez [SetLayout](#setlayout) pour modifier le contrôleur de domaine à la disposition de droite à gauche, **SetLayout** change automatiquement le mode de mappage à `MM_ISOTROPIC`. Par conséquent, tous les appels suivants à `GetMapMode` renvoie `MM_ISOTROPIC`.  
  
##  <a name="getmiterlimit"></a>CDC::GetMiterLimit  
 Retourne la limite de pointe pour le contexte de périphérique.  
  
```  
float GetMiterLimit() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La limite d’angle est utilisée lorsque les jointures d’angle aigu tracer des lignes géométriques qui ont.  
  
##  <a name="getnearestcolor"></a>CDC::GetNearestColor  
 Retourne la couleur unie qui correspond le mieux à une couleur logique spécifiée.  
  
```  
COLORREF GetNearestColor(COLORREF crColor) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `crColor`  
 Spécifie la couleur à mettre en correspondance.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur de couleur RVB (rouge, vert, bleu) qui définit le solide de couleur le plus proche de la `crColor` valeur représentant l’appareil.  
  
### <a name="remarks"></a>Notes  
 Le périphérique donné doit être en mesure de représenter cette couleur.  
  
##  <a name="getoutlinetextmetrics"></a>CDC::GetOutlineTextMetrics  
 Récupère des informations sur les métriques des polices TrueType.  
  
```  
UINT GetOutlineTextMetrics(
    UINT cbData,  
    LPOUTLINETEXTMETRIC lpotm) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpotm`  
 Pointe vers un tableau de [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) structures. Si ce paramètre est **NULL**, la fonction retourne la taille de la mémoire tampon requise pour les données récupérées de mesure.  
  
 `cbData`  
 Spécifie la taille, en octets, de la mémoire tampon à laquelle les informations sont renvoyées.  
  
 `lpotm`  
 Pointe vers une **OUTLINETEXTMETRIC** structure. Si ce paramètre est **NULL**, la fonction retourne la taille de la mémoire tampon requise pour les informations de mesure récupérées.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) structure contient la plupart des informations de mesure police fournies avec le format TrueType, y compris un [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) structure. Les quatre derniers membres de la **OUTLINETEXTMETRIC** structure sont des pointeurs vers des chaînes. Applications doivent allouer de l’espace de ces chaînes en plus de l’espace requis pour les autres membres. Étant donné qu’aucune limite imposée par le système à la taille des chaînes, la méthode la plus simple pour allouer de la mémoire consiste à extraire la taille requise en spécifiant **NULL** de `lpotm` dans le premier appel à la `GetOutlineTextMetrics` (fonction).  
  
##  <a name="getoutputcharwidth"></a>CDC::GetOutputCharWidth  
 Utilise le contexte de périphérique de sortie, `m_hDC`et récupère la largeur des caractères individuels dans un groupe de caractères consécutifs de la police actuelle.  
  
```  
BOOL GetOutputCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nFirstChar`  
 Spécifie le premier caractère dans un groupe de caractères de la police actuelle consécutifs.  
  
 `nLastChar`  
 Spécifie le dernier caractère dans un groupe de caractères de la police actuelle consécutifs.  
  
 `lpBuffer`  
 Pointe vers une mémoire tampon qui recevra les valeurs de largeur pour un groupe de caractères consécutifs dans la police actuelle.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Par exemple, si `nFirstChar` identifie la lettre « a » et `nLastChar` identifie la lettre « z », la fonction extrait les largeurs de tous les caractères en minuscules.  
  
 La fonction stocke les valeurs dans la mémoire tampon pointée par `lpBuffer`. Cette mémoire tampon doit être suffisamment grand pour contenir toutes les largeurs. Autrement dit, au moins 26 entrées doit être dans l’exemple donné.  
  
 Si un caractère dans le groupe de caractères consécutifs n’existe pas dans une police particulière, il recevront la valeur de la largeur de caractère par défaut.  
  
##  <a name="getoutputtabbedtextextent"></a>CDC::GetOutputTabbedTextExtent  
 Appelez cette fonction membre pour calculer la largeur et la hauteur d’une chaîne de caractères à l’aide de [m_hDC](#m_hdc), le contexte de périphérique de sortie.  
  
```  
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetOutputTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszString`  
 Pointe vers une chaîne de caractères à mesurer. Vous pouvez également transmettre un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne. Si `nCount` est –&1;, la longueur est calculée.  
  
 `nTabPositions`  
 Spécifie le nombre de positions de taquet de tabulation dans le tableau pointé par `lpnTabStopPositions`.  
  
 `lpnTabStopPositions`  
 Pointe vers un tableau d’entiers qui contient les positions de taquet de tabulation dans les unités logiques. Les taquets de tabulation doivent être triées par ordre croissant de commande ; la plus petite valeur x doit être le premier élément du tableau. Onglets précédent ne sont pas autorisés.  
  
 `str`  
 Un `CString` objet qui contient les caractères spécifiés à mesurer.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) dans un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 Si la chaîne contient un ou plusieurs caractères de tabulation, la largeur de la chaîne est basée sur les taquets de tabulation spécifiés par `lpnTabStopPositions`. La fonction utilise la police actuellement sélectionnée pour calculer les dimensions de la chaîne.  
  
 Décalage de la zone de découpage en cours ne pas la largeur et la hauteur retournée par le `GetOutputTabbedTextExtent` (fonction).  
  
 Étant donné que certains périphériques ne placent pas de caractères dans les tableaux de cellule standard (autrement dit, ils crénage les caractères), la somme des étendues dans une chaîne de caractères peut être différent dans la mesure de la chaîne.  
  
 Si `nTabPositions` est égal à 0 et `lpnTabStopPositions` est **NULL**, onglets sont étendues à la largeur de caractère moyenne huit. Si `nTabPositions` est 1, les taquets de tabulation sont séparés par la distance indiquée par la première valeur dans le tableau dans lequel `lpnTabStopPositions` points. Si `lpnTabStopPositions` points à plus d’une valeur unique, un taquet de tabulation est défini pour chaque valeur dans le tableau, jusqu’au nombre spécifié par `nTabPositions`.  
  
##  <a name="getoutputtextextent"></a>CDC::GetOutputTextExtent  
 Appelez cette fonction membre pour utiliser le contexte de périphérique de sortie, [m_hDC](#m_hdc)et le calcul de la largeur et la hauteur d’une ligne de texte, à l’aide de la police actuelle.  
  
```  
CSize GetOutputTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetOutputTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszString`  
 Pointe vers une chaîne de caractères. Vous pouvez également transmettre un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne. Si `nCount` est –&1;, la longueur est calculée.  
  
 `str`  
 Un `CString` objet qui contient les caractères spécifiés à mesurer.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) retournées dans une [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 La zone de découpage actuelle n’affecte pas la largeur et la hauteur retournée par `GetOutputTextExtent`.  
  
 Étant donné que certains périphériques ne placent pas de caractères dans les tableaux de cellule standard (autrement dit, qu’il effectue le crénage), la somme des étendues dans une chaîne de caractères peut être différent dans la mesure de la chaîne.  
  
##  <a name="getoutputtextmetrics"></a>CDC::GetOutputTextMetrics  
 Récupère les mesures de la police actuelle en utilisant `m_hDC`, le contexte de périphérique de sortie.  
  
```  
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpMetrics`  
 Pointe vers le [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) structure qui reçoit les mesures.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="getpath"></a>CDC::getPath  
 Récupère les coordonnées définissant les extrémités des lignes et les points de contrôle des courbes dans le chemin d’accès qui est sélectionné dans le contexte de périphérique.  
  
```  
int GetPath(
    LPPOINT lpPoints,  
    LPBYTE lpTypes,  
    int nCount) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données ou `CPoint` objets où des points de contrôle de courbe les points de terminaison de ligne sont placés.  
  
 `lpTypes`  
 Pointe vers un tableau d’octets où sont placés les types de sommets. Les valeurs sont les suivantes :  
  
- **PT_MOVETO** Spécifie que le point correspondant dans `lpPoints` démarre une figure distincte.  
  
- **PT_LINETO** Spécifie que le point précédent et correspondants point dans `lpPoints` sont les points de terminaison d’une ligne.  
  
- **PT_BEZIERTO** Spécifie que le point correspondant dans `lpPoints` est un point de contrôle ou d’un point de fin d’une courbe Bzier.  
  
 **PT_BEZIERTO** toujours se produire dans les ensembles de trois. Le point dans le chemin d’accès qui précède immédiatement les définit le point de départ de la courbe Bzier. Les deux premières **PT_BEZIERTO** points sont les points de contrôle et le troisième **PT_BEZIERTO** est le point de fin (si codées en dur).  
  
     A **PT_LINETO** ou **PT_BEZIERTO** type peut-être être combiné avec l’indicateur suivant (à l’aide de l’opérateur de bits `OR`) pour indiquer que le point correspondant est le dernier point d’une figure et que le doit être fermée :  
  
- **PT_CLOSEFIGURE** Spécifie que la figure est fermée automatiquement après la ligne correspondante ou courbe. La figure est fermée en dessinant une ligne du point de terminaison ou la courbe jusqu’au point correspondant au dernier **PT_MOVETO**.  
  
 `nCount`  
 Spécifie le nombre total de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui peuvent être placés dans le `lpPoints` tableau. Cette valeur doit être le même que le nombre d’octets qui peut être placé dans le `lpTypes` tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Si le `nCount` paramètre est différent de zéro, le nombre de points énumérés. Si `nCount` est 0, le nombre total de points dans le chemin d’accès (et `GetPath` n’écrit rien dans les mémoires tampons). Si `nCount` est différente de zéro et inférieur au nombre de points dans le chemin d’accès, la valeur de retour est -1.  
  
### <a name="remarks"></a>Remarques  
 Le contexte de périphérique doit contenir une trajectoire fermée. Les points du chemin d’accès sont retournées en coordonnées logiques. Points sont stockés dans le chemin d’accès dans les coordonnées de périphérique, par conséquent, `GetPath` modifie les points de coordonnées périphérique coordonnées logiques en utilisant l’inverse de la transformation actuelle. Le `FlattenPath` fonction membre peut être appelée avant `GetPath`pour convertir toutes les courbes dans le chemin d’accès dans des segments de ligne.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="getpixel"></a>CDC::getPixel  
 Récupère la valeur de couleur RVB du pixel au point spécifié par *x* et *y*.  
  
```  
COLORREF GetPixel(
    int x,  
    int y) const;  
  
COLORREF GetPixel(POINT point) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point à examiner.  
  
 *y*  
 Spécifie la coordonnée y logique du point à examiner.  
  
 `point`  
 Spécifie la logique et y coordonnées x du point à examiner.  
  
### <a name="return-value"></a>Valeur de retour  
 Pour toutes les versions de la fonction, une valeur de couleur RVB de la couleur du point donné. Elle est égale à –&1; si les coordonnées ne spécifient pas un point dans la zone de découpage.  
  
### <a name="remarks"></a>Notes  
 Le point doit être dans la zone de découpage. Si le point n’est pas dans la zone de découpage, la fonction n’a aucun effet et retourne -1.  
  
 Tous les périphériques prennent en charge la **GetPixel** (fonction). Pour plus d’informations, consultez la **RC_BITBLT** fonctionnalité raster sous la [GetDeviceCaps](#getdevicecaps) fonction membre.  
  
 Le **GetPixel** possède deux formes. Le premier accepte deux valeurs de coordonnées ; la deuxième prend soit un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet.  
  
##  <a name="getpolyfillmode"></a>CDC::GetPolyFillMode  
 Récupère le mode de remplissage de polygones en cours.  
  
```  
int GetPolyFillMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode plein de polygone actuel, **autre** ou **enroulement**, si la fonction réussite.  
  
### <a name="remarks"></a>Notes  
 Consultez le `SetPolyFillMode` fonction membre pour obtenir une description des modes de remplissage de polygones.  
  
##  <a name="getrop2"></a>CDC::GetROP2  
 Récupère le mode de dessin en cours.  
  
```  
int GetROP2() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de dessin. Pour obtenir la liste des valeurs en mode dessin, consultez la `SetROP2` fonction membre.  
  
### <a name="remarks"></a>Remarques  
 Le mode de dessin spécifie comment les couleurs du stylet et l’intérieur d’objets sont combinées avec la couleur déjà sur la surface d’affichage.  
  
##  <a name="getsafehdc"></a>CDC::GetSafeHdc  
 Appelez cette fonction membre pour obtenir [m_hDC](#m_hdc), le contexte de périphérique de sortie.  
  
```  
HDC GetSafeHdc() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un handle de contexte de périphérique.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre fonctionne également avec des pointeurs null.  
  
##  <a name="getstretchbltmode"></a>CDC::GetStretchBltMode  
 Récupère le mode d’étirement de bitmap actuel.  
  
```  
int GetStretchBltMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur de retour Spécifie le mode d’étirement de bitmap actuel : **STRETCH_ANDSCANS**, **STRETCH_DELETESCANS**, ou **STRETCH_ORSCANS** : si la fonction réussit.  
  
### <a name="remarks"></a>Notes  
 Le mode d’étirement de bitmap définit comment les informations sont supprimées de bitmaps qui sont étirés ou compressés par le `StretchBlt` fonction membre.  
  
 Le **STRETCH_ANDSCANS** et **STRETCH_ORSCANS** modes sont généralement utilisés pour préserver des pixels de premier plan dans les images bitmap monochromes. Le **STRETCH_DELETESCANS** mode est généralement utilisé pour conserver les couleurs dans les images bitmap de couleur.  
  
##  <a name="gettabbedtextextent"></a>CDC::GetTabbedTextExtent  
 Appelez cette fonction membre pour calculer la largeur et la hauteur d’une chaîne de caractères à l’aide de [m_hAttribDC](#m_hattribdc), le contexte de l’attribut.  
  
```  
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszString`  
 Pointe vers une chaîne de caractères. Vous pouvez également transmettre un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne. Si `nCount` est –&1;, la longueur est calculée.  
  
 `nTabPositions`  
 Spécifie le nombre de positions de taquet de tabulation dans le tableau pointé par `lpnTabStopPositions`.  
  
 `lpnTabStopPositions`  
 Pointe vers un tableau d’entiers qui contient les positions de taquet de tabulation dans les unités logiques. Les taquets de tabulation doivent être triées par ordre croissant de commande ; la plus petite valeur x doit être le premier élément du tableau. Onglets précédent ne sont pas autorisés.  
  
 `str`  
 Un `CString` objet qui contient les caractères spécifiés à dessiner.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) dans un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 Si la chaîne contient un ou plusieurs caractères de tabulation, la largeur de la chaîne est basée sur les taquets de tabulation spécifiés par `lpnTabStopPositions`. La fonction utilise la police actuellement sélectionnée pour calculer les dimensions de la chaîne.  
  
 Décalage de la zone de découpage en cours ne pas la largeur et la hauteur retournée par le `GetTabbedTextExtent` (fonction).  
  
 Étant donné que certains périphériques ne placent pas de caractères dans les tableaux de cellule standard (autrement dit, ils crénage les caractères), la somme des étendues dans une chaîne de caractères peut être différent dans la mesure de la chaîne.  
  
 Si `nTabPositions` est égal à 0 et `lpnTabStopPositions` est **NULL**, onglets sont étendues à la largeur de caractère moyenne huit fois. Si `nTabPositions` est 1, les taquets de tabulation sont séparés par la distance indiquée par la première valeur dans le tableau dans lequel `lpnTabStopPositions` points. Si `lpnTabStopPositions` points à plus d’une valeur unique, un taquet de tabulation est défini pour chaque valeur dans le tableau, jusqu’au nombre spécifié par `nTabPositions`.  
  
##  <a name="gettextalign"></a>CDC::GetTextAlign  
 Récupère l’état des indicateurs d’alignement de texte pour le contexte de périphérique.  
  
```  
UINT GetTextAlign() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 L’état des indicateurs d’alignement de texte. La valeur de retour est une ou plusieurs des valeurs suivantes :  
  
- **TA_BASELINE** Spécifie l’alignement de l’axe x et la ligne de base de la police choisie dans le rectangle englobant.  
  
- **TA_BOTTOM** Spécifie l’alignement de l’axe des abscisses et le bas du rectangle englobant.  
  
- **TA_CENTER** Spécifie l’alignement de l’axe y et le centre du rectangle englobant.  
  
- **TA_LEFT** Spécifie l’alignement de l’axe des y et le côté gauche du rectangle englobant.  
  
- **TA_NOUPDATECP** Spécifie que la position actuelle n’est pas mis à jour.  
  
- **TA_RIGHT** Spécifie l’alignement de l’axe y et le côté droit du rectangle englobant.  
  
- **TA_TOP** Spécifie l’alignement de l’axe des abscisses et le bord supérieur du rectangle englobant.  
  
- **TA_UPDATECP** Spécifie que la position actuelle est à jour.  
  
### <a name="remarks"></a>Notes  
 Les indicateurs d’alignement de texte déterminent comment le `TextOut` et `ExtTextOut` les fonctions membres alignement une chaîne de texte par rapport à point de départ de la chaîne. Les indicateurs d’alignement de texte ne sont pas nécessairement unique bits indicateurs et peuvent être égales à 0. Pour vérifier si un indicateur est défini, une application doit procédez comme suit :  
  
1.  Appliquer l’opérateur OR pour l’indicateur et ses indicateurs connexes, regroupées comme suit :  
  
    - **TA_LEFT**, **TA_CENTER**, et **TA_RIGHT**  
  
    - **TA_BASELINE**, **TA_BOTTOM**, et **TA_TOP**  
  
    - **TA_NOUPDATECP** et **TA_UPDATECP**  
  
2.  Appliquer l’opérateur de bits- et opérateur le résultat et la valeur de retour de `GetTextAlign`.  
  
3.  Tester l’égalité de ce résultat et de l’indicateur.  
  
##  <a name="gettextcharacterextra"></a>CDC::GetTextCharacterExtra  
 Récupère la valeur actuelle de la quantité de l’espacement entre les caractères.  
  
```  
int GetTextCharacterExtra() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La quantité de l’espacement entre les caractères.  
  
### <a name="remarks"></a>Remarques  
 GDI ajoute cet espacement à chaque caractère, y compris les caractères de saut, lorsqu’il écrit une ligne de texte dans le contexte de périphérique.  
  
 La valeur par défaut pour la quantité de l’espacement est 0.  
  
##  <a name="gettextcolor"></a>CDC::GetTextColor  
 Récupère la couleur de texte actuelle.  
  
```  
COLORREF GetTextColor() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La couleur de texte actuelle avec une valeur de couleur RVB.  
  
### <a name="remarks"></a>Remarques  
 La couleur du texte est la couleur de premier plan de caractères extraits à l’aide des fonctions membres de la sortie de texte GDI [TextOut](#textout), [ExtTextOut](#exttextout), et [TabbedTextOut](#tabbedtextout).  
  
##  <a name="gettextextent"></a>CDC::GetTextExtent  
 Appelez cette fonction membre pour calculer la largeur et la hauteur d’une ligne de texte à l’aide de la police actuelle pour déterminer les dimensions.  
  
```  
CSize GetTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszString`  
 Pointe vers une chaîne de caractères. Vous pouvez également transmettre un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne.  
  
 `str`  
 Un `CString` objet qui contient les caractères spécifiés.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) dans un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 Les informations sont extraites à partir de [m_hAttribDC](#m_hattribdc), le contexte de l’attribut.  
  
 Par défaut, `GetTextExtent` suppose que le texte pour lequel il récupère la dimension est défini sur une ligne horizontale (autrement dit, l’échappement est 0). Si vous créez une police en spécifiant un échappement différent de zéro, vous devez convertir l’angle du texte explicitement pour obtenir les dimensions de la chaîne.  
  
 La zone de découpage actuelle n’affecte pas la largeur et la hauteur retournée par `GetTextExtent`.  
  
 Étant donné que certains périphériques ne placent pas de caractères dans les tableaux de cellule standard (autrement dit, qu’il effectue le crénage), la somme des étendues dans une chaîne de caractères peut être différent dans la mesure de la chaîne.  
  
##  <a name="gettextextentexpointi"></a>CDC::GetTextExtentExPointI  
 Récupère le nombre de caractères dans une chaîne spécifiée qui occupent un espace spécifié et remplit un tableau avec l’étendue de texte pour chacun de ces caractères.  
  
```  
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,  
    int cgi,  
    int nMaxExtent,  
    LPINT lpnFit,  
    LPINT alpDx,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `pgiIn`  
 Pointeur vers un tableau d’indices de glyphe pour lequel les étendues doivent être récupérés.  
  
 `cgi`  
 Spécifie le nombre de glyphes dans le tableau pointé par `pgiIn`.  
  
 `nMaxExtent`  
 Spécifie la largeur maximale autorisée, en unités logiques, de la chaîne mise en forme.  
  
 `lpnFit`  
 Un pointeur vers un entier qui reçoit un nombre du nombre maximal de caractères qui tiendront dans l’espace spécifié par `nMaxExtent`. Lors de la `lpnFit` est **NULL**, `nMaxExtent` est ignoré.  
  
 *alpDx*  
 Pointeur vers un tableau d’entiers qui reçoit des étendues de glyphe partielle. Chaque élément dans le tableau donne la distance, en unités logiques, entre le début du tableau d’indices de glyphe et un des glyphes qui tient dans l’espace spécifié par `nMaxExtent`. Bien que ce tableau doit avoir au moins autant d’éléments que les indices de glyphe spécifiés par `cgi`, la fonction remplit le tableau avec étendues uniquement pour les index de glyphes autant spécifiés par `lpnFit`. Si *lpnDx* est **NULL**, la fonction ne calcule pas les largeurs partielle des chaînes.  
  
 `lpSize`  
 Pointeur vers un [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure qui reçoit les dimensions du tableau d’indices de glyphe, en unités logiques. Cette valeur ne peut pas être **NULL**.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre émule les fonctionnalités de la fonction [GetTextExtentExPointI](http://msdn.microsoft.com/library/windows/desktop/dd144936), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="gettextextentpointi"></a>CDC::GetTextExtentPointI  
 Récupère la largeur et la hauteur du tableau spécifié d’indices de glyphe.  
  
```  
BOOL GetTextExtentPointI(
    LPWORD pgiIn,  
    int cgi,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `pgiIn`  
 Pointeur vers un tableau d’indices de glyphe pour lequel les étendues doivent être récupérés.  
  
 `cgi`  
 Spécifie le nombre de glyphes dans le tableau pointé par `pgiIn`.  
  
 `lpSize`  
 Pointeur vers un [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure qui reçoit les dimensions du tableau d’indices de glyphe, en unités logiques. Cette valeur ne peut pas être **NULL**.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre émule les fonctionnalités de la fonction [GetTextExtentPointI](http://msdn.microsoft.com/library/windows/desktop/dd144939), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="gettextface"></a>CDC::GetTextFace  
 Appelez cette fonction membre pour copier le nom de la police actuelle dans une mémoire tampon.  
  
```  
int GetTextFace(
    int nCount,  
    LPTSTR lpszFacename) const;  
  
int GetTextFace(CString& rString) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nCount`  
 Spécifie la taille de la mémoire tampon (en octets). Si le nom de la police est plus long que le nombre d’octets spécifié par ce paramètre, le nom est tronqué.  
  
 *lpszFacename*  
 Pointe vers la mémoire tampon pour le nom de la police.  
  
 `rString`  
 Une référence à un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet.  
  
### <a name="return-value"></a>Valeur de retour  
 Le nombre d’octets copiés dans la mémoire tampon, non compris le caractère null de fin. Il est 0 si une erreur se produit.  
  
### <a name="remarks"></a>Remarques  
 Le nom de la police est copié sous forme de chaîne se terminant par null.  
  
##  <a name="gettextmetrics"></a>CDC::GetTextMetrics  
 Récupère les mesures pour la police actuelle en utilisant le contexte de périphérique d’attribut.  
  
```  
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpMetrics`  
 Pointe vers le [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) structure qui reçoit les mesures.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="getviewportext"></a>CDC::GetViewportExt  
 Récupère les étendues x et y de la fenêtre d’affichage du contexte de périphérique.  
  
```  
CSize GetViewportExt() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le x - et y-extensions (en unités de périphérique) comme un `CSize` objet.  
  
##  <a name="getviewportorg"></a>CDC::GetViewportOrg  
 Récupère les coordonnées x et y de l’origine de la fenêtre d’affichage associé au contexte de périphérique.  
  
```  
CPoint GetViewportOrg() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de la fenêtre d’affichage (dans les coordonnées de périphérique) comme un `CPoint` objet.  
  
##  <a name="getwindow"></a>CDC::GetWindow  
 Retourne la fenêtre associée au contexte de périphérique d’affichage.  
  
```  
CWnd* GetWindow() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CWnd` objet en cas de réussite ; sinon **NULL**.  
  
### <a name="remarks"></a>Remarques  
 Il s’agit d’une fonction avancée. Par exemple, cette fonction membre ne peut pas retourner la fenêtre d’affichage lors de l’impression ou en aperçu avant impression. Cette propriété retourne toujours la fenêtre de sortie. Dessinent des fonctions de sortie qui utilisent le contrôleur de domaine donné dans cette fenêtre.  
  
##  <a name="getwindowext"></a>CDC::GetWindowExt  
 Récupère les étendues x et y de la fenêtre associée au contexte de périphérique.  
  
```  
CSize GetWindowExt() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le x - et y-extensions (en unités logiques) comme un `CSize` objet.  
  
##  <a name="getwindoworg"></a>CDC::GetWindowOrg  
 Récupère les coordonnées x et y de l’origine de la fenêtre associée au contexte de périphérique.  
  
```  
CPoint GetWindowOrg() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de la fenêtre (en coordonnées logiques) comme un `CPoint` objet.  
  
##  <a name="getworldtransform"></a>CDC::GetWorldTransform  
 Récupère l’espace de monde actuel pour la transformation de l’espace de page.  
  
```  
BOOL GetWorldTransform(XFORM& rXform) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `rXform`  
 Référence à un [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) structure qui reçoit l’espace de monde actuel pour la transformation de l’espace de page.  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne une valeur différente de zéro.  
  
 Retourne 0 en cas d’échec.  
  
 Pour obtenir des informations d’erreur étendu appeler [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Notes  
 Cette méthode encapsule la fonction GDI de Windows [GetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd144953).  
  
##  <a name="gradientfill"></a>CDC::GradientFill  
 Appelez cette fonction membre pour remplir les structures et triangle rectangle avec une couleur qui permette le fondu en douceur d’un côté à l’autre.  
  
```  
BOOL GradientFill(
    TRIVERTEX* pVertices,  
    ULONG nVertices,  
    void* pMesh,  
    ULONG nMeshElements,  
    DWORD dwMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *pVertices*  
 Pointeur vers un tableau de [TRIVERTEX](http://msdn.microsoft.com/library/windows/desktop/dd145142) structures que définissent chacun un sommet du triangle.  
  
 *nVertices*  
 Le nombre de sommets.  
  
 `pMesh`  
 Tableau de [GRADIENT_TRIANGLE](http://msdn.microsoft.com/library/windows/desktop/dd144959) en mode de triangle ou un tableau de structures de [GRADIENT_RECT](http://msdn.microsoft.com/library/windows/desktop/dd144958) structures en mode de rectangle.  
  
 *nMeshElements*  
 Le nombre d’éléments (triangles ou les rectangles) dans `pMesh`.  
  
 `dwMode`  
 Spécifie le mode de remplissage dégradé. Pour obtenir la liste des valeurs possibles, consultez la page [GradientFill](http://msdn.microsoft.com/library/windows/desktop/dd144957) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
### <a name="return-value"></a>Valeur de retour  
 **TRUE** cas de réussite ; sinon **FALSE**.  
  
### <a name="remarks"></a>Remarques  
 Pour plus d’informations, consultez `GradientFill` dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="graystring"></a>CDC::GrayString  
 Dessine grisé (gris) à l’emplacement spécifié par écriture du texte dans une image bitmap de mémoire, affaiblissement de la bitmap, puis copie l’image bitmap à l’affichage.  
  
```  
virtual BOOL GrayString(
    CBrush* pBrush,  
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),  
    LPARAM lpData,  
    int nCount,  
    int x,  
    int y,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Paramètres  
 `pBrush`  
 Identifie le pinceau à utiliser pour l’estompage (graying).  
  
 `lpfnOutput`  
 Spécifie l’adresse de l’instance de la procédure de la fonction de rappel fournie par l’application qui dessine la chaîne. Pour plus d’informations, consultez la description des fenêtres **OutputFunc** [fonction de rappel](../../mfc/reference/callback-function-for-cdc-graystring.md). Si ce paramètre est **NULL**, le système utilise Windows `TextOut` fonction pour dessiner la chaîne, et `lpData` est supposé pour être un pointeur long vers la chaîne de caractères en sortie.  
  
 `lpData`  
 Spécifie un pointeur lointain vers les données à passer à la fonction de sortie. Si `lpfnOutput` est **NULL**, `lpData` doit être un pointeur long vers la chaîne de sortie.  
  
 `nCount`  
 Spécifie le nombre de caractères en sortie. Si ce paramètre est 0, `GrayString` calcule la longueur de la chaîne (en supposant que `lpData` est un pointeur vers la chaîne). Si `nCount` est – 1 et la fonction vers laquelle pointé `lpfnOutput` retourne 0, l’image est indiqué mais non estompé.  
  
 *x*  
 Spécifie la coordonnée x logique de la position de départ du rectangle qui englobe la chaîne.  
  
 *y*  
 Spécifie la coordonnée y logique de la position de départ du rectangle qui englobe la chaîne.  
  
 `nWidth`  
 Spécifie la largeur (en unités logiques) du rectangle qui englobe la chaîne. Si `nWidth` est 0, `GrayString` calcule la largeur de la zone, en supposant que `lpData` est un pointeur vers la chaîne.  
  
 `nHeight`  
 Spécifie la hauteur (en unités logiques) du rectangle qui englobe la chaîne. Si `nHeight` est 0, `GrayString` calcule la hauteur de la zone, en supposant que `lpData` est un pointeur vers la chaîne.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la chaîne est dessinée, ou 0 si le `TextOut` fonction ou la fonction fournie par l’application de sortie renvoyé 0, ou si la mémoire était insuffisante pour créer une image bitmap de mémoire pour cette fonction.  
  
### <a name="remarks"></a>Notes  
 La fonction efface le texte, quelle que soit la forme sélectionnée et l’arrière-plan. Le `GrayString` fonction membre utilise la police actuellement sélectionnée. La `MM_TEXT` mode de mappage doit être sélectionné avant d’utiliser cette fonction.  
  
 Une application peut dessiner des chaînes (grisées) grisées sur les périphériques qui prennent en charge une couleur grise unie sans appeler le `GrayString` fonction membre. La couleur système **COLOR_GRAYTEXT** est la couleur gris solide système utilisée pour dessiner le texte désactivé. L’application peut appeler le **GetSysColor** fonction Windows pour récupérer la valeur de couleur **COLOR_GRAYTEXT**. Si la couleur est différente de 0 (noir), l’application peut appeler le `SetTextColor` fonction membre pour définir la couleur du texte à la valeur de couleur et dessinez directement la chaîne. Si la couleur récupérée est noire, l’application doit appeler `GrayString` atténue (gris) le texte.  
  
 Si `lpfnOutput` est **NULL**, GDI utilise Windows [TextOut](http://msdn.microsoft.com/library/windows/desktop/dd145133) (fonction), et `lpData` est supposé pour être un pointeur lointain vers le caractère de sortie. Si les caractères en sortie ne peut pas être gérées par le `TextOut` fonction membre (par exemple, la chaîne est stockée sous forme de bitmap), l’application doit fournir sa propre fonction de sortie.  
  
 Notez également que toutes les fonctions de rappel doivent intercepter les exceptions de Microsoft Foundation avant de retourner à Windows, étant donné que les exceptions ne peuvent pas être levées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, consultez l’article [Exceptions](../../mfc/exception-handling-in-mfc.md).  
  
 La fonction de rappel transmise à `GrayString` doit utiliser le `__stdcall` convention d’appel et doit être exporté avec `__declspec`.  
  
 Lorsque l’infrastructure est en mode Aperçu, un appel à la `GrayString` fonction membre est convertie en un `TextOut` appel et la fonction de rappel n’est pas appelée.  
  
##  <a name="himetrictodp"></a>CDC::HIMETRICtoDP  
 Utilisez cette fonction lorsque vous convertissez **HIMETRIC** tailles allant de OLE en pixels.  
  
```  
void HIMETRICtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpSize`  
 Pointe vers une [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 Si le mode de mappage de l’objet de contexte de périphérique est `MM_LOENGLISH`, `MM_HIENGLISH`, `MM_LOMETRIC` ou `MM_HIMETRIC`, la conversion est basée sur le nombre de pixels de pouce physique. Si le mode de mappage est un des autres modes non limité (par exemple, `MM_TEXT`), la conversion est basée sur le nombre de pixels de pouce logique.  
  
##  <a name="himetrictolp"></a>CDC::HIMETRICtoLP  
 Appelez cette fonction pour convertir **HIMETRIC** unités en unités logiques.  
  
```  
void HIMETRICtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpSize`  
 Pointe vers une [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 Utilisez cette fonction lorsque vous obtenez **HIMETRIC** tailles allant de OLE et souhaitez convertir en mode de mappage naturel de votre application.  
  
 La conversion s’effectue en convertissant en premier le **HIMETRIC** unités en pixels, puis en convertissant ces unités dans des unités logiques à l’aide des unités de mappage du contexte de périphérique en cours. Notez que les étendues de fenêtre et la fenêtre d’affichage de l’appareil affecte le résultat.  
  
##  <a name="intersectcliprect"></a>CDC::IntersectClipRect  
 Crée une nouvelle zone de découpage par l’intersection de la zone en cours et le rectangle spécifié par `x1`, `y1`, `x2`, et `y2`.  
  
```  
int IntersectClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int IntersectClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle.  
  
 `y1`  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle.  
  
 `x2`  
 Spécifie la coordonnée x logique de l’angle inférieur droit du rectangle.  
  
 `y2`  
 Spécifie la coordonnée y logique de l’angle inférieur droit du rectangle.  
  
 `lpRect`  
 Spécifie le rectangle. Vous pouvez passer soit un `CRect` objet ou un pointeur vers un `RECT` structure pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de la nouvelle zone découpage. Il peut être l’une des valeurs suivantes :  
  
- **COMPLEXREGION** nouvelle zone de découpage a chevauchement des bordures.  
  
- **ERREUR** contexte de périphérique n’est pas valide.  
  
- **NULLREGION** nouvelle zone de découpage est vide.  
  
- **SIMPLEREGION** nouvelle zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Remarques  
 GDI fait coïncider toutes les sorties suivantes pour tenir dans la nouvelle limite. La largeur et la hauteur ne doivent pas dépasser 32 767.  
  
##  <a name="invertrect"></a>CDC::InvertRect  
 Inverse le contenu du rectangle donné.  
  
```  
void InvertRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers un `RECT` qui contient les coordonnées logiques du rectangle à inverser. Vous pouvez également transmettre un `CRect` objet pour ce paramètre.  
  
### <a name="remarks"></a>Notes  
 Inversion est un opérateur logique opération et les retournements de bits de chaque pixel. Sur un écran monochrome, la fonction rend pixels blancs noir et noir pixels blanc. Affiche des couleurs, l’inversion dépend sur la façon dont les couleurs sont générés pour l’affichage. Appel de `InvertRect` deux fois avec le même rectangle restaure l’affichage couleurs précédente.  
  
 Si le rectangle est vide, rien n’est dessiné.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView n °&36;](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]  
  
##  <a name="invertrgn"></a>CDC::InvertRgn  
 Inverse les couleurs dans la région spécifiée par `pRgn`.  
  
```  
BOOL InvertRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>Paramètres  
 `pRgn`  
 Identifie la région à inverser. Les coordonnées de la région sont spécifiées en unités logiques.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Sur un écran monochrome, la fonction rend pixels blancs noir et noir pixels blanc. Affiche des couleurs, l’inversion dépend sur la façon dont les couleurs sont générés pour l’affichage.  
  
##  <a name="isprinting"></a>CDC::IsPrinting  
 Détermine si le contexte de périphérique est utilisé pour l’impression.  
  
```  
BOOL IsPrinting() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si le `CDC` objet est contrôleur de domaine, sinon 0.  
  
##  <a name="lineto"></a>CDC::LineTo  
 Dessine une ligne à partir de la position actuelle jusqu'à, non compris, le point spécifié par *x* et *y* (ou `point`).  
  
```  
BOOL LineTo(
    int x,  
    int y);  
  
BOOL LineTo(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point de terminaison de la ligne.  
  
 *y*  
 Spécifie la coordonnée y logique du point de terminaison de la ligne.  
  
 `point`  
 Spécifie le point de terminaison de la ligne. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la ligne est tracée ; sinon 0.  
  
### <a name="remarks"></a>Remarques  
 La ligne est dessinée avec le stylo sélectionné. La position actuelle est définie sur *x*, *y* ou `point`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).  
  
##  <a name="lptodp"></a>CDC::LPtoDP  
 Convertit des unités logiques en unités de périphérique.  
  
```  
void LPtoDP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de points. Chaque point dans le tableau est un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet.  
  
 `nCount`  
 Le nombre de points dans le tableau.  
  
 `lpRect`  
 Pointe vers une [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet. Ce paramètre est utilisé pour le cas courant de mappage d’un rectangle de logique d’unités de périphérique.  
  
 `lpSize`  
 Pointe vers une [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 La fonction mappe les coordonnées de chaque point, ou les dimensions de taille, à partir du système de coordonnées logiques du GDI dans un système de coordonnées de périphérique. La conversion dépend du mode de mappage en cours et les paramètres des origines et étendues de fenêtre et la fenêtre d’affichage du périphérique.  
  
 Les coordonnées x et y des points sont des entiers signés de 2 octets dans la plage – 32 768 et 32 767. Dans le cas où le mode de mappage entraînerait des valeurs supérieures à ces limites, le système définit les valeurs à – 32 768 et 32 767, respectivement.  
  
##  <a name="lptohimetric"></a>CDC::LPtoHIMETRIC  
 Appelez cette fonction pour convertir les unités logiques dans **HIMETRIC** unités.  
  
```  
void LPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpSize`  
 Pointe vers une **taille** structure ou un `CSize` objet.  
  
### <a name="remarks"></a>Remarques  
 Utilisez cette fonction lorsque vous donnez **HIMETRIC** tailles à OLE, la conversion du mode de mappage naturel de votre application. Notez que les étendues de fenêtre et la fenêtre d’affichage de l’appareil affecte le résultat.  
  
 La conversion est effectuée par la première conversion les unités logiques en pixels à l’aide des unités de mappage du contexte de périphérique en cours, puis en convertissant ces unités dans **HIMETRIC** unités.  
  
##  <a name="m_hattribdc"></a>CDC::m_hAttribDC  
 Le contexte de périphérique d’attribut pour cette `CDC` objet.  
  
```  
HDC m_hAttribDC;  
```  
  
### <a name="remarks"></a>Remarques  
 Par défaut, ce contexte de périphérique est égal à `m_hDC`. En général, `CDC` appels GDI qui demandent des informations à partir du contexte de périphérique sont dirigés vers `m_hAttribDC`. Consultez le [CDC](../../mfc/reference/cdc-class.md) description pour plus d’informations sur l’utilisation de ces contextes de deux périphérique de classe.  
  
##  <a name="m_hdc"></a>CDC::m_hDC  
 Le contexte de périphérique de sortie pour cette `CDC` objet.  
  
```  
HDC m_hDC;  
```  
  
### <a name="remarks"></a>Remarques  
 Par défaut, `m_hDC` est égal à `m_hAttribDC`, l’autre contexte de périphérique encapsulé par `CDC`. En général, `CDC` appels GDI que créer une sortie atteindre la `m_hDC` contexte de périphérique. Vous pouvez initialiser `m_hDC` et `m_hAttribDC` pour pointer vers des périphériques différents. Consultez le [CDC](../../mfc/reference/cdc-class.md) description pour plus d’informations sur l’utilisation de ces contextes de deux périphérique de classe.  
  
##  <a name="maskblt"></a>CDC::MaskBlt  
 Combine les données de couleur pour les bitmaps source et de destination à l’aide du masque donné et opération.  
  
```  
BOOL MaskBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle de destination.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle de destination.  
  
 `nWidth`  
 Spécifie la largeur, en unités logiques, de la bitmap de destination rectangle et source.  
  
 `nHeight`  
 Spécifie la hauteur, en unités logiques, de la bitmap de destination rectangle et source.  
  
 `pSrcDC`  
 Identifie le contexte de périphérique à partir duquel l’image bitmap doit être copiée. Il doit être égal à zéro si la *dwRop* paramètre spécifie une opération qui n’inclut pas d’une source.  
  
 `xSrc`  
 Spécifie la coordonnée x logique de l’angle supérieur gauche de la bitmap source.  
  
 `ySrc`  
 Spécifie la coordonnée y logique de l’angle supérieur gauche de la bitmap source.  
  
 `maskBitmap`  
 Identifie le bitmap masque monochrome combiné avec le bitmap de couleur dans le contexte du périphérique source.  
  
 `xMask`  
 Spécifie le décalage horizontal pixels du bitmap masque spécifié par le `maskBitmap` paramètre.  
  
 `yMask`  
 Spécifie le décalage vertical pixels du bitmap masque spécifié par le `maskBitmap` paramètre.  
  
 *dwRop*  
 Spécifie le premier plan et arrière-plan ternaire opération de rastérisation, dont la fonction utilise pour contrôler la combinaison de données source et de destination. Le code d’opération en arrière-plan raster est stocké dans l’octet de poids fort du mot haut de cette valeur ; le code d’opération raster au premier plan est stocké dans l’octet de poids faible du mot haut de cette valeur ; le mot de poids faible de cette valeur est ignorée et doit être égal à zéro. La macro **MAKEROP4** crée des codes d’opération raster ces combinaisons de premier plan et d’arrière-plan. Consultez la section Notes pour une discussion de premier plan et d’arrière-plan dans le cadre de cette fonction. Consultez le `BitBlt` fonction membre pour obtenir la liste des codes d’opération raster communs.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 La valeur 1 dans le masque spécifié par `maskBitmap` indique que le code d’opération de rastérisation premier plan spécifié par *dwRop* doit être appliqué à cet emplacement. La valeur 0 dans le masque indique que le code d’opération en arrière-plan raster spécifié par *dwRop* doit être appliqué à cet emplacement. Si les opérations de rastérisation nécessitent une source, le rectangle masque doit couvrir le rectangle source. Si elle n’est pas le cas, la fonction échoue. Si les opérations raster ne requièrent pas d’une source, le rectangle masque doit couvrir le rectangle de destination. Si elle n’est pas le cas, la fonction échoue.  
  
 Si une transformation de rotation ou inclinaison est en vigueur pour le contexte du périphérique source lorsque cette fonction est appelée, une erreur se produit. Toutefois, les autres types de transformations sont autorisés.  
  
 Si les formats de couleur de la source, modèle et les bitmaps de destination diffèrent, cette fonction convertit le modèle ou format source ou les deux, pour faire correspondre le format de destination. Si la bitmap masque n’est pas un bitmap monochrome, une erreur se produit. Lorsqu’un métafichier amélioré est en cours d’enregistrement, une erreur se produit (ou la fonction renvoie la valeur 0) si le contexte du périphérique source identifie un contexte de périphérique de métafichier amélioré. Tous les périphériques prennent en charge `MaskBlt`. Une application doit appeler `GetDeviceCaps` pour déterminer si un périphérique prend en charge cette fonction. Si aucune image bitmap masque n’est fourni, cette fonction se comporte exactement comme `BitBlt`, à l’aide du code d’opération de rastérisation au premier plan. Le pixel des décalages dans le mappage de bitmap masque au point (0,0) dans l’image bitmap du contexte du périphérique source. Cela est utile pour les cas dans lesquels une bitmap masque contient un ensemble de masques ; une application peut facilement appliquer l’un d'entre eux à une tâche de fusion de masque en ajustant les décalages de pixels et tailles de rectangle envoyées à `MaskBlt`.  
  
##  <a name="modifyworldtransform"></a>CDC::ModifyWorldTransform  
 Modifie la transformation universelle pour un contexte de périphérique en utilisant le mode spécifié.  
  
```  
BOOL ModifyWorldTransform(
    const XFORM& rXform,  
    DWORD iMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `rXform`  
 Référence à un [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) structure permet de modifier la transformation universelle pour le contexte de périphérique donné.  
  
 `iMode`  
 Spécifie comment les données de transformation modifie la transformation universelle en cours. Pour obtenir la liste des valeurs possibles de ce paramètre, consultez [ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060).  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne une valeur différente de zéro.  
  
 Retourne 0 en cas d’échec.  
  
 Pour obtenir des informations d’erreur étendu appeler [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Remarques  
 Cette méthode encapsule la fonction GDI de Windows [ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060).  
  
##  <a name="moveto"></a>CDC::MoveTo  
 Déplace la position actuelle du point spécifié par *x* et *y* (ou `point`).  
  
```  
CPoint MoveTo(
    int x,  
    int y);  
  
CPoint MoveTo(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du nouvel emplacement.  
  
 *y*  
 Spécifie la coordonnée y logique du nouvel emplacement.  
  
 `point`  
 Spécifie la nouvelle position. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Les coordonnées x et y de la position précédente comme un `CPoint` objet.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).  
  
##  <a name="offsetcliprgn"></a>CDC::OffsetClipRgn  
 Déplace la zone de découpage du contexte de périphérique en offsets spécifiés.  
  
```  
int OffsetClipRgn(
    int x,  
    int y);  
  
int OffsetClipRgn(SIZE size);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie le nombre d’unités logiques à déplacer vers la gauche ou la droite.  
  
 *y*  
 Spécifie le nombre d’unités logiques pour faire monter ou Descendre.  
  
 `size`  
 Spécifie la valeur d’offset.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de la nouvelle zone. Il peut être l’une des valeurs suivantes :  
  
- **COMPLEXREGION** zone de découpage a chevauchement des bordures.  
  
- **ERREUR** contexte de périphérique n’est pas valide.  
  
- **NULLREGION** zone de découpage est vide.  
  
- **SIMPLEREGION** zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 La fonction déplace la région *x* unités sur l’axe x et *y* unités sur l’axe des y.  
  
##  <a name="offsetviewportorg"></a>CDC::OffsetViewportOrg  
 Modifie les coordonnées de l’origine de la fenêtre d’affichage par rapport aux coordonnées de l’origine de la fenêtre d’affichage en cours.  
  
```  
virtual CPoint OffsetViewportOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Paramètres  
 `nWidth`  
 Spécifie le nombre d’unités de périphérique à ajouter à la coordonnée x de l’origine actuelle.  
  
 `nHeight`  
 Spécifie le nombre d’unités de périphérique à ajouter à la coordonnée y de l’origine actuelle.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de la fenêtre d’affichage précédente (dans les coordonnées de périphérique) comme un `CPoint` objet.  
  
##  <a name="offsetwindoworg"></a>CDC::OffsetWindowOrg  
 Modifie les coordonnées de l’origine de la fenêtre par rapport aux coordonnées de l’origine de la fenêtre en cours.  
  
```  
CPoint OffsetWindowOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Paramètres  
 `nWidth`  
 Spécifie le nombre d’unités logiques à ajouter à la coordonnée x de l’origine actuelle.  
  
 `nHeight`  
 Spécifie le nombre d’unités logiques à ajouter à la coordonnée y de l’origine actuelle.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de fenêtre précédente (en coordonnées logiques) comme un `CPoint` objet.  
  
##  <a name="operator_hdc"></a>CDC::operator HDC  
 Utilisez cet opérateur pour récupérer le handle de contexte de périphérique de la `CDC` objet.  
  
```  
operator HDC() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Si l’opération réussit, le handle de l’objet de contexte de périphérique. dans le cas contraire, **NULL**.  
  
### <a name="remarks"></a>Notes  
 Vous pouvez utiliser le handle pour appeler directement les API Windows.  
  
##  <a name="paintrgn"></a>CDC::PaintRgn  
 Remplit la zone spécifiée par `pRgn` à l’aide de la brosse courante.  
  
```  
BOOL PaintRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>Paramètres  
 `pRgn`  
 Identifie la région doit être remplie. Les coordonnées de la région donnée sont spécifiées en unités logiques.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="patblt"></a>CDC::PatBlt  
 Crée un modèle binaire sur le périphérique.  
  
```  
BOOL PatBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle qui doit recevoir le modèle.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle qui doit recevoir le modèle.  
  
 `nWidth`  
 Spécifie la largeur (en unités logiques) du rectangle qui doit recevoir le modèle.  
  
 `nHeight`  
 Spécifie la hauteur (en unités logiques) du rectangle qui doit recevoir le modèle.  
  
 *dwRop*  
 Spécifie le code d’opération de rastérisation. Codes d’opération de rastérisation (ROP) définissent la façon dont GDI associe les couleurs dans les opérations de sortie qui impliquent le pinceau actuel, un éventuel bitmap source et une image bitmap de destination. Ce paramètre peut être une des valeurs suivantes :  
  
- **PATCOPY** modèle de Copies de l’image bitmap de destination.  
  
- **PATINVERT** combine l’image bitmap de destination avec le modèle à l’aide de l’opérateur booléen XOR.  
  
- **DSTINVERT** inverse le bitmap de destination.  
  
- **BLACKNESS** désactive toutes les sorties noir.  
  
- **WHITENESS** désactive toutes les sorties blanc.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le modèle est une combinaison du pinceau sélectionné et le modèle déjà sur l’appareil. Le code d’opération de rastérisation spécifié par *dwRop* définit la façon dont les modèles doivent être combinées. Les opérations de rastérisation répertoriées pour cette fonction sont un sous-ensemble limité des codes d’opération de rastérisation ternaire 256 complète ; en particulier, un code d’opération de rastérisation qui fait référence à une source ne peut pas être utilisé.  
  
 Pas tous les contextes de périphérique prennent en charge la `PatBlt` (fonction). Pour déterminer si un contexte de périphérique prend en charge `PatBlt`, appelez le `GetDeviceCaps` fonction membre avec le **RASTERCAPS** indexer et rechercher la valeur de retour pour la **RC_BITBLT** indicateur.  
  
##  <a name="pie"></a>CDC::Pie  
 Dessine un secteur en dessinant un arc elliptique dont le centre et deux points de terminaison sont jointes par des lignes.  
  
```  
BOOL Pie(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x de l’angle supérieur gauche du rectangle englobant (en unités logiques).  
  
 `y1`  
 Spécifie la coordonnée y de l’angle supérieur gauche du rectangle englobant (en unités logiques).  
  
 `x2`  
 Spécifie la coordonnée x de l’angle inférieur droit du rectangle englobant (en unités logiques).  
  
 `y2`  
 Spécifie la coordonnée y du coin inférieur droit du rectangle englobant (en unités logiques).  
  
 *x3*  
 Spécifie la coordonnée x du point de départ de l’arc (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc.  
  
 `y3`  
 Spécifie la coordonnée y du point de départ de l’arc (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc.  
  
 `x4`  
 Spécifie la coordonnée x du point de terminaison de l’arc (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc.  
  
 `y4`  
 Spécifie la coordonnée y du point de terminaison de l’arc (en unités logiques). Ce point ne devra pas se situer exactement sur l’arc.  
  
 `lpRect`  
 Spécifie le rectangle englobant. Vous pouvez passer soit un `CRect` objet ou un pointeur vers un `RECT` structure pour ce paramètre.  
  
 `ptStart`  
 Spécifie le point de départ de l’arc. Ce point ne devra pas se situer exactement sur l’arc. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
 `ptEnd`  
 Spécifie le point de terminaison de l’arc. Ce point ne devra pas se situer exactement sur l’arc. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le centre de l’arc est le centre du rectangle englobant spécifié par `x1`, `y1`, `x2`, et `y2` (ou `lpRect`). Le début et fin de l’arc sont spécifiées par *x3*, `y3`, `x4`, et `y4` (ou par `ptStart` et `ptEnd`).  
  
 L’arc est dessiné avec le stylo sélectionné, dans une direction vers la gauche. Deux lignes supplémentaires sont dessinés au centre de l’arc chaque point de terminaison. La zone secteurs est remplie avec le pinceau actuel. Si *x3* est égal à `x4` et `y3` est égal à `y4`, il en résulte une ellipse avec une seule ligne à partir du centre de l’ellipse et le point ( *x3*, `y3`) ou ( `x4`, `y4`).  
  
 La figure dessinée par cette fonction s’étend jusqu'à mais n’inclut pas les coordonnées de droite et inférieure. Cela signifie que la hauteur de la figure est `y2` – `y1` et la largeur de la figure est `x2` – `x1`. La largeur et la hauteur du rectangle englobant doivent être supérieures à 2 unités et inférieure à 32 767.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView&#37;](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]  
  
##  <a name="playmetafile"></a>CDC::PlayMetaFile  
 Lit le contenu du métafichier spécifié sur le contexte de périphérique.  
  
```  
BOOL PlayMetaFile(HMETAFILE hMF);

 
BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,  
    LPCRECT lpBounds);
```  
  
### <a name="parameters"></a>Paramètres  
 *hMF*  
 Identifie le métafichier à jouer.  
  
 *hEnhMetaFile*  
 Identifie le métafichier amélioré.  
  
 `lpBounds`  
 Pointe vers une `RECT` structure ou un `CRect` objet qui contient les coordonnées du rectangle englobant utilisé pour afficher l’image. Les coordonnées sont spécifiées en unités logiques.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le métafichier peut être lu un nombre de fois.  
  
 La deuxième version de `PlayMetaFile` affiche l’image stockée dans le métafichier de format amélioré donné. Lorsqu’une application appelle la deuxième version de `PlayMetaFile`, Windows utilise l’image dans l’en-tête du métafichier amélioré pour mapper l’image sur le rectangle vers lequel pointé le `lpBounds` paramètre. (Cette image peut être inclinée ou pivotée en définissant la transformation universelle dans le périphérique de sortie avant d’appeler `PlayMetaFile`.) Points le long des bords du rectangle sont inclus dans l’image. Une image de métafichier amélioré peut être découpée en définissant la zone de découpage dans le périphérique de sortie avant de lire le métafichier amélioré.  
  
 Si un métafichier amélioré contient une palette facultatif, une application peut obtenir des couleurs cohérentes en définissant une palette de couleurs sur le périphérique de sortie avant d’appeler la deuxième version de `PlayMetaFile`. Pour récupérer la palette facultatif, utilisez le **GetEnhMetaFilePaletteEntries** fonction Windows. Un métafichier amélioré peut être incorporé dans un métafichier amélioré nouvellement créé en appelant la deuxième version de `PlayMetaFile` et lire le métafichier amélioré de source dans le contexte de périphérique pour le nouveau métafichier amélioré.  
  
 Les États du contexte de périphérique de sortie sont conservées par cette fonction. Tout objet créé mais ne pas dans le métafichier amélioré est supprimé par cette fonction. Pour arrêter cette fonction, une application peut appeler le **CancelDC** fonction Windows à partir d’un autre thread pour terminer l’opération. Dans ce cas, la fonction retourne zéro.  
  
##  <a name="plgblt"></a>CDC::PlgBlt  
 Effectue un transfert de bloc de bits des bits de données de couleur du rectangle spécifié dans le contexte du périphérique source au parallélogramme spécifié dans le contexte de périphérique donné.  
  
```  
BOOL PlgBlt(
    LPPOINT lpPoint,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nWidth,  
    int nHeight,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoint`  
 Pointe vers un tableau de trois points dans l’espace logique qui identifie les trois angles du parallélogramme de destination. Le coin supérieur gauche du rectangle source est mappé au premier point dans le coin inférieur gauche au troisième point, l’angle supérieur droit et le deuxième point dans ce tableau et ce tableau. Le coin inférieur droit du rectangle source est mappé au quatrième point dans un parallélogramme implicit.  
  
 `pSrcDC`  
 Identifie le contexte du périphérique source.  
  
 `xSrc`  
 Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle source.  
  
 `ySrc`  
 Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle source.  
  
 `nWidth`  
 Spécifie la largeur, en unités logiques, du rectangle source.  
  
 `nHeight`  
 Spécifie la hauteur, en unités logiques, du rectangle source.  
  
 `maskBitmap`  
 Identifie un bitmap monochrome facultatif qui permet de masquer les couleurs du rectangle source.  
  
 `xMask`  
 Spécifie la coordonnée x de l’angle supérieur gauche de la bitmap monochrome.  
  
 `yMask`  
 Spécifie la coordonnée y de l’angle supérieur gauche de la bitmap monochrome.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Si le handle du masque de bits donné identifie un bitmap monochrome valid, la fonction utilise ce bitmap pour masquer les bits des données de couleur du rectangle source.  
  
 La quatrième sommet du parallélogramme (D) est défini en traitant les trois premiers points (A, B et C) en tant que vecteurs et informatique D = B + C - A.  
  
 Si le masque de bits existe, la valeur 1 dans le masque indique que la couleur du pixel source doit être copiée vers la destination. La valeur 0 dans le masque indique que la couleur de pixel de destination doit ne pas être modifiée.  
  
 Si le rectangle de masque est plus petit que les rectangles de source et de destination, la fonction réplique le modèle de masque.  
  
 Les transformations de mise à l’échelle, translation et de réflexion sont autorisées dans le contexte du périphérique source ; Toutefois, les transformations de rotation et l’inclinaison ne sont pas. Si la bitmap masque n’est pas un bitmap monochrome, une erreur se produit. Le mode d’étirement du contexte de périphérique de destination est utilisé pour déterminer comment étirer ou compresser les pixels, si cela est nécessaire. Lorsqu’un métafichier amélioré est en cours d’enregistrement, une erreur se produit si le contexte du périphérique source identifie un contexte de périphérique de métafichier amélioré.  
  
 Les coordonnées de destination sont transformées en fonction du contexte du périphérique de destination ; les coordonnées sources sont transformées en fonction du contexte du périphérique source. Si la transformation source possède une rotation ou une inclinaison, une erreur est renvoyée. Si les rectangles de source et de destination n’ont pas le même format de couleur, `PlgBlt` convertit le rectangle source pour faire correspondre le rectangle de destination. Tous les périphériques prennent en charge `PlgBlt`. Pour plus d’informations, consultez la description de la **RC_BITBLT** fonctionnalité raster dans la `CDC::GetDeviceCaps` fonction membre.  
  
 Si les contextes de périphérique source et destination représentent des périphériques incompatibles, `PlgBlt` renvoie une erreur.  
  
##  <a name="polybezier"></a>CDC::PolyBezier  
 Dessine une ou plusieurs splines Bzier.  
  
```  
BOOL PolyBezier(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui contiennent les points de terminaison et les points de contrôle de la spline(s).  
  
 `nCount`  
 Spécifie le nombre de points dans le `lpPoints` tableau. Cette valeur doit être plus de trois fois le nombre de splines à dessiner, étant donné que chaque Bzier nécessitent deux points de contrôle et un point de terminaison et la première spline requiert un point de départ supplémentaire.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction dessine des splines Bzier cubiques en utilisant les points de terminaison et les points de contrôle spécifiés par le `lpPoints` paramètre. La première spline est dessinée du premier point au quatrième point à l’aide des deuxième et troisième points comme points de contrôle. Chaque courbe suivante dans la séquence doit exactement trois points supplémentaires : le point de fin de la précédente est utilisé comme point de départ, les deux points suivants dans la séquence sont des points de contrôle et le troisième est le point de terminaison.  
  
 La position actuelle n’est ni utilisée ni mis à jour par le `PolyBezier` (fonction). La figure n’est pas remplie. Cette fonction dessine des lignes en utilisant le stylet actuel.  
  
##  <a name="polybezierto"></a>CDC::PolyBezierTo  
 Dessine une ou plusieurs splines Bzier.  
  
```  
BOOL PolyBezierTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) pointe des structures de données qui contient les points de terminaison et le contrôle.  
  
 `nCount`  
 Spécifie le nombre de points dans le `lpPoints` tableau. Cette valeur doit être de trois fois le nombre de splines à dessiner, car chaque spline Bzier requiert deux points de contrôle et un point de terminaison.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction dessine des splines Bzier cubiques en utilisant les points de contrôle spécifiés par le `lpPoints` paramètre. La première spline est dessinée à partir de la position actuelle au troisième point en utilisant les deux premiers points comme points de contrôle. Pour chaque spline ultérieur, la fonction doit exactement trois points supplémentaires et utilise le point de fin de la précédente comme point de départ pour la prochaine. `PolyBezierTo`Déplace la position actuelle jusqu'à la fin de la dernière spline Bzier. La figure n’est pas remplie. Cette fonction dessine des lignes en utilisant le stylet actuel.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="polydraw"></a>CDC::PolyDraw  
 Dessine un ensemble de segments de ligne et Bzier splines.  
  
```  
BOOL PolyDraw(
    const POINT* lpPoints,  
    const BYTE* lpTypes,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui contient les points de terminaison pour chaque segment et les points de terminaison de ligne et de points pour chaque spline Bzier de contrôle.  
  
 `lpTypes`  
 Pointe vers un tableau qui spécifie la manière dont chaque point dans le `lpPoints` tableau est utilisé. Valeurs peuvent être les suivantes :  
  
- **PT_MOVETO** Spécifie que ce point démarre une figure distincte. Ce point devient la nouvelle position en cours.  
  
- **PT_LINETO** Spécifie qu’une ligne doit être dessiné à partir de la position actuelle à ce stade, qui devient alors la nouvelle position en cours.  
  
- **PT_BEZIERTO** Spécifie que ce point est un point de contrôle ou d’un point de fin d’une spline Bzier.  
  
 **PT_BEZIERTO** toujours se produire dans les ensembles de trois. La position actuelle définit le point de départ pour la spline Bzier. Les deux premières **PT_BEZIERTO** points sont les points de contrôle et le troisième **PT_BEZIERTO** est le point de fin. Le point de fin devient la nouvelle position en cours. S’il n’existe pas trois consécutifs **PT_BEZIERTO** points, une erreur se produit.  
  
     A **PT_LINETO** ou **PT_BEZIERTO** type peut être combiné avec la constante suivante à l’aide de l’opérateur de bits ou pour indiquer que le point correspondant est le dernier point dans une illustration et la figure est fermée :  
  
- **PT_CLOSEFIGURE** Spécifie que la figure est fermée automatiquement après le **PT_LINETO** ou **PT_BEZIERTO** le type de ce point est effectué. Une ligne est tracée à partir de ce point à la plus récente **PT_MOVETO** ou `MoveTo` point.  
  
     Cet indicateur est combiné avec le **PT_LINETO** type pour une ligne, ou avec la **PT_BEZIERTO** type de point de fin pour une spline Bzier, à l’aide de l’opérateur de bits `OR` opérateur. La position actuelle est définie pour le point de fin de la ligne de fermeture.  
  
 `nCount`  
 Spécifie le nombre total de points dans le `lpPoints` de tableau, le même que le nombre d’octets dans le `lpTypes` tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction peut être utilisée pour dessiner des figures disjointes à la place des appels successifs à `CDC::MoveTo`, `CDC::LineTo`, et `CDC::PolyBezierTo` les fonctions membres. Les lignes et splines sont dessinés avec le stylet actuel, et les chiffres ne sont pas remplis. Si un chemin d’accès actif lancée par l’appel est la `CDC::BeginPath` fonction membre, `PolyDraw` ajoute le chemin d’accès. Les points contenus dans le `lpPoints` tableau et dans `lpTypes` indiquer si chaque point fait partie d’un `CDC::MoveTo`, un `CDC::LineTo`, ou un **CDC::BezierTo** opération. Il est également possible de fermer des chiffres. Cette fonction met à jour la position actuelle.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="polygon"></a>CDC::Polygon  
 Dessine un polygone consistant en deux ou plusieurs points (sommets) reliés par des lignes, en utilisant le stylet actuel.  
  
```  
BOOL Polygon(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de points qui spécifie les sommets du polygone. Chaque point dans le tableau est un **POINT** structure ou un `CPoint` objet.  
  
 `nCount`  
 Spécifie le nombre de sommets dans le tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le système ferme le polygone automatiquement, si nécessaire, en dessinant une ligne à partir du dernier sommet au premier.  
  
 Le mode de remplissage de polygones actuel peut être récupéré ou défini à l’aide de la `GetPolyFillMode` et `SetPolyFillMode` les fonctions membres.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView&#38;](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]  
  
##  <a name="polyline"></a>CDC::Polyline  
 Dessine un ensemble de segments de ligne reliant les points spécifiés par `lpPoints`.  
  
```  
BOOL Polyline(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de **POINT** structures ou `CPoint` les objets d’être connecté.  
  
 `nCount`  
 Spécifie le nombre de points dans le tableau. Cette valeur doit être au moins 2.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Les lignes sont dessinées sur le premier point via les points suivants à l’aide du stylet actuel. Contrairement à la `LineTo` fonction membre, le `Polyline` fonction utilise ni mises à jour de la position actuelle.  
  
 Pour plus d’informations, consultez [polyligne](http://msdn.microsoft.com/library/windows/desktop/dd162815) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="polylineto"></a>CDC::PolylineTo  
 Dessine une ou plusieurs lignes droites.  
  
```  
BOOL PolylineTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui contient les sommets de la ligne.  
  
 `nCount`  
 Spécifie le nombre de points dans le tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Une ligne est tracée à partir de la position actuelle et le premier point spécifié par la `lpPoints` paramètre en utilisant le stylet actuel. Pour chaque ligne supplémentaire, la fonction de trace à partir du point de fin de la ligne précédente au point suivant spécifié par `lpPoints`. `PolylineTo`Déplace la position actuelle vers le point de fin de la dernière ligne. Si les segments de ligne dessinées par cette fonction forment une figure fermée, la figure n’est pas remplie.  
  
##  <a name="polypolygon"></a>CDC::PolyPolygon  
 Crée deux ou plusieurs polygones qui sont remplis à l’aide du mode de remplissage de polygones actuel.  
  
```  
BOOL PolyPolygon(
    LPPOINT lpPoints,  
    LPINT lpPolyCounts,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de **POINT** structures ou `CPoint` les objets qui définissent les sommets du polygone.  
  
 `lpPolyCounts`  
 Pointe vers un tableau d’entiers, chacun d’eux spécifie le nombre de points dans un des polygones dans le `lpPoints` tableau.  
  
 `nCount`  
 Le nombre d’entrées dans la `lpPolyCounts` tableau. Cette valeur spécifie le nombre de polygones à dessiner. Cette valeur doit être au moins 2.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Les polygones peuvent être disjoints ou qui se chevauchent.  
  
 Chaque polygone spécifié dans un appel à la `PolyPolygon` fonction doit être fermée. Contrairement aux polygones créés par le **polygone** fonction membre, les polygones créés par `PolyPolygon` ne sont pas fermés automatiquement.  
  
 La fonction crée deux ou plusieurs polygones. Pour créer un polygone simple, une application doit utiliser le **polygone** fonction membre.  
  
 Le mode de remplissage de polygones actuel peut être récupéré ou défini à l’aide de la `GetPolyFillMode` et `SetPolyFillMode` les fonctions membres.  
  
##  <a name="polypolyline"></a>CDC::PolyPolyline  
 Trace de plusieurs séries de segments de ligne connectés.  
  
```  
BOOL PolyPolyline(
    const POINT* lpPoints,  
    const DWORD* lpPolyPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de structures contenant les sommets des polylignes. Les polylignes sont définis comme étant consécutifs.  
  
 `lpPolyPoints`  
 Pointe vers un tableau de variables en spécifiant le nombre de points dans le `lpPoints` tableau pour le polygone correspondant. Chaque entrée doit être supérieure ou égale à 2.  
  
 `nCount`  
 Spécifie le nombre total des nombres dans les `lpPolyPoints` tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Les segments de ligne sont dessinées en utilisant le stylet actuel. Les figures formés par les segments ne sont pas remplies. La position actuelle n’est ni utilisée ni mis à jour par cette fonction.  
  
##  <a name="ptvisible"></a>CDC::PtVisible  
 Détermine si le point spécifié est dans la zone de découpage du contexte de périphérique.  
  
```  
virtual BOOL PtVisible(
    int x,  
    int y) const;  
  
BOOL PtVisible(POINT point) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point.  
  
 *y*  
 Spécifie la coordonnée y logique du point.  
  
 `point`  
 Spécifie le point de vérification en coordonnées logiques. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si le point spécifié dans la zone de découpage ; sinon 0.  
  
##  <a name="queryabort"></a>CDC::QueryAbort  
 Appelle la fonction abort installée par le [SetAbortProc](#setabortproc) fonction membre pour l’application d’impression et les requêtes si l’impression doit être arrêtée.  
  
```  
BOOL QueryAbort() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur de retour est différent de zéro si l’impression doit continuer ou s’il n’existe aucune procédure d’abandon. Il est 0 si le travail d’impression doit être arrêté. La valeur de retour est fournie par la fonction d’annulation.  
  
##  <a name="realizepalette"></a>CDC::RealizePalette  
 Mappe les entrées de la palette logique actuelle vers la palette système.  
  
```  
UINT RealizePalette();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Indique le nombre d’entrées dans la palette logique ont été mappé à des entrées différentes dans la palette du système. Cela représente le nombre d’entrées que cette fonction remappée pour tenir compte des changements dans la palette système depuis la dernière réalisation de la palette logique.  
  
### <a name="remarks"></a>Remarques  
 Une palette de couleurs logique agit comme un tampon entre applications gourmandes en couleur et le système, permettant à une application à utiliser comme nombre de couleurs en fonction des besoins sans interférer avec son propre affiche des couleurs ou avec les couleurs affichées par d’autres fenêtres.  
  
 Lorsqu’une fenêtre a le focus d’entrée et appelle `RealizePalette`, Windows garantit que la fenêtre affiche toutes les couleurs demandées, le nombre maximal disponible simultanément sur l’écran. Windows affiche également les couleurs introuvables dans la palette de la fenêtre en les comparant à des couleurs disponibles.  
  
 En outre, Windows met en correspondance les couleurs demandés par les fenêtres inactives qui appellent la fonction autant que possible pour les couleurs disponibles. Cela réduit considérablement les modifications indésirables dans les couleurs affichées dans les fenêtres inactives.  
  
##  <a name="rectangle"></a>CDC::rectangle  
 Dessine un rectangle en utilisant le stylet actuel.  
  
```  
BOOL Rectangle(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Rectangle(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x de l’angle supérieur gauche du rectangle (en unités logiques).  
  
 `y1`  
 Spécifie la coordonnée y de l’angle supérieur gauche du rectangle (en unités logiques).  
  
 `x2`  
 Spécifie la coordonnée x de l’angle inférieur droit du rectangle (en unités logiques).  
  
 `y2`  
 Spécifie la coordonnée y du coin inférieur droit du rectangle (en unités logiques).  
  
 `lpRect`  
 Spécifie le rectangle en unités logiques. Vous pouvez passer soit un `CRect` objet ou un pointeur vers un `RECT` structure pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 L’intérieur du rectangle est rempli à l’aide de la brosse courante.  
  
 Le rectangle s’étend jusqu'à, mais n’inclut pas les coordonnées de droite et inférieure. Cela signifie que la hauteur du rectangle est `y2` – `y1` et la largeur du rectangle est `x2` – `x1`. La largeur et la hauteur d’un rectangle doivent être supérieures à 2 unités et inférieure à 32 767.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView n °&39;](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]  
  
##  <a name="rectvisible"></a>CDC::RectVisible  
 Détermine si une partie du rectangle donné se trouve dans la zone de découpage du contexte d’affichage.  
  
```  
virtual BOOL RectVisible(LPCRECT lpRect) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers une `RECT` structure ou un `CRect` objet qui contient les coordonnées logiques du rectangle spécifié.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si une partie du rectangle donné se trouve dans la zone de découpage ; sinon 0.  
  
##  <a name="releaseattribdc"></a>CDC::ReleaseAttribDC  
 Appelez cette fonction membre pour définir `m_hAttribDC` à **NULL**.  
  
```  
virtual void ReleaseAttribDC();
```  
  
### <a name="remarks"></a>Remarques  
 Cela ne provoque pas une **détachement** se produise. Uniquement le contexte de périphérique de sortie est attaché à la `CDC` objet et il peuvent être détachée.  
  
##  <a name="releaseoutputdc"></a>CDC::ReleaseOutputDC  
 Appelez cette fonction membre pour définir le `m_hDC` membre **NULL**.  
  
```  
virtual void ReleaseOutputDC();
```  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre ne peut pas être appelée lorsque le contexte de périphérique de sortie est attaché à la `CDC` objet. Utilisez le **détachement** fonction membre pour détacher le contexte de périphérique de sortie.  
  
##  <a name="resetdc"></a>CDC::ResetDC  
 Appelez cette fonction membre pour mettre à jour le contexte de périphérique encapsulé par le `CDC` objet.  
  
```  
BOOL ResetDC(const DEVMODE* lpDevMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpDevMode*  
 Un pointeur vers un Windows `DEVMODE` structure.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique est mis à jour à partir des informations spécifiées dans les fenêtres `DEVMODE` structure. Cette fonction membre réinitialise uniquement le contexte de l’attribut.  
  
 Une application utilise généralement le `ResetDC` fonction membre lorsqu’une fenêtre traite un `WM_DEVMODECHANGE` message. Vous pouvez également utiliser cette fonction membre pour modifier l’orientation du papier ou le bac à papier lors de l’impression d’un document.  
  
 Vous ne pouvez pas utiliser cette fonction membre pour modifier le nom du pilote, le nom de périphérique ou port de sortie. Lorsque l’utilisateur modifie la connexion de port ou le nom du périphérique, vous devez supprimer le contexte de périphérique d’origine et créer un nouveau contexte de périphérique avec les nouvelles informations.  
  
 Avant d’appeler cette fonction membre, vous devez vous assurer que tous les objets qui avaient été sélectionnés dans le contexte de périphérique (autres que les objets de stock) ont été sélectionnés.  
  
##  <a name="restoredc"></a>CDC::RestoreDC  
 Restaure le contexte de périphérique à l’état précédent identifié par `nSavedDC`.  
  
```  
virtual BOOL RestoreDC(int nSavedDC);
```  
  
### <a name="parameters"></a>Paramètres  
 `nSavedDC`  
 Spécifie le contexte de périphérique à restaurer. Il peut être une valeur renvoyée par une précédente `SaveDC` appel de fonction. Si `nSavedDC` est –&1;, le dernier enregistré contexte de périphérique est restauré.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si le contexte spécifié a été restauré ; sinon 0.  
  
### <a name="remarks"></a>Notes  
 `RestoreDC`Restaure le contexte de périphérique en affichant les informations d’état d’une pile créée par les appels antérieurs à la `SaveDC` fonction membre.  
  
 La pile peut contenir des informations d’état pour plusieurs contextes de périphérique. Si le contexte spécifié par `nSavedDC` n’est pas en haut de la pile, `RestoreDC` supprime toutes les informations d’état entre le contexte de périphérique spécifié par `nSavedDC` et le haut de la pile. Les informations supprimées sont perdues.  
  
##  <a name="roundrect"></a>CDC::RoundRect  
 Dessine un rectangle à angles arrondis avec le stylet actuel.  
  
```  
BOOL RoundRect(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3);

 
BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x de l’angle supérieur gauche du rectangle (en unités logiques).  
  
 `y1`  
 Spécifie la coordonnée y de l’angle supérieur gauche du rectangle (en unités logiques).  
  
 `x2`  
 Spécifie la coordonnée x de l’angle inférieur droit du rectangle (en unités logiques).  
  
 `y2`  
 Spécifie la coordonnée y du coin inférieur droit du rectangle (en unités logiques).  
  
 *x3*  
 Spécifie la largeur de l’ellipse utilisée pour dessiner les angles arrondis (en unités logiques).  
  
 `y3`  
 Spécifie la hauteur de l’ellipse utilisée pour dessiner les angles arrondis (en unités logiques).  
  
 `lpRect`  
 Spécifie le rectangle englobant dans les unités logiques. Vous pouvez passer soit un `CRect` objet ou un pointeur vers un `RECT` structure pour ce paramètre.  
  
 `point`  
 La coordonnée x de `point` spécifie la largeur de l’ellipse pour dessiner les angles arrondis (en unités logiques). Coordonnée y de `point` spécifie la hauteur de l’ellipse pour dessiner les angles arrondis (en unités logiques). Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 L’intérieur du rectangle est rempli à l’aide de la brosse courante.  
  
 L’illustration de que cette fonction dessine étend jusqu'à mais n’inclut pas les coordonnées de droite et inférieure. Cela signifie que la hauteur de la figure est `y2` – `y1` et la largeur de la figure est `x2` – `x1`. La hauteur et la largeur du rectangle englobant doivent être supérieures à 2 unités et inférieure à 32 767.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView numéro&40;](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]  
  
##  <a name="savedc"></a>CDC::SaveDC  
 Enregistre l’état actuel du contexte de périphérique en copiant les informations d’état (par exemple, la zone de découpage, les objets sélectionnés et mode de mappage) dans une pile de contexte gérée par Windows.  
  
```  
virtual int SaveDC();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un entier qui identifie le contexte de périphérique enregistré. Il est 0 si une erreur se produit. Cela retourne la valeur peut être utilisée pour restaurer le contexte de périphérique en appelant `RestoreDC`.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique enregistré ultérieurement peut être restauré à l’aide de `RestoreDC`.  
  
 `SaveDC`peut être utilisée autant de fois pour enregistrer n’importe quel nombre d’états de contexte de périphérique.  
  
##  <a name="scaleviewportext"></a>CDC::ScaleViewportExt  
 Modifie l’étendue de la fenêtre d’affichage par rapport aux valeurs actuelles.  
  
```  
virtual CSize ScaleViewportExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>Paramètres  
 `xNum`  
 Spécifie le montant par lequel multiplier la x-étendue en cours.  
  
 `xDenom`  
 Spécifie la quantité par laquelle diviser le résultat de la multiplication de l’étendue de x actuel par la valeur de le `xNum` paramètre.  
  
 `yNum`  
 Spécifie le montant par lequel multiplier l’étendue y actuelle.  
  
 `yDenom`  
 Spécifie la quantité par laquelle diviser le résultat de la multiplication de l’étendue y actuelle par la valeur de le `yNum` paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Les étendues de la fenêtre d’affichage précédent (en unités de périphérique) comme un `CSize` objet.  
  
### <a name="remarks"></a>Notes  
 Les formules sont écrites comme suit :  
  
 `xNewVE = ( xOldVE * xNum ) / xDenom`  
  
 `yNewVE = ( yOldVE * yNum ) / yDenom`  
  
 Les nouvelles étendues de la fenêtre d’affichage sont calculées en multipliant l’étendue actuelle par le numérateur donné, puis en divisant par le dénominateur donné.  
  
##  <a name="scalewindowext"></a>CDC::ScaleWindowExt  
 Modifie l’étendue de la fenêtre par rapport aux valeurs actuelles.  
  
```  
virtual CSize ScaleWindowExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>Paramètres  
 `xNum`  
 Spécifie le montant par lequel multiplier la x-étendue en cours.  
  
 `xDenom`  
 Spécifie la quantité par laquelle diviser le résultat de la multiplication de l’étendue de x actuel par la valeur de le `xNum` paramètre.  
  
 `yNum`  
 Spécifie le montant par lequel multiplier l’étendue y actuelle.  
  
 `yDenom`  
 Spécifie la quantité par laquelle diviser le résultat de la multiplication de l’étendue y actuelle par la valeur de le `yNum` paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Les étendues de fenêtre précédente (en unités logiques) comme un `CSize` objet.  
  
### <a name="remarks"></a>Remarques  
 Les formules sont écrites comme suit :  
  
 `xNewWE = ( xOldWE * xNum ) / xDenom`  
  
 `yNewWE = ( yOldWE * yNum ) / yDenom`  
  
 Les nouvelles étendues de fenêtre sont calculées en multipliant l’étendue actuelle par le numérateur donné, puis en divisant par le dénominateur donné.  
  
##  <a name="scrolldc"></a>CDC::ScrollDC  
 Fait défiler un rectangle de bits horizontalement et verticalement.  
  
```  
BOOL ScrollDC(
    int dx,  
    int dy,  
    LPCRECT lpRectScroll,  
    LPCRECT lpRectClip,  
    CRgn* pRgnUpdate,  
    LPRECT lpRectUpdate);
```  
  
### <a name="parameters"></a>Paramètres  
 `dx`  
 Spécifie le nombre d’unités de défilement horizontale.  
  
 *dy*  
 Spécifie le nombre d’unités de défilement verticale.  
  
 `lpRectScroll`  
 Pointe vers le `RECT` structure ou `CRect` objet qui contient les coordonnées du rectangle de défilement.  
  
 `lpRectClip`  
 Pointe vers le `RECT` structure ou `CRect` objet qui contient les coordonnées du rectangle de découpage. Lorsque ce rectangle est plus petit que l’original une pointe vers `lpRectScroll`, le défilement se produit uniquement dans le plus petit rectangle.  
  
 `pRgnUpdate`  
 Identifie la région non traitée par le processus de défilement. Le `ScrollDC` fonction définit cette région ; il n’est pas nécessairement un rectangle.  
  
 `lpRectUpdate`  
 Pointe vers le `RECT` structure ou `CRect` objet qui reçoit les coordonnées du rectangle qui délimite la zone de mise à jour en mode de défilement. Il s’agit de la plus grande zone rectangulaire qui nécessite la mise à jour. Les valeurs de la structure ou l’objet lorsque la fonction retourne sont dans les coordonnées clientes, quel que soit le mode de mappage pour le contexte de périphérique donné.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si le défilement est exécuté ; sinon 0.  
  
### <a name="remarks"></a>Remarques  
 Si `lpRectUpdate` est **NULL**, Windows ne calcule pas le rectangle de mise à jour. Si les deux `pRgnUpdate` et `lpRectUpdate` sont **NULL**, Windows ne calcule pas la zone de mise à jour. Si `pRgnUpdate` n’est pas **NULL**, Windows part du principe qu’il contient un pointeur valide vers la région non traité par le processus de défilement (définie par le `ScrollDC` fonction membre). La zone de mise à jour renvoyées dans `lpRectUpdate` peut être passé à `CWnd::InvalidateRgn` si nécessaire.  
  
 Une application doit utiliser le `ScrollWindow` fonction membre de classe `CWnd` lorsqu’il est nécessaire de faire défiler la zone client entière d’une fenêtre. Dans le cas contraire, elle doit utiliser `ScrollDC`.  
  
##  <a name="selectclippath"></a>CDC::SelectClipPath  
 Sélectionne le chemin d’accès actuel comme une zone de découpage pour le contexte de périphérique, en combinant la nouvelle région avec n’importe quelle région de découpage existant en utilisant le mode spécifié.  
  
```  
BOOL SelectClipPath(int nMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `nMode`  
 Spécifie la façon d’utiliser le chemin d’accès. Les valeurs suivantes sont autorisées :  
  
- **RGN_AND** la nouvelle zone de découpage inclut l’intersection (chevauchement des zones) de la zone de découpage active et le chemin d’accès actuel.  
  
- **RGN_COPY** la nouvelle zone de découpage est le chemin d’accès actuel.  
  
- **RGN_DIFF** la nouvelle zone de découpage comprend les zones de la zone de découpage en cours et celles du chemin d’accès actuel sont exclus.  
  
- **RGN_OR** la nouvelle zone de découpage inclut l’union (zones combinées) de la zone de découpage active et le chemin d’accès actuel.  
  
- **RGN_XOR** la nouvelle zone de découpage inclut l’union de la zone de découpage active et le chemin d’accès actuel, sans les zones qui se chevauchent.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le contexte de périphérique identifié doit contenir une trajectoire fermée.  
  
##  <a name="selectcliprgn"></a>CDC::SelectClipRgn  
 Sélectionne la zone donnée en tant que la zone de découpage actuelle pour le contexte de périphérique.  
  
```  
int SelectClipRgn(CRgn* pRgn);

 
int SelectClipRgn(
    CRgn* pRgn,  
    int nMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `pRgn`  
 Identifie la région à sélectionner.  
  
-   Pour la première version de cette fonction, si cette valeur est **NULL**, toute la zone cliente est activée et sortie est toujours attachée à la fenêtre.  
  
-   Pour la deuxième version de cette fonction, ce handle peut être **NULL** uniquement lorsque le **RGN_COPY** mode est spécifié.  
  
 `nMode`  
 Spécifie l’opération à effectuer. Il doit être une des valeurs suivantes :  
  
- **RGN_AND** la nouvelle zone de découpage combine les zones qui se chevauchent de la zone de découpage active et la région identifiée par `pRgn`.  
  
- **RGN_COPY** la nouvelle zone de découpage est une copie de la région identifiée par `pRgn`. Il s’agit des fonctionnalités est identique à la première version de `SelectClipRgn`. Si la région identifiée par `pRgn` est **NULL**, la nouvelle zone de découpage est la zone de découpage par défaut (région null).  
  
- **RGN_DIFF** la nouvelle zone de découpage combine les zones de la zone de découpage active avec les zones exclus de la région identifiée par `pRgn`.  
  
- **RGN_OR** la nouvelle zone de découpage combine la zone de découpage active et la région identifiée par `pRgn`.  
  
- **RGN_XOR** la nouvelle zone de découpage combine la zone de découpage active et la région identifiée par `pRgn` mais exclut les zones qui se chevauchent.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de cette région. Il peut être une des valeurs suivantes :  
  
- **COMPLEXREGION** nouvelle zone de découpage a chevauchement des bordures.  
  
- **ERREUR** contexte de périphérique ou de la région n’est pas valide.  
  
- **NULLREGION** nouvelle zone de découpage est vide.  
  
- **SIMPLEREGION** nouvelle zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 Seule une copie de la région sélectionnée est utilisée. La zone elle-même peut être sélectionnée pour n’importe quel nombre d’autres contextes de périphérique, ou il peut être supprimé.  
  
 La fonction suppose que les coordonnées de la région donnée sont exprimées en unités de périphérique. Certains périphériques d’impression prend en charge la sortie de texte à une résolution supérieure à la sortie graphique afin de conserver la précision nécessaire pour exprimer des mesures de texte. Ces périphériques signalent des unités d’appareil à la résolution plus élevée, autrement dit, en unités de texte. Ces périphériques puis mettre à l’échelle les coordonnées des graphiques afin que plusieurs signalées périphérique unités carte uniquement 1 unité graphique. Vous devez toujours appeler la `SelectClipRgn` fonction à l’aide des unités de texte.  
  
 Les applications que doivent effectuer la mise à l’échelle d’objets graphiques dans GDI peuvent utiliser le **GETSCALINGFACTOR** échappement d’imprimante pour déterminer le facteur d’échelle. Ce facteur d’échelle affecte le découpage. Si une région est utilisée pour découper des graphiques, GDI divise les coordonnées par le facteur d’échelle. Si la région est utilisée pour découper le texte, GDI n’effectue aucun ajustement de mise à l’échelle. Un facteur d’échelle de 1 provoque les coordonnées à être divisé par 2. un facteur d’échelle de 2 entraîne les coordonnées à être divisé par 4 ; et ainsi de suite.  
  
##  <a name="selectobject"></a>CDC::SelectObject  
 Sélectionne un objet dans le contexte de périphérique.  
  
```  
CPen* SelectObject(CPen* pPen);  
CBrush* SelectObject(CBrush* pBrush);  
virtual CFont* SelectObject(CFont* pFont);  
CBitmap* SelectObject(CBitmap* pBitmap);  
int SelectObject(CRgn* pRgn);  
CGdiObject* SelectObject(CGdiObject* pObject);
```  
  
### <a name="parameters"></a>Paramètres  
 *pPen*  
 Un pointeur vers un [CPen](../../mfc/reference/cpen-class.md) objet à sélectionner.  
  
 `pBrush`  
 Un pointeur vers un [CBrush](../../mfc/reference/cbrush-class.md) objet à sélectionner.  
  
 `pFont`  
 Un pointeur vers un [CFont](../../mfc/reference/cfont-class.md) objet à sélectionner.  
  
 `pBitmap`  
 Un pointeur vers un [CBitmap](../../mfc/reference/cbitmap-class.md) objet à sélectionner.  
  
 `pRgn`  
 Un pointeur vers un [CRgn](../../mfc/reference/crgn-class.md) objet à sélectionner.  
  
 `pObject`  
 Un pointeur vers un [CGdiObject](../../mfc/reference/cgdiobject-class.md) objet à sélectionner.  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers l’objet remplacé. Il s’agit d’un pointeur vers un objet de l’une des classes dérivées de `CGdiObject`, tel que `CPen`, selon la version de la fonction est utilisée. La valeur de retour est **NULL** s’il existe une erreur. Cette fonction peut retourner un pointeur vers un objet temporaire. Cet objet temporaire est valid uniquement pendant le traitement d’un message Windows. Pour plus d'informations, consultez `CGdiObject::FromHandle`.  
  
 La version de la fonction membre qui accepte un paramètre de région effectue la même tâche que la `SelectClipRgn` fonction membre. Sa valeur de retour peut être une des opérations suivantes :  
  
- **COMPLEXREGION** nouvelle zone de découpage a chevauchement des bordures.  
  
- **ERREUR** contexte de périphérique ou de la région n’est pas valide.  
  
- **NULLREGION** nouvelle zone de découpage est vide.  
  
- **SIMPLEREGION** nouvelle zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 Classe `CDC` fournit cinq versions spécialisées pour des types particuliers d’objets GDI, y compris les stylets, pinceaux, polices, images bitmap et régions. L’objet qui vient d’être sélectionné remplace l’objet précédent du même type. Par exemple, si `pObject` de la version générale de `SelectObject` pointe vers un [CPen](../../mfc/reference/cpen-class.md) de l’objet, la fonction remplace le stylet actuel avec le stylet spécifié par `pObject`.  
  
 Une application peut sélectionner une image bitmap dans les contextes de périphérique de mémoire uniquement et dans le contexte de périphérique de mémoire qu’un seul à la fois. Le format de l’image bitmap doit être monochrome ou compatible avec le contexte de périphérique ; s’il n’est pas `SelectObject` renvoie une erreur.  
  
 Pour Windows 3.1 et versions ultérieures, le `SelectObject` fonction retourne la même valeur si elle est utilisée dans un métafichier ou non. Dans les versions antérieures de Windows, `SelectObject` retourné une valeur différente de zéro pour la réussite et échec 0 lorsqu’il a été utilisé dans un métafichier.  
  
##  <a name="selectpalette"></a>CDC::SelectPalette  
 Sélectionne la palette logique spécifié par `pPalette` en tant que l’objet palette sélectionnée du contexte de périphérique.  
  
```  
CPalette* SelectPalette(
    CPalette* pPalette,  
    BOOL bForceBackground);
```  
  
### <a name="parameters"></a>Paramètres  
 `pPalette`  
 Identifie la palette logique à être sélectionné. Cette palette doit avoir déjà été créée avec le `CPalette` fonction membre [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).  
  
 `bForceBackground`  
 Spécifie si la palette logique est forcée à une palette d’arrière-plan. Si `bForceBackground` est différent de zéro, la palette sélectionnée est toujours une palette d’arrière-plan, indépendamment de si la fenêtre a le focus d’entrée. Si `bForceBackground` est 0 et le contexte de périphérique est attaché à une fenêtre, la palette logique se trouve une palette de premier plan lorsque la fenêtre a le focus d’entrée.  
  
### <a name="return-value"></a>Valeur de retour  
 Un pointeur vers un `CPalette` objet identifiant la palette logique remplacée par la palette spécifiée par `pPalette`. Il est **NULL** s’il existe une erreur.  
  
### <a name="remarks"></a>Remarques  
 La nouvelle palette devienne l’objet de la palette utilisée par GDI pour le contrôle les couleurs affichées dans le contexte de périphérique et remplace la palette précédente.  
  
 Une application peut sélectionner une palette logique dans plusieurs contextes de périphérique. Toutefois, les modifications apportées à une palette logique affectera tous les contextes de périphérique pour lequel il est sélectionné. Si une application sélectionne une palette dans plus d’un contexte de périphérique, les contextes de périphérique doivent appartenir à la même unité physique.  
  
##  <a name="selectstockobject"></a>CDC::SelectStockObject  
 Sélectionne un [CGdiObject](../../mfc/reference/cgdiobject-class.md) objet qui correspond à l’un des stylets stocks prédéfinis, des formes ou des polices.  
  
```  
virtual CGdiObject* SelectStockObject(int nIndex);
```  
  
### <a name="parameters"></a>Paramètres  
 `nIndex`  
 Spécifie le type d’objet de stock souhaité. Il peut prendre l’une des valeurs suivantes :  
  
- **BLACK_BRUSH** noir pinceau.  
  
- **DKGRAY_BRUSH** pinceau gris foncé.  
  
- **GRAY_BRUSH** Gray pinceau.  
  
- **HOLLOW_BRUSH** creuse pinceau.  
  
- **LTGRAY_BRUSH** Light pinceau gris.  
  
- **NULL_BRUSH** Null pinceau.  
  
- **WHITE_BRUSH** blanc pinceau.  
  
- **BLACK_PEN** stylet noir.  
  
- **NULL_PEN** stylo de valeur Null.  
  
- **WHITE_PEN** Crayon blanc.  
  
- **ANSI_FIXED_FONT** police système fixe de ANSI.  
  
- **ANSI_VAR_FONT** police de variables système ANSI.  
  
- **DEVICE_DEFAULT_FONT** les polices dépendant du périphérique.  
  
- **OEM_FIXED_FONT** police fixé OEM dépendant.  
  
- **SYSTEM_FONT** la police système. Par défaut, Windows utilise la police système pour dessiner les menus, les contrôles de boîte de dialogue et tout autre texte. Toutefois, il est préférable, ne pas s’appuyer sur SYSTEM_FONT pour obtenir la police utilisée par windows et les boîtes de dialogue. Utilisez plutôt le `SystemParametersInfo` fonction avec le paramètre SPI_GETNONCLIENTMETRICS pour récupérer la police actuelle. `SystemParametersInfo`prend en compte le thème actuel et fournit des informations de police pour les légendes, les menus et boîtes de dialogue de message.  
  
- **SYSTEM_FIXED_FONT** la police à largeur fixe système utilisée dans Windows antérieures à la version 3.0. Cet objet est disponible pour la compatibilité avec les versions antérieures de Windows.  
  
- **DEFAULT_PALETTE** palette de couleurs par défaut. Cette palette contient 20 statiques couleurs dans la palette du système.  
  
### <a name="return-value"></a>Valeur de retour  
 Un pointeur vers le `CGdiObject` objet qui a été remplacé si la fonction réussit. L’objet réel désigné est un [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md), ou [CFont](../../mfc/reference/cfont-class.md) objet. Si l’appel échoue, la valeur de retour est **NULL**.  
  
##  <a name="setabortproc"></a>CDC::SETABORTPROC  
 Installe la procédure d’abandon pour le travail d’impression.  
  
```  
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```  
  
### <a name="parameters"></a>Paramètres  
 `lpfn`  
 Pointeur vers la fonction d’annulation à installer en tant que la procédure d’abandon. Pour plus d’informations sur la fonction de rappel, consultez [fonction de rappel pour CDC::SetAbortProc](../../mfc/reference/callback-function-for-cdc-setabortproc.md).  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le résultat de la `SetAbortProc` (fonction). Certaines des valeurs suivantes sont plus probables que d’autres, mais tous sont possibles.  
  
- **SP_ERROR** erreur générale.  
  
- **SP_OUTOFDISK** pas suffisamment d’espace disque est actuellement disponible pour la mise en attente, et davantage d’espace est disponible.  
  
- **SP_OUTOFMEMORY** pas assez de mémoire est disponible pour la mise en attente.  
  
- **SP_USERABORT** utilisateur s’est terminé le travail via le Gestionnaire d’impression.  
  
### <a name="remarks"></a>Remarques  
 Si une application doit autoriser le travail d’impression doit être annulée au cours de la mise en attente, il doit définir la fonction d’annulation avant de démarre le travail d’impression avec la [StartDoc](#startdoc) fonction membre. Le Gestionnaire d’impression appelle la fonction de l’abandon lors de la mise en attente pour permettre à l’application d’annuler le travail d’impression ou de traiter les conditions d’espace disque. Si aucune fonction d’annulation est définie, le travail d’impression échoue s’il n’est pas suffisamment d’espace disque pour la mise en attente.  
  
 Notez que les fonctionnalités de Microsoft Visual C++ simplifient la création de la fonction de rappel transmise à `SetAbortProc`. L’adresse passée à la `EnumObjects` la fonction membre est un pointeur vers une fonction exportée avec **__declspec (dllexport)** et avec le `__stdcall` convention d’appel.  
  
 Aussi inutile exporter le nom de fonction dans une **exportations** instruction dans le fichier de définition de module de votre application. Vous pouvez utiliser la **exporter** fonction modificateur, comme dans  
  
 **EXPORTATION de rappel BOOL** AFunction ( **HDC**, `int` **) ;**  
  
 Pour que le compilateur émet l’enregistrement d’exportation correcte pour l’exportation par nom sans alias. Cela fonctionne pour la plupart des besoins. Pour certains cas spéciaux, tels que l’exportation d’une fonction par ordinal ou alias de l’exportation, vous devez toujours utiliser un **exportations** instruction dans un fichier de définition de module.  
  
 Interfaces de l’inscription de rappel sont maintenant de type sécurisé (vous devez passer un pointeur de fonction qui pointe vers le bon type de fonction pour le rappel spécifique).  
  
 Notez également que toutes les fonctions de rappel doivent intercepter les exceptions de Microsoft Foundation avant de retourner à Windows, étant donné que les exceptions ne peuvent pas être levées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, consultez l’article [Exceptions](../../mfc/exception-handling-in-mfc.md).  
  
##  <a name="setarcdirection"></a>CDC::SetArcDirection  
 Définit le sens de dessin à utiliser pour les fonctions d’arc de cercle et rectangle.  
  
```  
int SetArcDirection(int nArcDirection);
```  
  
### <a name="parameters"></a>Paramètres  
 *nArcDirection*  
 Spécifie la nouvelle direction d’arc de cercle. Ce paramètre peut être une des valeurs suivantes :  
  
- **AD_COUNTERCLOCKWISE** chiffres dessinés dans le sens inverse.  
  
- **AD_CLOCKWISE** chiffres dessinés dans le sens horaire.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie la direction d’arc ancien, en cas de réussite ; sinon 0.  
  
### <a name="remarks"></a>Notes  
 La direction par défaut est vers la gauche. Le `SetArcDirection` fonction spécifie la direction dans laquelle les éléments suivants fonctionnement dessin :  
  
|Arc|Secteur|  
|---------|---------|  
|`ArcTo`|**Rectangle**|  
|`Chord`|`RoundRect`|  
|**Ellipse**||  
  
##  <a name="setattribdc"></a>CDC::SetAttribDC  
 Appelez cette fonction pour définir le contexte de périphérique d’attribut, `m_hAttribDC`.  
  
```  
virtual void SetAttribDC(HDC hDC);
```  
  
### <a name="parameters"></a>Paramètres  
 `hDC`  
 Un contexte de périphérique Windows.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre ne joint pas le contexte de périphérique pour le `CDC` objet. Uniquement le contexte de périphérique de sortie est attaché à un `CDC` objet.  
  
##  <a name="setbkcolor"></a>CDC::SetBkColor  
 Définit la couleur d’arrière-plan actuelle de la couleur spécifiée.  
  
```  
virtual COLORREF SetBkColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 `crColor`  
 Spécifie la couleur d’arrière-plan.  
  
### <a name="return-value"></a>Valeur de retour  
 La couleur d’arrière-plan précédente comme une valeur de couleur RVB. Si une erreur se produit, la valeur de retour est 0 x 80000000.  
  
### <a name="remarks"></a>Remarques  
 Si le mode d’arrière-plan est **OPAQUE**, le système utilise la couleur d’arrière-plan pour remplir les vides dans les lignes de styles, les intervalles entre les lignes hachurées de pinceaux et de l’arrière-plan dans les cellules de caractères. Le système utilise également la couleur d’arrière-plan lors de la conversion de bitmaps entre la couleur et les contextes de périphérique monochrome.  
  
 Si le périphérique ne peut pas afficher la couleur spécifiée, le système définit la couleur d’arrière-plan de la couleur physique le plus proche.  
  
##  <a name="setbkmode"></a>CDC::SetBkMode  
 Définit le mode d’arrière-plan.  
  
```  
int SetBkMode(int nBkMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *nBkMode*  
 Spécifie le mode à définir. Ce paramètre peut être une des valeurs suivantes :  
  
- **OPAQUE** en arrière-plan est rempli avec la couleur d’arrière-plan actuelle avant le texte, le pinceau hachuré, ou le stylet est dessiné. Il s’agit du mode d’arrière-plan par défaut.  
  
- **TRANSPARENT** en arrière-plan n’est pas modifié avant le dessin.  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode arrière-plan précédent.  
  
### <a name="remarks"></a>Notes  
 Le mode d’arrière-plan définit si le système supprime les couleurs d’arrière-plan sur la surface de dessin avant de dessiner du texte, des pinceaux hachurées ou n’importe quel style de stylet n’est pas une ligne pleine.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).  
  
##  <a name="setboundsrect"></a>CDC::SetBoundsRect  
 Contrôle l’accumulation des informations du rectangle englobant pour le contexte de périphérique spécifié.  
  
```  
UINT SetBoundsRect(
    LPCRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRectBounds`  
 Pointe vers une `RECT` structure ou `CRect` objet qui est utilisé pour définir le rectangle englobant. Dimensions du rectangle sont exprimées en coordonnées logiques. Ce paramètre peut être **NULL**.  
  
 `flags`  
 Spécifie comment le nouveau rectangle est combiné avec le rectangle cumulé. Ce paramètre peut être une combinaison des valeurs suivantes :  
  
- **DCB_ACCUMULATE** ajouter le rectangle spécifié par `lpRectBounds` au rectangle englobant (à l’aide d’une opération union de rectangle).  
  
- **DCB_DISABLE** désactiver accumulation de limites.  
  
- **DCB_ENABLE** activer accumulation de limites. (Le paramètre par défaut pour l’accumulation de limites est désactivé).  
  
### <a name="return-value"></a>Valeur de retour  
 L’état actuel du rectangle englobant, si la fonction réussit. Comme `flags`, la valeur de retour peut être une combinaison de **DCB_** valeurs :  
  
- **DCB_ACCUMULATE** le rectangle englobant n’est pas vide. Cette valeur sera toujours être définie.  
  
- **DCB_DISABLE** accumulation de limites est désactivée.  
  
- **DCB_ENABLE** accumulation de limites est activé.  
  
### <a name="remarks"></a>Notes  
 Windows peut maintenir un rectangle englobant pour toutes les opérations de dessin. Ce rectangle peut être interrogé et réinitialiser par l’application. Les limites de dessin sont utiles pour invalider le cache de bitmap.  
  
##  <a name="setbrushorg"></a>CDC::SetBrushOrg  
 Spécifie l’origine GDI affecte au pinceau suivant que l’application sélectionne dans le contexte de périphérique.  
  
```  
CPoint SetBrushOrg(
    int x,  
    int y);  
  
CPoint SetBrushOrg(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x (en unités de périphérique) de l’origine. Cette valeur doit être dans la plage 0-7.  
  
 *y*  
 Spécifie la coordonnée y (en unités de périphérique) de l’origine. Cette valeur doit être dans la plage 0-7.  
  
 `point`  
 Spécifie les coordonnées x et y de l’origine. Chaque valeur doit être dans la plage 0-7. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine précédente du pinceau en unités de périphérique.  
  
### <a name="remarks"></a>Remarques  
 La valeur par défaut des coordonnées de l’origine du pinceau sont (0, 0). Pour modifier l’origine d’un pinceau, appelez le `UnrealizeObject` fonctionner pour le `CBrush` de l’objet, appelez `SetBrushOrg`, puis appelez le `SelectObject` fonction membre pour sélectionner le pinceau dans le contexte de périphérique.  
  
 N’utilisez pas `SetBrushOrg` avec stock `CBrush` objets.  
  
##  <a name="setcoloradjustment"></a>CDC::SetColorAdjustment  
 Définit les valeurs de réglage des couleurs pour le contexte de périphérique en utilisant les valeurs spécifiées.  
  
```  
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpColorAdjust`  
 Pointe vers une [COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md) structure de données contenant les valeurs de réglage des couleurs.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Les valeurs de réglage des couleurs sont utilisées pour ajuster la couleur d’entrée de la bitmap source pour les appels à la `CDC::StretchBlt` fonction membre lorsque **demi-teintes** mode est défini.  
  
##  <a name="setdcbrushcolor"></a>CDC::SetDCBrushColor  
 Définit la couleur du pinceau périphérique (DC) de contexte actuel à la valeur de la couleur spécifiée.  
  
```  
COLORREF SetDCBrushColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 `crColor`  
 Spécifie la couleur du pinceau.  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour spécifie la couleur du pinceau précédente du contrôleur de domaine en tant qu’un `COLORREF` valeur.  
  
 Si la fonction échoue, la valeur de retour est `CLR_INVALID`.  
  
### <a name="remarks"></a>Notes  
 Cette méthode émule les fonctionnalités de la fonction [SetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd162969), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="setdcpencolor"></a>CDC::SetDCPenColor  
 Définit la couleur du stylet périphérique (DC) de contexte actuel à la valeur de la couleur spécifiée.  
  
```  
COLORREF SetDCPenColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 `crColor`  
 Spécifie la couleur du stylet.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre utilise la fonction Win32 [SetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd162970), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="setgraphicsmode"></a>CDC::SetGraphicsMode  
 Définit le mode de graphiques pour le contexte de périphérique spécifié.  
  
```  
int SetGraphicsMode(int iMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `iMode`  
 Spécifie le mode graphique. Pour obtenir la liste des valeurs possibles de ce paramètre, consultez [SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977).  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne l’ancien mode graphique.  
  
 Retourne 0 en cas d’échec. Pour obtenir des informations d’erreur étendu appeler [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Remarques  
 Cette méthode encapsule la fonction GDI de Windows [SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977).  
  
##  <a name="setlayout"></a>CDC::SetLayout  
 Appelez cette fonction membre pour modifier la disposition du texte et des graphiques pour un contexte de périphérique à droite à gauche, la mise en forme standard pour les cultures telles que l’arabe et l’hébreu.  
  
```  
DWORD SetLayout(DWORD dwLayout);
```  
  
### <a name="parameters"></a>Paramètres  
 `dwLayout`  
 Indicateurs de contrôle de disposition de contexte de périphérique et de bitmap. Il peut être une combinaison des valeurs suivantes.  
  
|Valeur|Signification|  
|-----------|-------------|  
|LAYOUT_BITMAPORIENTATIONPRESERVED|Désactive toute la réflexion pour les appels à [CDC::BitBlt](#bitblt) et [CDC::StretchBlt](#stretchblt).|  
|LAYOUT_RTL|Définit la disposition horizontale par défaut de droite à gauche.|  
|LAYOUT_LTR|Définit la disposition par défaut pour être de gauche à droite.|  
  
### <a name="return-value"></a>Valeur de retour  
 Si l’opération réussit, la mise en page précédente du contexte de périphérique.  
  
 En cas d’échec, **GDI_ERROR**. Pour obtenir des informations d’erreur étendu appeler [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Notes  
 Normalement, vous n’appelez pas **SetLayout** pour une fenêtre. Au lieu de cela, vous contrôlez la disposition de droite à gauche dans une fenêtre en définissant le [les styles de fenêtre étendus](../../mfc/reference/extended-window-styles.md) comme **WS_EX_RTLREADING**. Un contexte de périphérique, comme une imprimante ou un métafichier, n’hérite pas de cette disposition. La seule façon de définir le contexte de périphérique, une disposition de droite à gauche consiste à appeler **SetLayout**.  
  
 Si vous appelez **SetLayout (LAYOUT_RTL** ), **SetLayout** change automatiquement le mode de mappage à `MM_ISOTROPIC`. Par conséquent, un appel ultérieur à [GetMapMode](#getmapmode) retournera **MM_ISOTROPIC** au lieu de `MM_TEXT`.  
  
 Dans certains cas, comme avec nombreux bitmaps, vous souhaiterez peut-être conserver la disposition de gauche à droite. Dans ces cas, afficher l’image en appelant `BitBlt` ou `StretchBlt`, puis définissez l’indicateur de contrôle d’image bitmap pour `dwLayout` à **LAYOUT_BITMAPORIENTATIONPRESERVED**.  
  
 Une fois que vous modifiez la disposition avec le **LAYOUT_RTL** indicateur, indicateurs spécifiant normalement droite ou gauche sont inversés. Pour éviter toute confusion, vous souhaiterez sans doute définir d’autres noms pour les indicateurs standards. Pour une liste de noms de l’indicateur de remplacement suggérées, consultez [SetLayout](http://msdn.microsoft.com/library/windows/desktop/dd162979) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="setmapmode"></a>CDC::SetMapMode  
 Définit le mode de mappage.  
  
```  
virtual int SetMapMode(int nMapMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `nMapMode`  
 Spécifie le nouveau mode de mappage. Il peut être l’une des valeurs suivantes :  
  
- `MM_ANISOTROPIC`Les unités logiques sont converties en unités arbitraires des axes à l’échelle de façon arbitraire. Le mode de mappage `MM_ANISOTROPIC` ne modifie pas les paramètres de fenêtre ou fenêtre d’affichage en cours. Pour modifier les unités, l’orientation et la mise à l’échelle, appellent le [SetWindowExt](#setwindowext) et [SetViewportExt](#setviewportext) les fonctions membres.  
  
- `MM_HIENGLISH`Chaque unité logique est convertie en 0,001 pouce. X positive est vers la droite. y positif est.  
  
- `MM_HIMETRIC`Chaque unité logique est convertie en 0,01 millimètre. X positive est vers la droite. y positif est.  
  
- `MM_ISOTROPIC`Les unités logiques sont converties en unités arbitraires avec tout aussi des axes à l’échelle ; Autrement dit, 1 unité sur l’axe x est égale à 1 unité sur l’axe des y. Utilisez le `SetWindowExt` et `SetViewportExt` des fonctions membres pour spécifier les unités de votre choisies et l’orientation des axes. GDI ajuste que nécessaire pour garantir que les coordonnées x et y unités conservent la même taille.  
  
- `MM_LOENGLISH`Chaque unité logique est convertie en 0,01 pouce. X positive est vers la droite. y positif est.  
  
- `MM_LOMETRIC`Chaque unité logique est convertie en 0,1 millimètre. X positive est vers la droite. y positif est.  
  
- `MM_TEXT`Chaque unité logique est convertie en pixels de 1 périphérique. X positive est vers la droite. y positif est arrêté.  
  
- `MM_TWIPS`Chaque unité logique est convertie en 1/20 de point. (Un point étant 1/72 pouce, un twip est 1/1440 pouce). X positive est vers la droite. y positif est.  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de mappage précédent.  
  
### <a name="remarks"></a>Remarques  
 Le mode de mappage définit l’unité de mesure utilisée pour convertir les unités logiques en unités de périphérique ; Il définit également l’orientation de l’appareil x et y. GDI utilise le mode de mappage pour convertir les coordonnées logiques dans les coordonnées de périphériques appropriés. La `MM_TEXT` mode permet aux applications de fonctionner en pixels de périphérique, où 1 unité est égale à 1 pixel. La taille physique d’un pixel varie d’un périphérique à l’autre.  
  
 Le `MM_HIENGLISH`, `MM_HIMETRIC`, `MM_LOENGLISH`, `MM_LOMETRIC`, et `MM_TWIPS` modes sont utiles pour les applications qui doivent dessiner en unités physiquement explicites (par exemple, des pouces ou des millimètres). La `MM_ISOTROPIC` mode garantit des proportions de 1:1, ce qui est utile lorsqu’il est important de conserver la forme exacte d’une image. La `MM_ANISOTROPIC` mode permet les coordonnées x et y être ajustée de manière indépendante.  
  
> [!NOTE]
>  Si vous appelez [SetLayout](#setlayout) pour modifier le contrôleur de domaine (contexte de périphérique) à la disposition de droite à gauche, **SetLayout** change automatiquement le mode de mappage à `MM_ISOTROPIC`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setmapperflags"></a>CDC::SetMapperFlags  
 Modifie la méthode utilisée par le mappeur de polices lorsqu’elle convertit une police logique avec une police physique.  
  
```  
DWORD SetMapperFlags(DWORD dwFlag);
```  
  
### <a name="parameters"></a>Paramètres  
 `dwFlag`  
 Spécifie si le mappeur de polices tente de correspondre à la hauteur d’aspect de la police et la largeur à l’appareil. Lorsque cette valeur est **ASPECT_FILTERING**, le Mappeur sélectionne uniquement les polices dont aspect de x et y-aspect correspondent exactement à ceux de l’unité spécifiée.  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur précédente de l’indicateur de mappeur de police.  
  
### <a name="remarks"></a>Remarques  
 Une application peut utiliser `SetMapperFlags` pour provoquer le mappeur de polices tente de choisir uniquement une police physique qui correspond exactement à la proportion du périphérique.  
  
 Une application qui utilise uniquement les polices raster peut utiliser le `SetMapperFlags` (fonction) pour vous assurer que la police sélectionnée par le mappeur de polices est attrayante et lisible sur le périphérique spécifié. Les applications qui utilisent généralement des polices dimensionnables (TrueType) n’utilisent pas `SetMapperFlags`.  
  
 Si aucune police physique n’a un format d’image qui correspond à la spécification de la police logique, GDI choisit un ratio d’aspect et sélectionne une police qui correspond à ce nouveau rapport.  
  
##  <a name="setmiterlimit"></a>CDC::SetMiterLimit  
 Définit la limite de la longueur des jointures de pointe pour le contexte de périphérique.  
  
```  
BOOL SetMiterLimit(float fMiterLimit);
```  
  
### <a name="parameters"></a>Paramètres  
 *fMiterLimit*  
 Spécifie la nouvelle limite de pointe pour le contexte de périphérique.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 La longueur d’onglet est définie comme la distance entre l’intersection des parois de ligne à l’intérieur de la jointure et l’intersection des parois de ligne à l’extérieur de la jointure. La limite est le ratio maximal autorisé de la longueur d’onglet à la largeur de ligne. La limite de pointe par défaut est de 10,0.  
  
##  <a name="setoutputdc"></a>CDC::SetOutputDC  
 Appelez cette fonction membre pour définir le contexte de périphérique de sortie, `m_hDC`.  
  
```  
virtual void SetOutputDC(HDC hDC);
```  
  
### <a name="parameters"></a>Paramètres  
 `hDC`  
 Un contexte de périphérique Windows.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre peut uniquement être appelée lorsqu’un contexte de périphérique n’a pas été attaché à la `CDC` objet. Cette fonction membre définit `m_hDC` mais n’attache ne pas le contexte de périphérique pour le `CDC` objet.  
  
##  <a name="setpixel"></a>CDC::SetPixel  
 Définit le pixel au point spécifié à la plus proche de la couleur spécifiée par `crColor`.  
  
```  
COLORREF SetPixel(
    int x,  
    int y,  
    COLORREF crColor);

 
COLORREF SetPixel(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point à définir.  
  
 *y*  
 Spécifie la coordonnée y logique du point à définir.  
  
 `crColor`  
 A **COLORREF** valeur RVB qui spécifie la couleur utilisée pour peindre le point. Consultez la page [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour obtenir une description de cette valeur.  
  
 `point`  
 Spécifie la logique et y coordonnées x du point à définir. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur RVB de la couleur que le point est réellement peinte. Cette valeur peut être différente de celle spécifiée par `crColor` si une approximation de cette couleur est utilisée. Si la fonction échoue (si le point est en dehors de la zone de découpage), la valeur de retour est -1.  
  
### <a name="remarks"></a>Notes  
 Le point doit être dans la zone de découpage. Si le point n’est pas dans la zone de découpage, la fonction ne fait rien.  
  
 La fonction `SetPixel` n'est pas prise en charge par tous les périphériques. Pour déterminer si un périphérique prend en charge `SetPixel`, appelez le `GetDeviceCaps` fonction membre avec le **RASTERCAPS** indexer et rechercher la valeur de retour pour la **RC_BITBLT** indicateur.  
  
##  <a name="setpixelv"></a>CDC::SetPixelV  
 Définit le pixel situé aux coordonnées spécifiées pour l’approximation plus proche de la couleur spécifiée.  
  
```  
BOOL SetPixelV(
    int x,  
    int y,  
    COLORREF crColor);

 
BOOL SetPixelV(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x, en unités logiques, du point à définir.  
  
 *y*  
 Spécifie la coordonnée y, en unités logiques, du point à définir.  
  
 `crColor`  
 Spécifie la couleur à utiliser pour peindre le point.  
  
 `point`  
 Spécifie la logique et y coordonnées x du point à définir. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure de données ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le point doit être dans la zone de découpage et de la partie visible de la surface du périphérique. Tous les périphériques prennent en charge la fonction membre. Pour plus d’informations, consultez la **RC_BITBLT** fonctionnalité dans la `CDC::GetDeviceCaps` fonction membre. `SetPixelV`est plus rapide que `SetPixel` car il n’a pas besoin de retourner la valeur de couleur du point réellement peinte.  
  
##  <a name="setpolyfillmode"></a>CDC::SetPolyFillMode  
 Définit le mode de remplissage de polygones.  
  
```  
int SetPolyFillMode(int nPolyFillMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `nPolyFillMode`  
 Spécifie le nouveau mode de remplissage. Cette valeur peut être soit **autre** ou **enroulement**. Le mode par défaut dans Windows est **autre**.  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de remplissage précédent, si l’opération a réussi ; sinon 0.  
  
### <a name="remarks"></a>Remarques  
 Lorsque le mode de remplissage de polygone est **autre**, le système remplit la zone entre les côtés d’un polygone impaires et paires sur chaque ligne de numérisation. Autrement dit, le système remplit la zone entre le premier et le deuxième côté, entre le troisième et quatrième côté et ainsi de suite. Ce mode est la valeur par défaut.  
  
 Lorsque le mode de remplissage de polygone est **enroulement**, le système utilise la direction dans laquelle figure a été dessinée pour déterminer s’il faut remplir une zone. Chaque segment dans un polygone est dessiné dans un sens horaire ou aiguilles. Chaque fois qu’une ligne imaginaire dessinée à partir d’une zone fermée à l’extérieur d’une figure traverse un segment de ligne vers la droite, un compteur est incrémenté. Lorsque la ligne traverse un segment de ligne dans le sens inverse, le compteur est décrémenté. La zone est remplie si le nombre est différent de zéro lorsque la ligne atteint à l’extérieur de la figure.  
  
##  <a name="setrop2"></a>CDC::SetROP2  
 Définit le mode de dessin en cours.  
  
```  
int SetROP2(int nDrawMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `nDrawMode`  
 Spécifie le nouveau mode de dessin. Il peut être une des valeurs suivantes :  
  
- **R2_BLACK** Pixel est toujours noir.  
  
- **R2_WHITE** Pixel est toujours blanc.  
  
- **R2_NOP** Pixel demeure inchangé.  
  
- **R2_NOT** Pixel est l’inverse de la couleur de l’écran.  
  
- **R2_COPYPEN** Pixel est la couleur du stylet.  
  
- **R2_NOTCOPYPEN** Pixel est l’inverse de la couleur du stylet.  
  
- **R2_MERGEPENNOT** Pixel est une combinaison de la couleur du stylet et l’inverse de la couleur de l’écran (pixel final = (pas pixel d’écran) ou de stylet).  
  
- **R2_MASKPENNOT** Pixel est une combinaison des couleurs communes pour le stylet et l’inverse de l’écran (pixel final = (pas pixel d’écran) et du stylet).  
  
- **R2_MERGENOTPEN** Pixel est une combinaison de la couleur de l’écran et à l’inverse de la couleur du stylet (pixel final = (non stylet) ou en pixels de l’écran).  
  
- **R2_MASKNOTPEN** Pixel est une combinaison des couleurs communes à l’écran et à l’inverse du stylet (pixel final = (non stylet) et le pixel de l’écran).  
  
- **R2_MERGEPEN** Pixel est une combinaison de la couleur du stylet et la couleur de l’écran (pixel final = pixel d’écran ou de stylet).  
  
- **R2_NOTMERGEPEN** Pixel est l’inverse de la **R2_MERGEPEN** couleur (pixel final = non (pixel d’écran ou de stylet)).  
  
- **R2_MASKPEN** Pixel est une combinaison des couleurs communes au crayon et à l’écran (pixel final = pen AND pixel d’écran).  
  
- **R2_NOTMASKPEN** Pixel est l’inverse de la **R2_MASKPEN** couleur (pixel final = non (pen AND pixel d’écran)).  
  
- **R2_XORPEN** Pixel est une combinaison de couleurs dans le stylet ou dans l’écran, mais pas dans les deux (pixel final = stylet XOR écran pixel).  
  
- **R2_NOTXORPEN** Pixel est l’inverse de la **R2_XORPEN** couleur (pixel final = non (pixel d’écran stylet XOR)).  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de dessin précédent.  
  
 Il peut être une des valeurs fournies dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
### <a name="remarks"></a>Notes  
 Le mode de dessin spécifie comment les couleurs du stylet et l’intérieur d’objets sont combinées avec la couleur déjà sur la surface d’affichage.  
  
 Le mode de dessin est pour les périphériques de rastérisation uniquement ; Il ne s’applique pas aux appareils de vecteur. Modes de dessin sont des codes d’opération de rastérisation binaire qui représente toutes les combinaisons booléennes de deux variables, à l’aide des opérateurs binaires AND, OR et XOR (ou exclusif) et l’opération unaire ne pas.  
  
##  <a name="setstretchbltmode"></a>CDC::SetStretchBltMode  
 Définit le mode d’étirement de bitmap pour les `StretchBlt` fonction membre.  
  
```  
int SetStretchBltMode(int nStretchMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *nStretchMode*  
 Spécifie le mode d’étirement. Il peut être une des valeurs suivantes :  
  
|Valeur|Description|  
|-----------|-----------------|  
|**BLACKONWHITE**|Effectue une opération booléenne et utilisant les valeurs de couleur des pixels élimination et existants. Si la bitmap est un bitmap monochrome, ce mode préserve les pixels noirs au détriment des pixels blancs.|  
|**COLORONCOLOR**|Supprime les pixels. Ce mode supprime éliminés toutes les lignes de pixels sans essayer de préserver leurs informations.|  
|**DEMI-TEINTES**|Mappe les pixels du rectangle source en blocs de pixels dans le rectangle de destination. La couleur moyenne sur le bloc de destination de pixels est une approximation de la couleur des pixels de la source.|  
||Après avoir défini le **demi-teintes** mode d’étirement, une application doit appeler la fonction Win32 [SetBrushOrgEx](http://msdn.microsoft.com/library/windows/desktop/dd162967) pour définir l’origine du pinceau. En cas d’échec pour ce faire, pinceau alignement se produit.|  
|**STRETCH_ANDSCANS**|**Windows 95/98**: identique à **BLACKONWHITE**|  
|**STRETCH_DELETESCANS**|**Windows 95/98**: identique à **COLORONCOLOR**|  
|**STRETCH_HALFTONE**|**Windows 95/98**: identique à **demi-teintes**.|  
|**STRETCH_ORSCANS**|**Windows 95/98**: identique à **WHITEONBLACK**|  
|**WHITEONBLACK**|Effectue une opération booléenne ou utilisant les valeurs de couleur des pixels élimination et existants. Si la bitmap est un bitmap monochrome, ce mode préserve les pixels blancs au détriment des pixels noirs.|  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode d’étirement précédent. Il peut être **STRETCH_ANDSCANS**, **STRETCH_DELETESCANS**, ou **STRETCH_ORSCANS**.  
  
### <a name="remarks"></a>Remarques  
 Le mode d’étirement de bitmap définit comment les informations sont supprimées de bitmaps qui sont compressées à l’aide de la fonction.  
  
 Le **BLACKONWHITE** ( **STRETCH_ANDSCANS**) et **WHITEONBLACK** ( **STRETCH_ORSCANS**) modes sont généralement utilisés pour préserver des pixels de premier plan dans les images bitmap monochromes. Le **COLORONCOLOR** ( **STRETCH_DELETESCANS**) en mode est généralement utilisé pour conserver les couleurs dans les images bitmap de couleur.  
  
 Le **demi-teintes** mode nécessite davantage de traitement de l’image source que les trois autres modes ; il est plus lent que les autres, mais génère des images de qualité supérieure. Notez également que **SetBrushOrgEx** doit être appelée après avoir défini le **demi-teintes** mode pour éviter un mauvais alignement du pinceau.  
  
 Modes d’étirement supplémentaires peuvent également être disponibles en fonction des capacités du pilote de périphérique.  
  
##  <a name="settextalign"></a>CDC::SetTextAlign  
 Définit les indicateurs d’alignement de texte.  
  
```  
UINT SetTextAlign(UINT nFlags);
```  
  
### <a name="parameters"></a>Paramètres  
 `nFlags`  
 Spécifie des indicateurs de l’alignement de texte. Les indicateurs spécifient la relation entre un point et un rectangle qui englobe le texte. Le point peut être soit la position actuelle ou les coordonnées spécifiées par une fonction de sortie de texte. Le rectangle qui englobe le texte est défini par les cellules adjacentes caractère dans la chaîne de texte. Le `nFlags` paramètre peut être un ou plusieurs indicateurs à partir de le des trois catégories suivantes. Choisir qu’un seul indicateur de chaque catégorie. La première catégorie affecte l’alignement du texte dans la direction x :  
  
- **TA_CENTER** aligne le point avec le Centre horizontal du rectangle englobant.  
  
- **TA_LEFT** aligne le point sur le côté gauche du rectangle englobant. Il s'agit du paramètre par défaut.  
  
- **TA_RIGHT** aligne le point avec le côté droit du rectangle englobant.  
  
 La seconde catégorie affecte l’alignement du texte dans la direction y :  
  
- **TA_BASELINE** aligne le point avec la ligne de base de la police choisie.  
  
- **TA_BOTTOM** aligne le point de la partie inférieure du rectangle englobant.  
  
- **TA_TOP** aligne le point de début du rectangle englobant. Il s'agit du paramètre par défaut.  
  
 La troisième catégorie détermine si la position actuelle est mise à jour lorsque le texte est écrit :  
  
- **TA_NOUPDATECP** ne met pas à jour la position actuelle après chaque appel à une fonction de sortie de texte. Il s'agit du paramètre par défaut.  
  
- **TA_UPDATECP** met à jour la position x actuelle après chaque appel à une fonction de sortie de texte. La nouvelle position est sur le côté droit du rectangle englobant pour le texte. Lorsque cet indicateur est défini, les coordonnées spécifiées dans les appels à la `TextOut` fonction membre sont ignorés.  
  
### <a name="return-value"></a>Valeur de retour  
 L’alignement de texte paramètre précédent, si l’opération réussit. L’octet de poids faible contienne le paramètre horizontal et l’octet de poids fort du paramètre vertical. sinon 0.  
  
### <a name="remarks"></a>Remarques  
 Le `TextOut` et `ExtTextOut` fonctions membres utilisent ces indicateurs lors du positionnement d’une chaîne de texte sur un périphérique ou un affichage. Les indicateurs spécifient la relation entre un point spécifique et un rectangle qui englobe le texte. Les coordonnées de ce point sont passées comme paramètres à la `TextOut` fonction membre. Le rectangle qui englobe le texte est formé par les cellules adjacentes caractère dans la chaîne de texte.  
  
##  <a name="settextcharacterextra"></a>CDC::SetTextCharacterExtra  
 Définit l’espacement entre les caractères.  
  
```  
int SetTextCharacterExtra(int nCharExtra);
```  
  
### <a name="parameters"></a>Paramètres  
 `nCharExtra`  
 Spécifie la quantité d’espace supplémentaire (en unités logiques) pour être ajouté à chaque caractère. Si le mode de mappage en cours n’est pas `MM_TEXT`, `nCharExtra` est transformé et arrondi au pixel près.  
  
### <a name="return-value"></a>Valeur de retour  
 La quantité de l’espacement entre les caractères précédent.  
  
### <a name="remarks"></a>Remarques  
 GDI ajoute cet espacement à chaque caractère, y compris les caractères de saut, lorsqu’il écrit une ligne de texte dans le contexte de périphérique. La valeur par défaut pour la quantité de l’espacement est 0.  
  
##  <a name="settextcolor"></a>CDC::SetTextColor  
 Définit la couleur du texte avec la couleur spécifiée.  
  
```  
virtual COLORREF SetTextColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 `crColor`  
 Spécifie la couleur du texte avec une valeur de couleur RVB.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur RVB de la couleur du texte précédent.  
  
### <a name="remarks"></a>Remarques  
 Le système utilisera cette couleur de texte lors de l’écriture de texte dans ce contexte de périphérique et également lorsque les bitmaps de conversion entre les couleurs et les contextes de périphérique monochrome.  
  
 Si le périphérique ne peut pas représenter la couleur spécifiée, le système définit la couleur du texte sur la couleur physique le plus proche. La couleur d’arrière-plan pour un caractère spécifiée par le `SetBkColor` et `SetBkMode` les fonctions membres.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).  
  
##  <a name="settextjustification"></a>CDC::SetTextJustification  
 Ajoute un espace pour les caractères de saut dans une chaîne.  
  
```  
int SetTextJustification(
    int nBreakExtra,  
    int nBreakCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `nBreakExtra`  
 Spécifie l’espace total supplémentaire à ajouter à la ligne de texte (en unités logiques). Si le mode de mappage en cours n’est pas `MM_TEXT`, la valeur indiquée par ce paramètre est convertie vers le mode de mappage actuel et arrondie à l’unité de périphérique le plus proche.  
  
 *nBreakCount*  
 Spécifie le nombre de caractères de saut de la ligne.  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit ; sinon 0.  
  
### <a name="remarks"></a>Notes  
 Une application peut utiliser la `GetTextMetrics` des fonctions membres pour extraire la police rompre des caractères.  
  
 Après le `SetTextJustification` la fonction membre est appelée, un appel à une fonction de sortie de texte (tel que `TextOut`) répartit l’espace supplémentaire spécifié uniformément entre le nombre spécifié de caractères de saut. Le caractère de saut est généralement le caractère espace (ASCII 32), mais peut être défini par une police en tant que d’autres caractères.  
  
 La fonction membre `GetTextExtent` est généralement utilisée avec `SetTextJustification`. `GetTextExtent`calcule la largeur d’une ligne donnée avant d’alignement. Une application peut déterminer la quantité d’espace pour spécifier dans le `nBreakExtra` paramètre en soustrayant la valeur retournée par `GetTextExtent` de la largeur de la chaîne située après alignement.  
  
 Le `SetTextJustification` fonction peut être utilisée pour aligner une ligne qui contient plusieurs séries de tests dans des polices. Dans ce cas, la ligne doit être créée fragmentaire l’alignement et l’écriture de chaque série séparément.  
  
 Étant donné que les erreurs d’arrondi peuvent se produire pendant l’alignement, le système conserve un terme d’erreur en cours d’exécution qui définit l’erreur actuelle. Lors de l’alignement d’une ligne qui contient plusieurs séries, `GetTextExtent` utilise automatiquement ce terme d’erreur lorsqu’il calcule l’étendue de la prochaine exécution. Ainsi, la fonction de sortie de texte fusionner l’erreur dans l’exécution de nouveau.  
  
 Une fois que chaque ligne a été aligné, ce terme d’erreur doit être désactivé pour l’empêcher d’être incorporées dans la ligne suivante. Le terme peut être supprimé en appelant `SetTextJustification` avec `nBreakExtra` défini sur 0.  
  
##  <a name="setviewportext"></a>CDC::SetViewportExt  
 Définit les extensions x et y de la fenêtre d’affichage du contexte de périphérique.  
  
```  
virtual CSize SetViewportExt(
    int cx,  
    int cy);  
  
CSize SetViewportExt(SIZE size);
```  
  
### <a name="parameters"></a>Paramètres  
 `cx`  
 Spécifie l’étendue x de la fenêtre d’affichage (en unités de périphérique).  
  
 `cy`  
 Spécifie l’étendue y de la fenêtre d’affichage (en unités de périphérique).  
  
 `size`  
 Spécifie les extensions x et y de la fenêtre d’affichage (en unités de périphérique).  
  
### <a name="return-value"></a>Valeur de retour  
 L’étendue précédente de la fenêtre d’affichage comme un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet. Lorsqu’une erreur se produit, les coordonnées x et y de retourné `CSize` de l’objet sont toutes deux définies sur 0.  
  
### <a name="remarks"></a>Remarques  
 La fenêtre d’affichage, ainsi que la fenêtre de contexte de périphérique définit comment GDI mappe les points dans le système de coordonnées logiques à points dans le système de coordonnées de l’appareil. En d’autres termes, elles définissent la façon dont GDI convertit les coordonnées logiques en coordonnées de périphérique.  
  
 Lorsque les modes de mappage suivants sont définis, les appels à `SetWindowExt` et `SetViewportExt` sont ignorés :  
  
|MM_HIENGLISH|MM_LOMETRIC|  
|-------------------|------------------|  
|`MM_HIMETRIC`|`MM_TEXT`|  
|`MM_LOENGLISH`|`MM_TWIPS`|  
  
 Lors de la `MM_ISOTROPIC` mode est défini, une application doit appeler la `SetWindowExt` fonction membre avant d’appeler `SetViewportExt`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setviewportorg"></a>CDC::SetViewportOrg  
 Définit l’origine de la fenêtre d’affichage du contexte de périphérique.  
  
```  
virtual CPoint SetViewportOrg(
    int x,  
    int y);  
  
CPoint SetViewportOrg(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x (en unités de périphérique) de l’origine de la fenêtre d’affichage. La valeur doit être dans la plage du système de coordonnées de périphérique.  
  
 *y*  
 Spécifie la coordonnée y (en unités de périphérique) de l’origine de la fenêtre d’affichage. La valeur doit être dans la plage du système de coordonnées de périphérique.  
  
 `point`  
 Spécifie l’origine de la fenêtre d’affichage. Les valeurs doivent être dans la plage du système de coordonnées de périphérique. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine précédent de la fenêtre d’affichage (dans les coordonnées de périphérique) comme un `CPoint` objet.  
  
### <a name="remarks"></a>Remarques  
 La fenêtre d’affichage, ainsi que la fenêtre de contexte de périphérique définit comment GDI mappe les points dans le système de coordonnées logiques à points dans le système de coordonnées de l’appareil. En d’autres termes, elles définissent la façon dont GDI convertit les coordonnées logiques en coordonnées de périphérique.  
  
 L’origine de la fenêtre d’affichage marque le point dans le système de coordonnées de périphérique à laquelle GDI est mappé à l’origine de la fenêtre, un point dans le système de coordonnées logiques spécifié par le **SetWindowOrg** fonction membre. GDI mappe tous les autres points en suivant la procédure requise pour mapper l’origine de la fenêtre à l’origine de la fenêtre d’affichage. Par exemple, tous les points d’un cercle autour du point à l’origine de la fenêtre sera dans un cercle autour du point à l’origine de la fenêtre d’affichage. De même, tous les points d’une ligne qui passe par l’origine de la fenêtre sera dans une ligne qui passe par l’origine de la fenêtre d’affichage.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setwindowext"></a>CDC::SetWindowExt  
 Définit les extensions x et y de la fenêtre associée au contexte de périphérique.  
  
```  
virtual CSize SetWindowExt(
    int cx,  
    int cy);  
  
CSize SetWindowExt(SIZE size);
```  
  
### <a name="parameters"></a>Paramètres  
 `cx`  
 Spécifie l’étendue-x (en unités logiques) de la fenêtre.  
  
 `cy`  
 Spécifie l’étendue-y (en unités logiques) de la fenêtre.  
  
 `size`  
 Spécifie les x - et y-étendues (unités logiques) de la fenêtre.  
  
### <a name="return-value"></a>Valeur de retour  
 L’étendue précédente de la fenêtre (en unités logiques) en tant qu’un `CSize` objet. Si une erreur se produit, les coordonnées x et y de retourné `CSize` de l’objet sont toutes deux définies sur 0.  
  
### <a name="remarks"></a>Notes  
 La fenêtre, ainsi que la fenêtre d’affichage du contexte de périphérique, définit comment GDI mappe les points dans le système de coordonnées logiques à points dans le système de coordonnées de périphérique.  
  
 Lorsque les modes de mappage suivants sont définis, les appels à `SetWindowExt` et `SetViewportExt` fonctions sont ignorées :  
  
- `MM_HIENGLISH`  
  
- `MM_HIMETRIC`  
  
- `MM_LOENGLISH`  
  
- `MM_LOMETRIC`  
  
- `MM_TEXT`  
  
- `MM_TWIPS`  
  
 Lors de la `MM_ISOTROPIC` mode est défini, une application doit appeler la `SetWindowExt` fonction membre avant d’appeler `SetViewportExt`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setwindoworg"></a>CDC::SetWindowOrg  
 Définit l’origine de la fenêtre du contexte de périphérique.  
  
```  
CPoint SetWindowOrg(
    int x,  
    int y);  
  
CPoint SetWindowOrg(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’origine de la fenêtre.  
  
 *y*  
 Spécifie la coordonnée y logique de l’origine de la fenêtre.  
  
 `point`  
 Spécifie les coordonnées logiques de l’origine de la fenêtre. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de la fenêtre précédente un `CPoint` objet.  
  
### <a name="remarks"></a>Remarques  
 La fenêtre, ainsi que la fenêtre d’affichage du contexte de périphérique, définit comment GDI mappe les points dans le système de coordonnées logiques à points dans le système de coordonnées de périphérique.  
  
 L’origine de la fenêtre marque le point dans le système de coordonnées logiques à partir de laquelle GDI est mappé à l’origine de la fenêtre d’affichage, un point dans le système de coordonnées de périphérique spécifié par le **SetWindowOrg** (fonction). GDI mappe tous les autres points en suivant la procédure requise pour mapper l’origine de la fenêtre à l’origine de la fenêtre d’affichage. Par exemple, tous les points d’un cercle autour du point à l’origine de la fenêtre sera dans un cercle autour du point à l’origine de la fenêtre d’affichage. De même, tous les points d’une ligne qui passe par l’origine de la fenêtre sera dans une ligne qui passe par l’origine de la fenêtre d’affichage.  
  
##  <a name="setworldtransform"></a>CDC::SetWorldTransform  
 Définit une transformation linéaire à deux dimensions entre espace universel et l’espace de page pour le contexte de périphérique spécifié. Cette transformation peut être utilisée pour mettre à l’échelle, faire pivoter, déformer ou traduire la sortie graphique.  
  
```  
BOOL SetWorldTransform(const XFORM& rXform);
```  
  
### <a name="parameters"></a>Paramètres  
 `rXform`  
 Référence à un [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) structure qui contient les données de la transformation.  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne une valeur différente de zéro.  
  
 Retourne 0 en cas d’échec.  
  
 Pour obtenir des informations d’erreur étendu appeler [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Notes  
 Cette méthode encapsule la fonction GDI de Windows [SetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145104).  
  
##  <a name="startdoc"></a>CDC::StartDoc  
 Indique au pilote de périphérique qui démarre un nouveau travail d’impression et que toutes les `StartPage` et `EndPage` appels doivent être spoulés sous la même tâche jusqu'à un `EndDoc` appel se produit.  
  
```  
int StartDoc(LPDOCINFO lpDocInfo);  
int StartDoc(LPCTSTR lpszDocName);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpDocInfo*  
 Pointe vers une [DOCINFO](http://msdn.microsoft.com/library/windows/desktop/dd183574) structure contenant le nom de fichier du document et le nom du fichier de sortie.  
  
 *lpszDocName*  
 Pointeur vers une chaîne contenant le nom de fichier du document.  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour est supérieure à zéro. Cette valeur est l’identificateur du travail d’impression du document.  
  
 Si la fonction échoue, la valeur de retour est inférieure ou égale à zéro.  
  
### <a name="remarks"></a>Notes  
 Cela garantit que les documents plus d’une page ne seront pas intercalés avec d’autres tâches.  
  
 Pour Windows 3.1 et versions ultérieures, cette fonction remplace la **STARTDOC** échappement d’imprimante. Cette fonction garantit que des documents contenant plusieurs pages ne sont pas mélangées avec les autres travaux d’impression.  
  
 `StartDoc`Il ne doit pas être utilisé à l’intérieur des métafichiers.  
  
### <a name="example"></a>Exemple  
 Ce fragment de code obtient l’imprimante par défaut, ouvre un travail d’impression et met en attente d’une page avec « Hello, World ! » sur ce dernier. Étant donné que le texte imprimé par le code n’est pas mis à l’échelle des unités logiques de l’imprimante, le texte de sortie peut être dans ces petites lettres que le résultat est illisible. Mise à l’échelle des fonctions, telles que CDC `SetMapMode`, `SetViewportOrg`, et `SetWindowExt`, peut être utilisé pour corriger la mise à l’échelle.  
  
 [!code-cpp[# NVC_MFCDocView&41;](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]  
  
##  <a name="startpage"></a>CDC::StartPage  
 Appelez cette fonction membre pour préparer le pilote d’imprimante pour recevoir des données.  
  
```  
int StartPage();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Supérieur ou égal à 0 si la fonction réussit, ou une valeur négative si une erreur s’est produite.  
  
### <a name="remarks"></a>Notes  
 `StartPage`remplace le **NEWFRAME** et **BANDINFO** d’échappement.  
  
 Pour une vue d’ensemble de la séquence d’appels d’impression, consultez la [StartDoc](#startdoc) fonction membre.  
  
 Le système désactive le `ResetDC` fonction membre entre les appels à `StartPage` et `EndPage`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::StartDoc](#startdoc).  
  
##  <a name="stretchblt"></a>CDC::StretchBlt  
 Copie une image bitmap depuis un rectangle source vers un rectangle de destination, en étirant ou en compressant le bitmap si nécessaire pour l'adapter aux dimensions du rectangle de destination.  
  
```  
BOOL StretchBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x (en unités logiques) de l'angle supérieur gauche du rectangle de destination.  
  
 *y*  
 Spécifie la coordonnée y (en unités logiques) de l'angle supérieur gauche du rectangle de destination.  
  
 `nWidth`  
 Spécifie la largeur (en unités logiques) du rectangle de destination.  
  
 `nHeight`  
 Spécifie la hauteur (en unités logiques) du rectangle de destination.  
  
 `pSrcDC`  
 Spécifie le contexte du périphérique source.  
  
 `xSrc`  
 Spécifie la coordonnée x (en unités logiques) de l'angle supérieur gauche du rectangle source.  
  
 `ySrc`  
 Spécifie la coordonnée y (en unités logiques) de l'angle supérieur gauche du rectangle source.  
  
 `nSrcWidth`  
 Spécifie la largeur (en unités logiques) du rectangle source.  
  
 `nSrcHeight`  
 Spécifie la hauteur (en unités logiques) du rectangle source.  
  
 *dwRop*  
 Spécifie l'opération de rastérisation à effectuer. Le code d'une opération de rastérisation définit la façon dont GDI associe les couleurs dans les opérations de sortie qui impliquent le pinceau actuel, un éventuel bitmap source et un bitmap de destination. Ce paramètre peut avoir l'une des valeurs suivantes :  
  
- **BLACKNESS** désactive toutes les sorties noir.  
  
- **DSTINVERT** inverse le bitmap de destination.  
  
- **MERGECOPY** associe le modèle et le bitmap source à l’aide de l’opérateur booléen AND.  
  
- **MERGEPAINT** associe le bitmap source inversé et le bitmap de destination à l’aide de l’opérateur booléen OR.  
  
- **NOTSRCCOPY** copie le bitmap source inversé vers la destination.  
  
- **NOTSRCERASE** inverse le résultat de la combinaison du bitmap source et de destination à l’aide de l’opérateur booléen OR.  
  
- **PATCOPY** copie le modèle vers le bitmap de destination.  
  
- **PATINVERT** associe le bitmap de destination et le modèle à l’aide de l’opérateur booléen XOR.  
  
- **PATPAINT** associe le bitmap source inversé et le modèle à l’aide de l’opérateur booléen OR. Associe le résultat de cette opération au bitmap de destination à l'aide de l'opérateur booléen OR.  
  
- **Src et** associe les pixels de la bitmap source et de destination à l’aide de l’opérateur booléen AND.  
  
- **SRCCOPY** copie le bitmap source vers l’image bitmap de destination.  
  
- **SRCERASE** inverse le bitmap de destination et associe le résultat de l’image bitmap source à l’aide de l’opérateur booléen AND.  
  
- **SRCINVERT** associe les pixels de la bitmap source et de destination à l’aide de l’opérateur booléen XOR.  
  
- **SRCPAINT** associe les pixels de la bitmap source et de destination à l’aide de l’opérateur booléen OR.  
  
- **WHITENESS** désactive toutes les sorties blanc.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si le bitmap est dessiné ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La fonction utilise le mode d'étirement du contexte du périphérique de destination (défini par `SetStretchBltMode`) afin de savoir comment étirer ou compresser le bitmap.  
  
 La fonction `StretchBlt` déplace le bitmap depuis le périphérique source fourni par `pSrcDC` vers le périphérique de destination représenté par l'objet de contexte de périphérique dont la fonction membre est appelée. Les paramètres `xSrc`, `ySrc`, `nSrcWidth` et `nSrcHeight` définissent l'angle supérieur gauche et les dimensions du rectangle source. Le *x*, *y*, `nWidth`, et `nHeight` paramètres définissent l’angle supérieur gauche et les dimensions du rectangle de destination. L’opération spécifiée par *dwRop* définit comment le bitmap source et les éléments déjà sur le périphérique de destination sont combinées.  
  
 La fonction `StretchBlt` crée une image miroir d'un bitmap si les signes des paramètres `nSrcWidth` et `nWidth`, ou `nSrcHeight` et `nHeight` sont différents. Si `nSrcWidth` et `nWidth` ont des signes différents, la fonction crée une image miroir du bitmap le long de l'axe des abscisses. Si `nSrcHeight` et `nHeight` ont des signes différents, la fonction crée une image miroir du bitmap le long de l'axe des ordonnées.  
  
 La fonction `StretchBlt` étire ou compresse le bitmap source en mémoire, puis copie le résultat vers la destination. Si un modèle doit être fusionné avec le résultat, il ne le sera pas tant que le bitmap source étiré n'est pas copié vers la destination. Si un pinceau est utilisé, il s'agira du pinceau sélectionné dans le contexte de périphérique de destination. Les coordonnées de destination sont transformées en fonction du contexte du périphérique de destination ; les coordonnées sources sont transformées en fonction du contexte du périphérique source.  
  
 Si les bitmaps sources, les bitmaps de destination et les bitmaps de modèle n'ont pas le même format de couleur, `StretchBlt` convertit les bitmaps sources et les bitmaps de modèle pour qu'ils correspondent aux bitmaps de destination. Les couleurs de premier plan et d'arrière-plan du contexte du périphérique de destination sont utilisées dans la conversion.  
  
 Si `StretchBlt` doit convertir un bitmap monochrome en bitmap de couleur, il définit les bits blancs (1) sur la couleur d'arrière-plan et les bits noirs (0) sur la couleur de premier plan. Pour convertir la couleur en monochrome, il définit les pixels qui correspondent à la couleur d'arrière-plan sur blanc (1) et définit tous les autres pixels sur noir (0). Les couleurs de premier plan et d'arrière-plan du contexte du périphérique coloré sont utilisées.  
  
 La fonction `StretchBlt` n'est pas prise en charge par tous les périphériques. Pour déterminer si un périphérique prend en charge `StretchBlt`, appelez le `GetDeviceCaps` fonction membre avec le **RASTERCAPS** indexer et rechercher la valeur de retour pour la **RC_STRETCHBLT** indicateur.  
  
##  <a name="strokeandfillpath"></a>CDC::StrokeAndFillPath  
 Ferme des figures ouvertes dans un chemin d’accès, des traits le contour du chemin d’accès en utilisant le stylet actuel et remplit son intérieur en utilisant le pinceau actuel.  
  
```  
BOOL StrokeAndFillPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le contexte de périphérique doit contenir une trajectoire fermée. Le `StrokeAndFillPath` fonction membre a le même effet que la fermeture de toutes les figures ouvertes dans le chemin d’accès et de contour et de remplissage séparément, le chemin d’accès, sauf que la région remplie ne superposent pas cet région tracées, même si le stylet est large.  
  
##  <a name="strokepath"></a>CDC::StrokePath  
 Affiche le chemin d’accès spécifié en utilisant le stylet actuel.  
  
```  
BOOL StrokePath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique doit contenir une trajectoire fermée.  
  
##  <a name="tabbedtextout"></a>CDC::TabbedTextOut  
 Appelez cette fonction membre pour écrire une chaîne de caractères à l’emplacement spécifié, en développant des onglets pour les valeurs spécifiées dans le tableau de positions de taquet de tabulation.  
  
```  
virtual CSize TabbedTextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);

 
CSize TabbedTextOut(
    int x,  
    int y,  
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point de départ de la chaîne.  
  
 *y*  
 Spécifie la coordonnée y logique du point de départ de la chaîne.  
  
 `lpszString`  
 Pointe vers une chaîne de caractères à dessiner. Vous pouvez passer un pointeur vers un tableau de caractères ou un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne. Si `nCount` est –&1;, la longueur est calculée.  
  
 `nTabPositions`  
 Spécifie le nombre de valeurs dans le tableau de positions de taquet de tabulation.  
  
 `lpnTabStopPositions`  
 Pointe vers un tableau qui contient les positions de taquet de tabulation (en unités logiques). Les taquets de tabulation doivent être triées par ordre croissant de commande ; la plus petite valeur x doit être le premier élément du tableau.  
  
 `nTabOrigin`  
 Spécifie la coordonnée x de la position de départ à partir duquel les onglets sont développés (en unités logiques).  
  
 `str`  
 Un `CString` objet qui contient les caractères spécifiés.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) comme un `CSize` objet.  
  
### <a name="remarks"></a>Remarques  
 Texte est écrit dans la police actuellement sélectionnée. Si `nTabPositions` est égal à 0 et `lpnTabStopPositions` est **NULL**, onglets sont étendues à la largeur de caractère moyenne huit fois.  
  
 Si `nTabPositions` est 1, l’onglet arrête est séparés par la distance indiquée par la première valeur de le `lpnTabStopPositions` tableau. Si le `lpnTabStopPositions` tableau contient plusieurs valeurs, d’un taquet de tabulation est défini pour chaque valeur dans le tableau, jusqu’au nombre spécifié par `nTabPositions`. Le `nTabOrigin` paramètre permet à une application appeler le `TabbedTextOut` fonction plusieurs fois pour une seule ligne. Si l’application appelle la fonction plusieurs fois avec la `nTabOrigin` affecter la même valeur chaque fois, la fonction développe tous les onglets par rapport à la position spécifiée par `nTabOrigin`.  
  
 Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction. Si une application doit mettre à jour la position actuelle lorsqu’il appelle la fonction, l’application peut appeler le [SetTextAlign](#settextalign) fonction membre avec `nFlags` la valeur **TA_UPDATECP**. Lorsque cet indicateur est défini, Windows ignore le *x* et *y* paramètres dans les appels ultérieurs à `TabbedTextOut`, à l’aide de la position actuelle à la place.  
  
##  <a name="textout"></a>CDC::TextOut  
 Écrit une chaîne de caractères à l'emplacement spécifié à l'aide de la police sélectionnée.  
  
```  
virtual BOOL TextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount);

 
BOOL TextOut(
    int x,
    int y,
    const CString& str);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point de départ du texte.  
  
 *y*  
 Spécifie la coordonnée y logique du point de départ du texte.  
  
 `lpszString`  
 Pointe vers la chaîne de caractères à ajouter.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne.  
  
 `str`  
 Objet `CString` qui contient les caractères à ajouter.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 L'origine des caractères se trouve dans l'angle supérieur gauche de la cellule de caractère. Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction.  
  
 Si une application doit mettre à jour la position actuelle lorsqu’il appelle `TextOut`, l’application peut appeler le `SetTextAlign` fonction membre avec `nFlags` la valeur **TA_UPDATECP**. Lorsque cet indicateur est défini, Windows ignore le *x* et *y* paramètres dans les appels ultérieurs à `TextOut`, à l’aide de la position actuelle à la place.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="transparentblt"></a>CDC::TransparentBlt  
 Appelez cette fonction membre pour transférer un bloc de bits des données de couleur, qui correspond à un rectangle de pixels à partir du contexte de périphérique source spécifiée, dans un contexte de périphérique de destination.  
  
```  
BOOL TransparentBlt(
    int xDest,  
    int yDest,
    int nDestWidth,
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    UINT clrTransparent);
```  
  
### <a name="parameters"></a>Paramètres  
 `xDest`  
 Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle de destination.  
  
 `yDest`  
 Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle de destination.  
  
 `nDestWidth`  
 Spécifie la largeur, en unités logiques, du rectangle de destination.  
  
 `nDestHeight`  
 Spécifie la hauteur, en unités logiques, du rectangle de destination.  
  
 `pSrcDC`  
 Pointeur vers le contexte du périphérique source.  
  
 `xSrc`  
 Spécifie la coordonnée x, en unités logiques, du rectangle source.  
  
 `ySrc`  
 Spécifie la coordonnée y, en unités logiques, du rectangle source.  
  
 `nSrcWidth`  
 Spécifie la largeur, en unités logiques, du rectangle source.  
  
 `nSrcHeight`  
 Spécifie la hauteur, en unités logiques, du rectangle source.  
  
 `clrTransparent`  
 La couleur RVB dans le bitmap source à traiter comme transparente.  
  
### <a name="return-value"></a>Valeur de retour  
 **TRUE** cas de réussite ; sinon **FALSE**.  
  
### <a name="remarks"></a>Notes  
 `TransparentBlt`permet de transparence ; Autrement dit, la couleur RVB indiqué par `clrTransparent` est rendu transparent pour le transfert.  
  
 Pour plus d’informations, consultez [TransparentBlt](http://msdn.microsoft.com/library/windows/desktop/dd145141) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="updatecolors"></a>CDC::UpdateColors  
 Mises à jour les couleurs de la zone cliente du contexte de périphérique en mettant en correspondance actuel dans la zone cliente de la palette système sur un pixel par pixel.  
  
```  
void UpdateColors();
```  
  
### <a name="remarks"></a>Notes  
 Une fenêtre avec une palette logique réalisée inactive peut appeler `UpdateColors` au lieu d’être redessiné sa zone cliente lors de la palette système change.  
  
 Pour plus d’informations sur l’utilisation des palettes de couleurs, consultez [UpdateColors](http://msdn.microsoft.com/library/windows/desktop/dd145166) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
 Le `UpdateColors` fonction membre met généralement à jour une zone client plus rapidement que le fait de redessiner la zone. Toutefois, étant donné que la fonction effectue la traduction de couleur selon la couleur de chaque pixel avant la modification de la palette système, chaque appel à cette fonction entraîne la perte de précision de certaines couleurs.  
  
##  <a name="widenpath"></a>CDC::WidenPath  
 Redéfinit le chemin d’accès actuel comme la zone serait être peinte si le chemin d’accès ont été dessiné avec le stylet actuellement sélectionné dans le contexte de périphérique.  
  
```  
BOOL WidenPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction réussit uniquement si le stylet actuel est un stylet géométrique créé par la deuxième version de `CreatePen` fonction membre, ou si le stylet est créé avec la première version de `CreatePen` et a une largeur, en unités de périphérique est supérieure à 1. Le contexte de périphérique doit contenir une trajectoire fermée. Les courbes de Bzier dans le chemin d’accès sont convertis en séquences de lignes droites se rapprochant les courbes élargies. Par conséquent, aucune courbe Bzier ne reste dans le chemin d’accès après `WidenPath` est appelée.  
  
## <a name="see-also"></a>Voir aussi  
 [CObject (classe)](../../mfc/reference/cobject-class.md)   
 [Graphique de la hiérarchie](../../mfc/hierarchy-chart.md)   
 [CPaintDC (classe)](../../mfc/reference/cpaintdc-class.md)   
 [CWindowDC (classe)](../../mfc/reference/cwindowdc-class.md)   
 [CClientDC (classe)](../../mfc/reference/cclientdc-class.md)   
 [CMetaFileDC (classe)](../../mfc/reference/cmetafiledc-class.md)

