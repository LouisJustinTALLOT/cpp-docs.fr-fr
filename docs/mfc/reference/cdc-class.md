---
title: CDC (classe) | Documents Microsoft
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: reference
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
dev_langs:
- C++
helpviewer_keywords:
- Windows [C++], device contexts
- Windows 95 [C++], screen coordinates
- device contexts [C++], CDC class
- screen coordinates in device contexts
- coordinates in Windows 95/98 [C++]
- Windows 98 [C++], screen coordinates
- CDC class
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
caps.latest.revision: 21
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: 3f91eafaf3b5d5c1b8f96b010206d699f666e224
ms.openlocfilehash: edbb8c4b62fc6536971f275c8079a3a91caccaa2
ms.lasthandoff: 04/01/2017

---
# <a name="cdc-class"></a>CDC (classe)
Définit une classe d’objets de contexte de périphérique.  
  
## <a name="syntax"></a>Syntaxe  
  
```  
class CDC : public CObject  
```  
  
## <a name="members"></a>Membres  
  
### <a name="public-constructors"></a>Constructeurs publics  
  
|Nom|Description|  
|----------|-----------------|  
|[CDC::CDC](#cdc)|Construit un objet `CDC`.|  
  
### <a name="public-methods"></a>M&#233;thodes publiques  
  
|Nom|Description|  
|----------|-----------------|  
|[CDC::AbortDoc](#abortdoc)|Met fin à l’impression en cours, tout ce que l’application a écrit sur le périphérique depuis le dernier appel d’effacement du `StartDoc` fonction membre.|  
|[CDC::AbortPath](#abortpath)|Ferme et ignore les chemins d’accès dans le contexte de périphérique.|  
|[CDC::AddMetaFileComment](#addmetafilecomment)|Copie le commentaire d’une mémoire tampon dans un métafichier amélioré au format spécifié.|  
|[CDC::AlphaBlend](#alphablend)|Affiche les bitmaps qui ont des pixels transparents ou semi-transparent.|  
|[CDC::AngleArc](#anglearc)|Dessine un arc un segment de ligne et déplace la position actuelle jusqu'à la fin de l’arc.|  
|[CDC::arc](#arc)|Dessine un arc elliptique.|  
|[CDC::ArcTo](#arcto)|Dessine un arc elliptique. Cette fonction est similaire à `Arc`, sauf que la position actuelle est mise à jour.|  
|[CDC::Attach](#attach)|Attache un contexte de périphérique Windows à ce `CDC` objet.|  
|[CDC::BeginPath](#beginpath)|Ouvre un crochet de chemin d’accès dans le contexte de périphérique.|  
|[CDC::BitBlt](#bitblt)|Copie une image bitmap à partir d’un contexte de périphérique spécifié.|  
|[CDC::Chord](#chord)|Dessine un segment (une figure fermée délimitée par l’intersection d’une ellipse et un segment de ligne).|  
|[CDC::CloseFigure](#closefigure)|Ferme une figure ouverte dans un chemin d’accès.|  
|[CDC::CreateCompatibleDC](#createcompatibledc)|Crée un contexte de périphérique de mémoire qui est compatible avec un autre contexte de périphérique. Vous pouvez l’utiliser pour préparer des images en mémoire.|  
|[CDC::CreateDC](#createdc)|Crée un contexte de périphérique pour un périphérique spécifique.|  
|[CDC::CreateIC](#createic)|Crée un contexte d’information pour un périphérique spécifique. Cela fournit un moyen rapide pour obtenir des informations sur l’appareil sans créer un contexte de périphérique.|  
|[CDC::DeleteDC](#deletedc)|Supprime le contexte de périphérique Windows associé à ce `CDC` objet.|  
|[CDC::DeleteTempMap](#deletetempmap)|Appelée par le `CWinApp` Gestionnaire de durée d’inactivité à supprimer n’importe quel temporaire `CDC` objet créé par `FromHandle`. Détache également le contexte de périphérique.|  
|[CDC::Detach](#detach)|Détache le contexte de périphérique Windows à partir de ce `CDC` objet.|  
|[CDC::DPtoHIMETRIC](#dptohimetric)|Convertit des unités de périphérique dans **HIMETRIC** unités.|  
|[CDC::DPtoLP](#dptolp)|Convertit des unités de périphérique dans des unités logiques.|  
|[CDC::Draw3dRect](#draw3drect)|Dessine un rectangle en trois dimensions.|  
|[CDC::DrawDragRect](#drawdragrect)|Efface et redessine un rectangle comme vous le faites glisser.|  
|[CDC::DrawEdge](#drawedge)|Dessine les bords d’un rectangle.|  
|[CDC::DrawEscape](#drawescape)|Accès aux fonctions qui ne sont pas directement disponibles via l’interface GDI (GDI) d’un moniteur vidéo de dessin.|  
|[CDC::DrawFocusRect](#drawfocusrect)|Dessine un rectangle dans le style utilisé pour indiquer le focus.|  
|[CDC::DrawFrameControl](#drawframecontrol)|Dessiner un contrôle frame.|  
|[CDC::DrawIcon](#drawicon)|Dessine une icône.|  
|[CDC::DrawState](#drawstate)|Affiche une image et applique un effet visuel pour indiquer un état.|  
|[CDC::DrawText](#drawtext)|Dessine mis en forme le texte dans le rectangle spécifié.|  
|[CDC::DrawTextEx](#drawtextex)|Dessine mis en forme le texte dans le rectangle spécifié à l’aide des formats supplémentaires.|  
|[CDC::ellipse](#ellipse)|Dessine une ellipse.|  
|[CDC::EndDoc](#enddoc)|Met fin à un travail d’impression démarré par le `StartDoc` fonction membre.|  
|[CDC::EndPage](#endpage)|Informe le pilote de périphérique, une page se termine.|  
|[CDC::EndPath](#endpath)|Ferme un crochet de chemin d’accès et de sélectionner le chemin d’accès défini par le crochet dans le contexte de périphérique.|  
|[CDC::EnumObjects](#enumobjects)|Énumère les stylets et pinceaux disponibles dans un contexte de périphérique.|  
|[CDC::escape](#escape)|Permet aux applications d’accéder à des fonctionnalités qui ne sont pas directement disponibles à partir d’un périphérique particulier via GDI. Autorise également l’accès aux fonctions d’échappement de Windows. Les appels d’échappement effectués par une application sont traduits et envoyées au pilote de périphérique.|  
|[CDC::ExcludeClipRect](#excludecliprect)|Crée une nouvelle zone de découpage qui se compose de la zone de découpage existant moins le rectangle spécifié.|  
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Empêche le dessin dans les zones non valides d’une fenêtre en excluant une région de mise à jour dans la fenêtre à partir d’une zone de découpage.|  
|[CDC::ExtFloodFill](#extfloodfill)|Remplit une zone avec le pinceau actuel. Fournit plus de flexibilité que la [CDC::FloodFill](#floodfill) fonction membre.|  
|[CDC::ExtTextOut](#exttextout)|Écrit une chaîne de caractères dans une zone rectangulaire à l’aide de la police actuellement sélectionnée.|  
|[CDC::FillPath](#fillpath)|Ferme des figures ouvertes dans le chemin d’accès actuel et remplit l’intérieur du chemin d’accès en utilisant le pinceau actuel et le mode de remplissage de polygones.|  
|[CDC::FillRect](#fillrect)|Remplit un rectangle donné à l’aide d’un pinceau spécifique.|  
|[CDC::FillRgn](#fillrgn)|Remplit une zone spécifique avec le pinceau spécifié.|  
|[CDC::FillSolidRect](#fillsolidrect)|Remplit un rectangle avec une couleur unie.|  
|[CDC::FlattenPath](#flattenpath)|Transforme les courbes dans le chemin d’accès sélectionné dans le contexte de périphérique en cours et active de chaque courbe en une séquence de lignes.|  
|[CDC::FloodFill](#floodfill)|Remplit une zone avec le pinceau actuel.|  
|[CDC::frameRect n'](#framerect)|Dessine une bordure autour d’un rectangle.|  
|[CDC::FrameRgn](#framergn)|Dessine une bordure autour d’une région spécifique à l’aide d’un pinceau.|  
|[CDC::FromHandle](#fromhandle)|Retourne un pointeur vers un `CDC` lorsqu’un handle vers un contexte de périphérique de l’objet. Si aucun objet `CDC` n'est attaché au handle, un objet `CDC` temporaire est créé et attaché.|  
|[CDC::GetArcDirection](#getarcdirection)|Renvoie la direction d’arc de cercle en cours pour le contexte de périphérique.|  
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Récupère le paramètre pour le filtre de proportions de l’image actuelle.|  
|[CDC::GetBkColor](#getbkcolor)|Récupère la couleur d’arrière-plan actuelle.|  
|[CDC::GetBkMode](#getbkmode)|Récupère le mode d’arrière-plan.|  
|[CDC::GetBoundsRect](#getboundsrect)|Retourne le rectangle englobant cumulé actuel pour le contexte de périphérique spécifié.|  
|[CDC::GetBrushOrg](#getbrushorg)|Extrait l’origine du pinceau actuel.|  
|[CDC::GetCharABCWidths](#getcharabcwidths)|Récupère la largeur, en unités logiques, de caractères consécutifs dans une plage donnée à partir de la police actuelle.|  
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Récupère la largeur, en unités logiques, des index de glyphes consécutifs dans une plage spécifiée à partir de la police TrueType en cours.|  
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Récupère les différents types d’informations sur une chaîne de caractères.|  
|[CDC::GetCharWidth](#getcharwidth)|Récupère les largeurs de fractions de seconde de caractères consécutifs dans une plage donnée à partir de la police actuelle.|  
|[CDC::GetCharWidthI](#getcharwidthi)|Récupère la largeur, en coordonnées logiques, des index de glyphes consécutifs dans une plage spécifiée à partir de la police actuelle.|  
|[CDC::GetClipBox](#getclipbox)|Récupère les dimensions du rectangle englobant plus étroite autour de la limite de découpage en cours.|  
|[CDC::GetColorAdjustment](#getcoloradjustment)|Récupère les valeurs d’ajustement de couleur pour le contexte de périphérique.|  
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Retourne un pointeur vers actuellement sélectionné `CBitmap` objet.|  
|[CDC::GetCurrentBrush](#getcurrentbrush)|Retourne un pointeur vers actuellement sélectionné `CBrush` objet.|  
|[CDC::GetCurrentFont](#getcurrentfont)|Retourne un pointeur vers actuellement sélectionné `CFont` objet.|  
|[CDC::GetCurrentPalette](#getcurrentpalette)|Retourne un pointeur vers actuellement sélectionné `CPalette` objet.|  
|[CDC::GetCurrentPen](#getcurrentpen)|Retourne un pointeur vers actuellement sélectionné `CPen` objet.|  
|[CDC::GetCurrentPosition](#getcurrentposition)|Récupère la position actuelle du stylet (en coordonnées logiques).|  
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Récupère la couleur actuelle du pinceau.|  
|[CDC::GetDCPenColor](#getdcpencolor)|Récupère la couleur actuelle du stylet.|  
|[CDC::GetDeviceCaps](#getdevicecaps)|Récupère un type spécifié et des informations spécifiques à l’appareil sur les fonctionnalités d’un périphérique d’affichage donné.|  
|[CDC::GetFontData](#getfontdata)|Récupère les informations sur les métriques de police à partir d’un fichier de polices évolutives. Les informations à récupérer sont identifiées en spécifiant un décalage dans le fichier de police et la longueur des informations à retourner.|  
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Retourne des informations sur la police actuellement sélectionnée pour le contexte d’affichage spécifié.|  
|[CDC::GetGlyphOutline](#getglyphoutline)|Récupère la courbe du plan ou une image bitmap pour un caractère avec contour dans la police actuelle.|  
|[CDC::GetGraphicsMode](#getgraphicsmode)|Récupère le mode graphique actuel pour le contexte de périphérique spécifié.|  
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Récupère un pinceau de demi-teintes.|  
|[CDC::GetKerningPairs](#getkerningpairs)|Récupère le caractère le crénage paires pour la police actuellement sélectionnée dans le contexte de périphérique spécifié.|  
|[CDC::GetLayout](#getlayout)|Récupère la disposition d’un contexte de périphérique (DC). La mise en page peut être soit de gauche à droite (par défaut) ou de droite à gauche (miroir).|  
|[CDC::GetMapMode](#getmapmode)|Récupère le mode de mappage en cours.|  
|[CDC::GetMiterLimit](#getmiterlimit)|Retourne la limite d’angle pour le contexte de périphérique.|  
|[CDC::GetNearestColor](#getnearestcolor)|Récupère la couleur logique le plus proche à une couleur spécifiée logique que le périphérique donné peut représenter.|  
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Récupère les informations de métriques de police pour les polices TrueType.|  
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Récupère la largeur des caractères individuels dans un groupe de caractères consécutifs à partir de la police actuelle en utilisant le contexte de périphérique de sortie.|  
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Calcule la largeur et la hauteur d’une chaîne de caractères dans le contexte de périphérique de sortie.|  
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Calcule la largeur et la hauteur d’une ligne de texte sur le contexte de périphérique de sortie à l’aide de la police actuelle pour déterminer les dimensions.|  
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Récupère les métriques pour la police actuelle à partir du contexte de périphérique de sortie.|  
|[CDC::getPath](#getpath)|Récupère les coordonnées de définition des points de terminaison des lignes et les points de contrôle des courbes trouvés dans le chemin d’accès qui est sélectionné dans le contexte de périphérique.|  
|[CDC::getPixel](#getpixel)|Récupère la valeur de couleur RVB du pixel au point spécifié.|  
|[CDC::GetPolyFillMode](#getpolyfillmode)|Récupère le mode de remplissage de polygones en cours.|  
|[CDC::GetROP2](#getrop2)|Récupère le mode de dessin en cours.|  
|[CDC::GetSafeHdc](#getsafehdc)|Retourne [CDC::m_hDC](#m_hdc), le contexte de périphérique de sortie.|  
|[CDC::GetStretchBltMode](#getstretchbltmode)|Récupère le mode d’étirement de bitmap en cours.|  
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Calcule la largeur et la hauteur d’une chaîne de caractères dans le contexte de l’attribut.|  
|[CDC::GetTextAlign](#gettextalign)|Récupère les indicateurs d’alignement de texte.|  
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Récupère la valeur actuelle pour la quantité d’espacement entre les caractères.|  
|[CDC::GetTextColor](#gettextcolor)|Récupère la couleur de texte actuelle.|  
|[CDC::GetTextExtent](#gettextextent)|Calcule la largeur et la hauteur d’une ligne de texte sur le contexte de l’attribut à l’aide de la police actuelle pour déterminer les dimensions.|  
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|Récupère le nombre de caractères dans une chaîne spécifiée qui pourra être contenue dans un espace spécifié et remplit un tableau avec l’étendue de texte pour chacun de ces caractères.|  
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Récupère la largeur et la hauteur du tableau spécifié d’index de glyphes.|  
|[CDC::GetTextFace](#gettextface)|Copie le nom de la police actuelle dans une mémoire tampon sous forme de chaîne se terminant par null.|  
|[CDC::GetTextMetrics](#gettextmetrics)|Récupère les métriques pour la police actuelle à partir du contexte de périphérique d’attribut.|  
|[CDC::GetViewportExt](#getviewportext)|Récupère les étendues x et y de la fenêtre d’affichage.|  
|[CDC::GetViewportOrg](#getviewportorg)|Récupère les coordonnées x et y de l’origine de la fenêtre d’affichage.|  
|[CDC::GetWindow](#getwindow)|Retourne la fenêtre associée au contexte de périphérique d’affichage.|  
|[CDC::GetWindowExt](#getwindowext)|Récupère les étendues x et y de la fenêtre associée.|  
|[CDC::GetWindowOrg](#getwindoworg)|Récupère les coordonnées x et y de l’origine de la fenêtre associée.|  
|[CDC::GetWorldTransform](#getworldtransform)|Récupère l’espace de monde actuel pour la transformation de l’espace de page.|  
|[CDC::GradientFill](#gradientfill)|Remplit les structures et triangle rectangle avec une couleur gradating.|  
|[CDC::GrayString](#graystring)|Dessine estompé (grisé) de texte à l’emplacement donné.|  
|[CDC::HIMETRICtoDP](#himetrictodp)|Convertit **HIMETRIC** unités en unités de périphérique.|  
|[CDC::HIMETRICtoLP](#himetrictolp)|Convertit **HIMETRIC** unités dans des unités logiques.|  
|[CDC::IntersectClipRect](#intersectcliprect)|Crée une nouvelle zone de découpage par l’intersection de la zone active et un rectangle.|  
|[CDC::InvertRect](#invertrect)|Inverse le contenu d’un rectangle.|  
|[CDC::InvertRgn](#invertrgn)|Inverse les couleurs dans une région.|  
|[CDC::IsPrinting](#isprinting)|Détermine si le contexte de périphérique est utilisé pour l’impression.|  
|[CDC::LineTo](#lineto)|Dessine une ligne à partir de la position actuelle jusqu'à, non compris, un point.|  
|[CDC::LPtoDP](#lptodp)|Convertit des unités logiques en unités de périphérique.|  
|[CDC::LPtoHIMETRIC](#lptohimetric)|Convertit des unités logiques vers **HIMETRIC** unités.|  
|[CDC::MaskBlt](#maskblt)|Combine les données de couleur pour les bitmaps sources et de destination à l’aide de la masque donné et l’opération de rastérisation.|  
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Modifie la transformation universelle pour un contexte de périphérique en utilisant le mode spécifié.|  
|[CDC::MoveTo](#moveto)|Déplace la position actuelle.|  
|[CDC::OffsetClipRgn](#offsetcliprgn)|Déplace la zone de découpage de l’appareil donné.|  
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Modifie l’origine de la fenêtre d’affichage par rapport aux coordonnées de l’origine de la fenêtre d’affichage actuel.|  
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Modifie l’origine de la fenêtre par rapport aux coordonnées de l’origine de la fenêtre en cours.|  
|[CDC::PaintRgn](#paintrgn)|Remplit une zone avec le pinceau sélectionné.|  
|[CDC::PatBlt](#patblt)|Crée un modèle binaire.|  
|[CDC::Pie](#pie)|Dessine un secteur.|  
|[CDC::PlayMetaFile](#playmetafile)|Lit le contenu du métafichier spécifié sur le périphérique donné. La version améliorée du `PlayMetaFile` affiche l’image stockée dans le métafichier de format amélioré donné. Le métafichier peut être lus à n’importe quel nombre de fois.|  
|[CDC::PlgBlt](#plgblt)|Effectue un transfert de bloc de bits des bits de données de couleur du rectangle spécifié dans le contexte du périphérique source au parallélogramme spécifié dans le contexte de périphérique donné.|  
|[CDC::PolyBezier](#polybezier)|Dessine une ou plusieurs splines de Bzier. La position actuelle n’est ni utilisée ni mise à jour.|  
|[CDC::PolyBezierTo](#polybezierto)|Dessine une ou plusieurs splines de Bzier et déplace la position actuelle pour le point de fin de la dernière Bzier.|  
|[CDC::PolyDraw](#polydraw)|Dessine un ensemble de segments de ligne et de splines de Bzier. Cette fonction met à jour la position actuelle.|  
|[CDC::Polygon](#polygon)|Dessine un polygone composé de deux ou plusieurs points (sommets) reliés par des lignes.|  
|[CDC::Polyline](#polyline)|Dessine un ensemble de segments de ligne reliant les points spécifiés.|  
|[CDC::PolylineTo](#polylineto)|Dessine une ou plusieurs lignes droites et déplace la position actuelle jusqu'à la fin de la dernière ligne.|  
|[CDC::PolyPolygon](#polypolygon)|Crée deux ou plusieurs polygones qui sont remplis à l’aide du mode de remplissage de polygones en cours. Les polygones peuvent être disjoints ou ils peuvent se chevaucher.|  
|[CDC::PolyPolyline](#polypolyline)|Dessine plusieurs séries de segments de ligne connectés. La position actuelle n’est ni utilisée ni mise à jour par cette fonction.|  
|[CDC::PtVisible](#ptvisible)|Spécifie si le point donné se trouve dans la zone de découpage.|  
|[CDC::RealizePalette](#realizepalette)|Mappe des entrées dans la palette logique en cours de la palette à la palette système.|  
|[CDC::rectangle](#rectangle)|Dessine un rectangle à l’aide du stylet courant et remplit à l’aide de la brosse courante.|  
|[CDC::RectVisible](#rectvisible)|Détermine si une partie du rectangle donné se trouve dans la zone de découpage.|  
|[CDC::ReleaseAttribDC](#releaseattribdc)|Les versions `m_hAttribDC`, le contexte de l’attribut.|  
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Les versions `m_hDC`, le contexte de périphérique de sortie.|  
|[CDC::ResetDC](#resetdc)|Les mises à jour le `m_hAttribDC` contexte de périphérique.|  
|[CDC::RestoreDC](#restoredc)|Restaure le contexte de périphérique à un état antérieur enregistré avec `SaveDC`.|  
|[CDC::RoundRect](#roundrect)|Dessine un rectangle à angles arrondis à l’aide du stylet courant et rempli à l’aide de la brosse courante.|  
|[CDC::SaveDC](#savedc)|Enregistre l’état actuel du contexte de périphérique.|  
|[CDC::ScaleViewportExt](#scaleviewportext)|Modifie l’étendue de la fenêtre d’affichage par rapport aux valeurs actuelles.|  
|[CDC::ScaleWindowExt](#scalewindowext)|Modifie les étendues de fenêtre par rapport aux valeurs actuelles.|  
|[CDC::ScrollDC](#scrolldc)|Fait défiler un rectangle de bits horizontalement et verticalement.|  
|[CDC::SelectClipPath](#selectclippath)|Sélectionne le chemin d’accès actuel comme une zone de découpage pour le contexte de périphérique, en combinant la nouvelle région avec n’importe quelle région de découpage existant en utilisant le mode spécifié.|  
|[CDC::SelectClipRgn](#selectcliprgn)|Combine la région donnée avec la zone de découpage actuelle en utilisant le mode spécifié.|  
|[CDC::SelectObject](#selectobject)|Sélectionne un dessin comme un stylet GDI.|  
|[CDC::SelectPalette](#selectpalette)|Sélectionne la palette logique.|  
|[CDC::SelectStockObject](#selectstockobject)|Sélectionne l’un des stylets stocks prédéfinis, pinceaux, polices fournies par Windows.|  
|[CDC::SETABORTPROC](#setabortproc)|Définit une fonction de rappel fourni par le programmeur Windows appelle si un travail d’impression doit être abandonné.|  
|[CDC::SetArcDirection](#setarcdirection)|Définit la direction de dessin à utiliser pour les fonctions d’arc de cercle et rectangle.|  
|[CDC::SetAttribDC](#setattribdc)|Jeux de `m_hAttribDC`, le contexte de l’attribut.|  
|[CDC::SetBkColor](#setbkcolor)|Définit la couleur d’arrière-plan actuelle.|  
|[CDC::SetBkMode](#setbkmode)|Définit le mode d’arrière-plan.|  
|[CDC::SetBoundsRect](#setboundsrect)|Contrôle l’accumulation des informations de rectangle englobant pour le contexte de périphérique spécifié.|  
|[CDC::SetBrushOrg](#setbrushorg)|Spécifie l’origine de la forme suivante sélectionnée dans un contexte de périphérique.|  
|[CDC::SetColorAdjustment](#setcoloradjustment)|Définit les valeurs d’ajustement de couleur pour le contexte de périphérique en utilisant les valeurs spécifiées.|  
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Définit la couleur actuelle du pinceau.|  
|[CDC::SetDCPenColor](#setdcpencolor)|Définit la couleur actuelle du stylet.|  
|[CDC::SetGraphicsMode](#setgraphicsmode)|Définit le mode graphique actuel pour le contexte de périphérique spécifié.|  
|[CDC::SetLayout](#setlayout)|Modifie la disposition d’un contexte de périphérique (DC).|  
|[CDC::SetMapMode](#setmapmode)|Définit le mode de mappage en cours.|  
|[CDC::SetMapperFlags](#setmapperflags)|Modifie l’algorithme utilisé par le mappeur de polices lorsqu’il mappe des polices logiques aux polices physiques.|  
|[CDC::SetMiterLimit](#setmiterlimit)|Définit la limite pour la longueur de jointures de pointe pour le contexte de périphérique.|  
|[CDC::SetOutputDC](#setoutputdc)|Jeux de `m_hDC`, le contexte de périphérique de sortie.|  
|[CDC::SetPixel](#setpixel)|Définit le pixel au point spécifié pour l’approximation la plus proche de la couleur spécifiée.|  
|[CDC::SetPixelV](#setpixelv)|Définit le pixel situé aux coordonnées spécifiées pour l’approximation la plus proche de la couleur spécifiée. `SetPixelV`est plus rapide que `SetPixel` car il n’a pas besoin de retourner la valeur de couleur du point réellement peinte.|  
|[CDC::SetPolyFillMode](#setpolyfillmode)|Définit le mode de remplissage de polygones.|  
|[CDC::SetROP2](#setrop2)|Définit le mode de dessin en cours.|  
|[CDC::SetStretchBltMode](#setstretchbltmode)|Définit le mode d’étirement de bitmap.|  
|[CDC::SetTextAlign](#settextalign)|Définit les indicateurs d’alignement de texte.|  
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Définit l’espacement entre les caractères.|  
|[CDC::SetTextColor](#settextcolor)|Définit la couleur du texte.|  
|[CDC::SetTextJustification](#settextjustification)|Ajoute un espace pour les caractères de saut dans une chaîne.|  
|[CDC::SetViewportExt](#setviewportext)|Définit les étendues x et y de la fenêtre d’affichage.|  
|[CDC::SetViewportOrg](#setviewportorg)|Définit l’origine de la fenêtre d’affichage.|  
|[CDC::SetWindowExt](#setwindowext)|Définit les étendues x et y de la fenêtre associée.|  
|[CDC::SetWindowOrg](#setwindoworg)|Définit l’origine de la fenêtre du contexte de périphérique.|  
|[CDC::SetWorldTransform](#setworldtransform)|Définit l’espace universel actuel pour la transformation de l’espace de page.|  
|[CDC::StartDoc](#startdoc)|Informe le pilote de périphérique qui démarre un nouveau travail d’impression.|  
|[CDC::StartPage](#startpage)|Informe le pilote de périphérique qui démarre une nouvelle page.|  
|[CDC::StretchBlt](#stretchblt)|Déplace une bitmap à partir d’un rectangle source et un périphérique dans un rectangle de destination, étirant ou en compressant le bitmap si nécessaire pour l’adapter aux dimensions du rectangle de destination.|  
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Ferme des figures ouvertes dans un chemin d’accès, établit le contour du chemin d’accès à l’aide du stylet courant et remplit son intérieur en utilisant le pinceau actuel.|  
|[CDC::StrokePath](#strokepath)|Affiche le chemin d’accès spécifié à l’aide du stylet courant.|  
|[CDC::TabbedTextOut](#tabbedtextout)|Écrit une chaîne de caractères à un emplacement spécifié, en développant des onglets pour les valeurs spécifiées dans un tableau de positions de taquet de tabulation.|  
|[CDC::TextOut](#textout)|Écrit une chaîne de caractères à un emplacement spécifié à l’aide de la police actuellement sélectionnée.|  
|[CDC::TransparentBlt](#transparentblt)|Transfère un bloc de bits des données de couleur à partir du contexte de périphérique source spécifiée dans un contexte de périphérique de destination, rendu transparent dans le transfert d’une couleur spécifiée.|  
|[CDC::UpdateColors](#updatecolors)|Mises à jour les couleurs de la zone cliente du contexte de périphérique en mettant en correspondance actuel dans la zone cliente de la palette système sur un pixel par pixel.|  
|[CDC::WidenPath](#widenpath)|Redéfinit le chemin d’accès actuel en tant que la zone est d’être peinte si le chemin d’accès ont été dessiné à l’aide du stylet actuellement sélectionné dans le contexte de périphérique.|  
  
### <a name="public-operators"></a>Op&#233;rateurs publics  
  
|Nom|Description|  
|----------|-----------------|  
|[CDC::operator HDC](#operator_hdc)|Récupère le handle du contexte de périphérique.|  
  
### <a name="public-data-members"></a>Membres de données publics  
  
|Nom|Description|  
|----------|-----------------|  
|[CDC::m_hAttribDC](#m_hattribdc)|Le contexte de périphérique de l’attribut utilisé par ce `CDC` objet.|  
|[CDC::m_hDC](#m_hdc)|Le contexte de périphérique de sortie utilisé par ce `CDC` objet.|  
  
## <a name="remarks"></a>Remarques  
 Le `CDC` objet fournit des fonctions membres pour travailler avec un contexte de périphérique, par exemple un affichage ou des imprimantes, ainsi que des membres pour travailler avec un contexte d’affichage associé à la zone cliente d’une fenêtre.  
  
 Effectuer des fonctions de tout le dessin via le membre un `CDC` objet. La classe fournit des fonctions membres pour les opérations de contexte de périphérique, utilisation des outils, sélection d’objets graphiques de type sécurisé appareil interface GDI (interface), de dessin et utilisation des couleurs et palettes. Il fournit également des fonctions membres pour obtenir et de définir des attributs, de dessin de mappage, utilisez la fenêtre d’affichage, utilisation de l’étendue de la fenêtre, convertir des coordonnées, utilisation de régions, de découpage, de tracer des lignes et de dessin des polygones, des ellipses et des formes simples. Fonctions membres sont également fournies pour dessiner du texte, l’utilisation des polices, à l’aide de séquences d’échappement imprimante, le défilement et lecture des métafichiers.  
  
 Pour utiliser un `CDC` de l’objet, le générer, puis appeler ses fonctions membres parallèles des fonctions de Windows qui utilisent des contextes de périphérique.  
  
> [!NOTE]
>  Sous Windows 95/98, toutes les coordonnées d’écran sont limitées à 16 bits. Par conséquent, un `int` passé à un `CDC` fonction membre doit être compris entre-32 768 et 32 767.  
  
 Pour des utilisations spécifiques, la bibliothèque Microsoft Foundation Class fournit plusieurs classes dérivées de `CDC` . `CPaintDC`encapsule les appels à `BeginPaint` et `EndPaint`. `CClientDC`gère un contexte d’affichage liée à la zone cliente d’une fenêtre. `CWindowDC`gère un contexte d’affichage associé à une fenêtre entière, y compris son frame et les contrôles. `CMetaFileDC`associe un contexte de périphérique de métafichier.  
  
 `CDC`fournit deux fonctions membres, [GetLayout](#getlayout) et [SetLayout](#setlayout), pour inverser la disposition d’un contexte de périphérique, qui n’hérite pas de sa disposition à partir d’une fenêtre. Ce type orientation de droite à gauche est nécessaire pour les applications écrites pour les cultures, telles que l’arabe ou l’hébreu, où la disposition des caractères n’est pas la norme européenne.  
  
 `CDC`contient deux contextes de périphérique, [m_hDC](#m_hdc) et [m_hAttribDC](#m_hattribdc), qui, lors de la création d’un `CDC` d’objet, reportez-vous au même appareil. `CDC`Indique tous les appels GDI de sortie à `m_hDC` et la plupart des attributs GDI appelle à `m_hAttribDC`. (Un exemple d’un appel de l’attribut est `GetTextColor`, tandis que `SetTextColor` est un appel de sortie.)  
  
 Par exemple, l’infrastructure utilise les contextes de deux périphérique pour implémenter un `CMetaFileDC` objet qui sera envoient la sortie dans un métafichier lors de la lecture des attributs à partir d’un périphérique physique. Aperçu avant impression est implémentée dans le cadre de la même manière. Vous pouvez également utiliser les contextes de deux périphérique de la même façon dans votre code d’application.  
  
 Il se peut que vous devez parfois des informations de mesure de texte à partir du `m_hDC` et `m_hAttribDC` contextes de périphérique. Les paires de fonctions suivantes fournissent cette fonctionnalité :  
  
|Utilise m_hAttribDC|Utilise m_hDC|  
|-----------------------|-----------------|  
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|  
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|  
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|  
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|  
  
 Pour plus d’informations sur `CDC`, consultez [contextes de périphérique](../../mfc/device-contexts.md).  
  
## <a name="inheritance-hierarchy"></a>Hiérarchie d’héritage  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 `CDC`  
  
## <a name="requirements"></a>Spécifications  
 **En-tête :** afxwin.h  
  
##  <a name="abortdoc"></a>CDC::AbortDoc  
 Met fin à l’impression en cours et supprime tout ce dont l’application a écrit sur le périphérique depuis le dernier appel à la [StartDoc](#startdoc) fonction membre.  
  
```  
int AbortDoc();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur supérieure ou égale à 0 en cas de réussite, ou une valeur négative si une erreur s’est produite. La liste suivante montre les valeurs d’erreur courantes et leurs significations :  
  
- **SP_ERROR** erreur générale.  
  
- **SP_OUTOFDISK** pas suffisamment d’espace disque est actuellement disponible pour la mise en attente, et aucun espace plus ne sera bientôt disponible.  
  
- **SP_OUTOFMEMORY** pas assez de mémoire est disponible pour la mise en attente.  
  
- **SP_USERABORT** utilisateur a interrompu la tâche via le Gestionnaire d’impression.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre remplace le `ABORTDOC` échappement de l’imprimante.  
  
 **AbortDoc** doit être utilisé pour mettre fin à ce qui suit :  
  
-   Les opérations d’impression qui ne spécifient pas une à l’aide de la fonction d’abort [SetAbortProc](#setabortproc).  
  
-   Les opérations d’impression qui n’ont pas encore atteint leur premier **NEWFRAME** ou **NEXTBAND** d’échappement d’appel.  
  
 Si une application rencontre une erreur d’impression ou d’une opération d’impression annulée, il ne devez pas tenter de terminer l’opération en utilisant la [EndDoc](#enddoc) ou **AbortDoc** fonctions membres de classe `CDC`. GDI termine automatiquement l’opération avant de retourner la valeur d’erreur.  
  
 Si l’application affiche une boîte de dialogue pour autoriser l’utilisateur d’annuler l’opération d’impression, il doit appeler **AbortDoc** avant la destruction de la boîte de dialogue.  
  
 Si le Gestionnaire d’impression a été utilisé pour démarrer le travail d’impression, l’appel **AbortDoc** efface le travail spool entière, l’imprimante reçoit nothing. Si le Gestionnaire d’impression n’a pas utilisé pour démarrer le travail d’impression, les données peuvent avoir été envoyées à l’imprimante avant **AbortDoc** a été appelée. Dans ce cas, le pilote d’imprimante serait avoir réinitialisé l’imprimante (si possible) et fermé le travail d’impression.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::StartDoc](#startdoc).  
  
##  <a name="abortpath"></a>CDC::AbortPath  
 Ferme et ignore les chemins d’accès dans le contexte de périphérique.  
  
```  
BOOL AbortPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 S’il existe un crochet de tracé ouvert dans le contexte de périphérique, le crochet de chemin d’accès est fermé et le chemin d’accès est ignoré. S’il existe un chemin d’accès fermé dans le contexte de périphérique, le chemin d’accès est ignoré.  
  
##  <a name="addmetafilecomment"></a>CDC::AddMetaFileComment  
 Copie le commentaire d’une mémoire tampon dans un métafichier amélioré au format spécifié.  
  
```  
BOOL AddMetaFileComment(
    UINT nDataSize,  
    const BYTE* pCommentData);
```  
  
### <a name="parameters"></a>Paramètres  
 *nDataSize*  
 Spécifie la longueur de la mémoire tampon de commentaire, en octets.  
  
 *pCommentData*  
 Pointe vers la mémoire tampon qui contient le commentaire.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Un commentaire peut inclure des informations confidentielles, par exemple, la source de l’image et la date de sa création. Un commentaire doit commencer par une signature d’application, suivie des données. Commentaires ne doivent pas contenir les données spécifiques à la position. Les données spécifiques à la position indique l’emplacement d’un enregistrement, et ne doit pas être inclus, car un métafichier peut être incorporé dans un autre métafichier. Cette fonction peut uniquement être utilisée avec des métafichiers améliorés.  
  
##  <a name="alphablend"></a>CDC::AlphaBlend  
 Appelez cette fonction membre pour afficher les bitmaps qui ont des pixels transparents ou semi-transparent.  
  
```  
BOOL AlphaBlend(
    int xDest,  
    int yDest,  
    int nDestWidth,  
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    BLENDFUNCTION blend);
```  
  
### <a name="parameters"></a>Paramètres  
 `xDest`  
 Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle de destination.  
  
 `yDest`  
 Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle de destination.  
  
 `nDestWidth`  
 Spécifie la largeur, en unités logiques, du rectangle de destination.  
  
 `nDestHeight`  
 Spécifie la hauteur, en unités logiques, du rectangle de destination.  
  
 `pSrcDC`  
 Pointeur vers le contexte du périphérique source.  
  
 `xSrc`  
 Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle source.  
  
 `ySrc`  
 Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle source.  
  
 `nSrcWidth`  
 Spécifie la largeur, en unités logiques, du rectangle source.  
  
 `nSrcHeight`  
 Spécifie la hauteur, en unités logiques, du rectangle source.  
  
 *Blend*  
 Spécifie un [BLENDFUNCTION](http://msdn.microsoft.com/library/windows/desktop/dd183393) structure.  
  
### <a name="return-value"></a>Valeur de retour  
 **TRUE** cas de réussite ; **FALSE**.  
  
### <a name="remarks"></a>Notes  
 Consultez [AlphaBlend](http://msdn.microsoft.com/library/windows/desktop/dd183351) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour plus d’informations.  
  
##  <a name="anglearc"></a>CDC::AngleArc  
 Dessine un arc et un segment de ligne.  
  
```  
BOOL AngleArc(
    int x,  
    int y,  
    int nRadius,  
    float fStartAngle,  
    float fSweepAngle);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du centre du cercle.  
  
 *y*  
 Spécifie la coordonnée y logique du centre du cercle.  
  
 *nRadius*  
 Spécifie le rayon du cercle en unités logiques. Cette valeur doit être positive.  
  
 *fStartAngle*  
 Spécifie l’angle de départ en degrés par rapport à l’axe des abscisses.  
  
 *fSweepAngle*  
 Spécifie l’angle de balayage en degrés par rapport à l’angle de départ.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le segment de ligne est dessiné à partir de la position actuelle vers le début de l’arc. L’arc est dessiné le long du périmètre d’un cercle avec le centre et le rayon donné. La longueur de l’arc est définie par les angles de début et de balayage donnés.  
  
 `AngleArc`Déplace la position actuelle jusqu'à la fin de l’arc. L’arc dessiné par cette fonction peut sembler être elliptique, selon le mode de transformation et le mappage actuel. Avant de dessiner l’arc, cette fonction Dessine le segment de ligne à partir de la position actuelle vers le début de l’arc. L’arc est dessiné en construisant un cercle imaginaire dont le rayon spécifié autour du point central spécifié. Le point de départ de l’arc est déterminé par la mesure dans le sens inverse à partir de l’axe des abscisses du cercle par le nombre de degrés de l’angle de début. Le point de fin se trouve de la même façon en mesurant dans le sens inverse à partir du point de départ par le nombre de degrés de l’angle de balayage.  
  
 Si l’angle de balayage est supérieur à 360 degrés l’arc est rangé plusieurs fois. Cette fonction dessine des lignes à l’aide du stylet courant. La figure n’est pas renseignée.  
  
##  <a name="arc"></a>CDC::arc  
 Dessine un arc elliptique.  
  
```  
BOOL Arc(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Arc(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x de l’angle supérieur gauche du rectangle englobant (en unités logiques).  
  
 `y1`  
 Spécifie la coordonnée y de l’angle supérieur gauche du rectangle englobant (en unités logiques).  
  
 `x2`  
 Spécifie la coordonnée x de l’angle inférieur droit du rectangle englobant (en unités logiques).  
  
 `y2`  
 Spécifie la coordonnée y du coin inférieur droit du rectangle englobant (en unités logiques).  
  
 *x3*  
 Spécifie le point (en unités logiques) de départ de la coordonnée x du point qui définit l’arc. Ce point n’a pas à se situer exactement sur l’arc.  
  
 `y3`  
 Spécifie le point (en unités logiques) de départ de la coordonnée y du point qui définit l’arc. Ce point n’a pas à se situer exactement sur l’arc.  
  
 `x4`  
 Spécifie la coordonnée x du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se situer exactement sur l’arc.  
  
 `y4`  
 Spécifie la coordonnée y du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se situer exactement sur l’arc.  
  
 `lpRect`  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer soit un `LPRECT` ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 `ptStart`  
 Spécifie les coordonnées x et y du point qui définit l’arc de départ de point (en unités logiques). Ce point n’a pas à se situer exactement sur l’arc. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
 `ptEnd`  
 Spécifie les coordonnées x et y du point qui définit le point de fin de l’arc (en unités logiques). Ce point n’a pas à se situer exactement sur l’arc. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 L’arc dessiné à l’aide de la fonction est un segment de l’ellipse définie par le rectangle englobant spécifié.  
  
 Point de début de l’arc est le point auquel un rayon dessiné à partir du centre du rectangle englobant via le point de départ spécifié entre en intersection avec les points de suspension. Le point de fin réels de l’arc est le point auquel un rayon dessiné à partir du centre du rectangle englobant via le point de fin spécifié entre en intersection avec les points de suspension. L’arc est dessiné dans une direction vers la gauche. Un arc n’étant pas une figure fermée, il n’est pas renseigné. La largeur et la hauteur du rectangle doivent être supérieures à 2 unités et inférieure à 32 767.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView #29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]  
  
##  <a name="arcto"></a>CDC::ArcTo  
 Dessine un arc elliptique.  
  
```  
BOOL ArcTo(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL ArcTo(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x de l’angle supérieur gauche du rectangle englobant (en unités logiques).  
  
 `y1`  
 Spécifie la coordonnée y de l’angle supérieur gauche du rectangle englobant (en unités logiques).  
  
 `x2`  
 Spécifie la coordonnée x de l’angle inférieur droit du rectangle englobant (en unités logiques).  
  
 `y2`  
 Spécifie la coordonnée y du coin inférieur droit du rectangle englobant (en unités logiques).  
  
 *x3*  
 Spécifie le point (en unités logiques) de départ de la coordonnée x du point qui définit l’arc. Ce point n’a pas à se situer exactement sur l’arc.  
  
 `y3`  
 Spécifie le point (en unités logiques) de départ de la coordonnée y du point qui définit l’arc. Ce point n’a pas à se situer exactement sur l’arc.  
  
 `x4`  
 Spécifie la coordonnée x du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se situer exactement sur l’arc.  
  
 `y4`  
 Spécifie la coordonnée y du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se situer exactement sur l’arc.  
  
 `lpRect`  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer soit un pointeur vers un [RECT](../../mfc/reference/rect-structure1.md) structure de données ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 `ptStart`  
 Spécifie les coordonnées x et y du point qui définit l’arc de départ de point (en unités logiques). Ce point n’a pas à se situer exactement sur l’arc. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure de données ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
 `ptEnd`  
 Spécifie les coordonnées x et y du point qui définit le point de fin de l’arc (en unités logiques). Ce point n’a pas à se situer exactement sur l’arc. Vous pouvez passer soit un **POINT** structure de données ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction est similaire à `CDC::Arc`, sauf que la position actuelle est mise à jour. Les points ( `x1`, `y1`) et ( `x2`, `y2`) définissent le rectangle englobant. Une ellipse formée par le rectangle donné définit la courbe de l’arc. L’arc s’étend dans le sens inverse (la direction par défaut d’arc de cercle) à partir du point où il entre en intersection avec la ligne radiale à partir du centre du rectangle englobant pour ( *x3*, `y3`). Les terminaisons d’arc de cercle où il entre en intersection avec la ligne radiale à partir du centre du rectangle englobant pour ( `x4`, `y4`). Si le point de départ et le point de fin sont identiques, une ellipse complète est dessinée.  
  
 Une ligne est tracée à partir de la position actuelle pour le point de départ de l’arc. Si aucune erreur ne se produit, la position actuelle est définie pour le point de fin de l’arc. L’arc est dessiné à l’aide du stylet actuel ; Il n’est pas renseigné.  
  
##  <a name="attach"></a>CDC::Attach  
 Cette fonction membre permet de joindre un `hDC` à la `CDC` objet.  
  
```  
BOOL Attach(HDC hDC);
```  
  
### <a name="parameters"></a>Paramètres  
 `hDC`  
 Un contexte de périphérique Windows.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le `hDC` sont stockées dans les deux `m_hDC`, le contexte de périphérique de sortie et dans `m_hAttribDC`, le contexte de l’attribut.  
  
##  <a name="beginpath"></a>CDC::BeginPath  
 Ouvre un crochet de chemin d’accès dans le contexte de périphérique.  
  
```  
BOOL BeginPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Après avoir ouvert un crochet de chemin d’accès, une application peut commencer l’appel de dessin des fonctions GDI pour définir les points qui se trouvent dans le chemin d’accès. Une application peut fermer un crochet de tracé ouvert en appelant le `EndPath` fonction membre. Lorsqu’une application appelle `BeginPath`, les chemins d’accès précédentes sont ignorés.  
  
 Consultez [BeginPath](http://msdn.microsoft.com/library/windows/desktop/dd183363) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour obtenir la liste des fonctions de dessin qui définissent les points dans un chemin d’accès.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView #30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]  
  
##  <a name="bitblt"></a>CDC::BitBlt  
 Copie une image bitmap à partir du contexte de périphérique source pour le contexte de périphérique en cours.  
  
```  
BOOL BitBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle de destination.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle de destination.  
  
 `nWidth`  
 Spécifie la largeur (en unités logiques) de la bitmap source et le rectangle de destination.  
  
 `nHeight`  
 Spécifie la hauteur (en unités logiques) de la bitmap source et le rectangle de destination.  
  
 `pSrcDC`  
 Pointeur vers un `CDC` objet qui identifie le contexte de périphérique à partir de laquelle la bitmap est copiée. Il doit être **NULL** si *dwRop* spécifie une opération de rastérisation qui n’inclut pas d’une source.  
  
 `xSrc`  
 Spécifie la coordonnée x logique de l’angle supérieur gauche de la bitmap source.  
  
 `ySrc`  
 Spécifie la coordonnée y logique de l’angle supérieur gauche de la bitmap source.  
  
 *dwRop*  
 Spécifie l'opération de rastérisation à effectuer. Codes d’opération de rastérisation définissent la façon dont GDI associe les couleurs dans les opérations de sortie qui impliquent le pinceau actuel, un éventuel bitmap source et une image bitmap de destination. Consultez [BitBlt](http://msdn.microsoft.com/library/windows/desktop/dd183370) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour obtenir la liste des codes d’opération de rastérisation pour *dwRop* et leurs descriptions  
  
 Pour obtenir une liste complète des codes d’opération de rastérisation, consultez [sur opération de rastérisation](http://msdn.microsoft.com/library/windows/desktop/dd162892) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 L’application peut aligner les fenêtres ou les zones clientes sur des limites d’octets pour vous assurer que le `BitBlt` se produisent dans les rectangles d’aligné sur un octet. (Définir le **CS_BYTEALIGNWINDOW** ou **CS_BYTEALIGNCLIENT** indicateurs lorsque vous inscrivez les classes de fenêtre.)  
  
 `BitBlt`opérations sur les rectangles d’aligné sur un octet sont beaucoup plus rapides que `BitBlt` opérations sur les rectangles qui ne sont pas alignées sur octets. Si vous souhaitez spécifier les styles de classe telles que de l’alignement des octets pour votre propre contexte de périphérique, vous devrez inscrire une classe de fenêtre au lieu de compter sur les classes Microsoft Foundation à faire pour vous. Utilisez la fonction globale [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).  
  
 GDI transforme `nWidth` et `nHeight`, en utilisant le contexte de périphérique de destination et qu’une seule fois à l’aide du contexte du périphérique source. Si les extensions qui en résulte ne correspondent pas, GDI utilise Windows `StretchBlt` afin de compresser ou étirer le bitmap source selon les besoins.  
  
 Si les bitmaps de modèle, source et de destination n’ont pas le même format de couleur, la `BitBlt` fonction convertit les bitmaps source et le modèle pour correspondre à la destination. Les couleurs de premier plan et d’arrière-plan de la bitmap de destination sont utilisés dans la conversion.  
  
 Lorsque le `BitBlt` fonction convertit un bitmap monochrome en couleur, il définit les bits blancs (1) pour la couleur d’arrière-plan et les bits noirs (0) à la couleur de premier plan. Les couleurs de premier plan et d’arrière-plan du contexte de périphérique de destination sont utilisées. Pour convertir la couleur en monochrome, `BitBlt` définit les pixels qui correspondent à la couleur d’arrière-plan en blanc et définit tous les autres pixels sur noir. `BitBlt`utilise les couleurs de premier plan et d’arrière-plan du contexte de périphérique de couleur pour convertir à partir de la couleur en monochrome.  
  
 Notez que la prise en charge pas tous les contextes de périphérique `BitBlt`. Pour vérifier si un contexte de périphérique donné ne prend pas en charge `BitBlt`, utilisez le `GetDeviceCaps` membre de fonction et spécifiez le **RASTERCAPS** index.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::CreateCompatibleDC](#createcompatibledc).  
  
##  <a name="cdc"></a>CDC::CDC  
 Construit un objet `CDC`.  
  
```  
CDC();
```  
  
##  <a name="chord"></a>CDC::Chord  
 Dessine un segment (une figure fermée délimitée par l’intersection d’une ellipse et un segment de ligne).  
  
```  
BOOL Chord(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Chord(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie que la coordonnée x du coin supérieur gauche de la pression simultanée de délimitation rectangle (en unités logiques).  
  
 `y1`  
 Spécifie que la coordonnée y du coin supérieur gauche de la pression simultanée de délimitation rectangle (en unités logiques).  
  
 `x2`  
 Spécifie que la coordonnée x du coin inférieur droit de la pression simultanée de délimitation rectangle (en unités logiques).  
  
 `y2`  
 Spécifie que la coordonnée y du coin inférieur droit de la pression simultanée de délimitation rectangle (en unités logiques).  
  
 *x3*  
 Spécifie la coordonnée x du point qui définit la pression simultanée de départ de point (en unités logiques).  
  
 `y3`  
 Spécifie la coordonnée y du point qui définit la pression simultanée de départ de point (en unités logiques).  
  
 `x4`  
 Spécifie la coordonnée x du point qui définit le point de terminaison de la pression simultanée (en unités logiques).  
  
 `y4`  
 Spécifie la coordonnée y du point qui définit le point de terminaison de la pression simultanée (en unités logiques).  
  
 `lpRect`  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer soit un `LPRECT` ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 `ptStart`  
 Spécifie les coordonnées x et y du point qui définit la pression simultanée de départ de point (en unités logiques). Ce point n’a pas à se situer exactement sur la pression simultanée. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
 `ptEnd`  
 Spécifie les coordonnées x et y du point qui définit le point de fin de la pression simultanée (en unités logiques). Ce point n’a pas à se situer exactement sur la pression simultanée. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le ( `x1`, `y1`) et ( `x2`, `y2`) paramètres spécifient respectivement les angles supérieur gauche et à droite, d’un rectangle englobant de l’ellipse qui fait partie de la pression simultanée. Le ( *x3*, `y3`) et ( `x4`, `y4`) les paramètres spécifient les points de terminaison d’une ligne qui coupe l’ellipse. La pression simultanée est dessinée à l’aide du stylet sélectionné et remplie à l’aide de la forme sélectionnée.  
  
 La figure dessinée par le `Chord` fonction étend jusqu'à, mais n’inclut pas les coordonnées de droite et en bas. Cela signifie que la hauteur de la figure est `y2`  -  `y1` et la largeur de la figure est `x2`  -  `x1`.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView #31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]  
  
##  <a name="closefigure"></a>CDC::CloseFigure  
 Ferme une figure ouverte dans un chemin d’accès.  
  
```  
BOOL CloseFigure();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 La fonction ferme la figure en dessinant une ligne à partir de la position actuelle et le premier point de la figure (en règle générale, le point spécifié par l’appel le plus récent pour le `MoveTo` fonction membre) et se connecte les lignes en utilisant le style de ligne de jointure. Si une figure est fermée à l’aide de la `LineTo` fonction membre au lieu de `CloseFigure`, majuscules sont utilisées pour créer l’angle au lieu d’une jointure. `CloseFigure`doit être appelée uniquement s’il existe un crochet de tracé ouvert dans le contexte de périphérique.  
  
 Figure dans un chemin d’accès est ouverte, sauf si elle est fermée explicitement à l’aide de cette fonction. (Figure peut être ouverte même si le point actuel et le point de départ de l’illustration sont les mêmes.) N’importe quel ou ajouté au chemin après une courbe `CloseFigure` démarre une nouvelle figure.  
  
##  <a name="createcompatibledc"></a>CDC::CreateCompatibleDC  
 Crée un contexte de périphérique de mémoire qui est compatible avec le périphérique spécifié par `pDC`.  
  
```  
BOOL CreateCompatibleDC(CDC* pDC);
```  
  
### <a name="parameters"></a>Paramètres  
 `pDC`  
 Pointeur vers un contexte de périphérique. Si `pDC` est **NULL**, la fonction crée un contexte de périphérique de mémoire qui est compatible avec l’affichage du système.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Un contexte de périphérique de mémoire est un bloc de mémoire qui représente une surface d’affichage. Il peut être utilisé pour préparer des images en mémoire avant de les copier vers la surface de périphérique réel de l’appareil compatible.  
  
 Lors de la création d’un contexte de périphérique de mémoire, GDI sélectionne automatiquement un bitmap de stock monochrome 1-par-1 pour celui-ci. Fonctions de sortie GDI peuvent être utilisées avec un contexte de périphérique de mémoire que si une image bitmap a été créée et sélectionnée dans ce contexte.  
  
 Cette fonction peut uniquement être utilisée pour créer des contextes de périphérique compatible pour les appareils qui prennent en charge les opérations raster. Consultez le [CDC::BitBlt](#bitblt) fonction membre pour plus d’informations concernant les transferts de bloc de bits entre les contextes de périphérique. Pour déterminer si un contexte de périphérique prend en charge les opérations raster, consultez le **RC_BITBLT** fonctionnalité raster dans la fonction membre `CDC::GetDeviceCaps`.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView #32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]  
  
##  <a name="createdc"></a>CDC::CreateDC  
 Crée un contexte de périphérique pour le périphérique spécifié.  
  
```  
BOOL CreateDC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszDriverName`  
 Pointe vers une chaîne se terminant par null qui spécifie le nom de fichier (sans extension) du pilote de périphérique (par exemple, « EPSON »). Vous pouvez également passer un `CString` objet pour ce paramètre.  
  
 `lpszDeviceName`  
 Pointe vers une chaîne se terminant par null qui spécifie le nom du périphérique à être pris en charge (par exemple, « EPSON FX-80 »). Le `lpszDeviceName` paramètre est utilisé si le module prend en charge plusieurs périphériques. Vous pouvez également passer un `CString` objet pour ce paramètre.  
  
 `lpszOutput`  
 Pointe vers une chaîne se terminant par null qui spécifie le nom de fichier ou un périphérique pour la sortie physique du port de fichier ou sortie. Vous pouvez également passer un `CString` objet pour ce paramètre.  
  
 `lpInitData`  
 Pointe vers un `DEVMODE` structure contenant des données d’initialisation spécifique au périphérique pour le pilote de périphérique. Les fenêtres **DocumentProperties** fonction récupère cette structure renseignée pour un appareil donné. Le `lpInitData` le paramètre doit être **NULL** si le pilote de périphérique est d’utiliser l’initialisation par défaut (le cas échéant) est spécifiée par l’utilisateur via le panneau de configuration.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 L’impression. Fichier d’en-tête H est requis si le [DEVMODE](http://msdn.microsoft.com/library/windows/desktop/dd183565) structure est utilisée.  
  
 Les noms des périphériques respectent ces conventions : une fin (deux-points) est recommandé mais facultatif. Windows supprime les deux points de terminaison afin qu’un nom de périphérique se terminant par un signe deux-points est mappé sur le même port que le même nom sans les deux-points. Les noms de pilote et le port ne doivent pas contenir des espaces de début ou de fin. Fonctions de sortie GDI ne peut pas être utilisées avec des contextes d’informations.  
  
##  <a name="createic"></a>CDC::CreateIC  
 Crée un contexte d’information pour le périphérique spécifié.  
  
```  
BOOL CreateIC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszDriverName`  
 Pointe vers une chaîne se terminant par null qui spécifie le nom de fichier (sans extension) du pilote de périphérique (par exemple, « EPSON »). Vous pouvez passer un `CString` objet pour ce paramètre.  
  
 `lpszDeviceName`  
 Pointe vers une chaîne se terminant par null qui spécifie le nom du périphérique à être pris en charge (par exemple, « EPSON FX-80 »). Le `lpszDeviceName` paramètre est utilisé si le module prend en charge plusieurs périphériques. Vous pouvez passer un `CString` objet pour ce paramètre.  
  
 `lpszOutput`  
 Pointe vers une chaîne se terminant par null qui spécifie le nom de fichier ou un périphérique pour le support de sortie physique (fichier ou le port). Vous pouvez passer un `CString` objet pour ce paramètre.  
  
 `lpInitData`  
 Points de données d’initialisation spécifique au périphérique pour le pilote de périphérique. Le `lpInitData` le paramètre doit être **NULL** si le pilote de périphérique est d’utiliser l’initialisation par défaut (le cas échéant) est spécifiée par l’utilisateur via le panneau de configuration. Consultez `CreateDC` pour le format de données pour l’initialisation spécifique au périphérique.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le contexte d’information fournit un moyen rapide pour obtenir des informations sur l’appareil sans créer un contexte de périphérique.  
  
 Les noms des périphériques respectent ces conventions : une fin (deux-points) est recommandé mais facultatif. Windows supprime les deux points de terminaison afin qu’un nom de périphérique se terminant par un signe deux-points est mappé sur le même port que le même nom sans les deux-points. Les noms de pilote et le port ne doivent pas contenir des espaces de début ou de fin. Fonctions de sortie GDI ne peut pas être utilisées avec des contextes d’informations.  
  
##  <a name="deletedc"></a>CDC::DeleteDC  
 En règle générale, n’appelez pas de cette fonction ; le destructeur faire pour vous.  
  
```  
BOOL DeleteDC();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la fonction a été effectuée avec succès ; Sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le `DeleteDC` fonction membre supprime les contextes de périphérique Windows qui sont associées aux `m_hDC` en cours `CDC` objet. Si cette `CDC` objet est le contexte de périphérique actif dernier pour un périphérique donné, le périphérique est notifié et toutes les ressources système et de stockage utilisées par le périphérique sont libérés.  
  
 Une application ne doit pas appeler `DeleteDC` si l’objet a été sélectionné dans le contexte de périphérique. Objets doivent être sélectionnés en premier hors du contexte de périphérique avant d’être supprimé.  
  
 Une application ne doit pas supprimer un contexte de périphérique dont le handle a été obtenu en appelant [CWnd::GetDC](../../mfc/reference/cwnd-class.md#getdc). Au lieu de cela, il doit appeler [CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) pour libérer le contexte de périphérique. Le [CClientDC](../../mfc/reference/cclientdc-class.md) et [CWindowDC](../../mfc/reference/cwindowdc-class.md) classes sont fournies pour encapsuler ces fonctionnalités.  
  
 Le `DeleteDC` fonction est généralement utilisée pour supprimer des contextes de périphérique créés avec [CreateDC](#createdc), [CreateIC](#createic), ou [CreateCompatibleDC](#createcompatibledc).  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).  
  
##  <a name="deletetempmap"></a>CDC::DeleteTempMap  
 Appelé automatiquement par le `CWinApp` Gestionnaire de durée d’inactivité, `DeleteTempMap` supprime tout temporaire `CDC` les objets créés par `FromHandle`, mais ne détruit ne pas les handles de contexte de périphérique ( `hDC`s) temporairement associé à la `CDC` objets.  
  
```  
static void PASCAL DeleteTempMap();
```  
  
##  <a name="detach"></a>CDC::Detach  
 Appelez cette fonction pour détacher `m_hDC` (le contexte de périphérique de sortie) à partir de la `CDC` de l’objet et définissez les options `m_hDC` et `m_hAttribDC` à **NULL**.  
  
```  
HDC Detach();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un contexte de périphérique Windows.  
  
##  <a name="dptohimetric"></a>CDC::DPtoHIMETRIC  
 Utilisez cette fonction lorsque vous accordez **HIMETRIC** tailles à OLE, conversion de pixels à **HIMETRIC**.  
  
```  
void DPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpSize`  
 Pointe vers un [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 Si le mode de mappage de l’objet de contexte de périphérique est `MM_LOENGLISH`, `MM_HIENGLISH`, `MM_LOMETRIC`, ou `MM_HIMETRIC`, la conversion est basée sur le nombre de pixels dans le pouce physique. Si le mode de mappage est un des autres modes non limité (par exemple, `MM_TEXT`), la conversion est basée sur le nombre de pixels dans le pouce logique.  
  
##  <a name="dptolp"></a>CDC::DPtoLP  
 Convertit des unités de périphérique dans des unités logiques.  
  
```  
void DPtoLP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) structures ou [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objets.  
  
 `nCount`  
 Le nombre de points dans le tableau.  
  
 `lpRect`  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet. Ce paramètre est utilisé pour le cas le plus simple de conversion d’un rectangle à partir de points de l’appareil en points logiques.  
  
 `lpSize`  
 Pointe vers un [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 La fonction mappe les coordonnées de chaque point, ou une dimension d’une taille, dans le système de coordonnées de périphérique dans le système de coordonnées logiques du GDI. La conversion varie selon le mode de mappage en cours et les paramètres de l’origine et les extensions de fenêtre et de la fenêtre d’affichage du périphérique.  
  
##  <a name="draw3drect"></a>CDC::Draw3dRect  
 Appelez cette fonction membre pour dessiner un rectangle en trois dimensions.  
  
```  
void Draw3dRect(
    LPCRECT lpRect,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);

 
void Draw3dRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer soit un pointeur vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 *clrTopLeft*  
 Spécifie la couleur des côtés supérieure et gauche du rectangle à trois dimensions.  
  
 `clrBottomRight`  
 Spécifie la couleur de la partie inférieure et droite du rectangle à trois dimensions.  
  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle à trois dimensions.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle à trois dimensions.  
  
 CX  
 Spécifie la largeur du rectangle à trois dimensions.  
  
 CY  
 Spécifie la hauteur du rectangle à trois dimensions.  
  
### <a name="remarks"></a>Remarques  
 Le rectangle sera dessiné avec les côtés supérieure et gauche de la couleur spécifiée par *clrTopLeft* et le bas et à droite dans la couleur spécifiée par `clrBottomRight`.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView #33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]  
  
##  <a name="drawdragrect"></a>CDC::DrawDragRect  
 Appelez cette fonction membre à plusieurs reprises pour redessiner un rectangle de glissement.  
  
```  
void DrawDragRect(
    LPCRECT lpRect,  
    SIZE size,  
    LPCRECT lpRectLast,  
    SIZE sizeLast,  
    CBrush* pBrush = NULL,  
    CBrush* pBrushLast = NULL);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui spécifie les coordonnées logiques d’un rectangle, dans ce cas, la position de fin du rectangle redessinée.  
  
 `size`  
 Spécifie le déplacement à partir de l’angle supérieur gauche de la bordure externe à l’angle supérieur gauche de la bordure interne (autrement dit, l’épaisseur de la bordure) d’un rectangle.  
  
 `lpRectLast`  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui spécifie les coordonnées logiques de la position d’un rectangle, dans ce cas, la position d’origine du rectangle redessinée.  
  
 *sizeLast*  
 Spécifie le déplacement à partir de l’angle supérieur gauche de la bordure externe à l’angle supérieur gauche de la bordure interne (autrement dit, l’épaisseur de la bordure) du rectangle d’origine est redessiné.  
  
 `pBrush`  
 Pointeur vers un objet de pinceau. La valeur **NULL** à utiliser le pinceau de demi-teintes par défaut.  
  
 *pBrushLast*  
 Pointeur vers le dernier objet pinceau utilisé. La valeur **NULL** à utiliser le pinceau de demi-teintes par défaut.  
  
### <a name="remarks"></a>Remarques  
 Appeler dans une boucle que des exemples de la position de la souris, pour fournir une rétroaction visuelle. Lorsque vous appelez `DrawDragRect`, le rectangle précédent est effacé et un autre est dessiné. Par exemple, en tant que l’utilisateur fait glisser un rectangle sur l’écran, `DrawDragRect` supprimera le rectangle d’origine et redessiner un dans sa nouvelle position. Par défaut, `DrawDragRect` Dessine le rectangle à l’aide d’un pinceau de demi-teintes pour éliminer le scintillement et pour créer l’apparence d’un rectangle sans heurts mobile.  
  
 La première fois que vous appelez `DrawDragRect`, le `lpRectLast` le paramètre doit être **NULL**.  
  
##  <a name="drawedge"></a>CDC::DrawEdge  
 Appelez cette fonction membre pour dessiner les bords d’un rectangle du type spécifié et du style.  
  
```  
BOOL DrawEdge(
    LPRECT lpRect,  
    UINT nEdge,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Un pointeur vers un **RECT** structure qui contient les coordonnées logiques du rectangle.  
  
 *nEdge*  
 Spécifie le type de bordure interne et externe à dessiner. Ce paramètre doit être une combinaison d’un indicateur de la bordure interne et un indicateur de la bordure externe. Consultez [DrawEdge](http://msdn.microsoft.com/library/windows/desktop/dd162477) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour un tableau de types du paramètre.  
  
 `nFlags`  
 Indicateurs qui spécifient le type de bordure à dessiner. Consultez `DrawEdge` dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour une table des valeurs du paramètre. Pour les lignes en diagonale, les **BF_RECT** indicateurs spécifient le point de terminaison du vecteur délimité par le paramètre de rectangle.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
##  <a name="drawescape"></a>CDC::DrawEscape  
 Accès aux fonctions qui ne sont pas directement disponibles via l’interface GDI (GDI) d’un moniteur vidéo de dessin.  
  
```  
int DrawEscape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData);
```  
  
### <a name="parameters"></a>Paramètres  
 `nEscape`  
 Spécifie la fonction d’échappement à effectuer.  
  
 `nInputSize`  
 Spécifie le nombre d’octets de données vers lequel pointées le `lpszInputData` paramètre.  
  
 `lpszInputData`  
 Pointe vers la structure d’entrée requis pour la séquence d’échappement spécifiée.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le résultat de la fonction. Supérieure à zéro en cas de réussite, à l’exception de la **QUERYESCSUPPORT** dessiner d’échappement, quels contrôles de mise en œuvre uniquement ; ou zéro si la séquence d’échappement n’est pas implémentée ; ou inférieur à zéro si une erreur s’est produite.  
  
### <a name="remarks"></a>Notes  
 Lorsqu’une application appelle `DrawEscape`, les données identifiées par `nInputSize` et `lpszInputData` est transmise directement au pilote d’affichage spécifié.  
  
##  <a name="drawfocusrect"></a>CDC::DrawFocusRect  
 Dessine un rectangle dans le style utilisé pour indiquer que le rectangle a le focus.  
  
```  
void DrawFocusRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui spécifie les coordonnées logiques du rectangle à dessiner.  
  
### <a name="remarks"></a>Remarques  
 Dans la mesure où il s’agit d’une fonction booléenne XOR, appel de cette fonction une seconde fois avec le même rectangle supprime le rectangle à partir de l’affichage. Le rectangle dessiné par cette fonction ne peut pas être l’objet d’un défilement. Pour faire défiler une zone qui contient un rectangle dessiné par cette fonction, appelez d’abord `DrawFocusRect` pour supprimer l’affichage du rectangle, puis faites défiler la zone, puis appelez `DrawFocusRect` pour dessiner le rectangle dans la nouvelle position.  
  
> [!CAUTION]
> `DrawFocusRect`fonctionne uniquement dans `MM_TEXT` mode. Dans les autres modes, cette fonction ne consomme pas correctement le rectangle de focus, mais elle ne retourne pas de valeurs d’erreur.  
  
##  <a name="drawframecontrol"></a>CDC::DrawFrameControl  
 Appelez cette fonction membre pour dessiner un contrôle frame du type spécifié et du style.  
  
```  
BOOL DrawFrameControl(
    LPRECT lpRect,  
    UINT nType,  
    UINT nState);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Un pointeur vers un **RECT** structure qui contient les coordonnées logiques du rectangle.  
  
 `nType`  
 Spécifie le type de contrôle image à dessiner. Consultez le *uType* paramètre dans [DrawFrameControl](http://msdn.microsoft.com/library/windows/desktop/dd162480) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour obtenir la liste des valeurs possibles de ce paramètre.  
  
 `nState`  
 Spécifie l’état initial du contrôle frame. Peut être une ou plusieurs des valeurs décrites pour le *uState* paramètre dans `DrawFrameControl` dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. Utilisez le `nState` valeur **DFCS_ADJUSTRECT** pour ajuster le rectangle englobant pour exclure le bord environnant du bouton de commande.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Dans certains cas, `nState` dépend de la `nType` paramètre. La liste suivante montre la relation entre les quatre `nType` valeurs et `nState`:  
  
- **DFC_BUTTON**  
  
    - **DFCS_BUTTON3STATE** bouton à trois États  
  
    - **DFCS_BUTTONCHECK** case à cocher  
  
    - **DFCS_BUTTONPUSH** bouton de commande  
  
    - **DFCS_BUTTONRADIO** case d’option  
  
    - **DFCS_BUTTONRADIOIMAGE** Image pour le bouton radio (carrés doit image)  
  
    - **DFCS_BUTTONRADIOMASK** masque pour la case d’option (carrés doit masque)  
  
- **DFC_CAPTION**  
  
    - **DFCS_CAPTIONCLOSE** bouton Fermer  
  
    - **DFCS_CAPTIONHELP** bouton d’aide  
  
    - **DFCS_CAPTIONMAX** bouton Agrandir  
  
    - **DFCS_CAPTIONMIN** bouton réduire  
  
    - **DFCS_CAPTIONRESTORE** bouton Restaurer  
  
- **DFC_MENU**  
  
    - **DFCS_MENUARROW** flèche de sous-menu  
  
    - **DFCS_MENUBULLET** puce  
  
    - **DFCS_MENUCHECK** case à cocher  
  
- **DFC_SCROLL**  
  
    - **DFCS_SCROLLCOMBOBOX** barre de défilement de la liste déroulante  
  
    - **DFCS_SCROLLDOWN** flèche de barre de défilement vers le bas  
  
    - **DFCS_SCROLLLEFT** flèche vers la gauche de la barre de défilement  
  
    - **DFCS_SCROLLRIGHT** flèche droite de la barre de défilement  
  
    - **DFCS_SCROLLSIZEGRIP** poignée de dimensionnement dans le coin inférieur droit de la fenêtre  
  
    - **DFCS_SCROLLUP** haut de la barre de défilement  
  
### <a name="example"></a>Exemple  
 Ce code dessine la barre de redimensionnement de taille dans le coin inférieur droit de la fenêtre. Il est approprié pour le `OnPaint` Gestionnaire de boîte de dialogue, qui ne dispose d’aucun style et qui normalement ne contiennent d’autres contrôles (par exemple, une barre d’état) qui peuvent lui donner une barre de redimensionnement de taille.  
  
 [!code-cpp[NVC_MFCDocView #34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]  
  
##  <a name="drawicon"></a>CDC::DrawIcon  
 Dessine une icône sur le périphérique représenté par les `CDC` objet.  
  
```  
BOOL DrawIcon(
    int x,  
    int y,  
    HICON hIcon);

 
BOOL DrawIcon(
    POINT point,  
    HICON hIcon);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche de l’icône.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche de l’icône.  
  
 `hIcon`  
 Identifie le handle de l’icône doit être dessiné.  
  
 `point`  
 Spécifie la logique coordonnées x et y-de l’angle supérieur gauche de l’icône. Vous pouvez passer un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la fonction a été effectuée avec succès ; Sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La fonction place le coin supérieur gauche de l’icône à l’emplacement spécifié par *x* et *y*. L’emplacement est soumis au mode de mappage en cours du contexte de périphérique.  
  
 La ressource icône doit avoir été précédemment chargée à l’aide de fonctions `CWinApp::LoadIcon`, `CWinApp::LoadStandardIcon`, ou `CWinApp::LoadOEMIcon`. Le `MM_TEXT` mode de mappage doit être sélectionné avant d’utiliser cette fonction.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).  
  
##  <a name="drawstate"></a>CDC::DrawState  
 Appelez cette fonction membre pour afficher une image et applique un effet visuel pour indiquer un état, par exemple un désactivé ou l’état par défaut.  
  
> [!NOTE]
>  Pour toutes les `nFlag` États sauf **DSS_NORMAL**, l’image est convertie en monochrome avant que l’effet est appliqué.  
  
```  
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HBITMAP hBitmap,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    CBitmap* pBitmap,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    CBrush* pBrush = NULL);
```  
  
### <a name="parameters"></a>Paramètres  
 `pt`  
 Spécifie l’emplacement de l’image.  
  
 `size`  
 Spécifie la taille de l’image.  
  
 `hBitmap`  
 Handle vers une image bitmap.  
  
 `nFlags`  
 Indicateurs qui spécifient le type d’image et l’état. Consultez [DrawState](http://msdn.microsoft.com/library/windows/desktop/dd162496) dans les [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour maximum `nFlags` types et les États.  
  
 `hBrush`  
 Un handle d’un pinceau.  
  
 `pBitmap`  
 Pointeur vers un objet CBitmap.  
  
 `pBrush`  
 Pointeur vers un objet CBrush.  
  
 `hIcon`  
 Un handle d’une icône.  
  
 `lpszText`  
 Un pointeur de texte.  
  
 *bPrefixText*  
 Texte qui peut contenir un mnémonique de l’accélérateur. Le `lData` paramètre spécifie l’adresse de la chaîne et le `nTextLen` paramètre spécifie la longueur. Si `nTextLen` est 0, la chaîne est supposée pour être terminée par null.  
  
 `nTextLen`  
 Longueur de la chaîne pointée par `lpszText`. Si `nTextLen` est 0, la chaîne est supposée pour être terminée par null.  
  
 *lpDrawProc*  
 Pointeur vers une fonction de rappel utilisé pour restituer une image. Ce paramètre est obligatoire si le type de l’image dans `nFlags` est **DST_COMPLEX**. Il est facultatif et peut être **NULL** si le type d’image est **DST_TEXT**. Pour tous les autres types d’image, ce paramètre est ignoré. Pour plus d’informations sur la fonction de rappel, consultez la [DrawStateProc](http://msdn.microsoft.com/library/windows/desktop/dd162497) de fonction dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
 `lData`  
 Spécifie des informations sur l’image. La signification de ce paramètre dépend du type d’image.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
##  <a name="drawtext"></a>CDC::DrawText  
 Appelez cette fonction membre pour mettre en forme le texte dans le rectangle donné. Pour spécifier les options de mise en forme supplémentaires, utilisez [CDC::DrawTextEx](#drawtextex).  
  
```  
virtual int DrawText(
    LPCTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat);

 
int DrawText(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszString`  
 Pointe vers la chaîne à dessiner. Si `nCount` est -1, la chaîne doit être terminée par null.  
  
 `nCount`  
 Spécifie le nombre de caractères dans la chaîne. Si `nCount` est -1, puis `lpszString` est supposé pour être un pointeur long vers une chaîne se terminant par null et `DrawText` calcule le nombre de caractères automatiquement.  
  
 `lpRect`  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui contient le rectangle dans lequel le texte doit être mis en forme (en coordonnées logiques).  
  
 `str`  
 A [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet qui contient les caractères spécifiés à dessiner.  
  
 `nFormat`  
 Spécifie la méthode de mise en forme le texte. Il peut être n’importe quelle combinaison des valeurs décrites pour le `uFormat` paramètre dans [DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. (combiner à l’aide de l’opérateur OR au niveau du bit) :  
  
> [!NOTE]
>  Certains `uFormat` combinaisons d’indicateur peuvent provoquer la chaîne passée à modifier. À l’aide de **DT_MODIFYSTRING** avec l’option **DT_END_ELLIPSIS** ou **DT_PATH_ELLIPSIS** peut entraîner une chaîne à être modifié, à l’origine d’une assertion dans le `CString` remplacer. Les valeurs `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, et `DT_NOPREFIX` ne peut pas être utilisé avec le `DT_TABSTOP` valeur.  
  
### <a name="return-value"></a>Valeur de retour  
 La hauteur du texte si la fonction réussit.  
  
### <a name="remarks"></a>Remarques  
 Il forme le texte en développant des onglets dans les espaces appropriés, aligner le texte à gauche, droite, ou au centre du rectangle donné et avec rupture du texte dans les lignes qui tiennent dans le rectangle donné. Le type de mise en forme est spécifié par `nFormat`.  
  
 Cette fonction membre utilise la police sélectionnée le contexte de périphérique, de couleur du texte et de couleur d’arrière-plan pour dessiner le texte. À moins que le `DT_NOCLIP` format est utilisé, `DrawText` découpe le texte afin que le texte n’apparaît pas en dehors du rectangle donné. Toute mise en forme est supposée pour avoir plusieurs lignes, sauf si le `DT_SINGLELINE` format est indiqué.  
  
 Si la police sélectionnée est trop grande pour le rectangle spécifié, le `DrawText` fonction membre ne tente pas de remplacer une police plus petite.  
  
 Si le `DT_CALCRECT` indicateur est spécifié, le rectangle spécifié par `lpRect` sera mise à jour pour refléter la largeur et la hauteur nécessaire pour dessiner le texte.  
  
 Si le **TA_UPDATECP** indicateur d’alignement de texte a été défini (consultez [CDC::SetTextAlign](#settextalign)), `DrawText` affichera le texte commençant à la position actuelle, plutôt qu’à gauche du rectangle donné. `DrawText`encapsule pas texte lors de la **TA_UPDATECP** indicateur a été défini (autrement dit, le `DT_WORDBREAK` indicateur n’a aucun effet).  
  
 La couleur du texte peut être définie en [CDC::SetTextColor](#settextcolor).  
  
##  <a name="drawtextex"></a>CDC::DrawTextEx  
 Met en forme le texte dans le rectangle donné.  
  
```  
virtual int DrawTextEx(
    LPTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

 
int DrawTextEx(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszString`  
 Pointe vers la chaîne à dessiner. Si `nCount` est -1, la chaîne doit se terminer par null.  
  
 `nCount`  
 Spécifie le nombre de caractères dans la chaîne. Si `nCount` est -1, puis `lpszString` est supposé pour être un pointeur long vers une chaîne se terminant par null et `DrawText` calcule le nombre de caractères automatiquement.  
  
 `lpRect`  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui contient le rectangle dans lequel le texte doit être mis en forme (en coordonnées logiques).  
  
 `str`  
 A [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet qui contient les caractères spécifiés à dessiner.  
  
 `nFormat`  
 Spécifie la méthode de mise en forme le texte. Il peut être n’importe quelle combinaison des valeurs décrites pour le `uFormat` paramètre dans [DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. (Combiner à l’aide de l’opérateur de bits `OR` opérateur) :  
  
> [!NOTE]
>  Certains `uFormat` combinaisons d’indicateur peuvent provoquer la chaîne passée à modifier. À l’aide de **DT_MODIFYSTRING** avec l’option **DT_END_ELLIPSIS** ou **DT_PATH_ELLIPSIS** peut entraîner une chaîne à être modifié, à l’origine d’une assertion dans le `CString` remplacer. Les valeurs `DT_CALCRECT`, `DT_EXTERNALLEADING`, **DT_INTERNAL**, `DT_NOCLIP`, et `DT_NOPREFIX` ne peut pas être utilisé avec le `DT_TABSTOP` valeur.  
  
 `lpDTParams`  
 Pointeur vers un [DRAWTEXTPARAMS](http://msdn.microsoft.com/library/windows/desktop/dd162500) options de structure qui spécifie la mise en forme supplémentaires. Ce paramètre peut être **NULL**.  
  
### <a name="remarks"></a>Remarques  
 Il forme le texte en développant des onglets dans les espaces appropriés, aligner le texte à gauche, droite, ou au centre du rectangle donné et avec rupture du texte dans les lignes qui tiennent dans le rectangle donné. Le type de mise en forme est spécifié par `nFormat` et `lpDTParams`. Pour plus d’informations, consultez [CDC::DrawText](#drawtext) et [DrawTextEx](http://msdn.microsoft.com/library/windows/desktop/dd162499) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
 La couleur du texte peut être définie en [CDC::SetTextColor](#settextcolor).  
  
##  <a name="ellipse"></a>CDC::ellipse  
 Dessine une ellipse.  
  
```  
BOOL Ellipse(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Ellipse(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle englobant de l’ellipse.  
  
 `y1`  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle englobant de l’ellipse.  
  
 `x2`  
 Spécifie la coordonnée x logique de l’angle inférieur droit du rectangle englobant de l’ellipse.  
  
 `y2`  
 Spécifie la coordonnée y logique de l’angle inférieur droit du rectangle englobant de l’ellipse.  
  
 `lpRect`  
 Spécifie que les points de suspension du rectangle englobant. Vous pouvez également passer un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le centre de l’ellipse est le centre du rectangle englobant spécifié par `x1`, `y1`, `x2`, et `y2`, ou `lpRect`. Les points de suspension est dessiné avec le stylet actuel et ses intérieur est rempli avec le pinceau actuel.  
  
 La figure dessinée par cette fonction étend jusqu'à, mais n’inclut pas les coordonnées de droite et en bas. Cela signifie que la hauteur de la figure est `y2`  -  `y1` et la largeur de la figure est `x2`  -  `x1`.  
  
 Si la largeur ou la hauteur du rectangle englobant est 0, aucune sélection n’est dessinée.  
  
##  <a name="enddoc"></a>CDC::EndDoc  
 Met fin à un travail d’impression démarré par un appel à la [StartDoc](#startdoc) fonction membre.  
  
```  
int EndDoc();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Supérieur ou égal à 0 si la fonction réussit, ou une valeur négative si une erreur s’est produite.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre remplace le **ENDDOC** échappement de l’imprimante et doit être appelée immédiatement après la fin d’un travail d’impression.  
  
 Si une application rencontre une erreur d’impression ou d’une opération d’impression annulée, il ne devez pas tenter de terminer l’opération à l’aide `EndDoc` ou [AbortDoc](#abortdoc). GDI termine automatiquement l’opération avant de retourner la valeur d’erreur.  
  
 Cette fonction ne doit pas être utilisée à l’intérieur des métafichiers.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::StartDoc](#startdoc).  
  
##  <a name="endpage"></a>CDC::EndPage  
 Informe le périphérique que l’application a terminé l’écriture dans une page.  
  
```  
int EndPage();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Supérieur ou égal à 0 si la fonction réussit, ou une valeur négative si une erreur s’est produite.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre est généralement utilisée pour diriger le pilote de périphérique pour passer à une nouvelle page.  
  
 Cette fonction membre remplace le **NEWFRAME** échappement de l’imprimante. Contrairement aux **NEWFRAME**, cette fonction est toujours appelée après l’impression d’une page.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::StartDoc](#startdoc).  
  
##  <a name="endpath"></a>CDC::EndPath  
 Ferme un crochet de chemin d’accès et de sélectionner le chemin d’accès défini par le crochet dans le contexte de périphérique.  
  
```  
BOOL EndPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="enumobjects"></a>CDC::EnumObjects  
 Énumère les stylets et pinceaux disponibles dans un contexte de périphérique.  
  
```  
int EnumObjects(
    int nObjectType,  
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),  
    LPARAM lpData);
```  
  
### <a name="parameters"></a>Paramètres  
 *nObjectType*  
 Spécifie le type d’objet. Il peut avoir les valeurs **OBJ_BRUSH** ou **OBJ_PEN**.  
  
 `lpfn`  
 Est l’adresse de l’instance de la procédure de la fonction de rappel fournie par l’application. Consultez la section « Remarques » ci-dessous.  
  
 `lpData`  
 Points de données fourni par l’application. Les données sont transmises à la fonction de rappel ainsi que des informations sur l’objet.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie la dernière valeur retournée par la [fonction de rappel](../../mfc/reference/callback-function-for-cdc-enumobjects.md). Sa signification est définie par l’utilisateur.  
  
### <a name="remarks"></a>Remarques  
 Pour chaque objet d’un type donné, la fonction de rappel que vous passez est appelée avec les informations de cet objet. Le système appelle la fonction de rappel jusqu'à ce qu’il n’existe plus aucun objet ou la fonction de rappel retourne 0.  
  
 Notez que les fonctionnalités nouvelles de Microsoft Visual C++ vous permettent d’utiliser une fonction ordinaire comme la fonction passé à `EnumObjects`. L’adresse passée à `EnumObjects` est un pointeur vers une fonction exportée avec **exporter** et avec la convention d’appel Pascal. Dans les applications en mode protégé, il est inutile de créer cette fonction avec la fonction Windows MakeProcInstance ou de libérer de la fonction après la fonction FreeProcInstance Windows.  
  
 Également inutile exporter le nom de fonction dans une **exportations** instruction dans le fichier de définition de module de votre application. Vous pouvez utiliser à la place la **exporter** fonction modificateur, comme dans  
  
 **int rappel exporter** AFunction **(LPSTR**, **LPSTR) ;**  
  
 Pour contraindre le compilateur à émettre l’enregistrement d’exportation correcte pour l’exportation par nom sans alias. Cela fonctionne pour la plupart des besoins. Dans certains cas spéciaux, tels que l’exportation d’une fonction par ordinal ou alias de l’exportation, vous devez quand même utiliser un **exportations** instruction dans un fichier de définition de module.  
  
 Pour compiler les programmes de Microsoft Foundation, vous utiliserez normalement le /GA et les options de compilateur /GEs. L’option de compilateur /Gw n’est pas utilisée avec Microsoft Foundation classes. (Si vous n’utilisez pas la fonction Windows **MakeProcInstance**, vous devez caster explicitement le pointeur de fonction retourné à partir de **FARPROC** pour le type nécessaire dans cette API.) Interfaces de rappel d’inscription sont maintenant de type sécurisé (vous devez passer un pointeur de fonction qui pointe vers le bon type de fonction pour le rappel spécifique).  
  
 Notez également que toutes les fonctions de rappel doivent intercepter les exceptions de Microsoft Foundation avant de retourner à Windows, étant donné que les exceptions ne peut pas être levées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, consultez l’article [Exceptions](../../mfc/exception-handling-in-mfc.md).  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView #35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]  
  
##  <a name="escape"></a>CDC::escape  
 Cette fonction membre est pratiquement obsolète pour la programmation de Win32.  
  
```  
virtual int Escape(
    int nEscape,  
    int nCount,  
    LPCSTR lpszInData,  
    LPVOID lpOutData);

 
int Escape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData,  
    int nOutputSize,  
    LPSTR lpszOutputData);
```  
  
### <a name="parameters"></a>Paramètres  
 `nEscape`  
 Spécifie la fonction d’échappement à effectuer.  
  
 Pour obtenir une liste complète des fonctions de d’échappement, consultez [échappement](http://msdn.microsoft.com/library/windows/desktop/dd162701) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
 `nCount`  
 Spécifie le nombre d’octets de données vers lequel pointées `lpszInData`.  
  
 `lpszInData`  
 Pointe vers la structure de données d’entrée requis pour cette d’échappement.  
  
 `lpOutData`  
 Pointe vers la structure qui doit recevoir la sortie à partir de cette d’échappement. Le `lpOutData` paramètre est **NULL** si aucune donnée n’est retournée.  
  
 `nInputSize`  
 Spécifie le nombre d’octets de données vers lequel pointées le `lpszInputData` paramètre.  
  
 `lpszInputData`  
 Pointe vers la structure d’entrée requis pour la séquence d’échappement spécifiée.  
  
 `nOutputSize`  
 Spécifie le nombre d’octets de données vers lequel pointées le `lpszOutputData` paramètre.  
  
 `lpszOutputData`  
 Pointe vers la structure qui reçoit le résultat de cette d’échappement. Ce paramètre doit être **NULL** si aucune donnée n’est retournée.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur positive est retournée si la fonction réussit, à l’exception de la **QUERYESCSUPPORT** échappement, qui contrôle uniquement pour l’implémentation. Valeur zéro est renvoyée si la séquence d’échappement n’est pas implémentée. Une valeur négative est retournée si une erreur s’est produite. Les valeurs d’erreur courantes sont les suivantes :  
  
- **SP_ERROR** erreur générale.  
  
- **SP_OUTOFDISK** pas suffisamment d’espace disque est actuellement disponible pour la mise en attente, et aucun espace plus ne sera bientôt disponible.  
  
- **SP_OUTOFMEMORY** pas assez de mémoire est disponible pour la mise en attente.  
  
- **SP_USERABORT** utilisateur s’est terminé le travail via le Gestionnaire d’impression.  
  
### <a name="remarks"></a>Remarques  
 De l’échappement d’imprimante d’origine, uniquement **QUERYESCSUPPORT** est pris en charge pour les applications Win32. Toutes les autres séquences d’échappement imprimante sont obsolètes et sont pris en charge uniquement pour la compatibilité avec les applications 16 bits.  
  
 Pour la programmation Win32 `CDC` maintenant fournit six fonctions membres qui remplacent leurs séquences d’échappement imprimante correspondante :  
  
- [CDC::AbortDoc](#abortdoc)  
  
- [CDC::EndDoc](#enddoc)  
  
- [CDC::EndPage](#endpage)  
  
- [CDC::SETABORTPROC](#setabortproc)  
  
- [CDC::StartDoc](#startdoc)  
  
- [CDC::StartPage](#startpage)  
  
 En outre, [CDC::GetDeviceCaps](#getdevicecaps) prend en charge les index Win32 qui remplacent d’autres séquences d’échappement des imprimantes. Consultez [GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour plus d’informations.  
  
 Cette fonction membre permet aux applications accéder aux installations d’un appareil particulier qui ne sont pas directement disponibles via GDI.  
  
 Utilisez la première version, si votre application utilise les valeurs prédéfinies d’échappement. Utilisez la deuxième version, si votre application définit les valeurs d’échappement privé. Consultez [ExtEscape](http://msdn.microsoft.com/library/windows/desktop/dd162708) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour plus d’informations sur la deuxième version.  
  
##  <a name="excludecliprect"></a>CDC::ExcludeClipRect  
 Crée une nouvelle zone de découpage qui se compose de la zone de découpage existant moins le rectangle spécifié.  
  
```  
int ExcludeClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int ExcludeClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle.  
  
 `y1`  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle.  
  
 `x2`  
 Spécifie la coordonnée x logique de l’angle inférieur droit du rectangle.  
  
 `y2`  
 Spécifie la coordonnée y logique de l’angle inférieur droit du rectangle.  
  
 `lpRect`  
 Spécifie le rectangle. Peut également être un `CRect` objet.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le type de la nouvelle zone découpage. Il peut être une des valeurs suivantes :  
  
- **COMPLEXREGION** a de la région de chevauchement des bordures.  
  
- **ERREUR** aucune région n’a été créée.  
  
- **NULLREGION** la région est vide.  
  
- **SIMPLEREGION** la région ne possède aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 La largeur du rectangle, spécifié par la valeur absolue de `x2`  -  `x1`, ne doit pas dépasser 32 767 unités. Cette limite s’applique à la hauteur du rectangle ainsi.  
  
##  <a name="excludeupdatergn"></a>CDC::ExcludeUpdateRgn  
 Empêche le dessin dans les zones non valides d’une fenêtre en excluant une région de mise à jour dans la fenêtre à partir de la zone de découpage associée à la `CDC` objet.  
  
```  
int ExcludeUpdateRgn(CWnd* pWnd);
```  
  
### <a name="parameters"></a>Paramètres  
 `pWnd`  
 Pointe vers l’objet de fenêtre dont la fenêtre est en cours de mise à jour.  
  
### <a name="return-value"></a>Valeur de retour  
 Le type de région exclu. Il peut prendre l’une des valeurs suivantes :  
  
- **COMPLEXREGION** a de la région de chevauchement des bordures.  
  
- **ERREUR** aucune région n’a été créée.  
  
- **NULLREGION** la région est vide.  
  
- **SIMPLEREGION** la région ne possède aucune bordure qui se chevauchent.  
  
##  <a name="extfloodfill"></a>CDC::ExtFloodFill  
 Remplit une zone de la surface d’affichage avec le pinceau actuel.  
  
```  
BOOL ExtFloodFill(
    int x,  
    int y,  
    COLORREF crColor,  
    UINT nFillType);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point où commence la saturation de ce dernier.  
  
 *y*  
 Spécifie la coordonnée y logique du point où commence la remplir.  
  
 `crColor`  
 Spécifie la couleur de la limite ou de la zone à remplir. L’interprétation de `crColor` dépend de la valeur de `nFillType`.  
  
 `nFillType`  
 Spécifie le type de remplissage à effectuer. Il doit être une des valeurs suivantes :  
  
- **FLOODFILLBORDER** la zone de remplissage est limitée par la couleur spécifiée par `crColor`. Ce style est identique à remplir à la fois effectuée par `FloodFill`.  
  
- **FLOODFILLSURFACE** la zone de remplissage est définie par la couleur spécifiée par `crColor`. Remplissage continue vers l’extérieur dans toutes les directions, tant que la couleur est rencontrée. Ce style est utile pour remplir des zones avec des limites multicolores.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la fonction réussit ; Sinon, 0 si le remplissage pas pu être effectué, si le point donné a la limite de couleur spécifié par `crColor` (si **FLOODFILLBORDER** a été demandée), si le point donné ne dispose pas de la couleur spécifiée par `crColor` (si **FLOODFILLSURFACE** a été demandée), ou si le point est à l’extérieur de la zone de découpage.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre est plus souple que `FloodFill` car vous pouvez spécifier un type de remplissage dans `nFillType`.  
  
 Si `nFillType` a la valeur **FLOODFILLBORDER**, la zone est censée être complètement limitée par la couleur spécifiée par `crColor`. La fonction commence au point spécifié par *x* et *y* et renseigne toutes les instructions à la limite de couleur.  
  
 Si `nFillType` a la valeur **FLOODFILLSURFACE**, la fonction commence au point spécifié par *x* et *y* et se poursuit dans toutes les directions, remplissage de toutes les zones adjacentes contenant la couleur spécifiée par `crColor`.  
  
 Uniquement les contextes de périphérique de mémoire et les périphériques qui prennent en charge de la prise en charge de la technologie raster-affichage `ExtFloodFill`. Pour plus d’informations, consultez la [GetDeviceCaps](#getdevicecaps) fonction membre.  
  
##  <a name="exttextout"></a>CDC::ExtTextOut  
 Appelez cette fonction membre pour écrire une chaîne de caractères dans une zone rectangulaire à l’aide de la police actuellement sélectionnée.  
  
```  
virtual BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    LPCTSTR lpszString,  
    UINT nCount,  
    LPINT lpDxWidths);

 
BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    const CString& str,  
    LPINT lpDxWidths);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de la cellule de caractère pour le premier caractère dans la chaîne spécifiée.  
  
 *y*  
 Spécifie la coordonnée y logique du haut de la cellule de caractère pour le premier caractère dans la chaîne spécifiée.  
  
 `nOptions`  
 Spécifie le type de rectangle. Ce paramètre peut être une, deux ou aucune des valeurs suivantes :  
  
- **ETO_CLIPPED** Spécifie que le texte est tronqué au rectangle.  
  
- **ETO_OPAQUE** Spécifie que la couleur d’arrière-plan actuelle remplit le rectangle. (Vous pouvez définir et interroger la couleur d’arrière-plan en cours avec le [SetBkColor](#setbkcolor) et [GetBkColor](#getbkcolor) fonctions membres.)  
  
 `lpRect`  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure qui détermine les dimensions du rectangle. Ce paramètre peut être **NULL**. Vous pouvez également passer un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 `lpszString`  
 Pointe vers la chaîne de caractères spécifiée doit être dessiné. Vous pouvez également passer un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne.  
  
 `lpDxWidths`  
 Pointe vers un tableau de valeurs qui indiquent la distance entre les origines de cellules de caractères adjacents. Par exemple, `lpDxWidths`[ *i*] les origines de cellule de caractère pour séparer les unités logiques *i* et la cellule de caractère *i* + 1. Si `lpDxWidths` est **NULL**, `ExtTextOut` utilise l’espacement par défaut entre les caractères.  
  
 `str`  
 A `CString` objet qui contient les caractères spécifiés à dessiner.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La région rectangulaire peut être opaque (rempli avec la couleur d’arrière-plan actuelle), et il peut être une zone de découpage.  
  
 Si `nOptions` est égal à 0 et `lpRect` est **NULL**, la fonction écrit du texte dans le contexte de périphérique sans l’aide d’une zone rectangulaire. Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction. Si une application doit mettre à jour la position actuelle lorsqu’il appelle `ExtTextOut`, l’application peut appeler le `CDC` fonction membre [SetTextAlign](#settextalign) avec `nFlags` la valeur **TA_UPDATECP**. Lorsque cet indicateur est défini, Windows ignore *x* et *y* sur les appels suivants à `ExtTextOut` et utilise à la place de la position actuelle. Lorsqu’une application utilise **TA_UPDATECP** pour mettre à jour la position actuelle, `ExtTextOut` définit la position actuelle, à la fin de la ligne précédente du texte ou à la position spécifiée par le dernier élément du tableau pointé par `lpDxWidths`, selon ce qui est supérieur.  
  
##  <a name="fillpath"></a>CDC::FillPath  
 Ferme des figures ouvertes dans le chemin d’accès actuel et remplit l’intérieur du chemin d’accès en utilisant le pinceau actuel et le mode de remplissage de polygones.  
  
```  
BOOL FillPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Une fois son intérieur est remplie, le chemin d’accès est supprimé à partir du contexte de périphérique.  
  
##  <a name="fillrect"></a>CDC::FillRect  
 Appelez cette fonction membre pour remplir un rectangle donné à l’aide de la forme spécifiée.  
  
```  
void FillRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure qui contient les coordonnées logiques du rectangle à remplir. Vous pouvez également passer un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet pour ce paramètre.  
  
 `pBrush`  
 Identifie le pinceau utilisé pour remplir le rectangle.  
  
### <a name="remarks"></a>Remarques  
 La fonction remplit le rectangle complète, y compris les bordures gauche et supérieure, mais elle ne remplit pas les bordures de droite et en bas.  
  
 Le pinceau doit soit être créé à l’aide de la [CBrush](../../mfc/reference/cbrush-class.md) fonctions membres [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush), et [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush), ou récupérée par le `GetStockObject` fonction Windows.  
  
 Lors du remplissage du rectangle spécifié, `FillRect` n’inclut pas les côtés droit et inférieur du rectangle. GDI remplit un rectangle jusqu'à, mais n’inclut pas la ligne de colonne et en bas à droite, quel que soit le mode de mappage en cours. `FillRect`Compare les valeurs de la **haut**, **bas**, **gauche**, et **droit** membres du rectangle spécifié. Si **bas** est inférieur ou égal à **haut**, ou si **droit** est inférieur ou égal à **gauche**, le rectangle n’est pas dessiné.  
  
 `FillRect`est semblable à [CDC::FillSolidRect](#fillsolidrect); Toutefois, `FillRect` prend un pinceau et par conséquent peut être utilisé pour remplir un rectangle avec une couleur unie, une couleur tramée, pinceaux hachurée ou un modèle. `FillSolidRect`utilise uniquement des couleurs unies (indiqué par une **COLORREF** paramètre). `FillRect`est généralement plus lent que `FillSolidRect`.  
  
##  <a name="fillrgn"></a>CDC::FillRgn  
 Remplit la région spécifiée par `pRgn` avec le pinceau spécifié par `pBrush`.  
  
```  
BOOL FillRgn(
    CRgn* pRgn,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>Paramètres  
 `pRgn`  
 Pointeur vers la zone à remplir. Les coordonnées de la région donnée sont spécifiées dans les unités logiques.  
  
 `pBrush`  
 Identifie le pinceau à utiliser pour remplir la zone.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le pinceau doit être créé soit à l’aide de la `CBrush` fonctions membres `CreateHatchBrush`, `CreatePatternBrush`, `CreateSolidBrush`, ou être récupérée par **GetStockObject**.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).  
  
##  <a name="fillsolidrect"></a>CDC::FillSolidRect  
 Appelez cette fonction membre pour remplir le rectangle donné avec la couleur unie spécifiée.  
  
```  
void FillSolidRect(
    LPCRECT lpRect,  
    COLORREF clr);

 
void FillSolidRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clr);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer soit un pointeur vers un [RECT](../../mfc/reference/rect-structure1.md) structure de données ou un `CRect` objet pour ce paramètre.  
  
 `clr`Spécifie la couleur à utiliser pour remplir le rectangle.  
  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle de destination.  
  
 `cx`  
 Spécifie la largeur du rectangle.  
  
 `cy`  
 Spécifie la hauteur du rectangle.  
  
### <a name="remarks"></a>Remarques  
 `FillSolidRect`est très similaire à [CDC::FillRect](#fillrect); Toutefois, `FillSolidRect` utilise uniquement des couleurs unies (indiqué par le **COLORREF** paramètre), tandis que `FillRect` prend un pinceau et par conséquent peut être utilisé pour remplir un rectangle avec une couleur unie, une couleur tramée, pinceaux hachurée ou un modèle. `FillSolidRect`est généralement plus rapide que `FillRect`.  
  
> [!NOTE]
>  Lorsque vous appelez `FillSolidRect`, la couleur d’arrière-plan, qui a été définie précédemment à l’aide de [SetBkColor](#setbkcolor), est défini sur la couleur indiquée par `clr`.  
  
##  <a name="flattenpath"></a>CDC::FlattenPath  
 Transforme les courbes dans le chemin d’accès sélectionné dans le contexte de périphérique en cours et active de chaque courbe en une séquence de lignes.  
  
```  
BOOL FlattenPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="floodfill"></a>CDC::FloodFill  
 Remplit une zone de la surface d’affichage avec le pinceau actuel.  
  
```  
BOOL FloodFill(
    int x,  
    int y,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point où commence la saturation de ce dernier.  
  
 *y*  
 Spécifie la coordonnée y logique du point où commence la remplir.  
  
 `crColor`  
 Spécifie la couleur de la limite.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la fonction réussit ; Sinon, 0 est retourné si le remplissage n’a pas pu être effectué, le point donné a la couleur de la limite spécifiée par `crColor`, ou le point est à l’extérieur de la zone de découpage.  
  
### <a name="remarks"></a>Remarques  
 La zone est supposée être limitées en tant que spécifiée par `crColor`. Le `FloodFill` fonction commence au point spécifié par *x* et *y* et se poursuit dans toutes les directions à la limite de couleur.  
  
 Uniquement les contextes de périphérique de mémoire et les périphériques qui prennent en charge de la prise en charge de la technologie raster-affichage du `FloodFill` fonction membre. Pour plus d’informations sur **RC_BITBLT** fonctionnalité, consultez le `GetDeviceCaps` fonction membre.  
  
 Le `ExtFloodFill` fonction fournit des fonctionnalités similaires mais une plus grande souplesse.  
  
##  <a name="framerect"></a>CDC::frameRect n'  
 Dessine une bordure autour du rectangle spécifié par `lpRect`.  
  
```  
void FrameRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui contient les coordonnées logiques des angles supérieur gauche et à droite du rectangle. Vous pouvez également passer un `CRect` objet pour ce paramètre.  
  
 `pBrush`  
 Identifie le pinceau à utiliser pour le rectangle de tramage.  
  
### <a name="remarks"></a>Remarques  
 La fonction utilise le pinceau donné pour dessiner la bordure. La largeur et la hauteur de la bordure est toujours 1 unité logique.  
  
 Si du rectangle **bas** coordonnée est inférieur ou égal à **haut**, ou si **droit** est inférieur ou égal à **gauche**, le rectangle n’est pas dessiné.  
  
 La bordure dessinée par `FrameRect` est à la même position en tant que bordure dessinée par le **Rectangle** fonction membre à l’aide des mêmes coordonnées (si **Rectangle** utilise un stylet est 1 unité logique large). L’intérieur du rectangle n’est pas renseigné par `FrameRect`.  
  
##  <a name="framergn"></a>CDC::FrameRgn  
 Dessine une bordure autour de la zone spécifiée par `pRgn` à l’aide de la forme spécifiée par `pBrush`.  
  
```  
BOOL FrameRgn(
    CRgn* pRgn,  
    CBrush* pBrush,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Paramètres  
 `pRgn`  
 Pointe vers le `CRgn` objet qui identifie la zone pour être placés dans une bordure. Les coordonnées de la région donnée sont spécifiées dans les unités logiques.  
  
 `pBrush`  
 Pointe vers le `CBrush` objet qui identifie le pinceau à utiliser pour dessiner la bordure.  
  
 `nWidth`  
 Spécifie la largeur de la bordure de contours verticale en unités de périphérique.  
  
 `nHeight`  
 Spécifie la hauteur de la bordure de contours horizontal en unités de périphérique.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).  
  
##  <a name="fromhandle"></a>CDC::FromHandle  
 Retourne un pointeur vers un `CDC` lorsqu’un handle vers un contexte de périphérique de l’objet.  
  
```  
static CDC* PASCAL FromHandle(HDC hDC);
```  
  
### <a name="parameters"></a>Paramètres  
 `hDC`  
 Contient un handle vers un contexte de périphérique Windows.  
  
### <a name="return-value"></a>Valeur de retour  
 Le pointeur peut être temporaire et ne doit pas être stocké au-delà utilisé immédiatement.  
  
### <a name="remarks"></a>Remarques  
 Si aucun objet `CDC` n'est attaché au handle, un objet `CDC` temporaire est créé et attaché.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).  
  
##  <a name="getarcdirection"></a>CDC::GetArcDirection  
 Renvoie la direction d’arc de cercle en cours pour le contexte de périphérique.  
  
```  
int GetArcDirection() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie la direction d’arc de cercle en cours, en cas de réussite. Voici les valeurs de retour valides :  
  
- **AD_COUNTERCLOCKWISE** arcs de cercle et rectangles dessinés dans le sens inverse.  
  
- **AD_CLOCKWISE** arcs de cercle et rectangles dessinés dans le sens horaire.  
  
 Si une erreur se produit, la valeur de retour est zéro.  
  
### <a name="remarks"></a>Remarques  
 Fonctions d’arc de cercle et rectangle utilisent la direction d’arc de cercle.  
  
##  <a name="getaspectratiofilter"></a>CDC::GetAspectRatioFilter  
 Récupère le paramètre pour le filtre de proportions de l’image actuelle.  
  
```  
CSize GetAspectRatioFilter() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 A `CSize` objet représentant les proportions utilisées par le filtre de proportions de l’image actuelle.  
  
### <a name="remarks"></a>Remarques  
 Les proportions est le ratio formé par la hauteur et de largeur en pixels d’un périphérique. Plus d’informations sur le rapport hauteur / largeur d’un appareil sont utilisés dans la création, la sélection et affichage des polices. Windows fournit un filtre spécial, le filtre de l’aspect, pour sélectionner des polices conçues pour une proportion particulier à partir de toutes les polices disponibles. Le filtre utilise les proportions spécifiée par le `SetMapperFlags` fonction membre.  
  
##  <a name="getbkcolor"></a>CDC::GetBkColor  
 Retourne la couleur d’arrière-plan actuelle.  
  
```  
COLORREF GetBkColor() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur de couleur RVB.  
  
### <a name="remarks"></a>Notes  
 Si le mode d’arrière-plan est **OPAQUE**, le système utilise la couleur d’arrière-plan pour remplir les vides dans les lignes de stylisés, les espaces entre les lignes hachurées de pinceaux et de l’arrière-plan dans les cellules de caractères. Le système utilise également la couleur d’arrière-plan lors de la conversion de bitmaps entre la couleur et les contextes de périphérique monochrome.  
  
##  <a name="getbkmode"></a>CDC::GetBkMode  
 Renvoie le mode d’arrière-plan.  
  
```  
int GetBkMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode actuel en arrière-plan, ce qui peut être **OPAQUE** ou **TRANSPARENT**.  
  
### <a name="remarks"></a>Remarques  
 Le mode d’arrière-plan définit si le système supprime les couleurs d’arrière-plan sur la surface de dessin avant de dessiner du texte, des pinceaux hachurées ou un style de stylet qui n’est pas un trait plein.  
  
##  <a name="getboundsrect"></a>CDC::GetBoundsRect  
 Retourne le rectangle englobant cumulé actuel pour le contexte de périphérique spécifié.  
  
```  
UINT GetBoundsRect(
    LPRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRectBounds`  
 Pointe vers une mémoire tampon qui reçoit le rectangle englobant actuel. Le rectangle est renvoyé en coordonnées logiques.  
  
 `flags`  
 Spécifie si le rectangle englobant doit être désactivée une fois qu’il est retourné. Ce paramètre doit être égal à zéro ou affectez la valeur suivante :  
  
- **DCB_RESET** force le rectangle englobant doit être effacé après qu’il est retourné.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie l’état actuel du rectangle englobant, si la fonction réussit. Il peut être une combinaison des valeurs suivantes :  
  
- **DCB_ACCUMULATE** accumulation du rectangle de délimitation est en cours.  
  
- **DCB_RESET** rectangle englobant est vide.  
  
- **DCB_SET** rectangle englobant n’est pas vide.  
  
- **DCB_ENABLE** englobant accumulation se trouve sur.  
  
- **DCB_DISABLE** englobant accumulation est désactivée.  
  
##  <a name="getbrushorg"></a>CDC::GetBrushOrg  
 Récupère l’origine (en unités de périphérique) de la forme actuellement sélectionnée pour le contexte de périphérique.  
  
```  
CPoint GetBrushOrg() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine actuelle du pinceau (en unités de l’appareil) en tant qu’un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 L’origine de la forme initiale est à (0,0) de la zone cliente. La valeur de retour spécifie ce point en unités de périphérique relatif à l’origine de la fenêtre du bureau.  
  
##  <a name="getcharacterplacement"></a>CDC::GetCharacterPlacement  
 Récupère les différents types d’informations sur une chaîne de caractères.  
  
```  
DWORD GetCharacterPlacement(
    LPCTSTR lpString,  
    int nCount,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
  
DWORD GetCharacterPlacement(
    CString& str,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpString`  
 Pointeur vers la chaîne de caractères à traiter.  
  
 `nCount`  
 Spécifie la longueur de la chaîne. Pour obtenir la version ANSI, il s’agit d’un nombre d’octets, et pour la fonction Unicode, il est un nombre de mots. Pour plus d’informations, consultez [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx).  
  
 `nMaxExtent`  
 Spécifie l’étendue maximale (en unités logiques) à laquelle la chaîne est traitée. Les caractères qui, si traité, dépasserait cette extension sont ignorés. Calculs pour les tableaux de classement ou du glyphe requises s’appliquent uniquement aux caractères inclus. Ce paramètre est utilisé uniquement si la valeur GCP_MAXEXTENT est spécifiée dans le `dwFlags` paramètre. La fonction traite la chaîne d’entrée, chaque caractère et son étendue est ajoutée à la sortie, étendue et les autres tableaux uniquement si la mesure total n’a pas encore dépassé le nombre maximal. Une fois que la limite est atteinte, le traitement s’arrête.  
  
 lpResults  
 Pointeur vers un [GCP_Results](http://msdn.microsoft.com/library/windows/desktop/dd144842\(v=vs.85\).aspx) structure qui reçoit les résultats de la fonction.  
  
 `dwFlags`  
 Spécifie comment traiter la chaîne dans les tableaux de requis. Ce paramètre peut prendre l’une ou plusieurs des valeurs répertoriées dans le `dwFlags` section de la [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx) rubrique.  
  
 `str`  
 Un pointeur vers un [CString](../../atl-mfc-shared/reference/cstringt-class.md) au processus de l’objet.  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour est la largeur et la hauteur de la chaîne en unités logiques.  
  
 Si la fonction échoue, la valeur de retour est égale à zéro.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre émule la fonctionnalité de la fonction [GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getcharabcwidths"></a>CDC::GetCharABCWidths  
 Récupère la largeur des caractères consécutifs dans une plage spécifiée à partir de la police TrueType en cours.  
  
```  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABC lpabc) const;  
  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABCFLOAT lpABCF) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nFirstChar`  
 Spécifie le premier caractère dans la plage de caractères à partir de la police en cours pour lequel la largeur des caractères est retournées.  
  
 `nLastChar`  
 Spécifie le dernier caractère de la plage de caractères à partir de la police en cours pour lequel la largeur des caractères est retournées.  
  
 `lpabc`  
 Pointe vers un tableau de [ABC](../../mfc/reference/abc-structure.md) structures qui reçoivent la largeur des caractères lorsque la fonction retourne. Ce tableau doit contenir au moins autant **ABC** structures qu’il sont a des caractères dans la plage spécifiée par la `nFirstChar` et `nLastChar` paramètres.  
  
 *lpABCF*  
 Pointe vers une mémoire tampon de fournie par l’application avec un tableau de [ABCFLOAT](../../mfc/reference/abcfloat-structure.md) structures pour recevoir les largeurs de caractère lorsque la fonction retourne. Les largeurs retournées par cette fonction se trouvent dans le format à virgule flottante IEEE.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Les largeurs sont retournées en unités logiques. Cette fonction réussit uniquement avec les polices TrueType.  
  
 Le convertisseur TrueType fournit l’espacement des caractères « ABC » après la sélection d’une taille spécifique. Espacement de « A » est la distance qui est ajoutée à la position actuelle avant de placer le glyphe. Espacement de « B » correspond à la largeur de la partie noire du glyphe. Espacement de « C » est ajouté à la position actuelle pour prendre en compte les espaces blancs à droite du glyphe. Le total avancé largeur est donné par un + B + C.  
  
 Lorsque le `GetCharABCWidths` fonction membre récupère négatif « A » ou inclut les largeurs « C » d’un caractère, ce caractère underhangs ou dépassements.  
  
 Pour convertir les largeurs ABC en unités de design de police, une application doit créer une police dont la hauteur (tel que spécifié dans le **lfHeight** membre du [LOGFONT](http://msdn.microsoft.com/library/windows/desktop/dd145037) structure) est égal à la valeur stockée dans le **ntmSizeEM** membre de la [NEWTEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162741) structure. (La valeur de la **ntmSizeEM** membre peut être récupéré en appelant le [EnumFontFamilies](http://msdn.microsoft.com/library/windows/desktop/dd162619) fonction Windows.)  
  
 Les largeurs de ABC de caractère par défaut sont utilisées pour les caractères qui sont en dehors de la plage de la police actuellement sélectionnée.  
  
 Pour récupérer la largeur des caractères dans les polices TrueType non, les applications doivent utiliser le [GetCharWidth](http://msdn.microsoft.com/library/windows/desktop/dd144861) fonction Windows.  
  
##  <a name="getcharabcwidthsi"></a>CDC::GetCharABCWidthsI  
 Récupère la largeur, en unités logiques, des index de glyphes consécutifs dans une plage spécifiée à partir de la police TrueType en cours.  
  
```  
BOOL GetCharABCWidthsI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPABC lpabc) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `giFirst`  
 Spécifie le premier index de glyphe dans le groupe d’index de glyphe consécutives à partir de la police actuelle. Ce paramètre est utilisé uniquement si la `pgi` paramètre est **NULL**.  
  
 `cgi`  
 Spécifie le nombre d’indices de glyphe.  
  
 `pgi`  
 Pointeur vers un tableau contenant les index de glyphes. Si la valeur est **NULL**, le `giFirst` paramètre est utilisé à la place. Le `cgi` paramètre spécifie le nombre d’index de glyphes dans ce tableau.  
  
 `lpabc`  
 Pointeur vers un tableau de [ABC](http://msdn.microsoft.com/library/windows/desktop/dd162454) structures de réception de la largeur des caractères. Ce tableau doit contenir au moins autant **ABC** structures qu’il sont a des index de glyphes spécifiés par le `cgi` paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre émule la fonctionnalité de la fonction [GetCharABCWidthsI](http://msdn.microsoft.com/library/windows/desktop/dd144859), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getcharwidth"></a>CDC::GetCharWidth  
 Récupère la largeur des caractères individuels dans un groupe de caractères consécutifs à partir de la police actuelle, à l’aide de `m_hAttribDC`, le contexte de périphérique d’entrée.  
  
```  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    float* lpFloatBuffer) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nFirstChar`  
 Spécifie le premier caractère dans un groupe de caractères de la police actuelle consécutifs.  
  
 `nLastChar`  
 Spécifie le dernier caractère dans un groupe de caractères de la police actuelle consécutifs.  
  
 `lpBuffer`  
 Pointe vers une mémoire tampon qui reçoit les valeurs de largeur pour un groupe de caractères consécutifs dans la police actuelle.  
  
 *lpFloatBuffer*  
 Pointe vers une mémoire tampon pour recevoir la largeur des caractères. Les largeurs retournés sont au format à virgule flottante IEEE 32 bits. (Les largeurs sont mesurées le long de la ligne de base des caractères).  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Par exemple, si `nFirstChar` identifie la lettre « a » et `nLastChar` identifie la lettre « z », la fonction extrait la largeur de tous les caractères minuscules.  
  
 La fonction stocke les valeurs dans la mémoire tampon pointée par `lpBuffer`. Cette mémoire tampon doit être suffisamment grand pour contenir toutes les largeurs. Autrement dit, au moins 26 entrées doit être dans l’exemple donné.  
  
 Si un caractère dans le groupe de caractères consécutifs n’existe pas dans une police particulière, il recevront la valeur de la largeur de caractère par défaut.  
  
##  <a name="getcharwidthi"></a>CDC::GetCharWidthI  
 Récupère la largeur, en coordonnées logiques, des index de glyphes consécutifs dans une plage spécifiée à partir de la police actuelle.  
  
```  
BOOL GetCharWidthI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `giFirst`  
 Spécifie le premier index de glyphe dans le groupe d’index de glyphe consécutives à partir de la police actuelle. Ce paramètre est utilisé uniquement si la `pgi` paramètre est **NULL**.  
  
 `cgi`  
 Spécifie le nombre d’indices de glyphe.  
  
 `pgi`  
 Pointeur vers un tableau contenant les index de glyphes. Si la valeur est **NULL**, le `giFirst` paramètre est utilisé à la place. Le `cgi` paramètre spécifie le nombre d’index de glyphes dans ce tableau.  
  
 `lpBuffer`  
 Pointeur vers une mémoire tampon qui reçoit les largeurs.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre émule la fonctionnalité de la fonction [GetCharWidthI](http://msdn.microsoft.com/library/windows/desktop/dd144864), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getclipbox"></a>CDC::GetClipBox  
 Récupère les dimensions du rectangle englobant plus étroite autour de la limite de découpage en cours.  
  
```  
virtual int GetClipBox(LPRECT lpRect) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers le [RECT](../../mfc/reference/rect-structure1.md) structure ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objet qui doit recevoir les dimensions du rectangle.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de la zone découpage. Il peut être une des valeurs suivantes :  
  
- **COMPLEXREGION** zone de découpage a chevauchement des bordures.  
  
- **ERREUR** contexte de périphérique n’est pas valide.  
  
- **NULLREGION** zone de découpage est vide.  
  
- **SIMPLEREGION** zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Remarques  
 Les dimensions sont copiées dans la mémoire tampon pointée par `lpRect`.  
  
##  <a name="getcoloradjustment"></a>CDC::GetColorAdjustment  
 Récupère les valeurs d’ajustement de couleur pour le contexte de périphérique.  
  
```  
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpColorAdjust`  
 Pointe vers un [réglage des couleurs](../../mfc/reference/coloradjustment-structure.md) structure de données pour recevoir les valeurs d’ajustement de couleur.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="getcurrentbitmap"></a>CDC::GetCurrentBitmap  
 Retourne un pointeur vers actuellement sélectionné `CBitmap` objet.  
  
```  
CBitmap* GetCurrentBitmap() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CBitmap` objet, en cas de réussite ; **NULL**.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentbrush"></a>CDC::GetCurrentBrush  
 Retourne un pointeur vers actuellement sélectionné `CBrush` objet.  
  
```  
CBrush* GetCurrentBrush() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CBrush` objet, en cas de réussite ; **NULL**.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentfont"></a>CDC::GetCurrentFont  
 Retourne un pointeur vers actuellement sélectionné `CFont` objet.  
  
```  
CFont* GetCurrentFont() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CFont` objet, en cas de réussite ; **NULL**.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentpalette"></a>CDC::GetCurrentPalette  
 Retourne un pointeur vers actuellement sélectionné `CPalette` objet.  
  
```  
CPalette* GetCurrentPalette() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CPalette` objet, en cas de réussite ; **NULL**.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentpen"></a>CDC::GetCurrentPen  
 Retourne un pointeur vers actuellement sélectionné `CPen` objet.  
  
```  
CPen* GetCurrentPen() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CPen` objet, en cas de réussite ; **NULL**.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre peut retourner des objets temporaires.  
  
##  <a name="getcurrentposition"></a>CDC::GetCurrentPosition  
 Récupère la position actuelle (en coordonnées logiques).  
  
```  
CPoint GetCurrentPosition() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La position actuelle comme un `CPoint` objet.  
  
### <a name="remarks"></a>Remarques  
 La position actuelle peut être définie avec la `MoveTo` fonction membre.  
  
##  <a name="getdcbrushcolor"></a>CDC::GetDCBrushColor  
 Récupère la couleur actuelle du pinceau.  
  
```  
COLORREF GetDCBrushColor() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour est la [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) valeur pour la couleur actuelle du pinceau.  
  
 Si la fonction échoue, la valeur de retour est **CLR_INVALID**.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre émule la fonctionnalité de la fonction [GetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd144872), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getdcpencolor"></a>CDC::GetDCPenColor  
 Récupère la couleur actuelle du stylet.  
  
```  
COLORREF GetDCPenColor() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour est la [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) valeur pour la couleur actuelle du stylet.  
  
 Si la fonction échoue, la valeur de retour est **CLR_INVALID**.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre utilise la fonction Win32 [GetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd144875), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getdevicecaps"></a>CDC::GetDeviceCaps  
 Récupère un large éventail d’informations spécifiques à l’appareil sur le périphérique d’affichage.  
  
```  
int GetDeviceCaps(int nIndex) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nIndex`  
 Spécifie le type d’informations à retourner. Consultez [GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour obtenir la liste de valeurs.  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur de la fonction demandée si la fonction réussit.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).  
  
##  <a name="getfontdata"></a>CDC::GetFontData  
 Récupère les informations de mesure de la police à partir d’un fichier de polices évolutives.  
  
```  
DWORD GetFontData(
    DWORD dwTable,  
    DWORD dwOffset,  
    LPVOID lpData,  
    DWORD cbData) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `dwTable`  
 Spécifie le nom de la table de métriques à retourner. Ce paramètre peut être une des tables de métriques documentées dans la spécification de fichiers de polices TrueType publiée par Microsoft Corporation. Si ce paramètre est 0, les informations sont récupérées en commençant au début du fichier de police.  
  
 `dwOffset`  
 Spécifie le décalage à partir du début de la table à partir duquel commencer la récupération des informations. Si ce paramètre est 0, les informations sont récupérées en commençant au début de la table spécifiée par le `dwTable` paramètre. Si cette valeur est supérieure ou égale à la taille de la table, `GetFontData` retourne 0.  
  
 `lpData`  
 Pointe vers une mémoire tampon qui reçoit les informations de police. Si cette valeur est **NULL**, la fonction retourne la taille de la mémoire tampon requise pour les données de police spécifiées dans le `dwTable` paramètre.  
  
 `cbData`  
 Spécifie la longueur, en octets, des informations à récupérer. Si ce paramètre est 0, `GetFontData` retourne la taille des données spécifiées dans le `dwTable` paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le nombre d’octets retournés dans la mémoire tampon pointée par `lpData` si la fonction réussit ; sinon, -1.  
  
### <a name="remarks"></a>Remarques  
 Les informations à récupérer sont identifiées en spécifiant un décalage dans le fichier de police et la longueur des informations à retourner.  
  
 Une application peut parfois utiliser la `GetFontData` fonction membre pour enregistrer une police TrueType avec un document. Pour ce faire, l’application détermine si la police peut être incorporée et récupère ensuite le fichier de l’intégralité de la police, en spécifiant 0 pour la `dwTable`, `dwOffset`, et `cbData` paramètres.  
  
 Si une police peut être incorporée en vérifiant les applications peuvent déterminer le **otmfsType** membre de la [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) structure. Si le bit 1 de **otmfsType** est défini, l’incorporation n’est pas autorisée pour la police. Si le bit 1 est désactivée, la police peut être incorporée. Si le bit 2 est défini, l’incorporation est en lecture seule.  
  
 Si une application tente d’utiliser cette fonction pour récupérer des informations pour une police TrueType non, le `GetFontData` fonction membre retourne -1.  
  
##  <a name="getfontlanguageinfo"></a>CDC::GetFontLanguageInfo  
 Retourne des informations sur la police actuellement sélectionnée pour le contexte d’affichage spécifié.  
  
```  
DWORD GetFontLanguageInfo() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur de retour identifie les caractéristiques de la police actuellement sélectionnée. Pour obtenir une liste complète des valeurs possibles, consultez [GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886).  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre émule la fonctionnalité de la fonction [GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getglyphoutline"></a>CDC::GetGlyphOutline  
 Récupère la courbe du plan ou une image bitmap pour un caractère avec contour dans la police actuelle.  
  
```  
DWORD GetGlyphOutline(
    UINT nChar,  
    UINT nFormat,  
    LPGLYPHMETRICS lpgm,  
    DWORD cbBuffer,  
    LPVOID lpBuffer,  
    const MAT2* lpmat2) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nChar`  
 Spécifie le caractère pour lequel les informations sont à retourner.  
  
 `nFormat`  
 Spécifie le format dans lequel la fonction doit retourner des informations. Il peut être une des valeurs suivantes, ou 0 :  
  
|Valeur|Signification|  
|-----------|-------------|  
|**GGO_BITMAP**|Retourne l’image bitmap de glyphe. Lorsque la fonction est retournée, la mémoire tampon vers laquelle pointe `lpBuffer` contient une bitmap de 1 bit par pixel dont les lignes démarrer sur des limites de mot double.|  
|**GGO_NATIVE**|Retourne la courbe de points de données au format natif du rastériseur, à l’aide d’unités de l’appareil. Lorsque cette valeur est spécifiée, toutes les transformations spécifiées dans `lpmat2` est ignoré.|  
  
 Lorsque la valeur de `nFormat` est 0, la fonction renseigne un [GLYPHMETRICS](http://msdn.microsoft.com/library/windows/desktop/dd144955) structure mais ne retourne pas de données de contour de glyphe.  
  
 *lpgm*  
 Pointe vers un **GLYPHMETRICS** structure qui décrit le positionnement du glyphe dans la cellule de caractère.  
  
 `cbBuffer`  
 Spécifie la taille de la mémoire tampon dans laquelle la fonction de copie plus d’informations sur le caractère de plan. Si cette valeur est 0 et la `nFormat` paramètre est soit le **GGO_BITMAP** ou **GGO_NATIVE** valeurs, la fonction retourne la taille requise de la mémoire tampon.  
  
 `lpBuffer`  
 Pointe vers une mémoire tampon dans laquelle la fonction de copie plus d’informations sur le caractère de plan. Si `nFormat` Spécifie le **GGO_NATIVE** valeur, les informations est copiée sous la forme de **TTPOLYGONHEADER** et **TTPOLYCURVE** structures. Si cette valeur est **NULL** et `nFormat` est soit le **GGO_BITMAP** ou **GGO_NATIVE** valeur, la fonction retourne la taille requise de la mémoire tampon.  
  
 `lpmat2`  
 Pointe vers un [MAT2](http://msdn.microsoft.com/library/windows/desktop/dd145048) structure qui contient une matrice de transformation pour le caractère. Ce paramètre ne peut pas être **NULL**, même quand le **GGO_NATIVE** valeur est spécifiée pour `nFormat`.  
  
### <a name="return-value"></a>Valeur de retour  
 La taille, en octets, de la mémoire tampon requise pour les informations récupérées si `cbBuffer` est égal à 0 ou `lpBuffer` est **NULL**. Sinon, c’est une valeur positive si la fonction réussit, ou -1 s’il existe une erreur.  
  
### <a name="remarks"></a>Notes  
 Une application peut faire pivoter les caractères extraites au format bitmap en spécifiant une matrice de transformation de 2 x 2 dans la structure vers laquelle pointée `lpmat2`.  
  
 Un contour du glyphe est retourné comme une série de profils. Chaque profil est défini par un [TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158) structure suivie autant **TTPOLYCURVE** structures que nécessaire pour le décrire. Tous les points sont retournés en tant que [POINTFX](http://msdn.microsoft.com/library/windows/desktop/dd162806) structures et représentent les positions absolues, se déplace pas relatif. Le point de départ donnée par le **pfxStart** membre de la [TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158) structure est le point auquel le plan pour un profil commence. Le [TTPOLYCURVE](http://msdn.microsoft.com/library/windows/desktop/dd145157) les structures qui suivent peuvent être soit des enregistrements de type polyligne ou spline. Les enregistrements de type polyligne sont une série de points ; des lignes dessinées entre les points de décrivent le contour du caractère. Les enregistrements de spline représentent les courbes quadratiques utilisés par TrueType (autrement dit, quadratiques b-splines).  
  
##  <a name="getgraphicsmode"></a>CDC::GetGraphicsMode  
 Récupère le mode graphique actuel pour le contexte de périphérique spécifié.  
  
```  
int GetGraphicsMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne le mode graphique actuel. Pour obtenir la liste des valeurs que cette méthode peut retourner, consultez [GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892).  
  
 Retourne 0 en cas d’échec.  
  
 Pour obtenir des informations d’erreur plus complètes, appelez [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Remarques  
 Cette méthode encapsule la fonction Windows GDI [GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892).  
  
##  <a name="gethalftonebrush"></a>CDC::GetHalftoneBrush  
 Appelez cette fonction membre pour récupérer un pinceau de demi-teintes.  
  
```  
static CBrush* PASCAL GetHalftoneBrush();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un pointeur vers un `CBrush` objet en cas de réussite ; **NULL**.  
  
### <a name="remarks"></a>Remarques  
 Un pinceau de demi-teintes montre les pixels qui sont également des couleurs de premier plan et d’arrière-plan pour créer un motif tramé. Voici un exemple d’un motif tramé créé par un pinceau de demi-teintes.  
  
 ![Détail d’un trait de stylet tramé](../../mfc/reference/media/vc318s1.gif "vc318s1")  
  
##  <a name="getkerningpairs"></a>CDC::GetKerningPairs  
 Récupère le caractère le crénage paires pour la police actuellement sélectionnée dans le contexte de périphérique spécifié.  
  
```  
int GetKerningPairs(
    int nPairs,  
    LPKERNINGPAIR lpkrnpair) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nPairs`  
 Spécifie le nombre de [KERNINGPAIR](http://msdn.microsoft.com/library/windows/desktop/dd145024) structures pointée par `lpkrnpair`. La fonction ne copie pas les paires de crénage plus que le nombre spécifié par `nPairs`.  
  
 `lpkrnpair`  
 Pointe vers un tableau de **KERNINGPAIR** lorsque la fonction retourne des paires de structures qui reçoivent le crénage. Ce tableau doit contenir au moins autant de structures tel que spécifié par `nPairs`. Si ce paramètre est **NULL**, la fonction retourne le nombre total de crénage paires pour la police.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le nombre de paires de récupérer le crénage ou le nombre total de crénage paires dans la police, si la fonction réussit. Valeur zéro est renvoyée si la fonction échoue ou si aucune paire crénage pour la police.  
  
##  <a name="getlayout"></a>CDC::GetLayout  
 Appelez cette fonction membre pour déterminer la disposition du texte et des graphiques pour un contexte de périphérique, comme une imprimante ou un métafichier.  
  
```  
DWORD GetLayout() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, la disposition des indicateurs pour le contexte de périphérique en cours. Dans le cas contraire, **GDI_ERROR**. Pour plus d’informations d’erreur étendues, appelez [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360). Pour obtenir la liste des indicateurs de mise en page, consultez [CDC::SetLayout](#setlayout).  
  
### <a name="remarks"></a>Remarques  
 La disposition par défaut est de gauche à droite.  
  
##  <a name="getmapmode"></a>CDC::GetMapMode  
 Récupère le mode de mappage en cours.  
  
```  
int GetMapMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de mappage.  
  
### <a name="remarks"></a>Remarques  
 Pour obtenir une description des modes de mappage, consultez le `SetMapMode` fonction membre.  
  
> [!NOTE]
>  Si vous appelez [SetLayout](#setlayout) pour modifier le contrôleur de domaine à la disposition de droite à gauche, **SetLayout** modifie automatiquement le mode de mappage à `MM_ISOTROPIC`. Par conséquent, tous les appels suivants à `GetMapMode` retournera `MM_ISOTROPIC`.  
  
##  <a name="getmiterlimit"></a>CDC::GetMiterLimit  
 Retourne la limite d’angle pour le contexte de périphérique.  
  
```  
float GetMiterLimit() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La limite d’angle est utilisée lorsque les jointures d’angle aigu tracer des lignes géométriques qui ont.  
  
##  <a name="getnearestcolor"></a>CDC::GetNearestColor  
 Retourne la couleur unie qui correspond le mieux à une couleur logique spécifiée.  
  
```  
COLORREF GetNearestColor(COLORREF crColor) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `crColor`  
 Spécifie la couleur à mettre en correspondance.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur de couleur RVB (rouge, vert, bleu) qui définit le solide de couleur plus proche de la `crColor` valeur représentant l’appareil.  
  
### <a name="remarks"></a>Notes  
 Le périphérique donné doit être en mesure de représenter cette couleur.  
  
##  <a name="getoutlinetextmetrics"></a>CDC::GetOutlineTextMetrics  
 Récupère les informations sur les métriques pour les polices TrueType.  
  
```  
UINT GetOutlineTextMetrics(
    UINT cbData,  
    LPOUTLINETEXTMETRIC lpotm) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpotm`  
 Pointe vers un tableau de [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) structures. Si ce paramètre est **NULL**, la fonction retourne la taille de la mémoire tampon requise pour les données extraites de la métrique.  
  
 `cbData`  
 Spécifie la taille, en octets, de la mémoire tampon à laquelle les informations sont retournées.  
  
 `lpotm`  
 Pointe vers une **OUTLINETEXTMETRIC** structure. Si ce paramètre est **NULL**, la fonction retourne la taille de la mémoire tampon requise pour les informations de métriques récupérées.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755) structure contient la plupart des informations de métriques de police fournies avec le format TrueType, y compris un [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) structure. Les quatre derniers membres de la **OUTLINETEXTMETRIC** structure sont des pointeurs vers des chaînes. Applications doivent allouer de l’espace pour ces chaînes en plus de l’espace requis pour les autres membres. Étant donné qu’aucune limite imposée par le système à la taille des chaînes, la méthode la plus simple pour allouer de la mémoire est à récupérer la taille requise en spécifiant **NULL** pour `lpotm` dans le premier appel à la `GetOutlineTextMetrics` (fonction).  
  
##  <a name="getoutputcharwidth"></a>CDC::GetOutputCharWidth  
 Utilise le contexte de périphérique de sortie, `m_hDC`et récupère la largeur des caractères individuels dans un groupe de caractères consécutifs à partir de la police actuelle.  
  
```  
BOOL GetOutputCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nFirstChar`  
 Spécifie le premier caractère dans un groupe de caractères de la police actuelle consécutifs.  
  
 `nLastChar`  
 Spécifie le dernier caractère dans un groupe de caractères de la police actuelle consécutifs.  
  
 `lpBuffer`  
 Pointe vers une mémoire tampon qui reçoit les valeurs de largeur pour un groupe de caractères consécutifs dans la police actuelle.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Par exemple, si `nFirstChar` identifie la lettre « a » et `nLastChar` identifie la lettre « z », la fonction extrait la largeur de tous les caractères minuscules.  
  
 La fonction stocke les valeurs dans la mémoire tampon pointée par `lpBuffer`. Cette mémoire tampon doit être suffisamment grand pour contenir toutes les largeurs. Autrement dit, au moins 26 entrées doit être dans l’exemple donné.  
  
 Si un caractère dans le groupe de caractères consécutifs n’existe pas dans une police particulière, il recevront la valeur de la largeur de caractère par défaut.  
  
##  <a name="getoutputtabbedtextextent"></a>CDC::GetOutputTabbedTextExtent  
 Appelez cette fonction membre pour calculer la largeur et la hauteur d’une chaîne de caractères à l’aide de [m_hDC](#m_hdc), le contexte de périphérique de sortie.  
  
```  
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetOutputTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszString`  
 Pointe vers une chaîne de caractères à mesurer. Vous pouvez également passer un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne. Si `nCount` est -1, la longueur est calculée.  
  
 `nTabPositions`  
 Spécifie le nombre de positions de taquet de tabulation dans le tableau vers lequel pointé `lpnTabStopPositions`.  
  
 `lpnTabStopPositions`  
 Pointe vers un tableau d’entiers qui contient les positions de taquet de tabulation dans les unités logiques. Les taquets de tabulation doivent être triées par ordre croissant de commande ; la plus petite valeur de x doit être le premier élément du tableau. Onglets précédent ne sont pas autorisés.  
  
 `str`  
 A `CString` objet qui contient les caractères spécifiés à mesurer.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) dans un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 Si la chaîne contient un ou plusieurs caractères de tabulation, la largeur de la chaîne est basée sur les taquets de tabulation spécifiés par `lpnTabStopPositions`. La fonction utilise la police actuellement sélectionnée pour calculer les dimensions de la chaîne.  
  
 Décalage de la zone de découpage en cours ne pas la largeur et la hauteur retournée par le `GetOutputTabbedTextExtent` (fonction).  
  
 Étant donné que certains appareils ne placent pas de caractères dans les tableaux de cellule standard (autrement dit, ils crénage les caractères), la somme des étendues dans une chaîne de caractères peut être différent dans la mesure de la chaîne.  
  
 Si `nTabPositions` est égal à 0 et `lpnTabStopPositions` est **NULL**, onglets sont étendues à la largeur de caractère moyenne huit. Si `nTabPositions` est 1, les taquets de tabulation doivent être séparés par la distance spécifiée par la première valeur dans le tableau auquel `lpnTabStopPositions` points. Si `lpnTabStopPositions` points à plus d’une valeur unique, un taquet de tabulation a la valeur pour chaque valeur dans le tableau, jusqu’au nombre spécifié par `nTabPositions`.  
  
##  <a name="getoutputtextextent"></a>CDC::GetOutputTextExtent  
 Appelez cette fonction membre pour utiliser le contexte de périphérique de sortie, [m_hDC](#m_hdc)et le calcul de la largeur et la hauteur d’une ligne de texte, à l’aide de la police actuelle.  
  
```  
CSize GetOutputTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetOutputTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszString`  
 Pointe vers une chaîne de caractères. Vous pouvez également passer un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne. Si `nCount` est -1, la longueur est calculée.  
  
 `str`  
 A `CString` objet qui contient les caractères spécifiés à mesurer.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) retournées dans un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Notes  
 La zone de découpage en cours n’affecte pas la largeur et la hauteur retournée par `GetOutputTextExtent`.  
  
 Étant donné que certains appareils ne placent pas de caractères dans les tableaux de cellule standard (autrement dit, ils effectuent le crénage), la somme des étendues dans une chaîne de caractères peut être différent dans la mesure de la chaîne.  
  
##  <a name="getoutputtextmetrics"></a>CDC::GetOutputTextMetrics  
 Récupère les métriques pour la police actuelle à l’aide `m_hDC`, le contexte de périphérique de sortie.  
  
```  
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpMetrics`  
 Pointe vers le [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) structure qui reçoit les métriques.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="getpath"></a>CDC::getPath  
 Récupère les coordonnées de définition des points de terminaison des lignes et les points de contrôle des courbes trouvés dans le chemin d’accès qui est sélectionné dans le contexte de périphérique.  
  
```  
int GetPath(
    LPPOINT lpPoints,  
    LPBYTE lpTypes,  
    int nCount) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données ou `CPoint` où des points de contrôle de points de terminaison de ligne et de la courbe des objets sont placés.  
  
 `lpTypes`  
 Pointe vers un tableau d’octets où sont placés les types de sommets. Les valeurs sont les suivantes :  
  
- **PT_MOVETO** Spécifie que le point correspondant dans `lpPoints` démarre une figure distincte.  
  
- **PT_LINETO** Spécifie que le point précédent et correspondants point dans `lpPoints` sont les points de terminaison d’une ligne.  
  
- **PT_BEZIERTO** Spécifie que le point correspondant dans `lpPoints` est un point de contrôle ou d’un point de fin d’une courbe Bzier.  
  
 **PT_BEZIERTO** toujours se produire dans les ensembles de trois. Le point dans le chemin d’accès immédiatement précéder définit le point de départ de la courbe Bzier. Les deux premières **PT_BEZIERTO** points sont les points de contrôle et le troisième **PT_BEZIERTO** est le point de fin (si codé en dur).  
  
     A **PT_LINETO** ou **PT_BEZIERTO** type peut-être être combiné avec l’indicateur suivant (à l’aide de l’opérateur de bits `OR`) pour indiquer que le point correspondant est le dernier point dans un graphique et que le doit être fermée :  
  
- **PT_CLOSEFIGURE** Spécifie que la figure est fermée automatiquement après la ligne correspondante ou la courbe est dessinée. La figure est fermée en dessinant une ligne du point de terminaison ou la courbe jusqu’au point correspondant au dernier **PT_MOVETO**.  
  
 `nCount`  
 Spécifie le nombre total de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui peuvent être placés dans le `lpPoints` tableau. Cette valeur doit être le même que le nombre d’octets qui peut-être être placé dans le `lpTypes` tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Si le `nCount` paramètre est différent de zéro, le nombre de points énumérés. Si `nCount` est 0, le nombre total de points dans le chemin d’accès (et `GetPath` rien écrit dans les mémoires tampons). Si `nCount` est différente de zéro et inférieur au nombre de points est dans le chemin d’accès, la valeur de retour est -1.  
  
### <a name="remarks"></a>Remarques  
 Le contexte de périphérique doit contenir un chemin d’accès fermé. Les points du chemin d’accès sont retournées en coordonnées logiques. Points sont stockés dans le chemin d’accès dans les coordonnées de périphérique, par conséquent, `GetPath` modifie les points de coordonnées périphérique coordonnées logiques à l’aide de l’inverse de la transformation actuelle. Le `FlattenPath` fonction membre peut être appelée avant `GetPath`, pour convertir toutes les courbes dans le chemin d’accès en segments de ligne.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="getpixel"></a>CDC::getPixel  
 Récupère la valeur de couleur RVB du pixel au point spécifié par *x* et *y*.  
  
```  
COLORREF GetPixel(
    int x,  
    int y) const;  
  
COLORREF GetPixel(POINT point) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point doit être examinée.  
  
 *y*  
 Spécifie la coordonnée y logique du point doit être examinée.  
  
 `point`  
 Spécifie la logique coordonnées x et y-du point doit être examinée.  
  
### <a name="return-value"></a>Valeur de retour  
 Pour toutes les versions de la fonction, une valeur de couleur RVB de la couleur du point donné. Il est -1 si les coordonnées ne spécifient pas un point dans la zone de découpage.  
  
### <a name="remarks"></a>Remarques  
 Le point doit être dans la zone de découpage. Si le point n’est pas dans la zone de découpage, la fonction n’a aucun effet et retourne -1.  
  
 Tous les périphériques prennent en charge la **GetPixel** (fonction). Pour plus d’informations, consultez la **RC_BITBLT** fonctionnalité raster sous le [GetDeviceCaps](#getdevicecaps) fonction membre.  
  
 Le **GetPixel** fonction membre a deux formes. Le premier accepte deux valeurs de coordonnées ; la deuxième prend soit un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet.  
  
##  <a name="getpolyfillmode"></a>CDC::GetPolyFillMode  
 Récupère le mode de remplissage de polygones en cours.  
  
```  
int GetPolyFillMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode plein de polygone actuel, **autre** ou **enroulement**, si la fonction réussit.  
  
### <a name="remarks"></a>Remarques  
 Consultez le `SetPolyFillMode` fonction membre pour obtenir une description des modes de remplissage de polygones.  
  
##  <a name="getrop2"></a>CDC::GetROP2  
 Récupère le mode de dessin en cours.  
  
```  
int GetROP2() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de dessin. Pour obtenir la liste des valeurs de mode dessin, consultez la `SetROP2` fonction membre.  
  
### <a name="remarks"></a>Remarques  
 Le mode dessin spécifie comment les couleurs du stylet et à l’intérieur d’objets sont combinées avec la couleur déjà présent sur la surface d’affichage.  
  
##  <a name="getsafehdc"></a>CDC::GetSafeHdc  
 Appelez cette fonction membre pour obtenir [m_hDC](#m_hdc), le contexte de périphérique de sortie.  
  
```  
HDC GetSafeHdc() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Un handle de contexte de périphérique.  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre fonctionne également avec des pointeurs null.  
  
##  <a name="getstretchbltmode"></a>CDC::GetStretchBltMode  
 Récupère le mode d’étirement de bitmap en cours.  
  
```  
int GetStretchBltMode() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur de retour Spécifie le mode d’étirement de bitmap actuel : **STRETCH_ANDSCANS**, **STRETCH_DELETESCANS**, ou **STRETCH_ORSCANS** : si la fonction réussit.  
  
### <a name="remarks"></a>Notes  
 Le mode d’étirement de bitmap définit comment les informations sont supprimées de bitmaps qui sont étendues ou compressés par le `StretchBlt` fonction membre.  
  
 Le **STRETCH_ANDSCANS** et **STRETCH_ORSCANS** modes sont généralement utilisés pour conserver les pixels de premier plan dans les images bitmap monochromes. Le **STRETCH_DELETESCANS** mode est généralement utilisé pour conserver les couleurs dans les images bitmap de couleur.  
  
##  <a name="gettabbedtextextent"></a>CDC::GetTabbedTextExtent  
 Appelez cette fonction membre pour calculer la largeur et la hauteur d’une chaîne de caractères à l’aide de [m_hAttribDC](#m_hattribdc), le contexte de l’attribut.  
  
```  
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszString`  
 Pointe vers une chaîne de caractères. Vous pouvez également passer un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne. Si `nCount` est -1, la longueur est calculée.  
  
 `nTabPositions`  
 Spécifie le nombre de positions de taquet de tabulation dans le tableau vers lequel pointé `lpnTabStopPositions`.  
  
 `lpnTabStopPositions`  
 Pointe vers un tableau d’entiers qui contient les positions de taquet de tabulation dans les unités logiques. Les taquets de tabulation doivent être triées par ordre croissant de commande ; la plus petite valeur de x doit être le premier élément du tableau. Onglets précédent ne sont pas autorisés.  
  
 `str`  
 A `CString` objet qui contient les caractères spécifiés à dessiner.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) dans un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 Si la chaîne contient un ou plusieurs caractères de tabulation, la largeur de la chaîne est basée sur les taquets de tabulation spécifiés par `lpnTabStopPositions`. La fonction utilise la police actuellement sélectionnée pour calculer les dimensions de la chaîne.  
  
 Décalage de la zone de découpage en cours ne pas la largeur et la hauteur retournée par le `GetTabbedTextExtent` (fonction).  
  
 Étant donné que certains appareils ne placent pas de caractères dans les tableaux de cellule standard (autrement dit, ils crénage les caractères), la somme des étendues dans une chaîne de caractères peut être différent dans la mesure de la chaîne.  
  
 Si `nTabPositions` est égal à 0 et `lpnTabStopPositions` est **NULL**, onglets sont étendues à la largeur de caractère moyenne huit fois. Si `nTabPositions` est 1, les taquets de tabulation doivent être séparés par la distance spécifiée par la première valeur dans le tableau auquel `lpnTabStopPositions` points. Si `lpnTabStopPositions` points à plus d’une valeur unique, un taquet de tabulation a la valeur pour chaque valeur dans le tableau, jusqu’au nombre spécifié par `nTabPositions`.  
  
##  <a name="gettextalign"></a>CDC::GetTextAlign  
 Récupère l’état des indicateurs d’alignement de texte pour le contexte de périphérique.  
  
```  
UINT GetTextAlign() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 L’état des indicateurs d’alignement de texte. La valeur de retour est un ou plusieurs des valeurs suivantes :  
  
- **TA_BASELINE** Spécifie l’alignement de l’axe des abscisses et de la ligne de base de la police choisie dans le rectangle englobant.  
  
- **TA_BOTTOM** Spécifie l’alignement de l’axe des abscisses et le bas du rectangle englobant.  
  
- **TA_CENTER** Spécifie l’alignement de l’axe y et le centre du rectangle englobant.  
  
- **TA_LEFT** Spécifie l’alignement de l’axe y et le côté gauche du rectangle englobant.  
  
- **TA_NOUPDATECP** Spécifie que la position actuelle n’est pas mis à jour.  
  
- **TA_RIGHT** Spécifie l’alignement de l’axe y et le côté droit du rectangle englobant.  
  
- **TA_TOP** Spécifie l’alignement de l’axe des abscisses et le bord supérieur du rectangle englobant.  
  
- **TA_UPDATECP** Spécifie que la position actuelle est à jour.  
  
### <a name="remarks"></a>Remarques  
 Les indicateurs d’alignement de texte déterminent comment le `TextOut` et `ExtTextOut` fonctions membres alignement une chaîne de texte par rapport à point de départ de la chaîne. Les indicateurs de l’alignement de texte ne sont pas nécessairement unique bits indicateurs et peuvent être égales à 0. Pour tester si un indicateur est défini, une application doit suivre ces étapes :  
  
1.  Appliquer l’opérateur OR au niveau du bit à l’indicateur et ses indicateurs associés, regroupées comme suit :  
  
    - **TA_LEFT**, **TA_CENTER**, et **TA_RIGHT**  
  
    - **TA_BASELINE**, **TA_BOTTOM**, et **TA_TOP**  
  
    - **TA_NOUPDATECP** et **TA_UPDATECP**  
  
2.  Appliquer l’opérateur de bits- et opérateur le résultat et la valeur de retour de `GetTextAlign`.  
  
3.  Tester l’égalité de ce résultat et de l’indicateur.  
  
##  <a name="gettextcharacterextra"></a>CDC::GetTextCharacterExtra  
 Récupère la valeur actuelle pour la quantité d’espacement entre les caractères.  
  
```  
int GetTextCharacterExtra() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La quantité de l’espacement entre les caractères.  
  
### <a name="remarks"></a>Remarques  
 GDI ajoute cet espacement à chaque caractère, y compris les caractères de saut, lorsqu’il écrit une ligne de texte dans le contexte de périphérique.  
  
 La valeur par défaut pour la quantité d’espacement entre les caractères est 0.  
  
##  <a name="gettextcolor"></a>CDC::GetTextColor  
 Récupère la couleur de texte actuelle.  
  
```  
COLORREF GetTextColor() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La couleur de texte actuelle avec une valeur de couleur RVB.  
  
### <a name="remarks"></a>Remarques  
 La couleur du texte est la couleur de premier plan de caractères extraits à l’aide des fonctions membres de la sortie de texte GDI [TextOut](#textout), [ExtTextOut](#exttextout), et [TabbedTextOut](#tabbedtextout).  
  
##  <a name="gettextextent"></a>CDC::GetTextExtent  
 Appelez cette fonction membre pour calculer la largeur et la hauteur d’une ligne de texte à l’aide de la police actuelle pour déterminer les dimensions.  
  
```  
CSize GetTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpszString`  
 Pointe vers une chaîne de caractères. Vous pouvez également passer un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne.  
  
 `str`  
 A `CString` objet qui contient les caractères spécifiés.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) dans un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 Les informations sont récupérées à partir de [m_hAttribDC](#m_hattribdc), le contexte de l’attribut.  
  
 Par défaut, `GetTextExtent` suppose que le texte pour lequel il récupère la dimension est défini sur une ligne horizontale (autrement dit, l’échappement est 0). Si vous créez une police en spécifiant un échappement différent de zéro, vous devez convertir l’angle du texte explicitement pour obtenir les dimensions de la chaîne.  
  
 La zone de découpage en cours n’affecte pas la largeur et la hauteur retournée par `GetTextExtent`.  
  
 Étant donné que certains appareils ne placent pas de caractères dans les tableaux de cellule standard (autrement dit, ils effectuent le crénage), la somme des étendues dans une chaîne de caractères peut être différent dans la mesure de la chaîne.  
  
##  <a name="gettextextentexpointi"></a>CDC::GetTextExtentExPointI  
 Récupère le nombre de caractères dans une chaîne spécifiée qui pourra être contenue dans un espace spécifié et remplit un tableau avec l’étendue de texte pour chacun de ces caractères.  
  
```  
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,  
    int cgi,  
    int nMaxExtent,  
    LPINT lpnFit,  
    LPINT alpDx,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `pgiIn`  
 Pointeur vers un tableau d’index de glyphes pour lequel les extensions doivent être récupérés.  
  
 `cgi`  
 Spécifie le nombre de glyphes dans le tableau vers lequel pointé `pgiIn`.  
  
 `nMaxExtent`  
 Spécifie la largeur maximale autorisée, en unités logiques, de la chaîne mise en forme.  
  
 `lpnFit`  
 Un pointeur vers un entier qui reçoit un nombre du nombre maximal de caractères qui tiendront dans l’espace spécifié par `nMaxExtent`. Lorsque `lpnFit` est **NULL**, `nMaxExtent` est ignoré.  
  
 *alpDx*  
 Pointeur vers un tableau d’entiers qui reçoit des étendues de glyphe partielle. Chaque élément dans le tableau donne la distance, en unités logiques, entre le début du tableau d’index de glyphe et l’autre des glyphes qui s’ajuste à l’espace spécifié par `nMaxExtent`. Bien que ce tableau doit avoir au moins autant d’éléments en tant qu’index de glyphe spécifiés par `cgi`, la fonction remplit le tableau avec les étendues uniquement pour les index de glyphes autant spécifiés par `lpnFit`. Si *lpnDx* est **NULL**, la fonction ne calcule pas la largeur de la chaîne partielle.  
  
 `lpSize`  
 Pointeur vers un [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure qui reçoit les dimensions du tableau d’index de glyphe, en unités logiques. Cette valeur ne peut pas être **NULL**.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre émule la fonctionnalité de la fonction [GetTextExtentExPointI](http://msdn.microsoft.com/library/windows/desktop/dd144936), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="gettextextentpointi"></a>CDC::GetTextExtentPointI  
 Récupère la largeur et la hauteur du tableau spécifié d’index de glyphes.  
  
```  
BOOL GetTextExtentPointI(
    LPWORD pgiIn,  
    int cgi,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `pgiIn`  
 Pointeur vers un tableau d’index de glyphes pour lequel les extensions doivent être récupérés.  
  
 `cgi`  
 Spécifie le nombre de glyphes dans le tableau vers lequel pointé `pgiIn`.  
  
 `lpSize`  
 Pointeur vers un [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure qui reçoit les dimensions du tableau d’index de glyphe, en unités logiques. Cette valeur ne peut pas être **NULL**.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre émule la fonctionnalité de la fonction [GetTextExtentPointI](http://msdn.microsoft.com/library/windows/desktop/dd144939), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="gettextface"></a>CDC::GetTextFace  
 Appelez cette fonction membre pour copier le nom de la police actuelle dans une mémoire tampon.  
  
```  
int GetTextFace(
    int nCount,  
    LPTSTR lpszFacename) const;  
  
int GetTextFace(CString& rString) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `nCount`  
 Spécifie la taille de la mémoire tampon (en octets). Si le nom de la police est plus long que le nombre d’octets spécifié par ce paramètre, le nom est tronqué.  
  
 *lpszFacename*  
 Pointe vers la mémoire tampon pour le nom de la police.  
  
 `rString`  
 Une référence à un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet.  
  
### <a name="return-value"></a>Valeur de retour  
 Le nombre d’octets copiés dans la mémoire tampon, non compris le caractère null de fin. Il est 0 si une erreur se produit.  
  
### <a name="remarks"></a>Remarques  
 Le nom de la police est copié sous forme de chaîne se terminant par null.  
  
##  <a name="gettextmetrics"></a>CDC::GetTextMetrics  
 Récupère les métriques pour la police actuelle en utilisant le contexte de périphérique d’attribut.  
  
```  
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpMetrics`  
 Pointe vers le [TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132) structure qui reçoit les métriques.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="getviewportext"></a>CDC::GetViewportExt  
 Récupère les étendues x et y de la fenêtre d’affichage du contexte de périphérique.  
  
```  
CSize GetViewportExt() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le x - et y-extensions (en unités de l’appareil) en tant qu’un `CSize` objet.  
  
##  <a name="getviewportorg"></a>CDC::GetViewportOrg  
 Récupère les coordonnées x et y de l’origine de la fenêtre d’affichage associé au contexte de périphérique.  
  
```  
CPoint GetViewportOrg() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de la fenêtre d’affichage (dans les coordonnées de l’appareil) en tant qu’un `CPoint` objet.  
  
##  <a name="getwindow"></a>CDC::GetWindow  
 Retourne la fenêtre associée au contexte de périphérique d’affichage.  
  
```  
CWnd* GetWindow() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers un `CWnd` objet en cas de réussite ; **NULL**.  
  
### <a name="remarks"></a>Notes  
 Il s’agit d’une fonction avancée. Par exemple, cette fonction membre ne peut pas retourner la fenêtre d’affichage lors de l’impression ou dans l’aperçu avant impression. Elle retourne toujours la fenêtre de sortie. Dessinent des fonctions de sortie qui utilisent le contrôleur de domaine donné dans cette fenêtre.  
  
##  <a name="getwindowext"></a>CDC::GetWindowExt  
 Récupère les étendues x et y de la fenêtre associée au contexte de périphérique.  
  
```  
CSize GetWindowExt() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Le x - et y-extensions (en unités logiques) comme un `CSize` objet.  
  
##  <a name="getwindoworg"></a>CDC::GetWindowOrg  
 Récupère les coordonnées x et y de l’origine de la fenêtre associée au contexte de périphérique.  
  
```  
CPoint GetWindowOrg() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de la fenêtre (en coordonnées logiques) en tant qu’un `CPoint` objet.  
  
##  <a name="getworldtransform"></a>CDC::GetWorldTransform  
 Récupère l’espace de monde actuel pour la transformation de l’espace de page.  
  
```  
BOOL GetWorldTransform(XFORM& rXform) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `rXform`  
 Référence à un [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) structure qui reçoit l’espace de monde actuel pour la transformation de l’espace de page.  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne une valeur différente de zéro.  
  
 Retourne 0 en cas d’échec.  
  
 Pour obtenir des informations d’erreur plus complètes, appelez [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Notes  
 Cette méthode encapsule la fonction Windows GDI [GetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd144953).  
  
##  <a name="gradientfill"></a>CDC::GradientFill  
 Appelez cette fonction membre pour remplir les structures rectangle et le triangle de couleur sans heurts en fondu à partir d’un côté à l’autre.  
  
```  
BOOL GradientFill(
    TRIVERTEX* pVertices,  
    ULONG nVertices,  
    void* pMesh,  
    ULONG nMeshElements,  
    DWORD dwMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *pVertices*  
 Pointeur vers un tableau de [TRIVERTEX](http://msdn.microsoft.com/library/windows/desktop/dd145142) structures que définissent chacun un sommet du triangle.  
  
 *nVertices*  
 Le nombre de sommets.  
  
 `pMesh`  
 Tableau de [GRADIENT_TRIANGLE](http://msdn.microsoft.com/library/windows/desktop/dd144959) en mode de triangle ou un tableau de structures de [GRADIENT_RECT](http://msdn.microsoft.com/library/windows/desktop/dd144958) structures en mode de rectangle.  
  
 *nMeshElements*  
 Le nombre d’éléments (les triangles ou les rectangles) dans `pMesh`.  
  
 `dwMode`  
 Spécifie le mode de remplissage dégradé. Pour obtenir la liste des valeurs possibles, consultez [GradientFill](http://msdn.microsoft.com/library/windows/desktop/dd144957) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
### <a name="return-value"></a>Valeur de retour  
 **TRUE** cas de réussite ; **FALSE**.  
  
### <a name="remarks"></a>Remarques  
 Pour plus d’informations, consultez `GradientFill` dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="graystring"></a>CDC::GrayString  
 Dessine estompé texte (gris) à l’emplacement donné par l’écriture du texte dans une image bitmap de mémoire, estompage l’image bitmap, puis copie l’image bitmap à l’affichage.  
  
```  
virtual BOOL GrayString(
    CBrush* pBrush,  
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),  
    LPARAM lpData,  
    int nCount,  
    int x,  
    int y,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Paramètres  
 `pBrush`  
 Identifie le pinceau à utiliser pour estompage (graying).  
  
 `lpfnOutput`  
 Spécifie l’adresse de l’instance de la procédure de la fonction de rappel fournie par l’application qui dessine la chaîne. Pour plus d’informations, consultez la description de la fenêtre de **OutputFunc** [fonction de rappel](../../mfc/reference/callback-function-for-cdc-graystring.md). Si ce paramètre est **NULL**, le système utilise Windows `TextOut` fonction pour dessiner la chaîne, et `lpData` est supposé pour être un pointeur long vers la chaîne de caractères en sortie.  
  
 `lpData`  
 Spécifie un pointeur lointain vers les données à passer à la fonction de sortie. Si `lpfnOutput` est **NULL**, `lpData` doit être un pointeur long à la chaîne de sortie.  
  
 `nCount`  
 Spécifie le nombre de caractères en sortie. Si ce paramètre est 0, `GrayString` calcule la longueur de la chaîne (en supposant que `lpData` est un pointeur vers la chaîne). Si `nCount` est -1 et la fonction vers laquelle pointé `lpfnOutput` retourne 0, l’image est indiqué mais non estompés.  
  
 *x*  
 Spécifie la coordonnée x logique de la position de départ du rectangle qui englobe la chaîne.  
  
 *y*  
 Spécifie la coordonnée y logique de la position de départ du rectangle qui englobe la chaîne.  
  
 `nWidth`  
 Spécifie la largeur (en unités logiques) du rectangle qui englobe la chaîne. Si `nWidth` est 0, `GrayString` calcule la largeur de la zone, en supposant que `lpData` est un pointeur vers la chaîne.  
  
 `nHeight`  
 Spécifie la hauteur (en unités logiques) du rectangle qui englobe la chaîne. Si `nHeight` est 0, `GrayString` calcule la hauteur de la zone, en supposant que `lpData` est un pointeur vers la chaîne.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la chaîne est dessinée, ou 0 si le `TextOut` fonction ou la fonction fournie par l’application de sortie renvoyé 0, ou si la mémoire était insuffisante pour créer une image bitmap de mémoire pour cette fonction.  
  
### <a name="remarks"></a>Notes  
 La fonction efface le texte, quel que soit le pinceau sélectionné et l’arrière-plan. Le `GrayString` fonction membre utilise la police actuellement sélectionnée. Le `MM_TEXT` mode de mappage doit être sélectionné avant d’utiliser cette fonction.  
  
 Une application peut dessiner grisés chaînes (grisées) sur les appareils qui prennent en charge le gris uni sans appeler le `GrayString` fonction membre. La couleur système **COLOR_GRAYTEXT** est la couleur gris uni système utilisée pour dessiner le texte désactivé. L’application peut appeler le **GetSysColor** fonction Windows pour récupérer la valeur de couleur de **COLOR_GRAYTEXT**. Si la couleur est différente de 0 (noir), l’application peut appeler le `SetTextColor` fonction membre pour définir la couleur du texte à la valeur de couleur et puis dessiner directement la chaîne. Si la couleur récupérée est noire, l’application doit appeler `GrayString` d’estompage (gris) le texte.  
  
 Si `lpfnOutput` est **NULL**, GDI utilise Windows [TextOut](http://msdn.microsoft.com/library/windows/desktop/dd145133) (fonction), et `lpData` est supposé pour être un pointeur lointain vers le caractère de sortie. Si les caractères en sortie ne peut pas être traités par le `TextOut` fonction membre (par exemple, la chaîne est stockée sous forme de bitmap), l’application doit fournir sa propre fonction de sortie.  
  
 Notez également que toutes les fonctions de rappel doivent intercepter les exceptions de Microsoft Foundation avant de retourner à Windows, étant donné que les exceptions ne peut pas être levées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, consultez l’article [Exceptions](../../mfc/exception-handling-in-mfc.md).  
  
 La fonction de rappel passé à `GrayString` doit utiliser le `__stdcall` convention d’appel et doit être exporté avec `__declspec`.  
  
 Lorsque l’infrastructure est en mode Aperçu, un appel à la `GrayString` fonction membre est convertie en un `TextOut` appel et la fonction de rappel n’est pas appelée.  
  
##  <a name="himetrictodp"></a>CDC::HIMETRICtoDP  
 Utilisez cette fonction lorsque vous convertissez **HIMETRIC** tailles comprises entre OLE et pixels.  
  
```  
void HIMETRICtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpSize`  
 Pointe vers un [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 Si le mode de mappage de l’objet de contexte de périphérique est `MM_LOENGLISH`, `MM_HIENGLISH`, `MM_LOMETRIC` ou `MM_HIMETRIC`, la conversion est basée sur le nombre de pixels dans le pouce physique. Si le mode de mappage est un des autres modes non limité (par exemple, `MM_TEXT`), la conversion est basée sur le nombre de pixels dans le pouce logique.  
  
##  <a name="himetrictolp"></a>CDC::HIMETRICtoLP  
 Appelez cette fonction pour convertir **HIMETRIC** unités dans des unités logiques.  
  
```  
void HIMETRICtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpSize`  
 Pointe vers un [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 Utilisez cette fonction lorsque vous obtenez **HIMETRIC** tailles comprises entre OLE et souhaitez les convertir vers le mode de mappage naturel de votre application.  
  
 La conversion s’effectue en convertissant d’abord le **HIMETRIC** unités en pixels, puis en convertissant ces unités dans des unités logiques à l’aide d’unités de mappage du contexte de périphérique en cours. Notez que les étendues de fenêtre et la fenêtre d’affichage du périphérique affecte le résultat.  
  
##  <a name="intersectcliprect"></a>CDC::IntersectClipRect  
 Crée une nouvelle zone de découpage par l’intersection de la région en cours et le rectangle spécifié par `x1`, `y1`, `x2`, et `y2`.  
  
```  
int IntersectClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int IntersectClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle.  
  
 `y1`  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle.  
  
 `x2`  
 Spécifie la coordonnée x logique de l’angle inférieur droit du rectangle.  
  
 `y2`  
 Spécifie la coordonnée y logique de l’angle inférieur droit du rectangle.  
  
 `lpRect`  
 Spécifie le rectangle. Vous pouvez passer soit un `CRect` objet ou un pointeur vers un `RECT` structure pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de la nouvelle zone découpage. Il peut prendre l’une des valeurs suivantes :  
  
- **COMPLEXREGION** nouvelle zone de découpage a chevauchement des bordures.  
  
- **ERREUR** contexte de périphérique n’est pas valide.  
  
- **NULLREGION** nouvelle zone de découpage est vide.  
  
- **SIMPLEREGION** nouvelle zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Remarques  
 GDI fait coïncider toutes les sorties suivantes pour tenir dans la nouvelle limite. La largeur et la hauteur ne doivent pas dépasser 32 767.  
  
##  <a name="invertrect"></a>CDC::InvertRect  
 Inverse le contenu du rectangle donné.  
  
```  
void InvertRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers un `RECT` qui contient les coordonnées logiques du rectangle à inverser. Vous pouvez également passer un `CRect` objet pour ce paramètre.  
  
### <a name="remarks"></a>Notes  
 L’inversion est un opérateur logique non opération et retourne les bits de chaque pixel. Sur un écran monochrome, la fonction rend les pixels noir et noir pixels blancs blanc. Sur les écrans de couleur, l’inversion dépend de la façon dont les couleurs sont générés pour l’affichage. Appel de `InvertRect` à deux reprises avec le même rectangle restaure l’affichage précédent couleurs.  
  
 Si le rectangle est vide, rien n’est dessiné.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView #36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]  
  
##  <a name="invertrgn"></a>CDC::InvertRgn  
 Inverse les couleurs dans la zone spécifiée par `pRgn`.  
  
```  
BOOL InvertRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>Paramètres  
 `pRgn`  
 Identifie la région à inverser. Les coordonnées de la région sont spécifiées dans les unités logiques.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Sur un écran monochrome, la fonction rend les pixels noir et noir pixels blancs blanc. Sur les écrans de couleur, l’inversion dépend de la façon dont les couleurs sont générés pour l’affichage.  
  
##  <a name="isprinting"></a>CDC::IsPrinting  
 Détermine si le contexte de périphérique est utilisé pour l’impression.  
  
```  
BOOL IsPrinting() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la `CDC` est un objet contrôleur de domaine, sinon 0.  
  
##  <a name="lineto"></a>CDC::LineTo  
 Dessine une ligne à partir de la position actuelle jusqu'à, non compris, le point spécifié par *x* et *y* (ou `point`).  
  
```  
BOOL LineTo(
    int x,  
    int y);  
  
BOOL LineTo(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point de terminaison de la ligne.  
  
 *y*  
 Spécifie la coordonnée y logique du point de terminaison de la ligne.  
  
 `point`  
 Spécifie le point de terminaison de la ligne. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si la courbe est tracée ; Sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 La courbe est tracée avec le stylet sélectionné. La position actuelle est définie sur *x*, *y* ou `point`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).  
  
##  <a name="lptodp"></a>CDC::LPtoDP  
 Convertit des unités logiques en unités de périphérique.  
  
```  
void LPtoDP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de points. Chaque point dans le tableau est un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet.  
  
 `nCount`  
 Le nombre de points dans le tableau.  
  
 `lpRect`  
 Pointe vers un [RECT](../../mfc/reference/rect-structure1.md) structure ou un [CRect](../../atl-mfc-shared/reference/crect-class.md) objet. Ce paramètre est utilisé pour le cas courant de mappage d’un rectangle de logique d’unités de périphérique.  
  
 `lpSize`  
 Pointe vers un [taille](http://msdn.microsoft.com/library/windows/desktop/dd145106) structure ou un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet.  
  
### <a name="remarks"></a>Remarques  
 La fonction mappe les coordonnées de chaque point, ou les dimensions de taille, à partir du système de coordonnées logiques du GDI dans un système de coordonnées de périphérique. La conversion varie selon le mode de mappage en cours et les paramètres de l’origine et les étendues de fenêtre et la fenêtre d’affichage du périphérique.  
  
 Les coordonnées x et y de points sont des entiers signés de 2 octets dans la plage de-32 768 à 32 767. Dans les cas où le mode de mappage entraînerait des valeurs supérieures à ces limites, le système définit les valeurs de-32 768 et 32 767, respectivement.  
  
##  <a name="lptohimetric"></a>CDC::LPtoHIMETRIC  
 Appelez cette fonction pour convertir les unités logiques vers **HIMETRIC** unités.  
  
```  
void LPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpSize`  
 Pointe vers un **taille** structure ou un `CSize` objet.  
  
### <a name="remarks"></a>Notes  
 Utilisez cette fonction lorsque vous accordez **HIMETRIC** tailles à OLE, la conversion du mode de mappage naturel de votre application. Notez que les étendues de fenêtre et la fenêtre d’affichage du périphérique affecte le résultat.  
  
 La conversion s’effectue en convertissant d’abord les unités logiques en pixels, à l’aide d’unités de mappage du contexte de périphérique en cours, puis en convertissant ces unités vers **HIMETRIC** unités.  
  
##  <a name="m_hattribdc"></a>CDC::m_hAttribDC  
 Le contexte de périphérique d’attribut pour ce `CDC` objet.  
  
```  
HDC m_hAttribDC;  
```  
  
### <a name="remarks"></a>Notes  
 Par défaut, le contexte de périphérique est égal à `m_hDC`. En général, `CDC` appels GDI qui demandent des informations à partir du contexte de périphérique sont dirigés vers `m_hAttribDC`. Consultez le [CDC](../../mfc/reference/cdc-class.md) description pour plus d’informations sur l’utilisation de ces contextes de deux périphérique de la classe.  
  
##  <a name="m_hdc"></a>CDC::m_hDC  
 Le contexte de périphérique de sortie pour cette `CDC` objet.  
  
```  
HDC m_hDC;  
```  
  
### <a name="remarks"></a>Remarques  
 Par défaut, `m_hDC` équivaut à `m_hAttribDC`, l’autre contexte de périphérique encapsulé par `CDC`. En général, `CDC` appels GDI créer une sortie atteindre le `m_hDC` contexte de périphérique. Vous pouvez initialiser `m_hDC` et `m_hAttribDC` pour pointer vers différents appareils. Consultez le [CDC](../../mfc/reference/cdc-class.md) description pour plus d’informations sur l’utilisation de ces contextes de deux périphérique de la classe.  
  
##  <a name="maskblt"></a>CDC::MaskBlt  
 Combine les données de couleur pour les bitmaps sources et de destination à l’aide de la masque donné et l’opération de rastérisation.  
  
```  
BOOL MaskBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle de destination.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle de destination.  
  
 `nWidth`  
 Spécifie la largeur, en unités logiques, de la bitmap source et le rectangle de destination.  
  
 `nHeight`  
 Spécifie la hauteur, en unités logiques, de la bitmap source et le rectangle de destination.  
  
 `pSrcDC`  
 Identifie le contexte de périphérique à partir de laquelle l’image bitmap doit être copiée. Il doit être égal à zéro si la *dwRop* paramètre spécifie une opération de rastérisation qui n’inclut pas d’une source.  
  
 `xSrc`  
 Spécifie la coordonnée x logique de l’angle supérieur gauche de la bitmap source.  
  
 `ySrc`  
 Spécifie la coordonnée y logique de l’angle supérieur gauche de la bitmap source.  
  
 `maskBitmap`  
 Identifie la bitmap monochrome masque associée à la bitmap de couleur dans le contexte du périphérique source.  
  
 `xMask`  
 Spécifie le décalage horizontal pixels du bitmap masque spécifié par le `maskBitmap` paramètre.  
  
 `yMask`  
 Spécifie le décalage vertical pixel de la bitmap de masque spécifié par le `maskBitmap` paramètre.  
  
 *dwRop*  
 Spécifie le premier plan et arrière-plan ternaire opération de rastérisation, dont la fonction utilise pour contrôler la combinaison de données source et de destination. Le code d’opération en arrière-plan raster est stocké dans l’octet de poids fort du mot haut de cette valeur ; le code d’opération raster au premier plan est stocké dans l’octet de poids faible de mot haut de cette valeur ; le mot de poids faible de cette valeur est ignorée et doit être égal à zéro. La macro **MAKEROP4** crée ces combinaisons de premier plan et arrière-plan opération de rastérisation. Consultez la section Notes pour une présentation de premier plan et d’arrière-plan dans le contexte de cette fonction. Consultez le `BitBlt` fonction membre pour obtenir la liste des codes d’opération raster courants.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Une valeur de 1 dans le masque spécifié par `maskBitmap` indique que le code d’opération raster au premier plan spécifié par *dwRop* doit être appliqué à cet emplacement. La valeur 0 dans le masque indique que le code d’opération en arrière-plan raster spécifié par *dwRop* doit être appliqué à cet emplacement. Si les opérations raster besoin d’une source, le rectangle masque doit couvrir le rectangle source. Si elle n’est pas le cas, la fonction échoue. Si les opérations raster ne nécessitent pas une source, le rectangle masque doit couvrir le rectangle de destination. Si elle n’est pas le cas, la fonction échoue.  
  
 Si une transformation de rotation ou inclinaison est appliquée pour le contexte du périphérique source lorsque cette fonction est appelée, une erreur se produit. Toutefois, les autres types de transformations sont autorisés.  
  
 Si les formats de couleur de la source, modèle et les bitmaps de destination diffèrent, cette fonction convertit le modèle ou format source ou les deux, pour correspondre au format de destination. Si l’image bitmap masque n’est pas une image bitmap monochrome, une erreur se produit. Lorsqu’un métafichier amélioré est en cours d’enregistrement, une erreur se produit (et la fonction renvoie la valeur 0) si le contexte du périphérique source identifie un contexte de périphérique de métafichier amélioré. Prise en charge par tous les périphériques `MaskBlt`. Une application doit appeler `GetDeviceCaps` pour déterminer si un périphérique prend en charge cette fonction. Si aucune bitmap masque n’est fournie, cette fonction se comporte exactement comme `BitBlt`, à l’aide du code d’opération de rastérisation au premier plan. Le pixel décalages dans le mappage de bitmap masque au point de (0,0) dans la bitmap du contexte du périphérique source. Cela est utile pour les cas où une image bitmap masque contient un ensemble de masques ; une application peut appliquer facilement l’un d'entre eux à une tâche de fusion de masque en ajustant les décalages de pixels et la taille du rectangle envoyées à `MaskBlt`.  
  
##  <a name="modifyworldtransform"></a>CDC::ModifyWorldTransform  
 Modifie la transformation universelle pour un contexte de périphérique en utilisant le mode spécifié.  
  
```  
BOOL ModifyWorldTransform(
    const XFORM& rXform,  
    DWORD iMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `rXform`  
 Référence à un [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) structure utilisée pour modifier la transformation universelle pour le contexte de périphérique donné.  
  
 `iMode`  
 Spécifie la façon dont les données de transformation modifie la transformation universelle en cours. Pour obtenir la liste des valeurs possibles de ce paramètre, consultez [ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060).  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne une valeur différente de zéro.  
  
 Retourne 0 en cas d’échec.  
  
 Pour obtenir des informations d’erreur plus complètes, appelez [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Remarques  
 Cette méthode encapsule la fonction Windows GDI [ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060).  
  
##  <a name="moveto"></a>CDC::MoveTo  
 Déplace la position actuelle du point spécifié par *x* et *y* (ou par `point`).  
  
```  
CPoint MoveTo(
    int x,  
    int y);  
  
CPoint MoveTo(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du nouvel emplacement.  
  
 *y*  
 Spécifie la coordonnée y logique du nouvel emplacement.  
  
 `point`  
 Spécifie la nouvelle position. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Les coordonnées x et y de la position précédente en tant qu’un `CPoint` objet.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).  
  
##  <a name="offsetcliprgn"></a>CDC::OffsetClipRgn  
 Déplace la zone de découpage du contexte de périphérique par le décalage spécifiés.  
  
```  
int OffsetClipRgn(
    int x,  
    int y);  
  
int OffsetClipRgn(SIZE size);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie le nombre d’unités logiques à déplacer vers la gauche ou droite.  
  
 *y*  
 Spécifie le nombre d’unités logiques pour faire monter ou Descendre.  
  
 `size`  
 Spécifie la valeur de décalage.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de la nouvelle région. Il peut prendre l’une des valeurs suivantes :  
  
- **COMPLEXREGION** zone de découpage a chevauchement des bordures.  
  
- **ERREUR** contexte de périphérique n’est pas valide.  
  
- **NULLREGION** zone de découpage est vide.  
  
- **SIMPLEREGION** zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 La fonction déplace la région *x* unités sur l’axe x et *y* unités sur l’axe y.  
  
##  <a name="offsetviewportorg"></a>CDC::OffsetViewportOrg  
 Modifie les coordonnées de l’origine de la fenêtre d’affichage par rapport aux coordonnées de l’origine de la fenêtre d’affichage actuel.  
  
```  
virtual CPoint OffsetViewportOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Paramètres  
 `nWidth`  
 Spécifie le nombre d’unités de périphérique à ajouter à la coordonnée x de l’origine actuelle.  
  
 `nHeight`  
 Spécifie le nombre d’unités de périphérique à ajouter à la coordonnée y de l’origine actuelle.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de la fenêtre d’affichage précédent (dans les coordonnées de l’appareil) en tant qu’un `CPoint` objet.  
  
##  <a name="offsetwindoworg"></a>CDC::OffsetWindowOrg  
 Modifie les coordonnées de l’origine de la fenêtre par rapport aux coordonnées de l’origine de la fenêtre en cours.  
  
```  
CPoint OffsetWindowOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>Paramètres  
 `nWidth`  
 Spécifie le nombre d’unités logiques à ajouter à la coordonnée x de l’origine actuelle.  
  
 `nHeight`  
 Spécifie le nombre d’unités logiques à ajouter à la coordonnée y de l’origine actuelle.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine de fenêtre précédent (en coordonnées logiques) comme un `CPoint` objet.  
  
##  <a name="operator_hdc"></a>CDC::operator HDC  
 Utilisez cet opérateur pour récupérer le handle de contexte de périphérique de la `CDC` objet.  
  
```  
operator HDC() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, le handle de l’objet de contexte de périphérique. dans le cas contraire, **NULL**.  
  
### <a name="remarks"></a>Remarques  
 Vous pouvez utiliser le handle d’appeler directement des API Windows.  
  
##  <a name="paintrgn"></a>CDC::PaintRgn  
 Remplit la région spécifiée par `pRgn` à l’aide de la brosse courante.  
  
```  
BOOL PaintRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>Paramètres  
 `pRgn`  
 Identifie la zone à remplir. Les coordonnées de la région donnée sont spécifiées dans les unités logiques.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
##  <a name="patblt"></a>CDC::PatBlt  
 Crée une série de bits sur l’appareil.  
  
```  
BOOL PatBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle qui doit recevoir le modèle.  
  
 *y*  
 Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle qui doit recevoir le modèle.  
  
 `nWidth`  
 Spécifie la largeur (en unités logiques) du rectangle qui doit recevoir le modèle.  
  
 `nHeight`  
 Spécifie la hauteur (en unités logiques) du rectangle qui doit recevoir le modèle.  
  
 *dwRop*  
 Spécifie le code d’opération de rastérisation. Codes d’opération de rastérisation (ROP) définissent la façon dont GDI associe les couleurs dans les opérations de sortie qui impliquent le pinceau actuel, un éventuel bitmap source et une image bitmap de destination. Ce paramètre peut être une des valeurs suivantes :  
  
- **PATCOPY** modèle de Copies de l’image bitmap de destination.  
  
- **PATINVERT** combine l’image bitmap de destination avec le modèle à l’aide de l’opérateur booléen XOR.  
  
- **DSTINVERT** inverse le bitmap de destination.  
  
- **NOIRCEUR** désactive toutes les sorties noir.  
  
- **WHITENESS** désactive toutes les sorties blanc.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le modèle est une combinaison du pinceau sélectionné et le modèle déjà présent sur l’appareil. Le code d’opération de rastérisation spécifié par *dwRop* définit la manière dont les modèles doivent être combinées. Les opérations raster répertoriées pour cette fonction sont un sous-ensemble limité des codes d’opération de rastérisation ternaire 256 complète ; en particulier, un code d’opération de rastérisation qui fait référence à une source ne peut pas être utilisé.  
  
 Pas de tous les contextes de périphérique prend en charge la `PatBlt` (fonction). Pour déterminer si un contexte de périphérique prend en charge `PatBlt`, appelez le `GetDeviceCaps` fonction membre avec le **RASTERCAPS** d’index et vérifiez la valeur de retour pour la **RC_BITBLT** indicateur.  
  
##  <a name="pie"></a>CDC::Pie  
 Dessine un secteur en dessinant un arc elliptique dont le centre et les deux points de terminaison sont jointes par des lignes.  
  
```  
BOOL Pie(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x de l’angle supérieur gauche du rectangle englobant (en unités logiques).  
  
 `y1`  
 Spécifie la coordonnée y de l’angle supérieur gauche du rectangle englobant (en unités logiques).  
  
 `x2`  
 Spécifie la coordonnée x de l’angle inférieur droit du rectangle englobant (en unités logiques).  
  
 `y2`  
 Spécifie la coordonnée y du coin inférieur droit du rectangle englobant (en unités logiques).  
  
 *x3*  
 Spécifie la coordonnée x du point de départ de l’arc (en unités logiques). Ce point n’a pas à se situer exactement sur l’arc.  
  
 `y3`  
 Spécifie la coordonnée y du point de départ de l’arc (en unités logiques). Ce point n’a pas à se situer exactement sur l’arc.  
  
 `x4`  
 Spécifie la coordonnée x du point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se situer exactement sur l’arc.  
  
 `y4`  
 Spécifie la coordonnée y du point de terminaison de l’arc (en unités logiques). Ce point n’a pas à se situer exactement sur l’arc.  
  
 `lpRect`  
 Spécifie le rectangle englobant. Vous pouvez passer soit un `CRect` objet ou un pointeur vers un `RECT` structure pour ce paramètre.  
  
 `ptStart`  
 Spécifie le point de départ de l’arc. Ce point n’a pas à se situer exactement sur l’arc. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
 `ptEnd`  
 Spécifie le point de terminaison de l’arc. Ce point n’a pas à se situer exactement sur l’arc. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le centre de l’arc est le centre du rectangle englobant spécifié par `x1`, `y1`, `x2`, et `y2` (ou par `lpRect`). Le début et fin de l’arc sont spécifiées par *x3*, `y3`, `x4`, et `y4` (ou par `ptStart` et `ptEnd`).  
  
 L’arc est dessiné avec le stylet sélectionné, déplacement dans une direction vers la gauche. Deux lignes supplémentaires sont dessinés au centre de l’arc chaque point de terminaison. La zone en forme de graphique à secteurs est remplie avec le pinceau actuel. Si *x3* est égal à `x4` et `y3` est égal à `y4`, le résultat est une ellipse avec une seule ligne à partir du centre de l’ellipse pour le point ( *x3*, `y3`) ou ( `x4`, `y4`).  
  
 La figure dessinée par cette fonction étend jusqu'à mais n’inclut pas les coordonnées de droite et en bas. Cela signifie que la hauteur de la figure est `y2`  -  `y1` et la largeur de la figure est `x2`  -  `x1`. La largeur et la hauteur du rectangle englobant doivent être supérieures à 2 unités et inférieure à 32 767.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView #37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]  
  
##  <a name="playmetafile"></a>CDC::PlayMetaFile  
 Lit le contenu du métafichier spécifié sur le contexte de périphérique.  
  
```  
BOOL PlayMetaFile(HMETAFILE hMF);

 
BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,  
    LPCRECT lpBounds);
```  
  
### <a name="parameters"></a>Paramètres  
 *hMF*  
 Identifie le métafichier devant être lu.  
  
 *hEnhMetaFile*  
 Identifie le métafichier amélioré.  
  
 `lpBounds`  
 Pointe vers un `RECT` structure ou un `CRect` objet qui contient les coordonnées du rectangle englobant utilisé pour afficher l’image. Les coordonnées sont spécifiées en unités logiques.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le métafichier peut être lus à n’importe quel nombre de fois.  
  
 La deuxième version de `PlayMetaFile` affiche l’image stockée dans le métafichier de format amélioré donné. Lorsqu’une application appelle la deuxième version de `PlayMetaFile`, Windows utilise l’image dans l’en-tête du métafichier amélioré pour mapper l’image sur le rectangle vers lequel pointé le `lpBounds` paramètre. (Cette image peut être inclinée ou pivotée en définissant la transformation universelle dans le périphérique de sortie avant d’appeler `PlayMetaFile`.) Points le long des bords du rectangle sont inclus dans l’image. Un métafichier amélioré peut être découpée en définissant la zone de découpage dans le périphérique de sortie avant de lire le métafichier amélioré.  
  
 Si un métafichier amélioré contient une palette facultatif, une application peut obtenir des couleurs cohérentes en définissant une palette de couleurs sur le périphérique de sortie avant l’appel de la deuxième version de `PlayMetaFile`. Pour récupérer la palette facultatif, utilisez le **GetEnhMetaFilePaletteEntries** fonction Windows. Un métafichier amélioré peut être incorporé dans un métafichier amélioré qui vient d’être créé en appelant la deuxième version de `PlayMetaFile` et lire le métafichier amélioré de source dans le contexte de périphérique pour le nouveau métafichier amélioré.  
  
 Les États du contexte de périphérique de sortie sont conservés par cette fonction. Tout objet créé mais ne pas supprimés dans le métafichier amélioré est supprimé par cette fonction. Pour arrêter cette fonction, une application peut appeler le **CancelDC** fonction Windows à partir d’un autre thread pour terminer l’opération. Dans ce cas, la fonction retourne zéro.  
  
##  <a name="plgblt"></a>CDC::PlgBlt  
 Effectue un transfert de bloc de bits des bits de données de couleur du rectangle spécifié dans le contexte du périphérique source au parallélogramme spécifié dans le contexte de périphérique donné.  
  
```  
BOOL PlgBlt(
    LPPOINT lpPoint,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nWidth,  
    int nHeight,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoint`  
 Pointe vers un tableau de trois points dans l’espace logique qui identifie les trois angles du parallélogramme de destination. L’angle supérieur gauche du rectangle source est mappé au premier point dans ce tableau, l’angle supérieur droit et le deuxième point dans ce tableau et l’angle inférieur gauche et le troisième point. L’angle inférieur droit du rectangle source est mappé au quatrième point dans un parallélogramme implicit.  
  
 `pSrcDC`  
 Identifie le contexte du périphérique source.  
  
 `xSrc`  
 Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle source.  
  
 `ySrc`  
 Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle source.  
  
 `nWidth`  
 Spécifie la largeur, en unités logiques, du rectangle source.  
  
 `nHeight`  
 Spécifie la hauteur, en unités logiques, du rectangle source.  
  
 `maskBitmap`  
 Identifie une bitmap monochrome facultatif qui permet de masquer les couleurs du rectangle source.  
  
 `xMask`  
 Spécifie la coordonnée x de l’angle supérieur gauche de l’image bitmap monochrome.  
  
 `yMask`  
 Spécifie la coordonnée y de l’angle supérieur gauche de l’image bitmap monochrome.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Si le handle du masque de bits donné identifie un bitmap monochrome valid, la fonction utilise cette image bitmap pour masquer les bits des données de couleur du rectangle source.  
  
 La quatrième sommet du parallélogramme (D) est défini en traitant les trois premiers points (A, B et C) comme des vecteurs et informatique D = B + C - A.  
  
 Si le masque de bits existe, une valeur de 1 dans le masque indique que la couleur de pixel source doit être copiée vers la destination. La valeur 0 dans le masque indique que la couleur de pixel de destination doit ne pas être modifiée.  
  
 Si le rectangle de masque est plus petit que les rectangles source et de destination, la fonction réplique le modèle de masque.  
  
 Les transformations de mise à l’échelle, de translation et de réflexion sont autorisées dans le contexte du périphérique source ; Toutefois, les transformations de rotation et l’inclinaison ne sont pas. Si l’image bitmap masque n’est pas une image bitmap monochrome, une erreur se produit. Le mode d’étirement pour le contexte de périphérique de destination est utilisé pour déterminer comment étirer ou compresser les pixels, si cela est nécessaire. Lorsqu’un métafichier amélioré est en cours d’enregistrement, une erreur se produit si le contexte du périphérique source identifie un contexte de périphérique de métafichier amélioré.  
  
 Les coordonnées de destination sont transformées en fonction du contexte du périphérique de destination ; les coordonnées sources sont transformées en fonction du contexte du périphérique source. Si la transformation source possède une rotation ou une inclinaison, une erreur est retournée. Si les rectangles de source et de destination n’ont pas le même format de couleur, `PlgBlt` convertit le rectangle source pour faire correspondre le rectangle de destination. Prise en charge par tous les périphériques `PlgBlt`. Pour plus d’informations, consultez la description de la **RC_BITBLT** fonctionnalité raster dans la `CDC::GetDeviceCaps` fonction membre.  
  
 Si les contextes de périphérique source et destination représentent des périphériques incompatibles, `PlgBlt` renvoie une erreur.  
  
##  <a name="polybezier"></a>CDC::PolyBezier  
 Dessine une ou plusieurs splines de Bzier.  
  
```  
BOOL PolyBezier(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui contiennent les points de terminaison et des points de contrôle de le spline(s).  
  
 `nCount`  
 Spécifie le nombre de points dans le `lpPoints` tableau. Cette valeur doit être plus de trois fois le nombre de splines à dessiner, étant donné que chaque Bzier nécessitent deux points de contrôle et un point de terminaison et la spline initiale requiert un point de départ supplémentaire.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction dessine des splines Bzier cubiques en utilisant les points de terminaison et les points de contrôle spécifiés par le `lpPoints` paramètre. La première spline est dessinée à partir du premier point au quatrième point à l’aide des deuxième et troisième points comme points de contrôle. Chaque spline suivante dans la séquence doit exactement trois points supplémentaires : le point de fin de la précédente est utilisé comme point de départ, les deux points dans la séquence sont des points de contrôle et le troisième est le point de terminaison.  
  
 La position actuelle n’est ni utilisée ni mise à jour par le `PolyBezier` (fonction). La figure n’est pas renseignée. Cette fonction dessine des lignes à l’aide du stylet courant.  
  
##  <a name="polybezierto"></a>CDC::PolyBezierTo  
 Dessine une ou plusieurs splines de Bzier.  
  
```  
BOOL PolyBezierTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui contient les points de terminaison et le contrôle des points.  
  
 `nCount`  
 Spécifie le nombre de points dans le `lpPoints` tableau. Cette valeur doit être de trois fois le nombre de splines à dessiner, étant donné que chaque Bzier nécessitent deux points de contrôle et un point de terminaison.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction dessine des splines Bzier cubiques en utilisant les points de contrôle spécifiés par le `lpPoints` paramètre. La première spline est dessinée à partir de la position actuelle pour le troisième point en utilisant les deux premiers points comme points de contrôle. Pour chaque spline ultérieur, la fonction doit exactement trois points supplémentaires et utilise le point de fin de la précédente comme point de départ pour la prochaine. `PolyBezierTo`Déplace la position actuelle vers le point de fin de la dernière Bzier. La figure n’est pas renseignée. Cette fonction dessine des lignes à l’aide du stylet courant.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="polydraw"></a>CDC::PolyDraw  
 Dessine un ensemble de segments de ligne et de splines de Bzier.  
  
```  
BOOL PolyDraw(
    const POINT* lpPoints,  
    const BYTE* lpTypes,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui contient les points de terminaison pour chaque segment et les points de terminaison de ligne et de points pour chaque spline Bzier de contrôle.  
  
 `lpTypes`  
 Pointe vers un tableau qui spécifie la façon dont chaque point dans le `lpPoints` tableau est utilisé. Valeurs peuvent être les suivantes :  
  
- **PT_MOVETO** Spécifie que ce point démarre une figure distincte. Ce point devient la nouvelle position actuelle.  
  
- **PT_LINETO** Spécifie qu’une ligne doit être dessiné à partir de la position actuelle vers ce point, qui devient alors la nouvelle position actuelle.  
  
- **PT_BEZIERTO** Spécifie que ce point est un point de contrôle ou d’un point de fin d’une spline Bzier.  
  
 **PT_BEZIERTO** toujours se produire dans les ensembles de trois. La position actuelle définit le point de départ pour la spline Bzier. Les deux premières **PT_BEZIERTO** points sont les points de contrôle et le troisième **PT_BEZIERTO** point est le point de fin. Le point de fin devient la nouvelle position actuelle. S’il n’existe pas trois consécutifs **PT_BEZIERTO** points, une erreur se produit.  
  
     A **PT_LINETO** ou **PT_BEZIERTO** type peut être combiné avec la constante suivante à l’aide de l’opérateur au niveau du bit ou pour indiquer que le point correspondant est le dernier point dans un graphique et de la figure est fermée :  
  
- **PT_CLOSEFIGURE** Spécifie que la figure est fermée automatiquement après le **PT_LINETO** ou **PT_BEZIERTO** de type pour ce point est effectué. Une ligne est tracée à partir de ce point à la plus récente **PT_MOVETO** ou `MoveTo` point.  
  
     Cet indicateur est combiné avec le **PT_LINETO** type pour une ligne, ou avec le **PT_BEZIERTO** type de point de fin pour une spline Bzier, à l’aide de l’opérateur de bits `OR` opérateur. La position actuelle est définie pour le point de fin de la ligne de fermeture.  
  
 `nCount`  
 Spécifie le nombre total de points dans le `lpPoints` de tableau, le même que le nombre d’octets dans le `lpTypes` tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Cette fonction peut être utilisée pour dessiner des figures disjoints à la place des appels successifs à `CDC::MoveTo`, `CDC::LineTo`, et `CDC::PolyBezierTo` fonctions membres. Les lignes et splines sont dessinées à l’aide du stylet courant et chiffres ne sont pas remplis. S’il existe un chemin d’accès actif lancée en appelant le `CDC::BeginPath` fonction membre, `PolyDraw` ajoute le chemin d’accès. Les points contenus dans le `lpPoints` tableau et dans `lpTypes` indiquer si chaque point fait partie d’un `CDC::MoveTo`, un `CDC::LineTo`, ou un **CDC::BezierTo** opération. Il est également possible de fermer les chiffres. Cette fonction met à jour la position actuelle.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="polygon"></a>CDC::Polygon  
 Dessine un polygone composé de deux ou plusieurs points (sommets) connectés par des lignes, à l’aide du stylet courant.  
  
```  
BOOL Polygon(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de points qui spécifie les sommets du polygone. Chaque point dans le tableau est un **POINT** structure ou un `CPoint` objet.  
  
 `nCount`  
 Spécifie le nombre de sommets dans le tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le système ferme le polygone automatiquement, si nécessaire, en dessinant une ligne à partir du dernier sommet au premier.  
  
 Le mode de remplissage de polygones en cours permettre être récupéré ou défini à l’aide de la `GetPolyFillMode` et `SetPolyFillMode` fonctions membres.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView #38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]  
  
##  <a name="polyline"></a>CDC::Polyline  
 Dessine un ensemble de segments de ligne reliant les points spécifiés par `lpPoints`.  
  
```  
BOOL Polyline(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de **POINT** structures ou `CPoint` objets pour la connexion.  
  
 `nCount`  
 Spécifie le nombre de points dans le tableau. Cette valeur doit être au moins 2.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Les lignes sont dessinées à partir du premier point via les points suivants à l’aide du stylet courant. Contrairement à la `LineTo` fonction membre, le `Polyline` fonction utilise ni mises à jour de la position actuelle.  
  
 Pour plus d’informations, consultez [polyligne](http://msdn.microsoft.com/library/windows/desktop/dd162815) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="polylineto"></a>CDC::PolylineTo  
 Dessine une ou plusieurs lignes droites.  
  
```  
BOOL PolylineTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de [POINT](../../mfc/reference/point-structure1.md) des structures de données qui contient les sommets de la ligne.  
  
 `nCount`  
 Spécifie le nombre de points dans le tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Une ligne est tracée à partir de la position actuelle et le premier point spécifié par le `lpPoints` paramètre à l’aide du stylet courant. Pour chaque ligne supplémentaire, la fonction de trace à partir du point de fin de la ligne précédente au point suivant spécifié par `lpPoints`. `PolylineTo`Déplace la position actuelle jusqu'à la fin de la dernière ligne. Si les segments de ligne dessinées par cette fonction forment une figure fermée, la figure n’est pas renseignée.  
  
##  <a name="polypolygon"></a>CDC::PolyPolygon  
 Crée deux ou plusieurs polygones qui sont remplis à l’aide du mode de remplissage de polygones en cours.  
  
```  
BOOL PolyPolygon(
    LPPOINT lpPoints,  
    LPINT lpPolyCounts,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de **POINT** structures ou `CPoint` objets qui définissent les sommets du polygone.  
  
 `lpPolyCounts`  
 Pointe vers un tableau d’entiers, chacun d’eux spécifie le nombre de points dans un des polygones dans la `lpPoints` tableau.  
  
 `nCount`  
 Le nombre d’entrées dans le `lpPolyCounts` tableau. Ce nombre spécifie le nombre de polygones à dessiner. Cette valeur doit être au moins 2.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Les polygones peuvent être disjoints ou qui se chevauchent.  
  
 Chaque polygone spécifié dans un appel à la `PolyPolygon` fonction doit être fermée. Contrairement aux polygones créés par le **polygone** fonction membre, les polygones créés par `PolyPolygon` ne sont pas fermées automatiquement.  
  
 La fonction crée deux ou plusieurs polygones. Pour créer un polygone unique, une application doit utiliser le **polygone** fonction membre.  
  
 Le mode de remplissage de polygones en cours permettre être récupéré ou défini à l’aide de la `GetPolyFillMode` et `SetPolyFillMode` fonctions membres.  
  
##  <a name="polypolyline"></a>CDC::PolyPolyline  
 Dessine plusieurs séries de segments de ligne connectés.  
  
```  
BOOL PolyPolyline(
    const POINT* lpPoints,  
    const DWORD* lpPolyPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpPoints`  
 Pointe vers un tableau de structures qui contient les sommets des polylignes. Les polylignes sont spécifiés consécutifs.  
  
 `lpPolyPoints`  
 Pointe vers un tableau de variables en spécifiant le nombre de points dans le `lpPoints` tableau pour le polygone correspondant. Chaque entrée doit être supérieure ou égale à 2.  
  
 `nCount`  
 Spécifie le nombre total des nombres dans les `lpPolyPoints` tableau.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Les segments de ligne sont dessinées à l’aide du stylet courant. Les figures formés par les segments ne sont pas remplies. La position actuelle n’est ni utilisée ni mise à jour par cette fonction.  
  
##  <a name="ptvisible"></a>CDC::PtVisible  
 Détermine si le point donné est dans la zone de découpage du contexte de périphérique.  
  
```  
virtual BOOL PtVisible(
    int x,  
    int y) const;  
  
BOOL PtVisible(POINT point) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point.  
  
 *y*  
 Spécifie la coordonnée y logique du point.  
  
 `point`  
 Spécifie le point à vérifier en coordonnées logiques. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si le point spécifié dans la zone de découpage ; Sinon, 0.  
  
##  <a name="queryabort"></a>CDC::QueryAbort  
 Appelle la fonction abort installée par le [SetAbortProc](#setabortproc) fonction membre pour l’application d’impression et les requêtes si l’impression doit être terminée.  
  
```  
BOOL QueryAbort() const;  
```  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur de retour est différente de zéro si l’impression doit continuer ou s’il n’existe aucune procédure d’abandon. Il est 0 si le travail d’impression doit être terminé. La valeur de retour est fournie par la fonction d’annulation.  
  
##  <a name="realizepalette"></a>CDC::RealizePalette  
 Mappe des entrées de la palette logique actuelle vers la palette système.  
  
```  
UINT RealizePalette();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Indique le nombre d’entrées dans la palette logique ont été mappé à des entrées différentes dans la palette système. Représente le nombre d’entrées remappée de cette fonction pour prendre en compte les modifications de la palette système depuis la dernière réalisation de la palette logique.  
  
### <a name="remarks"></a>Remarques  
 Une palette de couleurs logique agit comme une mémoire tampon entre les applications gourmandes en couleur et le système, permettant à une application à utiliser comme nombre de couleurs en fonction des besoins sans interférer avec son propre affiche des couleurs ou des couleurs affichées par d’autres fenêtres.  
  
 Lorsqu’une fenêtre a le focus d’entrée et appelle `RealizePalette`, Windows garantit que la fenêtre affiche toutes les couleurs demandées, le nombre maximal disponible simultanément sur l’écran. Windows affiche également les couleurs introuvables dans la palette de la fenêtre en faisant correspondre les couleurs disponibles.  
  
 En outre, Windows met en correspondance les couleurs demandées par les fenêtres inactives qui appellent la fonction autant que possible pour les couleurs disponibles. Cela réduit considérablement les modifications indésirables dans les couleurs affichées dans les fenêtres inactives.  
  
##  <a name="rectangle"></a>CDC::rectangle  
 Dessine un rectangle à l’aide du stylet courant.  
  
```  
BOOL Rectangle(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Rectangle(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x de l’angle supérieur gauche du rectangle (en unités logiques).  
  
 `y1`  
 Spécifie la coordonnée y de l’angle supérieur gauche du rectangle (en unités logiques).  
  
 `x2`  
 Spécifie la coordonnée x de l’angle inférieur droit du rectangle (en unités logiques).  
  
 `y2`  
 Spécifie la coordonnée y du coin inférieur droit du rectangle (en unités logiques).  
  
 `lpRect`  
 Spécifie le rectangle en unités logiques. Vous pouvez passer soit un `CRect` objet ou un pointeur vers un `RECT` structure pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 L’intérieur du rectangle est remplie à l’aide de la brosse courante.  
  
 Le rectangle s’étend jusqu'à, mais n’inclut pas les coordonnées de droite et en bas. Cela signifie que la hauteur du rectangle est `y2`  -  `y1` et la largeur du rectangle est `x2`  -  `x1`. La largeur et la hauteur d’un rectangle doivent être supérieures à 2 unités et inférieure à 32 767.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[NVC_MFCDocView #39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]  
  
##  <a name="rectvisible"></a>CDC::RectVisible  
 Détermine si une partie du rectangle donné se trouve dans la zone de découpage du contexte d’affichage.  
  
```  
virtual BOOL RectVisible(LPCRECT lpRect) const;  
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRect`  
 Pointe vers un `RECT` structure ou un `CRect` objet qui contient les coordonnées logiques du rectangle spécifié.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si une partie du rectangle donné se trouve dans la zone de découpage ; Sinon, 0.  
  
##  <a name="releaseattribdc"></a>CDC::ReleaseAttribDC  
 Appelez cette fonction membre pour définir `m_hAttribDC` à **NULL**.  
  
```  
virtual void ReleaseAttribDC();
```  
  
### <a name="remarks"></a>Remarques  
 Cela ne provoque pas une **détachement** se produise. Seul le contexte de périphérique de sortie est attaché à la `CDC` objet et il peuvent être détachée.  
  
##  <a name="releaseoutputdc"></a>CDC::ReleaseOutputDC  
 Appelez cette fonction membre pour définir le `m_hDC` membre **NULL**.  
  
```  
virtual void ReleaseOutputDC();
```  
  
### <a name="remarks"></a>Notes  
 Cette fonction membre ne peut pas être appelée lorsque le contexte de périphérique de sortie est attaché à la `CDC` objet. Utilisez le **détachement** fonction membre pour détacher le contexte de périphérique de sortie.  
  
##  <a name="resetdc"></a>CDC::ResetDC  
 Appelez cette fonction membre pour mettre à jour le contexte de périphérique encapsulé par le `CDC` objet.  
  
```  
BOOL ResetDC(const DEVMODE* lpDevMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpDevMode*  
 Un pointeur vers un Windows `DEVMODE` structure.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique est mis à jour à partir des informations spécifiées dans les fenêtres `DEVMODE` structure. Cette fonction membre réinitialise uniquement le contexte de l’attribut.  
  
 Une application utilise généralement le `ResetDC` fonction membre lorsqu’une fenêtre traite un `WM_DEVMODECHANGE` message. Vous pouvez également utiliser cette fonction membre pour modifier l’orientation du papier ou un bac à papier lors de l’impression d’un document.  
  
 Vous ne pouvez pas utiliser cette fonction membre pour modifier le nom du pilote, le nom de l’appareil ou le port de sortie. Lorsque l’utilisateur modifie la connexion de port ou le nom de périphérique, vous devez supprimer le contexte de périphérique d’origine et créer un nouveau contexte de périphérique avec les nouvelles informations.  
  
 Avant d’appeler cette fonction membre, vous devez vous assurer que tous les objets (autres que les objets de stock) qui avaient été sélectionnés dans le contexte de périphérique ont été sélectionnés.  
  
##  <a name="restoredc"></a>CDC::RestoreDC  
 Restaure le contexte de périphérique à l’état précédent identifié par `nSavedDC`.  
  
```  
virtual BOOL RestoreDC(int nSavedDC);
```  
  
### <a name="parameters"></a>Paramètres  
 `nSavedDC`  
 Spécifie le contexte de périphérique à restaurer. Il peut être une valeur renvoyée par une précédente `SaveDC` l’appel de fonction. Si `nSavedDC` est -1, le plus récemment enregistrés contexte de périphérique est restauré.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si le contexte spécifié a été restauré ; Sinon, 0.  
  
### <a name="remarks"></a>Notes  
 `RestoreDC`Restaure le contexte de périphérique en affichant les informations d’état d’une pile créée par les appels antérieurs à la `SaveDC` fonction membre.  
  
 La pile peut contenir les informations d’état pour plusieurs contextes de périphérique. Si le contexte spécifié par `nSavedDC` n’est pas en haut de la pile, `RestoreDC` supprime toutes les informations d’état entre le contexte de périphérique spécifié par `nSavedDC` et le haut de la pile. Les informations supprimées sont perdues.  
  
##  <a name="roundrect"></a>CDC::RoundRect  
 Dessine un rectangle à angles arrondis à l’aide du stylet courant.  
  
```  
BOOL RoundRect(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3);

 
BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 `x1`  
 Spécifie la coordonnée x de l’angle supérieur gauche du rectangle (en unités logiques).  
  
 `y1`  
 Spécifie la coordonnée y de l’angle supérieur gauche du rectangle (en unités logiques).  
  
 `x2`  
 Spécifie la coordonnée x de l’angle inférieur droit du rectangle (en unités logiques).  
  
 `y2`  
 Spécifie la coordonnée y du coin inférieur droit du rectangle (en unités logiques).  
  
 *x3*  
 Spécifie la largeur de l’ellipse utilisée pour dessiner les angles arrondis (en unités logiques).  
  
 `y3`  
 Spécifie la hauteur de l’ellipse utilisée pour dessiner les angles arrondis (en unités logiques).  
  
 `lpRect`  
 Spécifie le rectangle englobant dans les unités logiques. Vous pouvez passer soit un `CRect` objet ou un pointeur vers un `RECT` structure pour ce paramètre.  
  
 `point`  
 La coordonnée x de `point` spécifie la largeur de l’ellipse pour dessiner les angles arrondis (en unités logiques). Coordonnée y de `point` spécifie la hauteur de l’ellipse pour dessiner les angles arrondis (en unités logiques). Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 L’intérieur du rectangle est remplie à l’aide de la brosse courante.  
  
 L’illustration de que cette fonction dessine étend jusqu'à mais n’inclut pas les coordonnées de droite et en bas. Cela signifie que la hauteur de la figure est `y2`  -  `y1` et la largeur de la figure est `x2`  -  `x1`. La hauteur et la largeur du rectangle englobant doivent être supérieures à 2 unités et inférieure à 32 767.  
  
### <a name="example"></a>Exemple  
 [!code-cpp[# NVC_MFCDocView 40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]  
  
##  <a name="savedc"></a>CDC::SaveDC  
 Enregistre l’état actuel du contexte de périphérique en copiant les informations d’état (par exemple, la zone de découpage, les objets sélectionnés et mode de mappage) à une pile de contexte gérée par Windows.  
  
```  
virtual int SaveDC();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Entier qui identifie le contexte de périphérique enregistré. Il est 0 si une erreur se produit. Cela retourne la valeur peut être utilisée pour restaurer le contexte de périphérique en appelant `RestoreDC`.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique enregistré peut être restauré à l’aide de `RestoreDC`.  
  
 `SaveDC`peut être utilisée n’importe quel nombre de fois où enregistrer n’importe quel nombre d’états de contexte de périphérique.  
  
##  <a name="scaleviewportext"></a>CDC::ScaleViewportExt  
 Modifie les étendues de la fenêtre d’affichage par rapport aux valeurs actuelles.  
  
```  
virtual CSize ScaleViewportExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>Paramètres  
 `xNum`  
 Spécifie le montant par lequel multiplier l’étendue x actuel.  
  
 `xDenom`  
 Spécifie le montant par lequel diviser le résultat de la multiplication de l’étendue de x actuelle par la valeur de le `xNum` paramètre.  
  
 `yNum`  
 Spécifie le montant par lequel multiplier l’étendue y actuel.  
  
 `yDenom`  
 Spécifie le montant par lequel diviser le résultat de la multiplication de l’étendue d’y actuelle par la valeur de le `yNum` paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Les étendues de la fenêtre d’affichage précédent (en unités de l’appareil) en tant qu’un `CSize` objet.  
  
### <a name="remarks"></a>Notes  
 Les formules sont écrites comme suit :  
  
 `xNewVE = ( xOldVE * xNum ) / xDenom`  
  
 `yNewVE = ( yOldVE * yNum ) / yDenom`  
  
 Les nouvelles étendues de la fenêtre d’affichage sont calculées en multipliant l’étendue actuelle par le numérateur donné et en divisant par le dénominateur donné.  
  
##  <a name="scalewindowext"></a>CDC::ScaleWindowExt  
 Modifie les étendues de fenêtre par rapport aux valeurs actuelles.  
  
```  
virtual CSize ScaleWindowExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>Paramètres  
 `xNum`  
 Spécifie le montant par lequel multiplier l’étendue x actuel.  
  
 `xDenom`  
 Spécifie le montant par lequel diviser le résultat de la multiplication de l’étendue de x actuelle par la valeur de le `xNum` paramètre.  
  
 `yNum`  
 Spécifie le montant par lequel multiplier l’étendue y actuel.  
  
 `yDenom`  
 Spécifie le montant par lequel diviser le résultat de la multiplication de l’étendue d’y actuelle par la valeur de le `yNum` paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Les étendues de fenêtre précédent (en unités logiques) comme un `CSize` objet.  
  
### <a name="remarks"></a>Remarques  
 Les formules sont écrites comme suit :  
  
 `xNewWE = ( xOldWE * xNum ) / xDenom`  
  
 `yNewWE = ( yOldWE * yNum ) / yDenom`  
  
 Les nouvelles étendues de fenêtre sont calculées en multipliant l’étendue actuelle par le numérateur donné et en divisant par le dénominateur donné.  
  
##  <a name="scrolldc"></a>CDC::ScrollDC  
 Fait défiler un rectangle de bits horizontalement et verticalement.  
  
```  
BOOL ScrollDC(
    int dx,  
    int dy,  
    LPCRECT lpRectScroll,  
    LPCRECT lpRectClip,  
    CRgn* pRgnUpdate,  
    LPRECT lpRectUpdate);
```  
  
### <a name="parameters"></a>Paramètres  
 `dx`  
 Spécifie le nombre d’unités de défilement horizontale.  
  
 *dy*  
 Spécifie le nombre d’unités de défilement verticale.  
  
 `lpRectScroll`  
 Pointe vers le `RECT` structure ou `CRect` objet qui contient les coordonnées du rectangle de défilement.  
  
 `lpRectClip`  
 Pointe vers le `RECT` structure ou `CRect` objet qui contient les coordonnées du rectangle de découpage. Lorsque ce rectangle est inférieur à la version d’origine une vers laquelle pointe `lpRectScroll`, le défilement se produit uniquement dans le plus petit rectangle.  
  
 `pRgnUpdate`  
 Identifie la région non traitée par le processus de défilement. Le `ScrollDC` fonction définit cette région ; elle n’est pas nécessairement un rectangle.  
  
 `lpRectUpdate`  
 Pointe vers le `RECT` structure ou `CRect` objet qui reçoit les coordonnées du rectangle qui délimite la zone de mise à jour de défilement. Il s’agit de la plus grande zone rectangulaire qui nécessite la mise à jour. Les valeurs de la structure ou l’objet lorsque la fonction retourne sont dans les coordonnées clientes, quel que soit le mode de mappage pour le contexte de périphérique donné.  
  
### <a name="return-value"></a>Valeur de retour  
 Différent de zéro si le défilement est exécuté ; Sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Si `lpRectUpdate` est **NULL**, Windows ne calcule pas le rectangle de mise à jour. Si les deux `pRgnUpdate` et `lpRectUpdate` sont **NULL**, Windows ne calcule pas la région de mise à jour. Si `pRgnUpdate` n’est pas **NULL**, Windows suppose qu’il contient un pointeur valide vers la région non traité par le processus de défilement (défini par le `ScrollDC` fonction membre). La région de mise à jour retournée dans `lpRectUpdate` peut être passé à `CWnd::InvalidateRgn` si nécessaire.  
  
 Une application doit utiliser le `ScrollWindow` fonction membre de classe `CWnd` lorsqu’il est nécessaire de faire défiler la zone cliente d’une fenêtre. Sinon, elle doit utiliser `ScrollDC`.  
  
##  <a name="selectclippath"></a>CDC::SelectClipPath  
 Sélectionne le chemin d’accès actuel comme une zone de découpage pour le contexte de périphérique, en combinant la nouvelle région avec n’importe quelle région de découpage existant en utilisant le mode spécifié.  
  
```  
BOOL SelectClipPath(int nMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `nMode`  
 Spécifie la façon d’utiliser le chemin d’accès. Les valeurs suivantes sont autorisées :  
  
- **RGN_AND** la nouvelle zone de découpage inclut l’intersection (zones qui se chevauchent) de la zone de découpage active et le chemin d’accès actuel.  
  
- **RGN_COPY** la nouvelle zone de découpage est le chemin d’accès actuel.  
  
- **RGN_DIFF** la nouvelle zone de découpage inclut les zones de la zone de découpage en cours et celles du chemin d’accès actuel sont exclues.  
  
- **RGN_OR** la nouvelle zone de découpage inclut l’union (zones combinées) de la zone de découpage active et le chemin d’accès actuel.  
  
- **RGN_XOR** la nouvelle zone de découpage inclut l’union de la zone de découpage active et le chemin d’accès actuel, mais sans les zones qui se chevauchent.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique identifié doit contenir un chemin d’accès fermé.  
  
##  <a name="selectcliprgn"></a>CDC::SelectClipRgn  
 Sélectionne la région donnée en tant que la zone de découpage en cours pour le contexte de périphérique.  
  
```  
int SelectClipRgn(CRgn* pRgn);

 
int SelectClipRgn(
    CRgn* pRgn,  
    int nMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `pRgn`  
 Identifie la zone de sélection.  
  
-   Pour la première version de cette fonction, si cette valeur est **NULL**, toute la zone cliente est activée et sortie est encore attachée à la fenêtre.  
  
-   Pour la deuxième version de cette fonction, ce handle peut être **NULL** uniquement lorsque le **RGN_COPY** mode est spécifié.  
  
 `nMode`  
 Spécifie l’opération à effectuer. Il doit être une des valeurs suivantes :  
  
- **RGN_AND** la nouvelle zone de découpage combine les zones qui se chevauchent de la zone de découpage active et de la région identifiée par `pRgn`.  
  
- **RGN_COPY** la nouvelle zone de découpage est une copie de la région identifiée par `pRgn`. Cette fonctionnalité est identique à la première version de `SelectClipRgn`. Si la région identifiée par `pRgn` est **NULL**, la nouvelle zone de découpage devient la zone de découpage de valeur par défaut (région null).  
  
- **RGN_DIFF** la nouvelle zone de découpage combine les zones de la zone de découpage active avec les zones exclus de la région identifiée par `pRgn`.  
  
- **RGN_OR** la nouvelle zone de découpage combine la zone de découpage active et de la région identifiée par `pRgn`.  
  
- **RGN_XOR** la nouvelle zone de découpage combine la zone de découpage active et de la région identifiée par `pRgn` mais exclut toutes les zones qui se chevauchent.  
  
### <a name="return-value"></a>Valeur de retour  
 Type de la région. Il peut être une des valeurs suivantes :  
  
- **COMPLEXREGION** nouvelle zone de découpage a chevauchement des bordures.  
  
- **ERREUR** contexte de périphérique ou une région n’est pas valide.  
  
- **NULLREGION** nouvelle zone de découpage est vide.  
  
- **SIMPLEREGION** nouvelle zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 Une copie de la région sélectionnée est utilisée. La région lui-même peut être sélectionnée pour n’importe quel nombre d’autres contextes de périphérique, ou il peut être supprimé.  
  
 La fonction suppose que les coordonnées de la région donnée sont spécifiées dans les unités de périphérique. Certains périphériques d’impression prend en charge la sortie de texte à une résolution supérieure à celle de la sortie graphique afin de conserver la précision nécessaire pour exprimer des métriques de texte. Ces appareils signalent des unités d’appareil à la résolution plus élevée, autrement dit, en unités de texte. Ces périphériques puis mettre à l’échelle les coordonnées des graphiques afin que plusieurs signalées mappage des unités de périphérique uniquement 1 unité graphique. Vous devez toujours appeler la `SelectClipRgn` à l’aide d’unités de texte de la fonction.  
  
 Les applications qui doivent prendre la mise à l’échelle d’objets graphiques dans l’interface GDI peuvent utiliser le **GETSCALINGFACTOR** échappement d’imprimante pour déterminer le facteur d’échelle. Ce facteur d’échelle affecte l’extrait. Si une région est utilisée pour découper les graphiques, GDI divise les coordonnées par le facteur d’échelle. Si la région est utilisée pour découper le texte, GDI n’effectue aucun ajustement de mise à l’échelle. Un facteur d’échelle de 1 provoque les coordonnées à être divisée par 2 ; un facteur d’échelle de 2 entraîne les coordonnées à être divisé par 4 ; et ainsi de suite.  
  
##  <a name="selectobject"></a>CDC::SelectObject  
 Sélectionne un objet dans le contexte de périphérique.  
  
```  
CPen* SelectObject(CPen* pPen);  
CBrush* SelectObject(CBrush* pBrush);  
virtual CFont* SelectObject(CFont* pFont);  
CBitmap* SelectObject(CBitmap* pBitmap);  
int SelectObject(CRgn* pRgn);  
CGdiObject* SelectObject(CGdiObject* pObject);
```  
  
### <a name="parameters"></a>Paramètres  
 *pPen*  
 Un pointeur vers un [CPen](../../mfc/reference/cpen-class.md) objet à sélectionner.  
  
 `pBrush`  
 Un pointeur vers un [CBrush](../../mfc/reference/cbrush-class.md) objet à sélectionner.  
  
 `pFont`  
 Un pointeur vers un [CFont](../../mfc/reference/cfont-class.md) objet à sélectionner.  
  
 `pBitmap`  
 Un pointeur vers un [CBitmap](../../mfc/reference/cbitmap-class.md) objet à sélectionner.  
  
 `pRgn`  
 Un pointeur vers un [CRgn](../../mfc/reference/crgn-class.md) objet à sélectionner.  
  
 `pObject`  
 Un pointeur vers un [CGdiObject](../../mfc/reference/cgdiobject-class.md) objet à sélectionner.  
  
### <a name="return-value"></a>Valeur de retour  
 Pointeur vers l’objet en cours de remplacement. Il s’agit d’un pointeur vers un objet de l’une des classes dérivées de `CGdiObject`, tel que `CPen`, selon la version de la fonction est utilisée. La valeur de retour est **NULL** s’il existe une erreur. Cette fonction peut retourner un pointeur vers un objet temporaire. Cet objet temporaire est uniquement valid pendant le traitement d’un message Windows. Pour plus d'informations, consultez `CGdiObject::FromHandle`.  
  
 La version de la fonction membre qui accepte un paramètre de région effectue la même tâche que la `SelectClipRgn` fonction membre. Sa valeur de retour peut être une des opérations suivantes :  
  
- **COMPLEXREGION** nouvelle zone de découpage a chevauchement des bordures.  
  
- **ERREUR** contexte de périphérique ou une région n’est pas valide.  
  
- **NULLREGION** nouvelle zone de découpage est vide.  
  
- **SIMPLEREGION** nouvelle zone de découpage n’a aucune bordure qui se chevauchent.  
  
### <a name="remarks"></a>Notes  
 Classe `CDC` fournit cinq versions spécialisées pour des types particuliers d’objets GDI, y compris les stylets, pinceaux, polices, images bitmap et régions. L’objet qui vient d’être sélectionné remplace l’objet précédent du même type. Par exemple, si `pObject` de la version générale de `SelectObject` pointe vers un [CPen](../../mfc/reference/cpen-class.md) de l’objet, la fonction remplace le stylet actuel avec le stylet spécifié par `pObject`.  
  
 Une application peut sélectionner une image bitmap dans les contextes de périphérique de mémoire uniquement et dans le contexte de périphérique de mémoire qu’un seul à la fois. Le format de l’image bitmap doit être monochrome ou compatible avec le contexte de périphérique ; Si elle n’est pas, `SelectObject` renvoie une erreur.  
  
 Pour Windows 3.1 et versions ultérieures, le `SelectObject` fonction retourne la même valeur si elle est utilisée dans un métafichier ou non. Dans les versions antérieures de Windows, `SelectObject` retourné une valeur différente de zéro pour la réussite et 0 pour un échec lorsqu’il a été utilisé dans un métafichier.  
  
##  <a name="selectpalette"></a>CDC::SelectPalette  
 Sélectionne la palette logique spécifié par `pPalette` en tant que l’objet sélectionné de palette du contexte de périphérique.  
  
```  
CPalette* SelectPalette(
    CPalette* pPalette,  
    BOOL bForceBackground);
```  
  
### <a name="parameters"></a>Paramètres  
 `pPalette`  
 Identifie la palette logique à être sélectionné. Cette palette doit avoir déjà été créée avec le `CPalette` fonction membre [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).  
  
 `bForceBackground`  
 Spécifie si la palette logique est forcée à une palette d’arrière-plan. Si `bForceBackground` est différent de zéro, la palette sélectionnée est toujours une palette d’arrière-plan, indépendamment de si la fenêtre a le focus d’entrée. Si `bForceBackground` a la valeur 0 et le contexte de périphérique est attaché à une fenêtre, la palette logique est une palette de premier plan lorsque la fenêtre a le focus d’entrée.  
  
### <a name="return-value"></a>Valeur de retour  
 Un pointeur vers un `CPalette` objet identifiant la palette logique remplacée par la palette spécifiée par `pPalette`. Il s’agit de **NULL** s’il existe une erreur.  
  
### <a name="remarks"></a>Notes  
 La nouvelle palette devienne l’objet de la palette utilisée par GDI pour contrôle les couleurs affichées dans le contexte de périphérique et remplace la palette précédente.  
  
 Une application peut sélectionner une palette logique dans plusieurs contextes de périphérique. Toutefois, les modifications apportées à une palette logique affectera tous les contextes de périphérique pour lequel il est sélectionné. Si une application sélectionne une palette dans plus d’un contexte de périphérique, les contextes de périphérique doivent tous appartenir au même appareil physique.  
  
##  <a name="selectstockobject"></a>CDC::SelectStockObject  
 Sélectionne un [CGdiObject](../../mfc/reference/cgdiobject-class.md) objet correspondant à un des stylets stocks prédéfinis, pinceaux, polices.  
  
```  
virtual CGdiObject* SelectStockObject(int nIndex);
```  
  
### <a name="parameters"></a>Paramètres  
 `nIndex`  
 Spécifie le type d’objet stock souhaité. Il peut prendre l’une des valeurs suivantes :  
  
- **BLACK_BRUSH** noir pinceau.  
  
- **DKGRAY_BRUSH** pinceau gris foncé.  
  
- **GRAY_BRUSH** gris pinceau.  
  
- **HOLLOW_BRUSH** creuse pinceau.  
  
- **LTGRAY_BRUSH** clair pinceau gris.  
  
- **NULL_BRUSH** Null pinceau.  
  
- **WHITE_BRUSH** blanc pinceau.  
  
- **BLACK_PEN** stylet noir.  
  
- **NULL_PEN** stylet de valeur Null.  
  
- **WHITE_PEN** stylet blanc.  
  
- **ANSI_FIXED_FONT** police système fixe de ANSI.  
  
- **ANSI_VAR_FONT** police de variables système ANSI.  
  
- **DEVICE_DEFAULT_FONT** police de dépendante de l’appareil.  
  
- **OEM_FIXED_FONT** police fixé OEM dépendant.  
  
- **SYSTEM_FONT** la police système. Par défaut, Windows utilise la police système pour dessiner les menus, les contrôles de boîte de dialogue et tout autre texte. Toutefois, il est préférable, ne pas s’appuyer sur SYSTEM_FONT pour obtenir la police utilisée par windows et les boîtes de dialogue. Utilisez plutôt le `SystemParametersInfo` fonction avec le paramètre SPI_GETNONCLIENTMETRICS pour récupérer la police actuelle. `SystemParametersInfo`prend en compte le thème actuel et fournit des informations de police pour les légendes, les menus et les boîtes de dialogue de message.  
  
- **SYSTEM_FIXED_FONT** la police à largeur fixe système utilisée dans les fenêtres antérieures à la version 3.0. Cet objet est disponible pour la compatibilité avec les versions antérieures de Windows.  
  
- **DEFAULT_PALETTE** palette de couleurs par défaut. Cette palette contient 20 couleurs statiques dans la palette système.  
  
### <a name="return-value"></a>Valeur de retour  
 Un pointeur vers le `CGdiObject` objet qui a été remplacé si la fonction réussit. Est de l’objet réel vers lequel pointé une [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md), ou [CFont](../../mfc/reference/cfont-class.md) objet. Si l’appel échoue, la valeur de retour est **NULL**.  
  
##  <a name="setabortproc"></a>CDC::SETABORTPROC  
 Installe la procédure d’abandon pour le travail d’impression.  
  
```  
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```  
  
### <a name="parameters"></a>Paramètres  
 `lpfn`  
 Pointeur vers la fonction d’annulation à installer en tant que la procédure d’abandon. Pour plus d’informations sur la fonction de rappel, consultez [fonction de rappel pour CDC::SetAbortProc](../../mfc/reference/callback-function-for-cdc-setabortproc.md).  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie le résultat de la `SetAbortProc` (fonction). Certaines des valeurs suivantes sont plus probables que d’autres, mais tous sont possibles.  
  
- **SP_ERROR** erreur générale.  
  
- **SP_OUTOFDISK** pas suffisamment d’espace disque est actuellement disponible pour la mise en attente, et aucun espace plus ne sera bientôt disponible.  
  
- **SP_OUTOFMEMORY** pas assez de mémoire est disponible pour la mise en attente.  
  
- **SP_USERABORT** utilisateur s’est terminé le travail via le Gestionnaire d’impression.  
  
### <a name="remarks"></a>Remarques  
 Si une application doit autoriser le travail d’impression doit être annulée au cours de la mise en attente, il doit définir la fonction d’annulation avant que le travail d’impression est démarré avec le [StartDoc](#startdoc) fonction membre. Le Gestionnaire d’impression appelle la fonction de l’abandon lors de la mise en attente pour permettre à l’application d’annuler le travail d’impression ou pour traiter les conditions d’espace disque. Si aucune fonction d’annulation est définie, le travail d’impression échoue s’il n’est pas suffisamment d’espace disque pour la mise en attente.  
  
 Notez que les fonctionnalités de Microsoft Visual C++ simplifient la création de la fonction de rappel passée à `SetAbortProc`. L’adresse passée à la `EnumObjects` la fonction membre est un pointeur vers une fonction exportée avec **__declspec (dllexport)** et avec le `__stdcall` convention d’appel.  
  
 Également inutile exporter le nom de fonction dans une **exportations** instruction dans le fichier de définition de module de votre application. Vous pouvez utiliser à la place la **exporter** fonction modificateur, comme dans  
  
 **EXPORTATION de rappel BOOL** AFunction ( **HDC**, `int` **) ;**  
  
 Pour contraindre le compilateur à émettre l’enregistrement d’exportation correcte pour l’exportation par nom sans alias. Cela fonctionne pour la plupart des besoins. Dans certains cas spéciaux, tels que l’exportation d’une fonction par ordinal ou alias de l’exportation, vous devez quand même utiliser un **exportations** instruction dans un fichier de définition de module.  
  
 Interfaces de rappel d’inscription sont maintenant de type sécurisé (vous devez passer un pointeur de fonction qui pointe vers le bon type de fonction pour le rappel spécifique).  
  
 Notez également que toutes les fonctions de rappel doivent intercepter les exceptions de Microsoft Foundation avant de retourner à Windows, étant donné que les exceptions ne peut pas être levées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, consultez l’article [Exceptions](../../mfc/exception-handling-in-mfc.md).  
  
##  <a name="setarcdirection"></a>CDC::SetArcDirection  
 Définit la direction de dessin à utiliser pour les fonctions d’arc de cercle et rectangle.  
  
```  
int SetArcDirection(int nArcDirection);
```  
  
### <a name="parameters"></a>Paramètres  
 *nArcDirection*  
 Spécifie la nouvelle direction d’arc de cercle. Ce paramètre peut être une des valeurs suivantes :  
  
- **AD_COUNTERCLOCKWISE** chiffres dessinés dans le sens inverse.  
  
- **AD_CLOCKWISE** chiffres dessinés dans le sens horaire.  
  
### <a name="return-value"></a>Valeur de retour  
 Spécifie la direction d’arc de cercle ancien, en cas de réussite ; Sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 La direction par défaut est dans le sens inverse. Le `SetArcDirection` fonction spécifie la direction dans laquelle les fonctions suivantes dessin :  
  
|Arc|Secteur|  
|---------|---------|  
|`ArcTo`|**Rectangle**|  
|`Chord`|`RoundRect`|  
|**Ellipse**||  
  
##  <a name="setattribdc"></a>CDC::SetAttribDC  
 Appelez cette fonction pour définir le contexte de périphérique d’attribut, `m_hAttribDC`.  
  
```  
virtual void SetAttribDC(HDC hDC);
```  
  
### <a name="parameters"></a>Paramètres  
 `hDC`  
 Un contexte de périphérique Windows.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre ne s’attache pas le contexte de périphérique pour le `CDC` objet. Seul le contexte de périphérique de sortie est attaché à un `CDC` objet.  
  
##  <a name="setbkcolor"></a>CDC::SetBkColor  
 Définit la couleur d’arrière-plan en cours sur la couleur spécifiée.  
  
```  
virtual COLORREF SetBkColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 `crColor`  
 Spécifie la couleur d’arrière-plan.  
  
### <a name="return-value"></a>Valeur de retour  
 La couleur d’arrière-plan précédente comme une valeur de couleur RVB. Si une erreur se produit, la valeur de retour est 0 x 80000000.  
  
### <a name="remarks"></a>Notes  
 Si le mode d’arrière-plan est **OPAQUE**, le système utilise la couleur d’arrière-plan pour remplir les vides dans les lignes de stylisés, les espaces entre les lignes hachurées de pinceaux et de l’arrière-plan dans les cellules de caractères. Le système utilise également la couleur d’arrière-plan lors de la conversion de bitmaps entre la couleur et les contextes de périphérique monochrome.  
  
 Si l’appareil ne peut pas afficher la couleur spécifiée, le système définit la couleur d’arrière-plan de la couleur physique le plus proche.  
  
##  <a name="setbkmode"></a>CDC::SetBkMode  
 Définit le mode d’arrière-plan.  
  
```  
int SetBkMode(int nBkMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *nBkMode*  
 Spécifie le mode à définir. Ce paramètre peut être une des valeurs suivantes :  
  
- **OPAQUE** arrière-plan est rempli avec la couleur d’arrière-plan actuelle avant le texte, hachuré pinceau, ou le stylet est dessiné. Il s’agit du mode d’arrière-plan par défaut.  
  
- **TRANSPARENT** en arrière-plan n’est pas modifié avant le dessin.  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode précédent de l’arrière-plan.  
  
### <a name="remarks"></a>Remarques  
 Le mode d’arrière-plan définit si le système supprime les couleurs d’arrière-plan sur la surface de dessin avant de dessiner du texte, des pinceaux hachurées ou un style de stylet qui n’est pas un trait plein.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).  
  
##  <a name="setboundsrect"></a>CDC::SetBoundsRect  
 Contrôle l’accumulation des informations de rectangle englobant pour le contexte de périphérique spécifié.  
  
```  
UINT SetBoundsRect(
    LPCRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpRectBounds`  
 Pointe vers un `RECT` structure ou `CRect` objet qui est utilisé pour définir le rectangle englobant. Dimensions du rectangle sont fournies en coordonnées logiques. Ce paramètre peut être **NULL**.  
  
 `flags`  
 Spécifie comment combiner le nouveau rectangle avec le rectangle cumulé. Ce paramètre peut être une combinaison des valeurs suivantes :  
  
- **DCB_ACCUMULATE** ajoutent le rectangle spécifié par `lpRectBounds` au rectangle englobant (à l’aide d’une opération union rectangle).  
  
- **DCB_DISABLE** désactiver accumulation de limites.  
  
- **DCB_ENABLE** activer accumulation de limites. (Le paramètre par défaut pour l’accumulation de limites est désactivé).  
  
### <a name="return-value"></a>Valeur de retour  
 L’état actuel du rectangle englobant, si la fonction réussit. Comme `flags`, la valeur de retour peut être une combinaison de **DCB_** valeurs :  
  
- **DCB_ACCUMULATE** le rectangle englobant n’est pas vide. Cette valeur sera toujours être définie.  
  
- **DCB_DISABLE** accumulation de limites est désactivée.  
  
- **DCB_ENABLE** accumulation de limites est activé.  
  
### <a name="remarks"></a>Remarques  
 Windows peut maintenir un rectangle englobant pour toutes les opérations de dessin. Ce rectangle peut être interrogé et réinitialiser par l’application. Les limites de dessin sont utiles pour invalider les caches de bitmap.  
  
##  <a name="setbrushorg"></a>CDC::SetBrushOrg  
 Spécifie l’origine GDI attribue au pinceau suivant qui sélectionne de l’application dans le contexte de périphérique.  
  
```  
CPoint SetBrushOrg(
    int x,  
    int y);  
  
CPoint SetBrushOrg(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x (en unités de périphérique) de l’origine. Cette valeur doit être dans la plage 0-7.  
  
 *y*  
 Spécifie la coordonnée y (en unités de périphérique) de l’origine. Cette valeur doit être dans la plage 0-7.  
  
 `point`  
 Spécifie les coordonnées x et y de l’origine. Chaque valeur doit être dans la plage 0-7. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine précédente du pinceau dans les unités de périphérique.  
  
### <a name="remarks"></a>Remarques  
 Coordonnées de la valeur par défaut pour l’origine de pinceau sont (0, 0). Pour modifier l’origine d’un pinceau, appelez le `UnrealizeObject` de fonction pour le `CBrush` de l’objet, appelez `SetBrushOrg`, puis appelez le `SelectObject` fonction membre pour sélectionner le pinceau dans le contexte de périphérique.  
  
 N’utilisez pas `SetBrushOrg` avec stock `CBrush` objets.  
  
##  <a name="setcoloradjustment"></a>CDC::SetColorAdjustment  
 Définit les valeurs d’ajustement de couleur pour le contexte de périphérique en utilisant les valeurs spécifiées.  
  
```  
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```  
  
### <a name="parameters"></a>Paramètres  
 `lpColorAdjust`  
 Pointe vers un [réglage des couleurs](../../mfc/reference/coloradjustment-structure.md) structure de données contenant les valeurs d’ajustement de couleur.  
  
### <a name="return-value"></a>Valeur de retour  
 Valeur différente de zéro cas de réussite ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Les valeurs d’ajustement de couleur sont utilisées pour ajuster la couleur d’entrée de la bitmap source pour les appels à la `CDC::StretchBlt` fonction membre quand **demi-teintes** mode est défini.  
  
##  <a name="setdcbrushcolor"></a>CDC::SetDCBrushColor  
 Définit la couleur actuelle du pinceau de contexte (DC) de l’appareil à la valeur de la couleur spécifiée.  
  
```  
COLORREF SetDCBrushColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 `crColor`  
 Spécifie la couleur du pinceau.  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour spécifie la couleur du pinceau précédente contrôleur de domaine en tant qu’un `COLORREF` valeur.  
  
 Si la fonction échoue, la valeur de retour est `CLR_INVALID`.  
  
### <a name="remarks"></a>Remarques  
 Cette méthode émule la fonctionnalité de la fonction [SetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd162969), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="setdcpencolor"></a>CDC::SetDCPenColor  
 Définit la couleur du stylet périphérique (DC) de contexte actuel à la valeur de la couleur spécifiée.  
  
```  
COLORREF SetDCPenColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 `crColor`  
 Spécifie la couleur du stylet.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre utilise la fonction Win32 [SetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd162970), comme décrit dans la [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="setgraphicsmode"></a>CDC::SetGraphicsMode  
 Définit le mode graphique pour le contexte de périphérique spécifié.  
  
```  
int SetGraphicsMode(int iMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `iMode`  
 Spécifie le mode graphique. Pour obtenir la liste des valeurs possibles de ce paramètre, consultez [SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977).  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne l’ancien mode graphique.  
  
 Retourne 0 en cas d’échec. Pour obtenir des informations d’erreur plus complètes, appelez [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Remarques  
 Cette méthode encapsule la fonction Windows GDI [SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977).  
  
##  <a name="setlayout"></a>CDC::SetLayout  
 Appelez cette fonction membre pour modifier la disposition du texte et des graphiques pour un contexte de périphérique à droite à gauche, la mise en page standard pour les cultures telles que l’arabe et l’hébreu.  
  
```  
DWORD SetLayout(DWORD dwLayout);
```  
  
### <a name="parameters"></a>Paramètres  
 `dwLayout`  
 Indicateurs de contrôle de disposition de contexte de périphérique et de la bitmap. Il peut être une combinaison des valeurs suivantes.  
  
|Valeur|Signification|  
|-----------|-------------|  
|LAYOUT_BITMAPORIENTATIONPRESERVED|Désactive toute réflexion pour les appels à [CDC::BitBlt](#bitblt) et [CDC::StretchBlt](#stretchblt).|  
|LAYOUT_RTL|Définit la disposition horizontale de la valeur par défaut de droite à gauche.|  
|LAYOUT_LTR|Définit la disposition par défaut pour être de gauche à droite.|  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, la mise en page précédente du contexte de périphérique.  
  
 En cas d’échec, **GDI_ERROR**. Pour obtenir des informations d’erreur plus complètes, appelez [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Remarques  
 Normalement, vous n’appelez pas **SetLayout** pour une fenêtre. Au lieu de cela, vous contrôlez la disposition de droite à gauche dans une fenêtre en définissant le [les styles de fenêtre étendus](../../mfc/reference/extended-window-styles.md) comme **WS_EX_RTLREADING**. Un contexte de périphérique, comme une imprimante ou un métafichier, n’hérite pas de cette mise en page. La seule façon de définir le contexte de périphérique, une disposition de droite à gauche consiste à appeler **SetLayout**.  
  
 Si vous appelez **SetLayout (LAYOUT_RTL** ), **SetLayout** modifie automatiquement le mode de mappage à `MM_ISOTROPIC`. Par conséquent, un appel ultérieur à [GetMapMode](#getmapmode) retournera **MM_ISOTROPIC** au lieu de `MM_TEXT`.  
  
 Dans certains cas, comme avec les images de nombreux, vous souhaiterez conserver la disposition de gauche à droite. Dans ces cas, afficher l’image en appelant `BitBlt` ou `StretchBlt`, puis définissez l’indicateur de contrôle d’image bitmap pour `dwLayout` à **LAYOUT_BITMAPORIENTATIONPRESERVED**.  
  
 Une fois que vous modifiez la disposition avec le **LAYOUT_RTL** indicateur, indicateurs spécifiant normalement de droite ou gauche sont inversées. Pour éviter toute confusion, vous voudrez sans doute définir d’autres noms pour les indicateurs standards. Pour obtenir la liste des noms de l’indicateur de remplacement suggérées, consultez [SetLayout](http://msdn.microsoft.com/library/windows/desktop/dd162979) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="setmapmode"></a>CDC::SetMapMode  
 Définit le mode de mappage.  
  
```  
virtual int SetMapMode(int nMapMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `nMapMode`  
 Spécifie le nouveau mode de mappage. Il peut prendre l’une des valeurs suivantes :  
  
- `MM_ANISOTROPIC`Les unités logiques sont converties en unités arbitraires avec des axes à l’échelle de façon arbitraire. Le mode de mappage `MM_ANISOTROPIC` ne modifie pas les paramètres de fenêtre ou la fenêtre d’affichage actuels. Pour modifier les unités, l’orientation et la mise à l’échelle, appellent le [SetWindowExt](#setwindowext) et [SetViewportExt](#setviewportext) fonctions membres.  
  
- `MM_HIENGLISH`Chaque unité logique est convertie en pouces 0,001. X positif est vers la droite. y positif est activé.  
  
- `MM_HIMETRIC`Chaque unité logique est convertie en 0,01 millimètre. X positif est vers la droite. y positif est activé.  
  
- `MM_ISOTROPIC`Les unités logiques sont converties aux unités arbitraires avec tout aussi des axes à l’échelle ; 1 unité sur l’axe x est égale à 1 unité sur l’axe y. Utilisez le `SetWindowExt` et `SetViewportExt` des fonctions membres pour spécifier les unités souhaitées et l’orientation des axes. Ajuste GDI que nécessaire pour garantir que x et y unités restent la même taille.  
  
- `MM_LOENGLISH`Chaque unité logique est convertie en 0,01 pouce. X positif est vers la droite. y positif est activé.  
  
- `MM_LOMETRIC`Chaque unité logique est convertie en millimètres 0,1. X positif est vers la droite. y positif est activé.  
  
- `MM_TEXT`Chaque unité logique est convertie en pixels de 1 périphérique. X positif est vers la droite. y positif est arrêté.  
  
- `MM_TWIPS`Chaque unité logique est convertie en 1/20 de point. (Un point est 1/72 pouce, un twips étant 1/1440 pouce.) X positif est vers la droite. y positif est activé.  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de mappage précédent.  
  
### <a name="remarks"></a>Remarques  
 Le mode de mappage définit l’unité de mesure utilisée pour convertir les unités logiques en unités de l’appareil ; Il définit également l’orientation de l’appareil x et y. GDI utilise le mode de mappage pour convertir des coordonnées logiques en les coordonnées de périphériques appropriés. Le `MM_TEXT` mode permet aux applications de fonctionner en pixels de périphérique, où 1 unité est égale à 1 pixel. La taille physique d’un pixel varie d’un périphérique.  
  
 Le `MM_HIENGLISH`, `MM_HIMETRIC`, `MM_LOENGLISH`, `MM_LOMETRIC`, et `MM_TWIPS` modes sont utiles pour les applications qui doivent dessiner dans des unités significatives physiquement (tels que des pouces ou des millimètres). Le `MM_ISOTROPIC` mode garantit des proportions de 1:1, ce qui est utile lorsqu’il est important de conserver la forme exacte d’une image. Le `MM_ANISOTROPIC` mode permet les coordonnées x et y être ajustée de manière indépendante.  
  
> [!NOTE]
>  Si vous appelez [SetLayout](#setlayout) pour modifier le contrôleur de domaine (contexte de périphérique) à la disposition de droite à gauche, **SetLayout** modifie automatiquement le mode de mappage à `MM_ISOTROPIC`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setmapperflags"></a>CDC::SetMapperFlags  
 Modifie la méthode utilisée par le mappeur de polices lors de la conversion d’une police logique pour une police physique.  
  
```  
DWORD SetMapperFlags(DWORD dwFlag);
```  
  
### <a name="parameters"></a>Paramètres  
 `dwFlag`  
 Spécifie si le mappeur de polices tente de correspondre à la hauteur d’aspect de la police et la largeur à l’appareil. Lorsque cette valeur est **ASPECT_FILTERING**, le Mappeur sélectionne uniquement les polices dont aspect de x et y-aspect correspondent exactement à ceux de l’appareil spécifié.  
  
### <a name="return-value"></a>Valeur de retour  
 La valeur précédente de l’indicateur de mappeur de polices.  
  
### <a name="remarks"></a>Notes  
 Une application peut utiliser `SetMapperFlags` pour provoquer le mappeur de polices choisir uniquement une police physique qui correspond exactement aux proportions de l’appareil spécifié.  
  
 Une application qui utilise uniquement les polices raster peut utiliser le `SetMapperFlags` (fonction) pour vous assurer que la police sélectionnée par le mappeur de police est intéressante et accessible en lecture sur le périphérique spécifié. Les applications qui utilisent les polices évolutives (TrueType) en général, n’utilisent pas `SetMapperFlags`.  
  
 Si aucune police physique n’a un format d’image qui correspond à la spécification de la police logique, GDI choisit une nouveau proportions et sélectionne une police qui correspond à ce nouveau rapport.  
  
##  <a name="setmiterlimit"></a>CDC::SetMiterLimit  
 Définit la limite pour la longueur de jointures de pointe pour le contexte de périphérique.  
  
```  
BOOL SetMiterLimit(float fMiterLimit);
```  
  
### <a name="parameters"></a>Paramètres  
 *fMiterLimit*  
 Spécifie la nouvelle limite de pointe pour le contexte de périphérique.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 La longueur d’onglet est définie comme la distance entre l’intersection des parois de ligne à l’intérieur de la jointure à l’intersection des parois de ligne à l’extérieur de la jointure. La limite est le taux maximal autorisé de la longueur de l’onglet de la largeur de ligne. La limite d’angle par défaut est 10.0.  
  
##  <a name="setoutputdc"></a>CDC::SetOutputDC  
 Appelez cette fonction membre pour définir le contexte de périphérique de sortie, `m_hDC`.  
  
```  
virtual void SetOutputDC(HDC hDC);
```  
  
### <a name="parameters"></a>Paramètres  
 `hDC`  
 Un contexte de périphérique Windows.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction membre peut uniquement être appelée quand un contexte de périphérique n’a pas été attaché à la `CDC` objet. Cette fonction membre affecte `m_hDC` mais ne s’attache ne pas le contexte de périphérique pour le `CDC` objet.  
  
##  <a name="setpixel"></a>CDC::SetPixel  
 Définit le pixel au point spécifié pour l’approximation la plus proche de la couleur spécifiée par `crColor`.  
  
```  
COLORREF SetPixel(
    int x,  
    int y,  
    COLORREF crColor);

 
COLORREF SetPixel(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point à définir.  
  
 *y*  
 Spécifie la coordonnée y logique du point à définir.  
  
 `crColor`  
 A **COLORREF** valeur RVB qui spécifie la couleur utilisée pour peindre le point. Consultez [COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] pour obtenir une description de cette valeur.  
  
 `point`  
 Spécifie la logique coordonnées x et y-du point à définir. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur RVB de la couleur que le point est réellement peinte. Cette valeur peut être différente de celui spécifié par `crColor` si une approximation de cette couleur est utilisée. Si la fonction échoue (si le point est à l’extérieur de la zone de découpage), la valeur de retour est -1.  
  
### <a name="remarks"></a>Remarques  
 Le point doit être dans la zone de découpage. Si le point n’est pas dans la zone de découpage, la fonction ne fait rien.  
  
 La fonction `SetPixel` n'est pas prise en charge par tous les périphériques. Pour déterminer si un périphérique prend en charge `SetPixel`, appelez le `GetDeviceCaps` fonction membre avec le **RASTERCAPS** d’index et vérifiez la valeur de retour pour la **RC_BITBLT** indicateur.  
  
##  <a name="setpixelv"></a>CDC::SetPixelV  
 Définit le pixel situé aux coordonnées spécifiées pour l’approximation la plus proche de la couleur spécifiée.  
  
```  
BOOL SetPixelV(
    int x,  
    int y,  
    COLORREF crColor);

 
BOOL SetPixelV(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x, en unités logiques, du point à définir.  
  
 *y*  
 Spécifie la coordonnée y, en unités logiques, du point à définir.  
  
 `crColor`  
 Spécifie la couleur à utiliser pour peindre le point.  
  
 `point`  
 Spécifie la logique coordonnées x et y-du point à définir. Vous pouvez passer soit un [POINT](../../mfc/reference/point-structure1.md) structure de données ou un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le point doit être dans la zone de découpage et de la partie visible de la surface de l’appareil. Tous les périphériques prennent en charge la fonction membre. Pour plus d’informations, consultez la **RC_BITBLT** fonctionnalité dans le `CDC::GetDeviceCaps` fonction membre. `SetPixelV`est plus rapide que `SetPixel` car il n’a pas besoin de retourner la valeur de couleur du point réellement peinte.  
  
##  <a name="setpolyfillmode"></a>CDC::SetPolyFillMode  
 Définit le mode de remplissage de polygones.  
  
```  
int SetPolyFillMode(int nPolyFillMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `nPolyFillMode`  
 Spécifie le nouveau mode de remplissage. Cette valeur peut être soit **autre** ou **enroulement**. Le mode par défaut défini dans Windows est **autre**.  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de remplissage précédent, en cas de réussite ; Sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Lorsque le mode de remplissage de polygone est **autre**, le système remplit la zone entre les côtés d’un polygone impaires et paires sur chaque ligne d’analyse. Autrement dit, le système remplit la zone entre le premier et deuxième côté, entre les troisième et quatrième côté et ainsi de suite. Ce mode est la valeur par défaut.  
  
 Lorsque le mode de remplissage de polygone est **enroulement**, le système utilise la direction dans laquelle figure a été dessinée pour déterminer s’il faut remplir une zone. Chaque segment de ligne dans un polygone est dessiné dans un dans le sens horaire ou aiguilles. Chaque fois qu’une ligne imaginaire dessinée à partir d’une zone entre parenthèses à l’extérieur d’une figure traverse un segment de ligne dans le sens horaire, c’est un nombre qui est incrémenté. Lorsque la ligne traverse un segment de ligne dans le sens inverse, le nombre est décrémenté. La zone est remplie si le nombre est différente de zéro lorsque la ligne atteint à l’extérieur de la figure.  
  
##  <a name="setrop2"></a>CDC::SetROP2  
 Définit le mode de dessin en cours.  
  
```  
int SetROP2(int nDrawMode);
```  
  
### <a name="parameters"></a>Paramètres  
 `nDrawMode`  
 Spécifie le nouveau mode de dessin. Il peut être une des valeurs suivantes :  
  
- **R2_BLACK** Pixel est toujours noir.  
  
- **R2_WHITE** Pixel est toujours le blanc.  
  
- **R2_NOP** Pixel demeure inchangé.  
  
- **R2_NOT** Pixel est l’inverse de la couleur de l’écran.  
  
- **R2_COPYPEN** Pixel est la couleur du stylet.  
  
- **R2_NOTCOPYPEN** Pixel est l’inverse de la couleur du stylet.  
  
- **R2_MERGEPENNOT** Pixel est une combinaison de la couleur du stylet et l’inverse de la couleur d’écran (pixel final = (pas pixel d’écran) ou de stylet).  
  
- **R2_MASKPENNOT** Pixel est une combinaison des couleurs communes à la plume et à l’inverse de l’écran (pixel final = (pas pixel d’écran) et du stylet).  
  
- **R2_MERGENOTPEN** Pixel est une combinaison de la couleur d’écran et l’inverse de la couleur du stylet (pixel final = (non stylet) ou en pixels de l’écran).  
  
- **R2_MASKNOTPEN** Pixel est une combinaison des couleurs communes à l’écran et l’inverse du stylet (pixel final = (non stylet) et de pixels de l’écran).  
  
- **R2_MERGEPEN** Pixel est une combinaison de la couleur du stylet et la couleur d’écran (pixel final = pixel d’écran ou de stylet).  
  
- **R2_NOTMERGEPEN** Pixel est l’inverse de la **R2_MERGEPEN** couleur (pixel final = non (pen pixel d’écran ou)).  
  
- **R2_MASKPEN** Pixel est une combinaison des couleurs courantes du crayon et à l’écran (pixel final = stylet et pixel d’écran).  
  
- **R2_NOTMASKPEN** Pixel est l’inverse de la **R2_MASKPEN** couleur (pixel final = non (pen AND pixel d’écran)).  
  
- **R2_XORPEN** Pixel est une combinaison des couleurs qui sont dans le stylet ou dans l’écran, mais pas dans les deux (pixel final = stylet XOR écran pixel).  
  
- **R2_NOTXORPEN** Pixel est l’inverse de la **R2_XORPEN** couleur (pixel final = non (pixel d’écran du stylet XOR)).  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode de dessin précédent.  
  
 Il peut être une des valeurs présentées le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
### <a name="remarks"></a>Notes  
 Le mode dessin spécifie comment les couleurs du stylet et à l’intérieur d’objets sont combinées avec la couleur déjà présent sur la surface d’affichage.  
  
 Le mode de dessin est destiné aux appareils raster uniquement. Il ne s’applique pas aux appareils de vecteur. Modes de dessin sont des codes d’opération de rastérisation binaire qui représente toutes les combinaisons de booléennes de deux variables, à l’aide des opérateurs binaires AND, OR et XOR (OR exclusif) et l’opération unaire ne pas.  
  
##  <a name="setstretchbltmode"></a>CDC::SetStretchBltMode  
 Définit le mode d’étirement de bitmap pour les `StretchBlt` fonction membre.  
  
```  
int SetStretchBltMode(int nStretchMode);
```  
  
### <a name="parameters"></a>Paramètres  
 *nStretchMode*  
 Spécifie le mode d’étirement. Il peut être une des valeurs suivantes :  
  
|Valeur|Description|  
|-----------|-----------------|  
|**BLACKONWHITE**|Effectue une opération booléenne et utilisant les valeurs de couleur pour les pixels éliminées et existants. Si la bitmap est un bitmap monochrome, ce mode préserve les pixels noirs au détriment de pixels blancs.|  
|**COLORONCOLOR**|Supprime les pixels. Ce mode supprime éliminées toutes les lignes de pixels sans essayer de préserver leurs informations.|  
|**DEMI-TEINTES**|Mappe les pixels du rectangle source dans les blocs de pixels dans le rectangle de destination. La couleur moyenne sur le bloc de destination de pixels est une approximation de la couleur des pixels de la source.|  
||Après avoir défini la **demi-teintes** mode d’étirement, une application doit appeler la fonction Win32 [SetBrushOrgEx](http://msdn.microsoft.com/library/windows/desktop/dd162967) pour définir l’origine du pinceau. En cas d’échec pour ce faire, alignement incorrect de pinceau se produit.|  
|**STRETCH_ANDSCANS**|**Windows 95/98**: identique à **BLACKONWHITE**|  
|**STRETCH_DELETESCANS**|**Windows 95/98**: identique à **COLORONCOLOR**|  
|**STRETCH_HALFTONE**|**Windows 95/98**: identique à **demi-teintes**.|  
|**STRETCH_ORSCANS**|**Windows 95/98**: identique à **WHITEONBLACK**|  
|**WHITEONBLACK**|Effectue une opération booléenne ou utilisant les valeurs de couleur pour les pixels éliminées et existants. Si la bitmap est un bitmap monochrome, ce mode préserve les pixels blancs au détriment de pixels noirs.|  
  
### <a name="return-value"></a>Valeur de retour  
 Le mode d’étirement précédent. Il peut être **STRETCH_ANDSCANS**, **STRETCH_DELETESCANS**, ou **STRETCH_ORSCANS**.  
  
### <a name="remarks"></a>Notes  
 Le mode d’étirement de bitmap définit la façon dont les informations sont supprimées de bitmaps qui sont compressées à l’aide de la fonction.  
  
 Le **BLACKONWHITE** ( **STRETCH_ANDSCANS**) et **WHITEONBLACK** ( **STRETCH_ORSCANS**) modes sont généralement utilisés pour conserver les pixels de premier plan dans les images bitmap monochromes. Le **COLORONCOLOR** ( **STRETCH_DELETESCANS**) en mode est généralement utilisé pour conserver les couleurs dans les images bitmap de couleur.  
  
 Le **demi-teintes** mode nécessite davantage de traitement de l’image source que les trois autres modes ; elle est plus lente que les autres, mais génère des images de qualité supérieure. Notez également que **SetBrushOrgEx** doit être appelé après avoir défini la **demi-teintes** mode pour éviter un mauvais alignement du pinceau.  
  
 Modes d’étirement supplémentaires peuvent également être disponibles en fonction des capacités du pilote de périphérique.  
  
##  <a name="settextalign"></a>CDC::SetTextAlign  
 Définit les indicateurs d’alignement de texte.  
  
```  
UINT SetTextAlign(UINT nFlags);
```  
  
### <a name="parameters"></a>Paramètres  
 `nFlags`  
 Spécifie des indicateurs de l’alignement de texte. Les indicateurs spécifient la relation entre un point et d’un rectangle qui englobe le texte. Le point peut être soit la position actuelle ou les coordonnées spécifiées par une fonction de sortie de texte. Le rectangle qui englobe le texte est défini par les cellules adjacentes caractère dans la chaîne de texte. Le `nFlags` paramètre peut être un ou plusieurs indicateurs à partir de le des trois catégories suivantes. Choisissez uniquement un indicateur dans chaque catégorie. La première catégorie affecte l’alignement du texte sur l’axe x :  
  
- **TA_CENTER** aligne le point avec le Centre horizontal du rectangle englobant.  
  
- **TA_LEFT** aligne le point sur le côté gauche du rectangle englobant. Il s'agit du paramètre par défaut.  
  
- **TA_RIGHT** aligne le point avec le côté droit du rectangle englobant.  
  
 La seconde catégorie affecte l’alignement du texte dans la direction y :  
  
- **TA_BASELINE** aligne le point avec la ligne de base de la police choisie.  
  
- **TA_BOTTOM** aligne le point de la partie inférieure du rectangle englobant.  
  
- **TA_TOP** aligne le point sur le haut du rectangle englobant. Il s'agit du paramètre par défaut.  
  
 La troisième catégorie détermine si la position actuelle est mise à jour lorsque le texte est écrit :  
  
- **TA_NOUPDATECP** ne met pas à jour la position actuelle après chaque appel à une fonction de sortie de texte. Il s'agit du paramètre par défaut.  
  
- **TA_UPDATECP** met à jour la position x actuelle après chaque appel à une fonction de sortie de texte. La nouvelle position est sur le côté droit du rectangle englobant pour le texte. Lorsque cet indicateur est défini, les coordonnées spécifiées dans les appels à la `TextOut` fonction membre sont ignorés.  
  
### <a name="return-value"></a>Valeur de retour  
 L’alignement de texte paramètre précédent, en cas de réussite. L’octet de poids faible contient le paramètre horizontal et l’octet de poids fort du paramètre vertical. Sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le `TextOut` et `ExtTextOut` fonctions membres utilisent ces indicateurs lors du positionnement d’une chaîne de texte sur un périphérique ou un affichage. Les indicateurs spécifient la relation entre un point spécifique et un rectangle qui englobe le texte. Les coordonnées de ce point sont passées comme paramètres à la `TextOut` fonction membre. Le rectangle qui englobe le texte est formé par les cellules adjacentes caractère dans la chaîne de texte.  
  
##  <a name="settextcharacterextra"></a>CDC::SetTextCharacterExtra  
 Définit l’espacement entre les caractères.  
  
```  
int SetTextCharacterExtra(int nCharExtra);
```  
  
### <a name="parameters"></a>Paramètres  
 `nCharExtra`  
 Spécifie la quantité d’espace supplémentaire (en unités logiques) pour être ajouté à chaque caractère. Si le mode de mappage en cours n’est pas `MM_TEXT`, `nCharExtra` est transformé et arrondi au pixel le plus proche.  
  
### <a name="return-value"></a>Valeur de retour  
 La quantité de l’espacement entre les caractères précédent.  
  
### <a name="remarks"></a>Notes  
 GDI ajoute cet espacement à chaque caractère, y compris les caractères de saut, lorsqu’il écrit une ligne de texte dans le contexte de périphérique. La valeur par défaut pour la quantité d’espacement entre les caractères est 0.  
  
##  <a name="settextcolor"></a>CDC::SetTextColor  
 Définit la couleur du texte sur la couleur spécifiée.  
  
```  
virtual COLORREF SetTextColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>Paramètres  
 `crColor`  
 Spécifie la couleur du texte avec une valeur de couleur RVB.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur RVB de la couleur du texte précédent.  
  
### <a name="remarks"></a>Remarques  
 Le système utilisera cette couleur de texte lors de l’écriture de texte et ce contexte de périphérique et également lorsque des couleurs des bitmaps lors de la conversion entre les contextes de périphérique monochrome.  
  
 Si l’appareil ne peut pas représenter la couleur spécifiée, le système définit la couleur du texte de la couleur physique le plus proche. La couleur d’arrière-plan d’un caractère spécifiée par le `SetBkColor` et `SetBkMode` fonctions membres.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).  
  
##  <a name="settextjustification"></a>CDC::SetTextJustification  
 Ajoute un espace pour les caractères de saut dans une chaîne.  
  
```  
int SetTextJustification(
    int nBreakExtra,  
    int nBreakCount);
```  
  
### <a name="parameters"></a>Paramètres  
 `nBreakExtra`  
 Spécifie l’espace total supplémentaire à ajouter à la ligne de texte (en unités logiques). Si le mode de mappage en cours n’est pas `MM_TEXT`, la valeur indiquée par ce paramètre est convertie vers le mode de mappage en cours et arrondie à l’unité de périphérique le plus proche.  
  
 *nBreakCount*  
 Spécifie le nombre de caractères de saut dans la ligne.  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit ; Sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Une application peut utiliser la `GetTextMetrics` des fonctions membres pour récupérer d’une police interrompre caractère.  
  
 Après le `SetTextJustification` fonction membre est appelée, un appel à une fonction de sortie de texte (tel que `TextOut`) répartit l’espace supplémentaire spécifié uniformément parmi le nombre spécifié de caractères de saut. Le caractère de saut est généralement le caractère espace (ASCII 32), mais peut être défini par une police en tant que d’autres caractères.  
  
 La fonction membre `GetTextExtent` est généralement utilisé avec `SetTextJustification`. `GetTextExtent`calcule la largeur d’une ligne donnée avant d’alignement. Une application peut déterminer la quantité d’espace pour spécifier dans le `nBreakExtra` paramètre en soustrayant la valeur retournée par `GetTextExtent` à partir de la largeur de la chaîne après alignement.  
  
 Le `SetTextJustification` fonction peut être utilisée pour aligner une ligne qui contient plusieurs séries de polices différentes. Dans ce cas, la ligne doit être créée fragmentaire l’alignement et l’écriture de chaque série séparément.  
  
 Étant donné que les erreurs d’arrondi peuvent se produire pendant l’alignement, le système conserve un terme d’erreur en cours d’exécution qui définit l’erreur actuelle. Lors de l’alignement d’une ligne qui contient plusieurs séries, `GetTextExtent` utilise automatiquement ce terme d’erreur lorsqu’il calcule l’étendue de la prochaine exécution. Ainsi, la fonction de sortie de texte fusionner l’erreur dans la nouvelle exécution.  
  
 Une fois que chaque ligne a été alignée, ce terme erreur doit être désactivé pour l’empêcher d’être incorporées dans la ligne suivante. Le terme peut être désactivé en appelant `SetTextJustification` avec `nBreakExtra` définie sur 0.  
  
##  <a name="setviewportext"></a>CDC::SetViewportExt  
 Définit les étendues x et y de la fenêtre d’affichage du contexte de périphérique.  
  
```  
virtual CSize SetViewportExt(
    int cx,  
    int cy);  
  
CSize SetViewportExt(SIZE size);
```  
  
### <a name="parameters"></a>Paramètres  
 `cx`  
 Spécifie l’étendue de x de la fenêtre d’affichage (en unités de l’appareil).  
  
 `cy`  
 Spécifie l’étendue y de la fenêtre d’affichage (en unités de l’appareil).  
  
 `size`  
 Spécifie les étendues x et y de la fenêtre d’affichage (en unités de l’appareil).  
  
### <a name="return-value"></a>Valeur de retour  
 L’étendue précédente de la fenêtre d’affichage en tant qu’un [CSize](../../atl-mfc-shared/reference/csize-class.md) objet. Lorsqu’une erreur se produit, les coordonnées x et y de retourné `CSize` de l’objet sont toutes deux définies sur 0.  
  
### <a name="remarks"></a>Remarques  
 La fenêtre d’affichage, ainsi que la fenêtre de contexte de périphérique définit comment GDI mappe les points dans le système de coordonnées logiques à des points dans le système de coordonnées de l’appareil réel. En d’autres termes, elles définissent la façon dont GDI convertit les coordonnées logiques en coordonnées de périphérique.  
  
 Lorsque les modes de mappage suivantes sont définies, les appels à `SetWindowExt` et `SetViewportExt` sont ignorés :  
  
|MM_HIENGLISH|MM_LOMETRIC|  
|-------------------|------------------|  
|`MM_HIMETRIC`|`MM_TEXT`|  
|`MM_LOENGLISH`|`MM_TWIPS`|  
  
 Lorsque `MM_ISOTROPIC` mode est défini, une application doit appeler la `SetWindowExt` fonction membre avant d’appeler `SetViewportExt`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setviewportorg"></a>CDC::SetViewportOrg  
 Définit l’origine de la fenêtre d’affichage du contexte de périphérique.  
  
```  
virtual CPoint SetViewportOrg(
    int x,  
    int y);  
  
CPoint SetViewportOrg(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x (en unités de périphérique) de l’origine de la fenêtre d’affichage. La valeur doit être dans la plage du système de coordonnées de périphérique.  
  
 *y*  
 Spécifie la coordonnée y (en unités de périphérique) de l’origine de la fenêtre d’affichage. La valeur doit être dans la plage du système de coordonnées de périphérique.  
  
 `point`  
 Spécifie l’origine de la fenêtre d’affichage. Les valeurs doivent être dans la plage du système de coordonnées de périphérique. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine précédent de la fenêtre d’affichage (dans les coordonnées de l’appareil) en tant qu’un `CPoint` objet.  
  
### <a name="remarks"></a>Notes  
 La fenêtre d’affichage, ainsi que la fenêtre de contexte de périphérique définit comment GDI mappe les points dans le système de coordonnées logiques à des points dans le système de coordonnées de l’appareil réel. En d’autres termes, elles définissent la façon dont GDI convertit les coordonnées logiques en coordonnées de périphérique.  
  
 L’origine de la fenêtre d’affichage marque le point dans le système de coordonnées de périphérique à laquelle GDI est mappé à l’origine de la fenêtre, un point dans le système de coordonnées logiques, spécifié par la **SetWindowOrg** fonction membre. GDI mappe tous les autres points en suivant le même processus requis pour mapper l’origine de la fenêtre à l’origine de la fenêtre d’affichage. Par exemple, tous les points dans un cercle autour du point à l’origine de la fenêtre sera dans un cercle autour du point à l’origine de la fenêtre d’affichage. De même, tous les points d’une ligne qui passe par l’origine de la fenêtre sera dans une ligne qui passe par l’origine de la fenêtre d’affichage.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setwindowext"></a>CDC::SetWindowExt  
 Définit les étendues x et y de la fenêtre associée au contexte de périphérique.  
  
```  
virtual CSize SetWindowExt(
    int cx,  
    int cy);  
  
CSize SetWindowExt(SIZE size);
```  
  
### <a name="parameters"></a>Paramètres  
 `cx`  
 Spécifie l’étendue-x (en unités logiques) de la fenêtre.  
  
 `cy`  
 Spécifie l’étendue-y (en unités logiques) de la fenêtre.  
  
 `size`  
 Spécifie les x - et y-étendues (en unités logiques) de la fenêtre.  
  
### <a name="return-value"></a>Valeur de retour  
 L’étendue précédente de la fenêtre (en unités logiques) en tant qu’un `CSize` objet. Si une erreur se produit, les coordonnées x et y de retourné `CSize` de l’objet sont toutes deux définies sur 0.  
  
### <a name="remarks"></a>Remarques  
 La fenêtre, ainsi que la fenêtre d’affichage du contexte de périphérique, définit comment GDI mappe les points dans le système de coordonnées logiques à des points dans le système de coordonnées de périphérique.  
  
 Lorsque les modes de mappage suivantes sont définies, les appels à `SetWindowExt` et `SetViewportExt` fonctions sont ignorées :  
  
- `MM_HIENGLISH`  
  
- `MM_HIMETRIC`  
  
- `MM_LOENGLISH`  
  
- `MM_LOMETRIC`  
  
- `MM_TEXT`  
  
- `MM_TWIPS`  
  
 Lorsque `MM_ISOTROPIC` mode est défini, une application doit appeler la `SetWindowExt` fonction membre avant d’appeler `SetViewportExt`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).  
  
##  <a name="setwindoworg"></a>CDC::SetWindowOrg  
 Définit l’origine de la fenêtre du contexte de périphérique.  
  
```  
CPoint SetWindowOrg(
    int x,  
    int y);  
  
CPoint SetWindowOrg(POINT point);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique de l’origine de la fenêtre.  
  
 *y*  
 Spécifie la coordonnée y logique de l’origine de la fenêtre.  
  
 `point`  
 Spécifie les coordonnées logiques de l’origine de la fenêtre. Vous pouvez passer soit un **POINT** structure ou un `CPoint` objet pour ce paramètre.  
  
### <a name="return-value"></a>Valeur de retour  
 L’origine précédent de la fenêtre comme un `CPoint` objet.  
  
### <a name="remarks"></a>Remarques  
 La fenêtre, ainsi que la fenêtre d’affichage du contexte de périphérique, définit comment GDI mappe les points dans le système de coordonnées logiques à des points dans le système de coordonnées de périphérique.  
  
 L’origine de la fenêtre marque le point dans le système de coordonnées logiques à partir de laquelle GDI est mappé à l’origine de la fenêtre d’affichage, un point dans le système de coordonnées de périphérique spécifié par le **SetWindowOrg** (fonction). GDI mappe tous les autres points en suivant le même processus requis pour mapper l’origine de la fenêtre à l’origine de la fenêtre d’affichage. Par exemple, tous les points dans un cercle autour du point à l’origine de la fenêtre sera dans un cercle autour du point à l’origine de la fenêtre d’affichage. De même, tous les points d’une ligne qui passe par l’origine de la fenêtre sera dans une ligne qui passe par l’origine de la fenêtre d’affichage.  
  
##  <a name="setworldtransform"></a>CDC::SetWorldTransform  
 Définit une transformation linéaire à deux dimensions entre l’espace universel et l’espace de page pour le contexte de périphérique spécifié. Cette transformation peut être utilisée pour mettre à l’échelle, faire pivoter, déformer ou traduire sortie graphique.  
  
```  
BOOL SetWorldTransform(const XFORM& rXform);
```  
  
### <a name="parameters"></a>Paramètres  
 `rXform`  
 Référence à un [XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228) structure qui contient les données de la transformation.  
  
### <a name="return-value"></a>Valeur de retour  
 En cas de réussite, retourne une valeur différente de zéro.  
  
 Retourne 0 en cas d’échec.  
  
 Pour obtenir des informations d’erreur plus complètes, appelez [GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360).  
  
### <a name="remarks"></a>Remarques  
 Cette méthode encapsule la fonction Windows GDI [SetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145104).  
  
##  <a name="startdoc"></a>CDC::StartDoc  
 Informe le pilote de périphérique qui démarre un nouveau travail d’impression et que toutes les `StartPage` et `EndPage` appels doivent être mis en attente sous le même travail jusqu'à ce qu’une `EndDoc` appel se produit.  
  
```  
int StartDoc(LPDOCINFO lpDocInfo);  
int StartDoc(LPCTSTR lpszDocName);
```  
  
### <a name="parameters"></a>Paramètres  
 *lpDocInfo*  
 Pointe vers un [DOCINFO](http://msdn.microsoft.com/library/windows/desktop/dd183574) structure qui contient le nom de fichier du document et le nom du fichier de sortie.  
  
 *lpszDocName*  
 Pointeur vers une chaîne contenant le nom de fichier du document.  
  
### <a name="return-value"></a>Valeur de retour  
 Si la fonction réussit, la valeur de retour est supérieure à zéro. Cette valeur est l’identificateur du travail d’impression pour le document.  
  
 Si la fonction échoue, la valeur de retour est inférieure ou égale à zéro.  
  
### <a name="remarks"></a>Notes  
 Cela garantit que les documents plus d’une page ne seront pas intercalées avec d’autres tâches.  
  
 Pour Windows 3.1 et versions ultérieures, cette fonction remplace la **STARTDOC** échappement de l’imprimante. À l’aide de cette fonction permet de s’assurer que les documents contenant plus d’une page ne sont pas mélangées avec les autres travaux d’impression.  
  
 `StartDoc`Il ne doit pas être utilisée à l’intérieur des métafichiers.  
  
### <a name="example"></a>Exemple  
 Ce fragment de code obtient l’imprimante par défaut, ouvre un travail d’impression et met en attente d’une page avec « Hello, World ! » sur ce dernier. Étant donné que le texte imprimé par ce code n’est pas mis à l’échelle sur des unités logiques de l’imprimante, le texte de sortie peut être dans ces minuscules pour que le résultat est illisible. La capture de données modifiées mise à l’échelle des fonctions, telles que `SetMapMode`, `SetViewportOrg`, et `SetWindowExt`, peut être utilisé pour corriger la mise à l’échelle.  
  
 [!code-cpp[# NVC_MFCDocView 41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]  
  
##  <a name="startpage"></a>CDC::StartPage  
 Appelez cette fonction membre pour préparer le pilote d’imprimante pour recevoir des données.  
  
```  
int StartPage();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Supérieur ou égal à 0 si la fonction réussit, ou une valeur négative si une erreur s’est produite.  
  
### <a name="remarks"></a>Remarques  
 `StartPage`remplace le **NEWFRAME** et **BANDINFO** d’échappement.  
  
 Pour une vue d’ensemble de la séquence d’appels d’impression, consultez la [StartDoc](#startdoc) fonction membre.  
  
 Le système désactive le `ResetDC` fonction membre entre les appels à `StartPage` et `EndPage`.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::StartDoc](#startdoc).  
  
##  <a name="stretchblt"></a>CDC::StretchBlt  
 Copie une image bitmap depuis un rectangle source vers un rectangle de destination, en étirant ou en compressant le bitmap si nécessaire pour l'adapter aux dimensions du rectangle de destination.  
  
```  
BOOL StretchBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x (en unités logiques) de l'angle supérieur gauche du rectangle de destination.  
  
 *y*  
 Spécifie la coordonnée y (en unités logiques) de l'angle supérieur gauche du rectangle de destination.  
  
 `nWidth`  
 Spécifie la largeur (en unités logiques) du rectangle de destination.  
  
 `nHeight`  
 Spécifie la hauteur (en unités logiques) du rectangle de destination.  
  
 `pSrcDC`  
 Spécifie le contexte du périphérique source.  
  
 `xSrc`  
 Spécifie la coordonnée x (en unités logiques) de l'angle supérieur gauche du rectangle source.  
  
 `ySrc`  
 Spécifie la coordonnée y (en unités logiques) de l'angle supérieur gauche du rectangle source.  
  
 `nSrcWidth`  
 Spécifie la largeur (en unités logiques) du rectangle source.  
  
 `nSrcHeight`  
 Spécifie la hauteur (en unités logiques) du rectangle source.  
  
 *dwRop*  
 Spécifie l'opération de rastérisation à effectuer. Le code d'une opération de rastérisation définit la façon dont GDI associe les couleurs dans les opérations de sortie qui impliquent le pinceau actuel, un éventuel bitmap source et un bitmap de destination. Ce paramètre peut avoir l'une des valeurs suivantes :  
  
- **NOIRCEUR** désactive toutes les sorties noir.  
  
- **DSTINVERT** inverse le bitmap de destination.  
  
- **MERGECOPY** associe le modèle et le bitmap source à l’aide de l’opérateur booléen AND.  
  
- **MERGEPAINT** associe le bitmap source inversé et le bitmap de destination à l’aide de l’opérateur booléen OR.  
  
- **NOTSRCCOPY** copie le bitmap source inversé vers la destination.  
  
- **NOTSRCERASE** inverse le résultat de la combinaison du bitmap source et de destination à l’aide de l’opérateur booléen OR.  
  
- **PATCOPY** copie le modèle vers le bitmap de destination.  
  
- **PATINVERT** associe le bitmap de destination et le modèle à l’aide de l’opérateur booléen XOR.  
  
- **PATPAINT** associe le bitmap source inversé avec le modèle à l’aide de l’opérateur booléen OR. Associe le résultat de cette opération au bitmap de destination à l'aide de l'opérateur booléen OR.  
  
- **Src et** associe les pixels du bitmap du bitmap source et de destination à l’aide de l’opérateur booléen AND.  
  
- **SRCCOPY** copie le bitmap source à l’image bitmap de destination.  
  
- **SRCERASE** inverse le bitmap de destination et associe le résultat de l’image bitmap source à l’aide de l’opérateur booléen AND.  
  
- **SRCINVERT** associe les pixels du bitmap du bitmap source et de destination à l’aide de l’opérateur booléen XOR.  
  
- **SRCPAINT** associe les pixels du bitmap du bitmap source et de destination à l’aide de l’opérateur booléen OR.  
  
- **WHITENESS** désactive toutes les sorties blanc.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si le bitmap est dessiné ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 La fonction utilise le mode d'étirement du contexte du périphérique de destination (défini par `SetStretchBltMode`) afin de savoir comment étirer ou compresser le bitmap.  
  
 La fonction `StretchBlt` déplace le bitmap depuis le périphérique source fourni par `pSrcDC` vers le périphérique de destination représenté par l'objet de contexte de périphérique dont la fonction membre est appelée. Les paramètres `xSrc`, `ySrc`, `nSrcWidth` et `nSrcHeight` définissent l'angle supérieur gauche et les dimensions du rectangle source. Le *x*, *y*, `nWidth`, et `nHeight` paramètres fournissent le coin supérieur gauche et les dimensions du rectangle de destination. L’opération de rastérisation spécifiée par *dwRop* définit comment le bitmap source et les bits déjà présent sur le périphérique de destination sont combinées.  
  
 La fonction `StretchBlt` crée une image miroir d'un bitmap si les signes des paramètres `nSrcWidth` et `nWidth`, ou `nSrcHeight` et `nHeight` sont différents. Si `nSrcWidth` et `nWidth` ont des signes différents, la fonction crée une image miroir du bitmap le long de l'axe des abscisses. Si `nSrcHeight` et `nHeight` ont des signes différents, la fonction crée une image miroir du bitmap le long de l'axe des ordonnées.  
  
 La fonction `StretchBlt` étire ou compresse le bitmap source en mémoire, puis copie le résultat vers la destination. Si un modèle doit être fusionné avec le résultat, il ne le sera pas tant que le bitmap source étiré n'est pas copié vers la destination. Si un pinceau est utilisé, il s'agira du pinceau sélectionné dans le contexte de périphérique de destination. Les coordonnées de destination sont transformées en fonction du contexte du périphérique de destination ; les coordonnées sources sont transformées en fonction du contexte du périphérique source.  
  
 Si les bitmaps sources, les bitmaps de destination et les bitmaps de modèle n'ont pas le même format de couleur, `StretchBlt` convertit les bitmaps sources et les bitmaps de modèle pour qu'ils correspondent aux bitmaps de destination. Les couleurs de premier plan et d'arrière-plan du contexte du périphérique de destination sont utilisées dans la conversion.  
  
 Si `StretchBlt` doit convertir un bitmap monochrome en bitmap de couleur, il définit les bits blancs (1) sur la couleur d'arrière-plan et les bits noirs (0) sur la couleur de premier plan. Pour convertir la couleur en monochrome, il définit les pixels qui correspondent à la couleur d'arrière-plan sur blanc (1) et définit tous les autres pixels sur noir (0). Les couleurs de premier plan et d'arrière-plan du contexte du périphérique coloré sont utilisées.  
  
 La fonction `StretchBlt` n'est pas prise en charge par tous les périphériques. Pour déterminer si un périphérique prend en charge `StretchBlt`, appelez le `GetDeviceCaps` fonction membre avec le **RASTERCAPS** d’index et vérifiez la valeur de retour pour la **RC_STRETCHBLT** indicateur.  
  
##  <a name="strokeandfillpath"></a>CDC::StrokeAndFillPath  
 Ferme des figures ouvertes dans un chemin d’accès, des traits le contour du chemin d’accès à l’aide du stylet courant et remplit son intérieur en utilisant le pinceau actuel.  
  
```  
BOOL StrokeAndFillPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Le contexte de périphérique doit contenir un chemin d’accès fermé. Le `StrokeAndFillPath` fonction membre a le même effet que la fermeture de toutes les figures ouvertes dans le chemin d’accès et de contour et de remplir le chemin d’accès séparément, à ceci près que la région remplie ne superposent pas au tracé de région, même si le stylet est large.  
  
##  <a name="strokepath"></a>CDC::StrokePath  
 Affiche le chemin d’accès spécifié à l’aide du stylet courant.  
  
```  
BOOL StrokePath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Notes  
 Le contexte de périphérique doit contenir un chemin d’accès fermé.  
  
##  <a name="tabbedtextout"></a>CDC::TabbedTextOut  
 Appelez cette fonction membre pour écrire une chaîne de caractères à l’emplacement spécifié, en développant des onglets pour les valeurs spécifiées dans le tableau de positions de taquet de tabulation.  
  
```  
virtual CSize TabbedTextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);

 
CSize TabbedTextOut(
    int x,  
    int y,  
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point de départ de la chaîne.  
  
 *y*  
 Spécifie la coordonnée y logique du point de départ de la chaîne.  
  
 `lpszString`  
 Pointe vers la chaîne de caractères à dessiner. Vous pouvez passer soit un pointeur vers un tableau de caractères ou un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objet pour ce paramètre.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne. Si `nCount` est -1, la longueur est calculée.  
  
 `nTabPositions`  
 Spécifie le nombre de valeurs dans le tableau de positions de taquet de tabulation.  
  
 `lpnTabStopPositions`  
 Pointe vers un tableau qui contient les positions de taquet de tabulation (en unités logiques). Les taquets de tabulation doivent être triées par ordre croissant de commande ; la plus petite valeur de x doit être le premier élément du tableau.  
  
 `nTabOrigin`  
 Spécifie la coordonnée x de la position de départ à partir duquel les onglets sont développées (en unités logiques).  
  
 `str`  
 A `CString` objet qui contient les caractères spécifiés.  
  
### <a name="return-value"></a>Valeur de retour  
 Les dimensions de la chaîne (en unités logiques) comme un `CSize` objet.  
  
### <a name="remarks"></a>Remarques  
 Texte est écrit dans la police actuellement sélectionnée. Si `nTabPositions` est égal à 0 et `lpnTabStopPositions` est **NULL**, onglets sont étendues à la largeur de caractère moyenne huit fois.  
  
 Si `nTabPositions` est 1, l’onglet s’arrête est séparées par la distance spécifiée par la première valeur dans la `lpnTabStopPositions` tableau. Si le `lpnTabStopPositions` tableau contient plusieurs valeurs, une tabulation est définie pour chaque valeur dans le tableau, jusqu’au nombre spécifié par `nTabPositions`. Le `nTabOrigin` paramètre permet à une application d’appeler le `TabbedTextOut` fonction plusieurs fois pour une seule ligne. Si l’application appelle la fonction de plusieurs fois avec la `nTabOrigin` définies sur la même valeur chaque fois, la fonction développe tous les onglets par rapport à la position spécifiée par `nTabOrigin`.  
  
 Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction. Si une application doit mettre à jour la position actuelle lorsqu’il appelle la fonction, l’application peut appeler le [SetTextAlign](#settextalign) fonction membre avec `nFlags` la valeur **TA_UPDATECP**. Lorsque cet indicateur est défini, Windows ignore les *x* et *y* paramètres sur les appels suivants à `TabbedTextOut`, à l’aide de la position actuelle à la place.  
  
##  <a name="textout"></a>CDC::TextOut  
 Écrit une chaîne de caractères à l'emplacement spécifié à l'aide de la police sélectionnée.  
  
```  
virtual BOOL TextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount);

 
BOOL TextOut(
    int x,
    int y,
    const CString& str);
```  
  
### <a name="parameters"></a>Paramètres  
 *x*  
 Spécifie la coordonnée x logique du point de départ du texte.  
  
 *y*  
 Spécifie la coordonnée y logique du point de départ du texte.  
  
 `lpszString`  
 Pointe vers la chaîne de caractères à ajouter.  
  
 `nCount`  
 Spécifie le nombre de caractères de la chaîne.  
  
 `str`  
 Objet `CString` qui contient les caractères à ajouter.  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 L'origine des caractères se trouve dans l'angle supérieur gauche de la cellule de caractère. Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction.  
  
 Si une application doit mettre à jour la position actuelle lorsqu’il appelle `TextOut`, l’application peut appeler le `SetTextAlign` fonction membre avec `nFlags` la valeur **TA_UPDATECP**. Lorsque cet indicateur est défini, Windows ignore les *x* et *y* paramètres sur les appels suivants à `TextOut`, à l’aide de la position actuelle à la place.  
  
### <a name="example"></a>Exemple  
  Consultez l’exemple de [CDC::BeginPath](#beginpath).  
  
##  <a name="transparentblt"></a>CDC::TransparentBlt  
 Appelez cette fonction membre pour transférer un bloc de bits des données de couleur, qui correspond à un rectangle de pixels à partir du contexte de périphérique source spécifiée, dans un contexte de périphérique de destination.  
  
```  
BOOL TransparentBlt(
    int xDest,  
    int yDest,
    int nDestWidth,
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    UINT clrTransparent);
```  
  
### <a name="parameters"></a>Paramètres  
 `xDest`  
 Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle de destination.  
  
 `yDest`  
 Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle de destination.  
  
 `nDestWidth`  
 Spécifie la largeur, en unités logiques, du rectangle de destination.  
  
 `nDestHeight`  
 Spécifie la hauteur, en unités logiques, du rectangle de destination.  
  
 `pSrcDC`  
 Pointeur vers le contexte du périphérique source.  
  
 `xSrc`  
 Spécifie la coordonnée x, en unités logiques, du rectangle source.  
  
 `ySrc`  
 Spécifie la coordonnée y, en unités logiques, du rectangle source.  
  
 `nSrcWidth`  
 Spécifie la largeur, en unités logiques, du rectangle source.  
  
 `nSrcHeight`  
 Spécifie la hauteur, en unités logiques, du rectangle source.  
  
 `clrTransparent`  
 La couleur RVB dans le bitmap source à traiter comme transparente.  
  
### <a name="return-value"></a>Valeur de retour  
 **TRUE** cas de réussite ; **FALSE**.  
  
### <a name="remarks"></a>Notes  
 `TransparentBlt`permet de transparence ; Autrement dit, la couleur RVB indiqué par `clrTransparent` est rendu transparent pour le transfert.  
  
 Pour plus d’informations, consultez [TransparentBlt](http://msdn.microsoft.com/library/windows/desktop/dd145141) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="updatecolors"></a>CDC::UpdateColors  
 Mises à jour les couleurs de la zone cliente du contexte de périphérique en mettant en correspondance actuel dans la zone cliente de la palette système sur un pixel par pixel.  
  
```  
void UpdateColors();
```  
  
### <a name="remarks"></a>Notes  
 Une fenêtre inactive avec une palette logique réalisée peut appeler `UpdateColors` au lieu d’être redessiné sa zone cliente lors de la palette système change.  
  
 Pour plus d’informations sur l’utilisation des palettes de couleurs, consultez [UpdateColors](http://msdn.microsoft.com/library/windows/desktop/dd145166) dans le [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
 Le `UpdateColors` fonction membre met généralement à jour une zone client plus rapidement que la zone de rafraîchissement du dessin. Toutefois, étant donné que la fonction effectue la traduction de couleur en fonction de la couleur de chaque pixel avant la modification de la palette système, chaque appel à cette fonction entraîne la perte de précision de certaines couleurs.  
  
##  <a name="widenpath"></a>CDC::WidenPath  
 Redéfinit le chemin d’accès actuel en tant que la zone est d’être peinte si le chemin d’accès ont été dessiné à l’aide du stylet actuellement sélectionné dans le contexte de périphérique.  
  
```  
BOOL WidenPath();
```  
  
### <a name="return-value"></a>Valeur de retour  
 Une valeur différente de zéro si la fonction réussit ; sinon, 0.  
  
### <a name="remarks"></a>Remarques  
 Cette fonction réussit uniquement si le stylet actuel est un stylet géométrique créé par la deuxième version de `CreatePen` fonction membre, ou si le stylet est créé avec la première version de `CreatePen` et a une largeur, en unités de périphérique, supérieure à 1. Le contexte de périphérique doit contenir un chemin d’accès fermé. Toutes les courbes de Bzier dans le chemin d’accès sont converties en séquences de lignes droites en approchant de la courbe des courbes élargies. Par conséquent, aucune des courbes Bzier ne restent dans le chemin d’accès après `WidenPath` est appelée.  
  
## <a name="see-also"></a>Voir aussi  
 [CObject (classe)](../../mfc/reference/cobject-class.md)   
 [Graphique hiérarchique](../../mfc/hierarchy-chart.md)   
 [CPaintDC (classe)](../../mfc/reference/cpaintdc-class.md)   
 [Classe de CWindowDC](../../mfc/reference/cwindowdc-class.md)   
 [CClientDC (classe)](../../mfc/reference/cclientdc-class.md)   
 [CMetaFileDC, classe](../../mfc/reference/cmetafiledc-class.md)

