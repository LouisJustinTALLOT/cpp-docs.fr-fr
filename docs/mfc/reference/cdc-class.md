---
title: Classe CDC
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: bae2f9a5a4f39c4eeffe68cc33e744e44c6800c8
ms.sourcegitcommit: 389c559918d9bfaf303d262ee5430d787a662e92
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/25/2019
ms.locfileid: "69507013"
---
# <a name="cdc-class"></a>Classe CDC

Définit une classe d’objets de contexte de périphérique.

## <a name="syntax"></a>Syntaxe

```
class CDC : public CObject
```

## <a name="members"></a>Membres

### <a name="public-constructors"></a>Constructeurs publics

|Nom|Description|
|----------|-----------------|
|[CDC::CDC](#cdc)|Construit un objet `CDC`.|

### <a name="public-methods"></a>M&#233;thodes publiques

|Nom|Description|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|Termine le travail d’impression en cours et efface tout ce que l’application a écrit sur l’appareil depuis le `StartDoc` dernier appel de la fonction membre.|
|[CDC::AbortPath](#abortpath)|Ferme et ignore tous les chemins d’accès dans le contexte de périphérique.|
|[CDC::AddMetaFileComment](#addmetafilecomment)|Copie le commentaire d’une mémoire tampon dans un métafichier de format amélioré spécifié.|
|[CDC::AlphaBlend](#alphablend)|Affiche les bitmaps qui ont des pixels transparents ou translucides.|
|[CDC::AngleArc](#anglearc)|Dessine un segment de ligne et un arc, puis déplace la position actuelle jusqu’au point de fin de l’arc.|
|[CDC::Arc](#arc)|Dessine un arc elliptique.|
|[CDC::ArcTo](#arcto)|Dessine un arc elliptique. Cette fonction est semblable à `Arc`, à ceci près que la position actuelle est mise à jour.|
|[CDC::Attach](#attach)|Attache un contexte de périphérique Windows à cet `CDC` objet.|
|[CDC::BeginPath](#beginpath)|Ouvre un crochet de chemin d’accès dans le contexte de périphérique.|
|[CDC::BitBlt](#bitblt)|Copie une image bitmap à partir d’un contexte de périphérique spécifié.|
|[CDC::Chord](#chord)|Dessine une corde (une figure fermée délimitée par l’intersection d’une ellipse et d’un segment de ligne).|
|[CDC::CloseFigure](#closefigure)|Ferme une figure ouverte dans un chemin d’accès.|
|[CDC::CreateCompatibleDC](#createcompatibledc)|Crée un contexte de périphérique de mémoire qui est compatible avec un autre contexte de périphérique. Vous pouvez l’utiliser pour préparer des images en mémoire.|
|[CDC::CreateDC](#createdc)|Crée un contexte de périphérique pour un appareil spécifique.|
|[CDC::CreateIC](#createic)|Crée un contexte d’informations pour un appareil spécifique. Cela offre un moyen rapide d’obtenir des informations sur l’appareil sans créer de contexte de périphérique.|
|[CDC::DeleteDC](#deletedc)|Supprime le contexte de périphérique Windows associé à cet `CDC` objet.|
|[CDC::DeleteTempMap](#deletetempmap)|Appelée par le `CWinApp` gestionnaire de temps d’inactivité pour supprimer `CDC` tout objet temporaire `FromHandle`créé par. Détache également le contexte de périphérique.|
|[CDC::Detach](#detach)|Détache le contexte de périphérique Windows de cet `CDC` objet.|
|[CDC ::D PtoHIMETRIC](#dptohimetric)|Convertit les unités de l’appareil en unités HIMETRIC.|
|[CDC::DPtoLP](#dptolp)|Convertit les unités d’appareil en unités logiques.|
|[CDC::Draw3dRect](#draw3drect)|Dessine un rectangle à trois dimensions.|
|[CDC::DrawDragRect](#drawdragrect)|Efface et redessine un rectangle au fur et à mesure qu’il est glissé.|
|[CDC::DrawEdge](#drawedge)|Dessine les bords d’un rectangle.|
|[CDC::DrawEscape](#drawescape)|Accède aux fonctionnalités de dessin d’un affichage vidéo qui ne sont pas directement disponibles via l’interface GDI (Graphics Device Interface).|
|[CDC::DrawFocusRect](#drawfocusrect)|Dessine un rectangle dans le style utilisé pour indiquer le focus.|
|[CDC::DrawFrameControl](#drawframecontrol)|Dessinez un contrôle Frame.|
|[CDC::DrawIcon](#drawicon)|Dessine une icône.|
|[CDC::DrawState](#drawstate)|Affiche une image et applique un effet visuel pour indiquer un État.|
|[CDC::DrawText](#drawtext)|Dessine du texte mis en forme dans le rectangle spécifié.|
|[CDC::DrawTextEx](#drawtextex)|Dessine du texte mis en forme dans le rectangle spécifié à l’aide de formats supplémentaires.|
|[CDC::Ellipse](#ellipse)|Dessine une ellipse.|
|[CDC::EndDoc](#enddoc)|Met fin à un travail d’impression `StartDoc` Démarré par la fonction membre.|
|[CDC::EndPage](#endpage)|Informe le pilote de périphérique qu’une page se termine.|
|[CDC::EndPath](#endpath)|Ferme un crochet de tracé et sélectionne le chemin d’accès défini par le crochet dans le contexte de périphérique.|
|[CDC::EnumObjects](#enumobjects)|Énumère les stylets et les pinceaux disponibles dans un contexte de périphérique.|
|[CDC::Escape](#escape)|Permet aux applications d’accéder à des fonctionnalités qui ne sont pas directement disponibles à partir d’un appareil particulier via GDI. Permet également d’accéder aux fonctions d’échappement Windows. Les appels d’échappement effectués par une application sont traduits et envoyés au pilote de périphérique.|
|[CDC::ExcludeClipRect](#excludecliprect)|Crée une nouvelle zone de découpage qui se compose de la région de découpage existante moins le rectangle spécifié.|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Empêche le dessin dans des zones non valides d’une fenêtre en excluant une région mise à jour dans la fenêtre d’une zone de découpage.|
|[CDC::ExtFloodFill](#extfloodfill)|Remplit une zone avec le pinceau actuel. Offre une plus grande flexibilité que la fonction membre [CDC :: FloodFill](#floodfill) .|
|[CDC::ExtTextOut](#exttextout)|Écrit une chaîne de caractères dans une zone rectangulaire à l’aide de la police actuellement sélectionnée.|
|[CDC::FillPath](#fillpath)|Ferme toutes les figures ouvertes dans le chemin d’accès actuel et remplit l’intérieur du tracé à l’aide du pinceau actuel et du mode de remplissage du polygone.|
|[CDC::FillRect](#fillrect)|Remplit un rectangle donné à l’aide d’un pinceau spécifique.|
|[CDC::FillRgn](#fillrgn)|Remplit une région spécifique avec le pinceau spécifié.|
|[CDC::FillSolidRect](#fillsolidrect)|Remplit un rectangle avec une couleur unie.|
|[CDC::FlattenPath](#flattenpath)|Transforme toutes les courbes dans le tracé sélectionné dans le contexte de périphérique actuel et convertit chaque courbe en une séquence de lignes.|
|[CDC::FloodFill](#floodfill)|Remplit une zone avec le pinceau actuel.|
|[CDC::FrameRect](#framerect)|Dessine une bordure autour d’un rectangle.|
|[CDC::FrameRgn](#framergn)|Dessine une bordure autour d’une région spécifique à l’aide d’un pinceau.|
|[CDC::FromHandle](#fromhandle)|Retourne un pointeur vers un `CDC` objet en fonction d’un handle vers un contexte de périphérique (Device Context). Si aucun objet `CDC` n'est attaché au handle, un objet `CDC` temporaire est créé et attaché.|
|[CDC::GetArcDirection](#getarcdirection)|Retourne la direction actuelle de l’arc pour le contexte de périphérique.|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Récupère le paramètre pour le filtre de rapport d’aspect actuel.|
|[CDC::GetBkColor](#getbkcolor)|Récupère la couleur d’arrière-plan actuelle.|
|[CDC::GetBkMode](#getbkmode)|Récupère le mode arrière-plan.|
|[CDC::GetBoundsRect](#getboundsrect)|Retourne le rectangle englobant cumulé actuel pour le contexte de périphérique spécifié.|
|[CDC::GetBrushOrg](#getbrushorg)|Récupère l’origine du pinceau actuel.|
|[CDC::GetCharABCWidths](#getcharabcwidths)|Récupère les largeurs, en unités logiques, des caractères consécutifs d’une plage donnée à partir de la police actuelle.|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Récupère les largeurs, en unités logiques, d’index de glyphe consécutifs dans une plage spécifiée à partir de la police TrueType actuelle.|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Récupère différents types d’informations sur une chaîne de caractères.|
|[CDC::GetCharWidth](#getcharwidth)|Récupère la largeur fractionnaire des caractères consécutifs d’une plage donnée à partir de la police actuelle.|
|[CDC::GetCharWidthI](#getcharwidthi)|Récupère les largeurs, en coordonnées logiques, d’index de glyphe consécutifs dans une plage spécifiée à partir de la police actuelle.|
|[CDC::GetClipBox](#getclipbox)|Récupère les dimensions du rectangle englobant le plus étroit autour de la limite de découpage actuelle.|
|[CDC::GetColorAdjustment](#getcoloradjustment)|Récupère les valeurs de réglage des couleurs pour le contexte de périphérique.|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Retourne un pointeur vers l’objet actuellement `CBitmap` sélectionné.|
|[CDC::GetCurrentBrush](#getcurrentbrush)|Retourne un pointeur vers l’objet actuellement `CBrush` sélectionné.|
|[CDC::GetCurrentFont](#getcurrentfont)|Retourne un pointeur vers l’objet actuellement `CFont` sélectionné.|
|[CDC::GetCurrentPalette](#getcurrentpalette)|Retourne un pointeur vers l’objet actuellement `CPalette` sélectionné.|
|[CDC::GetCurrentPen](#getcurrentpen)|Retourne un pointeur vers l’objet actuellement `CPen` sélectionné.|
|[CDC::GetCurrentPosition](#getcurrentposition)|Récupère la position actuelle du stylet (en coordonnées logiques).|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Récupère la couleur actuelle du pinceau.|
|[CDC::GetDCPenColor](#getdcpencolor)|Récupère la couleur actuelle du stylet.|
|[CDC::GetDeviceCaps](#getdevicecaps)|Récupère un type spécifié d’informations spécifiques à l’appareil sur les fonctionnalités d’un périphérique d’affichage donné.|
|[CDC::GetFontData](#getfontdata)|Récupère des informations sur la métrique des polices à partir d’un fichier de police Scalable. Les informations à récupérer sont identifiées en spécifiant un décalage dans le fichier de police et la longueur des informations à retourner.|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Retourne des informations sur la police actuellement sélectionnée pour le contexte d’affichage spécifié.|
|[CDC::GetGlyphOutline](#getglyphoutline)|Récupère la courbe ou l’image bitmap du plan d’un caractère de contour dans la police actuelle.|
|[CDC::GetGraphicsMode](#getgraphicsmode)|Récupère le mode graphique actuel pour le contexte de périphérique spécifié.|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Récupère un pinceau en demi-teinte.|
|[CDC::GetKerningPairs](#getkerningpairs)|Récupère les paires de crénage de caractères pour la police actuellement sélectionnée dans le contexte de périphérique spécifié.|
|[CDC::GetLayout](#getlayout)|Récupère la disposition d’un contexte de périphérique (DC). La disposition peut être soit de gauche à droite (par défaut), soit de droite à gauche (en miroir).|
|[CDC::GetMapMode](#getmapmode)|Récupère le mode de mappage actuel.|
|[CDC::GetMiterLimit](#getmiterlimit)|Retourne la limite d’angle pour le contexte de périphérique.|
|[CDC::GetNearestColor](#getnearestcolor)|Récupère la couleur logique la plus proche d’une couleur logique spécifiée que l’appareil donné peut représenter.|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Récupère des informations sur la métrique des polices pour les polices TrueType.|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Récupère la largeur des caractères individuels dans un groupe consécutif de caractères à partir de la police actuelle à l’aide du contexte de périphérique de sortie.|
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Calcule la largeur et la hauteur d’une chaîne de caractères sur le contexte de périphérique de sortie.|
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Calcule la largeur et la hauteur d’une ligne de texte sur le contexte de périphérique de sortie à l’aide de la police actuelle pour déterminer les dimensions.|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Récupère les métriques de la police actuelle dans le contexte de périphérique de sortie.|
|[CDC::GetPath](#getpath)|Récupère les coordonnées qui définissent les points de terminaison de lignes et les points de contrôle des courbes trouvées dans le chemin d’accès sélectionné dans le contexte de périphérique.|
|[CDC::GetPixel](#getpixel)|Récupère la valeur de couleur RVB du pixel au point spécifié.|
|[CDC::GetPolyFillMode](#getpolyfillmode)|Récupère le mode de remplissage de polygone actuel.|
|[CDC::GetROP2](#getrop2)|Récupère le mode de dessin actuel.|
|[CDC::GetSafeHdc](#getsafehdc)|Retourne [CDC :: m_hDC](#m_hdc), le contexte de périphérique de sortie.|
|[CDC::GetStretchBltMode](#getstretchbltmode)|Récupère le mode d’étirement de l’image en cours.|
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Calcule la largeur et la hauteur d’une chaîne de caractères sur le contexte de périphérique d’attribut.|
|[CDC::GetTextAlign](#gettextalign)|Récupère les indicateurs d’alignement de texte.|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Récupère le paramètre actuel pour la quantité d’espacement entre les caractères.|
|[CDC::GetTextColor](#gettextcolor)|Récupère la couleur de texte actuelle.|
|[CDC::GetTextExtent](#gettextextent)|Calcule la largeur et la hauteur d’une ligne de texte sur l’attribut de contexte de périphérique à l’aide de la police actuelle pour déterminer les dimensions.|
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|Récupère le nombre de caractères dans une chaîne spécifiée qui tiennent dans un espace spécifié et remplit un tableau avec l’étendue du texte pour chacun de ces caractères.|
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Récupère la largeur et la hauteur du tableau spécifié d’index de glyphes.|
|[CDC::GetTextFace](#gettextface)|Copie le nom de police de la police actuelle dans une mémoire tampon comme une chaîne se terminant par un caractère null.|
|[CDC::GetTextMetrics](#gettextmetrics)|Récupère les métriques de la police actuelle à partir du contexte de périphérique d’attribut.|
|[CDC::GetViewportExt](#getviewportext)|Récupère les étendues x et y de la fenêtre d’affichage.|
|[CDC::GetViewportOrg](#getviewportorg)|Récupère les coordonnées x et y de l’origine de la fenêtre d’affichage.|
|[CDC::GetWindow](#getwindow)|Retourne la fenêtre associée au contexte de périphérique d’affichage.|
|[CDC::GetWindowExt](#getwindowext)|Récupère les étendues x et y de la fenêtre associée.|
|[CDC::GetWindowOrg](#getwindoworg)|Récupère les coordonnées x et y de l’origine de la fenêtre associée.|
|[CDC::GetWorldTransform](#getworldtransform)|Récupère l’espace universel actuel pour la transformation d’espace de page.|
|[CDC::GradientFill](#gradientfill)|Remplit les structures rectangle et triangle avec une couleur gradating.|
|[CDC::GrayString](#graystring)|Dessine le texte estompé (grisé) à l’emplacement donné.|
|[CDC :: HIMETRICtoDP](#himetrictodp)|Convertit les unités HIMETRIC en unités de périphérique.|
|[CDC :: HIMETRICtoLP](#himetrictolp)|Convertit les unités HIMETRIC en unités logiques.|
|[CDC::IntersectClipRect](#intersectcliprect)|Crée une nouvelle zone de découpage en formant l’intersection de la région actuelle et d’un rectangle.|
|[CDC::InvertRect](#invertrect)|Inverse le contenu d’un rectangle.|
|[CDC::InvertRgn](#invertrgn)|Inverse les couleurs d’une région.|
|[CDC::IsPrinting](#isprinting)|Détermine si le contexte de périphérique est utilisé pour l’impression.|
|[CDC::LineTo](#lineto)|Dessine une ligne à partir de la position actuelle jusqu’à un point, mais sans l’inclure.|
|[CDC::LPtoDP](#lptodp)|Convertit les unités logiques en unités de périphérique.|
|[CDC :: LPtoHIMETRIC](#lptohimetric)|Convertit les unités logiques en unités HIMETRIC.|
|[CDC::MaskBlt](#maskblt)|Combine les données de couleur pour les bitmaps sources et de destination à l’aide du masque et de l’opération Raster donnés.|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Modifie la transformation universelle d’un contexte de périphérique à l’aide du mode spécifié.|
|[CDC::MoveTo](#moveto)|Déplace la position actuelle.|
|[CDC::OffsetClipRgn](#offsetcliprgn)|Déplace la zone de découpage du périphérique donné.|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Modifie l’origine de la fenêtre d’affichage par rapport aux coordonnées de l’origine de la fenêtre d’affichage actuelle.|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Modifie l’origine de la fenêtre par rapport aux coordonnées de l’origine de la fenêtre active.|
|[CDC::PaintRgn](#paintrgn)|Remplit une zone avec le pinceau sélectionné.|
|[CDC::PatBlt](#patblt)|Crée un modèle binaire.|
|[CDC::Pie](#pie)|Dessine un coin en forme de secteur.|
|[CDC::PlayMetaFile](#playmetafile)|Lit le contenu du métafichier spécifié sur le périphérique donné. La version améliorée de `PlayMetaFile` affiche l’image stockée dans le métafichier de format amélioré donné. Le métafichier peut être lu un nombre quelconque de fois.|
|[CDC::PlgBlt](#plgblt)|Effectue le transfert par bloc de bits des bits des données de couleur du rectangle spécifié dans le contexte de périphérique source vers le parallélogramme spécifié dans le contexte de périphérique donné.|
|[CDC::PolyBezier](#polybezier)|Dessine une ou plusieurs splines Bzier. La position actuelle n’est ni utilisée ni mise à jour.|
|[CDC::PolyBezierTo](#polybezierto)|Dessine une ou plusieurs splines Bzier et déplace la position actuelle jusqu’au point de terminaison de la dernière spline Bzier.|
|[CDC::PolyDraw](#polydraw)|Dessine un ensemble de segments de ligne et de splines Bzier. Cette fonction met à jour la position actuelle.|
|[CDC::Polygon](#polygon)|Dessine un polygone constitué d’au moins deux points (sommets) reliés par des lignes.|
|[CDC::Polyline](#polyline)|Dessine un ensemble de segments de ligne reliant les points spécifiés.|
|[CDC::PolylineTo](#polylineto)|Dessine une ou plusieurs lignes droites et déplace la position actuelle jusqu’au point de fin de la dernière ligne.|
|[CDC::PolyPolygon](#polypolygon)|Crée deux polygones ou plus qui sont remplis à l’aide du mode de remplissage de polygone actuel. Les polygones peuvent être disjoints ou se chevaucher.|
|[CDC::PolyPolyline](#polypolyline)|Dessine plusieurs séries de segments de ligne connectés. La position actuelle n’est ni utilisée ni mise à jour par cette fonction.|
|[CDC::PtVisible](#ptvisible)|Spécifie si le point donné se trouve dans la zone de découpage.|
|[CDC::RealizePalette](#realizepalette)|Mappe les entrées de palette de la palette logique actuelle à la palette du système.|
|[CDC::Rectangle](#rectangle)|Dessine un rectangle à l’aide du stylet actuel et le remplit à l’aide du pinceau actuel.|
|[CDC::RectVisible](#rectvisible)|Détermine si une partie du rectangle donné se trouve dans la zone de découpage.|
|[CDC::ReleaseAttribDC](#releaseattribdc)|Releases `m_hAttribDC`, le contexte de périphérique d’attribut.|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Releases `m_hDC`, le contexte de périphérique de sortie.|
|[CDC::ResetDC](#resetdc)|Met à jour le `m_hAttribDC` contexte de périphérique.|
|[CDC::RestoreDC](#restoredc)|Restaure le contexte de périphérique (Device Context) à un `SaveDC`état précédent enregistré avec.|
|[CDC::RoundRect](#roundrect)|Dessine un rectangle avec des angles arrondis à l’aide du stylet actuel et rempli à l’aide du pinceau actuel.|
|[CDC::SaveDC](#savedc)|Enregistre l’état actuel du contexte de périphérique.|
|[CDC::ScaleViewportExt](#scaleviewportext)|Modifie l’étendue de la fenêtre d’affichage par rapport aux valeurs actuelles.|
|[CDC::ScaleWindowExt](#scalewindowext)|Modifie les étendues de fenêtre par rapport aux valeurs actuelles.|
|[CDC::ScrollDC](#scrolldc)|Fait défiler un rectangle de bits horizontalement et verticalement.|
|[CDC::SelectClipPath](#selectclippath)|Sélectionne le chemin d’accès actuel comme zone de découpage pour le contexte de périphérique, en combinant la nouvelle région avec une région de découpage existante à l’aide du mode spécifié.|
|[CDC::SelectClipRgn](#selectcliprgn)|Combine la région donnée avec la zone de découpage en cours à l’aide du mode spécifié.|
|[CDC::SelectObject](#selectobject)|Sélectionne un objet de dessin GDI, tel qu’un stylet.|
|[CDC::SelectPalette](#selectpalette)|Sélectionne la palette logique.|
|[CDC::SelectStockObject](#selectstockobject)|Sélectionne l’un des stylets, pinceaux ou polices prédéfinis fournis par Windows.|
|[CDC::SetAbortProc](#setabortproc)|Définit une fonction de rappel fournie par le programmeur que Windows appelle si un travail d’impression doit être abandonné.|
|[CDC::SetArcDirection](#setarcdirection)|Définit la direction de dessin à utiliser pour les fonctions d’arc et de rectangle.|
|[CDC::SetAttribDC](#setattribdc)|Définit `m_hAttribDC`, le contexte de périphérique de l’attribut.|
|[CDC::SetBkColor](#setbkcolor)|Définit la couleur d’arrière-plan actuelle.|
|[CDC::SetBkMode](#setbkmode)|Définit le mode d’arrière-plan.|
|[CDC::SetBoundsRect](#setboundsrect)|Contrôle l’accumulation des informations de rectangle englobant pour le contexte de périphérique spécifié.|
|[CDC::SetBrushOrg](#setbrushorg)|Spécifie l’origine du pinceau suivant sélectionné dans un contexte de périphérique.|
|[CDC::SetColorAdjustment](#setcoloradjustment)|Définit les valeurs de réglage des couleurs pour le contexte de périphérique à l’aide des valeurs spécifiées.|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Définit la couleur actuelle du pinceau.|
|[CDC::SetDCPenColor](#setdcpencolor)|Définit la couleur actuelle du stylet.|
|[CDC::SetGraphicsMode](#setgraphicsmode)|Définit le mode graphique actuel pour le contexte de périphérique spécifié.|
|[CDC::SetLayout](#setlayout)|Modifie la disposition d’un contexte de périphérique (DC).|
|[CDC::SetMapMode](#setmapmode)|Définit le mode de mappage actuel.|
|[CDC::SetMapperFlags](#setmapperflags)|Modifie l’algorithme utilisé par le mappeur de polices lorsqu’il mappe des polices logiques à des polices physiques.|
|[CDC::SetMiterLimit](#setmiterlimit)|Définit la limite de la longueur des jointures mitres pour le contexte de périphérique.|
|[CDC::SetOutputDC](#setoutputdc)|Définit `m_hDC`, le contexte de périphérique de sortie.|
|[CDC::SetPixel](#setpixel)|Définit le pixel au point spécifié sur l’approximation la plus proche de la couleur spécifiée.|
|[CDC::SetPixelV](#setpixelv)|Définit le pixel aux coordonnées spécifiées sur l’approximation la plus proche de la couleur spécifiée. `SetPixelV`est plus rapide `SetPixel` que parce qu’il n’a pas besoin de retourner la valeur de couleur du point réellement peint.|
|[CDC::SetPolyFillMode](#setpolyfillmode)|Définit le mode de remplissage du polygone.|
|[CDC::SetROP2](#setrop2)|Définit le mode de dessin actuel.|
|[CDC::SetStretchBltMode](#setstretchbltmode)|Définit le mode d’étirement de bitmap.|
|[CDC::SetTextAlign](#settextalign)|Définit les indicateurs d’alignement du texte.|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Définit la quantité d’espacement entre les caractères.|
|[CDC::SetTextColor](#settextcolor)|Définit la couleur du texte.|
|[CDC::SetTextJustification](#settextjustification)|Ajoute de l’espace aux caractères de saut de ligne dans une chaîne.|
|[CDC::SetViewportExt](#setviewportext)|Définit les étendues x et y de la fenêtre d’affichage.|
|[CDC::SetViewportOrg](#setviewportorg)|Définit l’origine de la fenêtre d’affichage.|
|[CDC::SetWindowExt](#setwindowext)|Définit les étendues x et y de la fenêtre associée.|
|[CDC::SetWindowOrg](#setwindoworg)|Définit l’origine de la fenêtre du contexte de périphérique.|
|[CDC::SetWorldTransform](#setworldtransform)|Définit l’espace universel actuel sur la transformation d’espace de page.|
|[CDC::StartDoc](#startdoc)|Informe le pilote de périphérique qu’un nouveau travail d’impression démarre.|
|[CDC::StartPage](#startpage)|Informe le pilote de périphérique qu’une nouvelle page est en cours de démarrage.|
|[CDC::StretchBlt](#stretchblt)|Déplace une image bitmap d’un rectangle source et d’un appareil dans un rectangle de destination, en étirant ou en compressant le bitmap si nécessaire pour l’ajuster aux dimensions du rectangle de destination.|
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Ferme toutes les figures ouvertes dans un chemin d’accès, frappe le contour du tracé à l’aide du stylet actuel et remplit son intérieur à l’aide du pinceau actuel.|
|[CDC::StrokePath](#strokepath)|Restitue le chemin d’accès spécifié à l’aide du stylet actuel.|
|[CDC::TabbedTextOut](#tabbedtextout)|Écrit une chaîne de caractères à un emplacement spécifié, en développant des tabulations aux valeurs spécifiées dans un tableau de positions de taquet de tabulation.|
|[CDC::TextOut](#textout)|Écrit une chaîne de caractères à un emplacement spécifié à l’aide de la police actuellement sélectionnée.|
|[CDC::TransparentBlt](#transparentblt)|Transfère un bloc de bits des données de couleur du contexte de périphérique source spécifié dans un contexte de périphérique de destination, en rendant une couleur spécifiée transparente dans le transfert.|
|[CDC::UpdateColors](#updatecolors)|Met à jour la zone cliente du contexte de périphérique en faisant correspondre les couleurs actuelles de la zone cliente à la palette du système pixel par pixel.|
|[CDC::WidenPath](#widenpath)|Redéfinit le chemin d’accès actuel comme zone qui serait peinte si le tracé était tracé à l’aide du stylet actuellement sélectionné dans le contexte de périphérique.|

### <a name="public-operators"></a>Op&#233;rateurs publics

|Nom|Description|
|----------|-----------------|
|[CDC :: Operator HDC](#operator_hdc)|Récupère le handle du contexte de périphérique.|

### <a name="public-data-members"></a>Membres de données publics

|Nom|Description|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|Contexte de périphérique d’attribut utilisé par cet `CDC` objet.|
|[CDC::m_hDC](#m_hdc)|Contexte de périphérique de sortie utilisé par cet `CDC` objet.|

## <a name="remarks"></a>Notes

L' `CDC` objet fournit des fonctions membres pour travailler avec un contexte de périphérique, tel qu’un affichage ou une imprimante, ainsi que des membres pour l’utilisation d’un contexte d’affichage associé à la zone cliente d’une fenêtre.

Effectuez tous les dessins à travers les fonctions membres `CDC` d’un objet. La classe fournit des fonctions membres pour les opérations de contexte de périphérique, l’utilisation d’outils de dessin, la sélection d’objets GDI (Graphics Device Interface) de type sécurisé et l’utilisation des couleurs et des palettes. Il fournit également des fonctions membres pour obtenir et définir des attributs de dessin, le mappage, l’utilisation de la fenêtre d’affichage, l’utilisation de l’extension de la fenêtre, la conversion de coordonnées, l’utilisation de régions, le découpage, le dessin de lignes et le dessin de formes simples, de ellipses et polygones. Les fonctions membres sont également fournies pour dessiner du texte, travailler avec des polices, utiliser des séquences d’échappement d’imprimante, faire défiler et écouter des fichiers de recherche.

Pour utiliser un `CDC` objet, construisez-le, puis appelez ses fonctions membres pour les fonctions Windows parallèles qui utilisent des contextes de périphérique.

> [!NOTE]
>  Sous Windows 95/98, toutes les coordonnées d’écran sont limitées à 16 bits. Par conséquent, un **entier** passé à `CDC` une fonction membre doit se situer dans la plage comprise entre-32768 et 32767.

Pour des utilisations spécifiques, le bibliothèque MFC (Microsoft Foundation Class) fournit plusieurs classes dérivées de `CDC` . `CPaintDC`encapsule les appels `BeginPaint` à `EndPaint`et. `CClientDC`gère un contexte d’affichage associé à la zone cliente d’une fenêtre. `CWindowDC`gère un contexte d’affichage associé à une fenêtre entière, y compris son frame et ses contrôles. `CMetaFileDC`associe un contexte de périphérique à un métafichier.

`CDC`fournit deux fonctions membres, [GetLayout](#getlayout) et [setLayout](#setlayout), pour inverser la disposition d’un contexte de périphérique, qui n’hérite pas de sa disposition d’une fenêtre. Cette orientation de droite à gauche est nécessaire pour les applications écrites pour des cultures, telles que l’arabe ou l’hébreu, où la disposition des caractères n’est pas la norme européenne.

`CDC`contient deux contextes de périphérique, [m_hDC](#m_hdc) et [m_hAttribDC](#m_hattribdc), qui, lors de la `CDC` création d’un objet, font référence au même appareil. `CDC`dirige tous les appels GDI de sortie `m_hDC` vers et la plupart des appels `m_hAttribDC`GDI d’attribut à. (Un exemple d’appel d’attribut est `GetTextColor`, tandis que `SetTextColor` est un appel de sortie.)

Par exemple, le Framework utilise ces deux contextes de périphérique pour implémenter un `CMetaFileDC` objet qui enverra la sortie à un métafichier tout en lisant les attributs d’un appareil physique. L’aperçu avant impression est implémenté dans le Framework de la même façon. Vous pouvez également utiliser les deux contextes de périphérique de la même façon dans le code spécifique à votre application.

Il peut arriver que vous ayez besoin d’informations de métriques textuelles `m_hDC` à `m_hAttribDC` la fois pour les contextes de périphérique et. Les paires de fonctions suivantes offrent cette fonctionnalité :

|Utilise m_hAttribDC|Utilise m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

Pour plus d’informations `CDC`sur, consultez [contextes de périphérique](../../mfc/device-contexts.md).

## <a name="inheritance-hierarchy"></a>Hiérarchie d'héritage

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Configuration requise

**En-tête :** afxwin.h

##  <a name="abortdoc"></a>  CDC::AbortDoc

Termine le travail d’impression en cours et efface tout ce que l’application a écrit sur l’appareil depuis le dernier appel à la fonction membre [StartDoc](#startdoc) .

```
int AbortDoc();
```

### <a name="return-value"></a>Valeur de retour

Valeur supérieure ou égale à 0 en cas de réussite, ou valeur négative si une erreur s’est produite. La liste suivante répertorie les valeurs d’erreur courantes et leurs significations :

- Erreur générale SP_ERROR.

- SP_OUTOFDISK espace disque insuffisant est actuellement disponible pour la mise en file d’attente, et aucun espace supplémentaire n’est disponible.

- SP_OUTOFMEMORY mémoire disponible est insuffisante pour la mise en file d’attente.

- L’utilisateur SP_USERABORT a terminé le travail par le biais du gestionnaire d’impression.

### <a name="remarks"></a>Notes

Cette fonction membre remplace l’échappement d’imprimante ABORTDOC.

`AbortDoc`doit être utilisé pour mettre fin à ce qui suit :

- Opérations d’impression qui ne spécifient pas de fonction Abort à l’aide de [SETABORTPROC](#setabortproc).

- Les opérations d’impression qui n’ont pas encore atteint leur premier appel d’échappement NEWFRAME ou NEXTBAND.

Si une application rencontre une erreur d’impression ou une opération d’impression annulée, elle ne doit pas tenter de mettre fin à l’opération à l’aide des `AbortDoc` fonctions membres ou [EndDoc](#enddoc) de la classe `CDC`. GDI termine automatiquement l’opération avant de retourner la valeur d’erreur.

Si l’application affiche une boîte de dialogue pour permettre à l’utilisateur d’annuler l’opération d’impression, `AbortDoc` elle doit appeler avant de détruire la boîte de dialogue.

Si le gestionnaire d’impression a été utilisé pour démarrer le travail `AbortDoc` d’impression, l’appel de efface l’ensemble du travail du spoule : l’imprimante ne reçoit rien. Si le gestionnaire d’impression n’a pas été utilisé pour démarrer le travail d’impression, les données ont peut- `AbortDoc` être été envoyées à l’imprimante avant l’appel de. Dans ce cas, le pilote d’imprimante doit réinitialiser l’imprimante (lorsque cela est possible) et fermer le travail d’impression.

### <a name="example"></a>Exemples

  Consultez l’exemple pour [CDC :: StartDoc](#startdoc).

##  <a name="abortpath"></a>  CDC::AbortPath

Ferme et ignore tous les chemins d’accès dans le contexte de périphérique.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

S’il y a un crochet ouvrant dans le contexte de périphérique, le crochet de tracé est fermé et le chemin d’accès est ignoré. Si un chemin d’accès est fermé dans le contexte de périphérique, le chemin d’accès est ignoré.

##  <a name="addmetafilecomment"></a>  CDC::AddMetaFileComment

Copie le commentaire d’une mémoire tampon dans un métafichier de format amélioré spécifié.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Paramètres

*nDataSize*<br/>
Spécifie la longueur de la mémoire tampon de commentaire, en octets.

*pCommentData*<br/>
Pointe vers la mémoire tampon qui contient le commentaire.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Un commentaire peut inclure des informations privées, par exemple la source de l’image et la date à laquelle il a été créé. Un commentaire doit commencer par une signature d’application, suivi des données. Les commentaires ne doivent pas contenir de données spécifiques à la position. Les données spécifiques à la position spécifient l’emplacement d’un enregistrement, et elles ne doivent pas être incluses, car un seul métafichier peut être incorporé dans un autre métafichier. Cette fonction ne peut être utilisée qu’avec des refichiers améliorés.

##  <a name="alphablend"></a>  CDC::AlphaBlend

Appelez cette fonction membre pour afficher les bitmaps qui ont des pixels transparents ou translucides.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Paramètres

*xDest*<br/>
Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle de destination.

*yDest*<br/>
Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle de destination.

*nDestWidth*<br/>
Spécifie la largeur, en unités logiques, du rectangle de destination.

*nDestHeight*<br/>
Spécifie la hauteur, en unités logiques, du rectangle de destination.

*pSrcDC*<br/>
Pointeur vers le contexte de périphérique source.

*xSrc*<br/>
Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle source.

*ySrc*<br/>
Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle source.

*nSrcWidth*<br/>
Spécifie la largeur, en unités logiques, du rectangle source.

*nSrcHeight*<br/>
Spécifie la hauteur, en unités logiques, du rectangle source.

*blend*<br/>
Spécifie une structure [BLENDFUNCTION](/windows/win32/api/wingdi/ns-wingdi-blendfunction) .

### <a name="return-value"></a>Valeur de retour

TRUE en cas de réussite, sinon FALSE.

### <a name="remarks"></a>Notes

Pour plus d’informations, consultez [AlphaBlend](/windows/win32/api/wingdi/nf-wingdi-alphablend) dans le SDK Windows.

##  <a name="anglearc"></a>  CDC::AngleArc

Dessine un segment de ligne et un arc.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique du centre du cercle.

*y*<br/>
Spécifie la coordonnée y logique du centre du cercle.

*nRadius*<br/>
Spécifie le rayon du cercle en unités logiques. Cette valeur doit être positive.

*fStartAngle*<br/>
Spécifie l’angle de départ, en degrés, par rapport à l’axe x.

*fSweepAngle*<br/>
Spécifie l’angle de balayage, en degrés, par rapport à l’angle de départ.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Le segment de ligne est dessiné à partir de la position actuelle jusqu’au début de l’arc. L’arc est dessiné le long du périmètre d’un cercle avec le rayon et le centre donnés. La longueur de l’arc est définie par les angles de début et de balayage donnés.

`AngleArc`déplace la position actuelle jusqu’au point de fin de l’arc. L’arc dessiné par cette fonction peut paraître elliptique, en fonction de la transformation et du mode de mappage actuels. Avant de dessiner l’arc, cette fonction dessine le segment de ligne à partir de la position actuelle jusqu’au début de l’arc. L’arc est dessiné en construisant un cercle imaginaire avec le rayon spécifié autour du point central spécifié. Le point de départ de l’arc est déterminé par le sens des aiguilles d’une ligne à partir de l’axe x du cercle par le nombre de degrés dans l’angle de départ. Le point de fin est similaire en mesurant le sens des aiguilles d’une ligne à partir du point de départ par le nombre de degrés dans l’angle de balayage.

Si l’angle de balayage est supérieur à 360 degrés, l’arc est balayé plusieurs fois. Cette fonction dessine des lignes à l’aide du stylet actuel. La figure n’est pas remplie.

##  <a name="arc"></a>  CDC::Arc

Dessine un arc elliptique.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la coordonnée x de l’angle supérieur gauche du rectangle englobant (en unités logiques).

*y1*<br/>
Spécifie la coordonnée y de l’angle supérieur gauche du rectangle englobant (en unités logiques).

*x2*<br/>
Spécifie la coordonnée x du coin inférieur droit du rectangle englobant (en unités logiques).

*y2*<br/>
Spécifie la coordonnée y du coin inférieur droit du rectangle englobant (en unités logiques).

*x3*<br/>
Spécifie la coordonnée x du point qui définit le point de départ de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc.

*y3*<br/>
Spécifie la coordonnée y du point qui définit le point de départ de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc.

*x4*<br/>
Spécifie la coordonnée x du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc.

*y4*<br/>
Spécifie la coordonnée y du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc.

*lpRect*<br/>
Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer un objet LPRECT ou [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

*ptStart*<br/>
Spécifie les coordonnées x et y du point qui définit le point de départ de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc. Vous pouvez passer une structure [point](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) pour ce paramètre.

*ptEnd*<br/>
Spécifie les coordonnées x et y du point qui définit le point de fin de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc. Vous pouvez passer une `POINT` structure ou un `CPoint` objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

L’arc dessiné à l’aide de la fonction est un segment de l’ellipse définie par le rectangle englobant spécifié.

Le point de départ réel de l’arc est le point auquel un rayon dessiné à partir du centre du rectangle englobant à travers le point de départ spécifié croise l’ellipse. Le point de fin réel de l’arc est le point auquel un rayon dessiné à partir du centre du rectangle englobant à travers le point de terminaison spécifié croise l’ellipse. L’arc est dessiné dans le sens inverse des aiguilles d’une passe. Comme un arc n’est pas une figure fermée, il n’est pas rempli. La largeur et la hauteur du rectangle doivent être supérieures à 2 unités et inférieures à 32 767 unités.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

##  <a name="arcto"></a>  CDC::ArcTo

Dessine un arc elliptique.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la coordonnée x de l’angle supérieur gauche du rectangle englobant (en unités logiques).

*y1*<br/>
Spécifie la coordonnée y de l’angle supérieur gauche du rectangle englobant (en unités logiques).

*x2*<br/>
Spécifie la coordonnée x du coin inférieur droit du rectangle englobant (en unités logiques).

*y2*<br/>
Spécifie la coordonnée y du coin inférieur droit du rectangle englobant (en unités logiques).

*x3*<br/>
Spécifie la coordonnée x du point qui définit le point de départ de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc.

*y3*<br/>
Spécifie la coordonnée y du point qui définit le point de départ de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc.

*x4*<br/>
Spécifie la coordonnée x du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc.

*y4*<br/>
Spécifie la coordonnée y du point qui définit le point de terminaison de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc.

*lpRect*<br/>
Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer un pointeur vers une structure de données [Rect](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

*ptStart*<br/>
Spécifie les coordonnées x et y du point qui définit le point de départ de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc. Vous pouvez passer une structure de données de [point](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) pour ce paramètre.

*ptEnd*<br/>
Spécifie les coordonnées x et y du point qui définit le point de fin de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc. Vous pouvez transmettre une `POINT` structure de données ou un `CPoint` objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction est semblable à `CDC::Arc`, à ceci près que la position actuelle est mise à jour. Les points ( *x1*, *Y1*) et ( *x2*, *Y2*) spécifient le rectangle englobant. Une ellipse formée par le rectangle englobant donné définit la courbe de l’arc. L’arc s’étend dans le sens inverse des aiguilles d’une position (par défaut) à partir du point où il croise la ligne radiale du centre du rectangle englobant à ( *x3*, *Y3*). L’arc se termine là où il croise la ligne radiale du centre du rectangle englobant à ( *x4*, *Y4*). Si le point de départ et le point de fin sont identiques, une ellipse complète est dessinée.

Une ligne est dessinée de la position actuelle jusqu’au point de départ de l’arc. Si aucune erreur ne se produit, la position actuelle est définie sur le point de fin de l’arc. L’arc est dessiné à l’aide du stylet actuel ; elle n’est pas remplie.

##  <a name="attach"></a>  CDC::Attach

Utilisez cette fonction membre pour attacher un *HDC* à l' `CDC` objet.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Paramètres

*hDC*<br/>
Contexte de périphérique Windows.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le *HDC* est stocké à `m_hDC`la fois dans le contexte de périphérique de `m_hAttribDC`sortie et dans, dans le contexte de périphérique d’attribut.

##  <a name="beginpath"></a>  CDC::BeginPath

Ouvre un crochet de chemin d’accès dans le contexte de périphérique.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Une fois qu’un crochet de tracé est ouvert, une application peut commencer à appeler des fonctions de dessin GDI pour définir les points qui se trouvent dans le chemin d’accès. Une application peut fermer un crochet ouvrant en appelant la `EndPath` fonction membre. Quand une application appelle `BeginPath`, tous les chemins d’accès précédents sont ignorés.

Consultez [BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath) dans la SDK Windows pour obtenir la liste des fonctions de dessin qui définissent des points dans un chemin d’accès.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

##  <a name="bitblt"></a>  CDC::BitBlt

Copie une image bitmap du contexte de périphérique source vers ce contexte de périphérique actuel.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle de destination.

*y*<br/>
Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle de destination.

*nWidth*<br/>
Spécifie la largeur (en unités logiques) du rectangle de destination et de la bitmap source.

*nHeight*<br/>
Spécifie la hauteur (en unités logiques) du rectangle de destination et de la bitmap source.

*pSrcDC*<br/>
Pointeur vers un `CDC` objet qui identifie le contexte de périphérique à partir duquel la bitmap sera copiée. Elle doit avoir la valeur NULL si *dwRop* spécifie une opération Raster qui n’inclut pas de source.

*xSrc*<br/>
Spécifie la coordonnée x logique de l’angle supérieur gauche de l’image bitmap source.

*ySrc*<br/>
Spécifie la coordonnée y logique de l’angle supérieur gauche de l’image bitmap source.

*dwRop*<br/>
Spécifie l'opération de rastérisation à effectuer. Les codes d’opération Raster définissent la façon dont le GDI combine les couleurs dans les opérations de sortie qui impliquent un pinceau actuel, une bitmap source possible et une bitmap de destination. Pour obtenir la liste des codes d’opération Raster pour *dwRop* et leurs descriptions, consultez [BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt) dans le SDK Windows.

Pour obtenir la liste complète des codes d’opération Raster, consultez [à propos des codes d’opération Raster](/windows/win32/gdi/raster-operation-codes) dans le SDK Windows.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

L’application peut aligner les zones clientes ou Windows sur les limites d’octets pour `BitBlt` s’assurer que les opérations se produisent sur des rectangles alignés sur les octets. (Définissez les indicateurs CS_BYTEALIGNWINDOW ou CS_BYTEALIGNCLIENT lorsque vous inscrivez les classes de fenêtre.)

`BitBlt`les opérations sur les rectangles alignés sur les octets `BitBlt` sont beaucoup plus rapides que les opérations sur les rectangles qui ne sont pas alignés sur les octets. Si vous souhaitez spécifier des styles de classe tels que l’alignement d’octets pour votre propre contexte de périphérique, vous devrez inscrire une classe de fenêtre au lieu de vous appuyer sur les classes Microsoft Foundation pour la faire pour vous. Utilisez la fonction globale [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

GDI transforme *nWidth* et *nHeight*, une fois en utilisant le contexte de périphérique de destination et une fois à l’aide du contexte de périphérique source. Si les étendues résultantes ne correspondent pas, GDI utilise la `StretchBlt` fonction Windows pour compresser ou étirer l’image bitmap source si nécessaire.

Si les bitmaps de destination, source et de modèle n’ont pas le même format de `BitBlt` couleur, la fonction convertit les bitmaps de la source et du modèle pour qu’elles correspondent à la destination. Les couleurs de premier plan et d’arrière-plan de la bitmap de destination sont utilisées lors de la conversion.

Quand la `BitBlt` fonction convertit une image bitmap monochrome en couleur, elle définit les bits blancs (1) sur la couleur d’arrière-plan et les bits noirs (0) sur la couleur de premier plan. Les couleurs de premier plan et d’arrière-plan du contexte de périphérique de destination sont utilisées. Pour convertir la couleur en monochrome `BitBlt` , définit les pixels qui correspondent à la couleur d’arrière-plan en blanc et définit tous les autres pixels en noir. `BitBlt`utilise les couleurs de premier plan et d’arrière-plan du contexte de périphérique de couleur pour convertir la couleur en monochrome.

Notez que tous les contextes d’appareil `BitBlt`ne prennent pas en charge. Pour vérifier si un contexte de périphérique donné prend `BitBlt`en charge, `GetDeviceCaps` utilisez la fonction membre et spécifiez l’index RasterCaps.

### <a name="example"></a>Exemple

  Consultez l’exemple pour [CDC :: CreateCompatibleDC](#createcompatibledc).

##  <a name="cdc"></a>  CDC::CDC

Construit un objet `CDC`.

```
CDC();
```

##  <a name="chord"></a>  CDC::Chord

Dessine une corde (une figure fermée délimitée par l’intersection d’une ellipse et d’un segment de ligne).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la coordonnée x de l’angle supérieur gauche du rectangle englobant de la corde (en unités logiques).

*y1*<br/>
Spécifie la coordonnée y de l’angle supérieur gauche du rectangle englobant de la corde (en unités logiques).

*x2*<br/>
Spécifie la coordonnée x du coin inférieur droit du rectangle englobant de la corde (en unités logiques).

*y2*<br/>
Spécifie la coordonnée y du coin inférieur droit du rectangle englobant de la corde (en unités logiques).

*x3*<br/>
Spécifie la coordonnée x du point qui définit le point de départ de la corde (en unités logiques).

*y3*<br/>
Spécifie la coordonnée y du point qui définit le point de départ de la corde (en unités logiques).

*x4*<br/>
Spécifie la coordonnée x du point qui définit le point de terminaison de la corde (en unités logiques).

*y4*<br/>
Spécifie la coordonnée y du point qui définit le point de terminaison de la corde (en unités logiques).

*lpRect*<br/>
Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer un objet LPRECT ou [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

*ptStart*<br/>
Spécifie les coordonnées x et y du point qui définit le point de départ de la corde (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur la corde. Vous pouvez passer une `POINT` structure ou un `CPoint` objet pour ce paramètre.

*ptEnd*<br/>
Spécifie les coordonnées x et y du point qui définit le point de fin de la corde (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur la corde. Vous pouvez passer une structure [point](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Les paramètres ( *x1*, *Y1*) et ( *x2*, *Y2*) spécifient respectivement les angles supérieur gauche et inférieur droit d’un rectangle englobant l’ellipse faisant partie du segment. Les paramètres ( *x3*, *Y3*) et ( *x4*, *Y4*) spécifient les points de terminaison d’une ligne qui croise l’ellipse. La corde est dessinée à l’aide du stylet sélectionné et remplie à l’aide du pinceau sélectionné.

La figure dessinée par `Chord` la fonction s’étend jusqu’à, mais n’inclut pas les coordonnées droite et inférieure. Cela signifie que la hauteur de la figure est *Y2* - *Y1* et que la largeur de la figure est *x2* - *x1*.

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

##  <a name="closefigure"></a>  CDC::CloseFigure

Ferme une figure ouverte dans un chemin d’accès.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

La fonction ferme la figure en dessinant une ligne à partir de la position actuelle jusqu’au premier point de la figure (en général, le point spécifié par l’appel `MoveTo` le plus récent à la fonction membre) et relie les lignes à l’aide du style de jonction de ligne. Si une figure est fermée à l’aide `LineTo` de la fonction membre `CloseFigure`au lieu de, les bouchons de fin sont utilisés pour créer l’angle au lieu d’une jointure. `CloseFigure`doit être appelé uniquement s’il existe un crochet ouvrant dans le contexte de périphérique.

Une figure dans un chemin d’accès est ouverte, sauf si elle est explicitement fermée à l’aide de cette fonction. (Une figure peut être ouverte même si le point actuel et le point de départ de la figure sont identiques.) Toute ligne ou courbe ajoutée au tracé après `CloseFigure` le démarrage d’une nouvelle figure.

##  <a name="createcompatibledc"></a>  CDC::CreateCompatibleDC

Crée un contexte de périphérique de mémoire qui est compatible avec l’appareil spécifié par le *contrôleur de domaine principal*.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Paramètres

*pDC*<br/>
Pointeur vers un contexte de périphérique. Si le *contrôleur de domaine principal* a la valeur null, la fonction crée un contexte de périphérique de mémoire qui est compatible avec l’affichage système.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Un contexte de périphérique de mémoire est un bloc de mémoire qui représente une surface d’affichage. Il peut être utilisé pour préparer des images en mémoire avant de les copier sur la surface réelle du périphérique de l’appareil compatible.

Quand un contexte de périphérique de mémoire est créé, GDI sélectionne automatiquement une bitmap de stock monochrome 1 par 1. Les fonctions de sortie GDI peuvent être utilisées avec un contexte de périphérique de mémoire uniquement si une bitmap a été créée et sélectionnée dans ce contexte.

Cette fonction ne peut être utilisée que pour créer des contextes de périphérique compatibles pour les appareils qui prennent en charge les opérations raster. Pour plus d’informations sur les transferts de bloc de bits entre les contextes de périphérique, consultez la fonction membre [CDC :: BitBlt](#bitblt) . Pour déterminer si un contexte de périphérique prend en charge les opérations raster, consultez la fonctionnalité raster RC_BITBLT dans la `CDC::GetDeviceCaps`fonction membre.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

##  <a name="createdc"></a>  CDC::CreateDC

Crée un contexte de périphérique pour le périphérique spécifié.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Paramètres

*lpszDriverName*<br/>
Pointe vers une chaîne se terminant par un caractère null qui spécifie le nom de fichier (sans extension) du pilote de périphérique (par exemple, « EPSON »). Vous pouvez également passer un `CString` objet pour ce paramètre.

*lpszDeviceName*<br/>
Pointe vers une chaîne se terminant par un caractère null qui spécifie le nom de l’appareil spécifique à prendre en charge (par exemple, « EPSON FX-80 »). Le paramètre *lpszDeviceName* est utilisé si le module prend en charge plusieurs appareils. Vous pouvez également passer un `CString` objet pour ce paramètre.

*lpszOutput*<br/>
Pointe vers une chaîne se terminant par un caractère null qui spécifie le nom du fichier ou du périphérique pour le support de sortie physique (fichier ou port de sortie). Vous pouvez également passer un `CString` objet pour ce paramètre.

*lpInitData*<br/>
Pointe vers une `DEVMODE` structure contenant des données d’initialisation spécifiques à l’appareil pour le pilote de périphérique. La fonction `DocumentProperties` Windows récupère cette structure remplie pour un appareil donné. Le paramètre *lpInitData* doit avoir la valeur null si le pilote de périphérique doit utiliser l’initialisation par défaut (le cas échéant) spécifiée par l’utilisateur via le panneau de configuration.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

IMPRESSION. Le fichier d’en-tête H est requis si la structure [DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea) est utilisée.

Les noms des appareils respectent les conventions suivantes : un signe deux-points de fin ( :) est recommandé, mais facultatif. Windows supprime le signe deux-points de fin de manière à ce qu’un nom de périphérique se terminant par un signe deux-points soit mappé sur le même port que le même nom, sans le signe deux-points. Les noms de pilote et de port ne doivent pas contenir d’espaces de début ou de fin. Les fonctions de sortie GDI ne peuvent pas être utilisées avec des contextes d’informations.

##  <a name="createic"></a>  CDC::CreateIC

Crée un contexte d’informations pour le périphérique spécifié.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Paramètres

*lpszDriverName*<br/>
Pointe vers une chaîne se terminant par un caractère null qui spécifie le nom de fichier (sans extension) du pilote de périphérique (par exemple, « EPSON »). Vous pouvez passer un `CString` objet pour ce paramètre.

*lpszDeviceName*<br/>
Pointe vers une chaîne se terminant par un caractère null qui spécifie le nom de l’appareil spécifique à prendre en charge (par exemple, « EPSON FX-80 »). Le paramètre *lpszDeviceName* est utilisé si le module prend en charge plusieurs appareils. Vous pouvez passer un `CString` objet pour ce paramètre.

*lpszOutput*<br/>
Pointe vers une chaîne se terminant par un caractère null qui spécifie le nom du fichier ou du périphérique pour le support de sortie physique (fichier ou port). Vous pouvez passer un `CString` objet pour ce paramètre.

*lpInitData*<br/>
Pointe vers des données d’initialisation spécifiques à l’appareil pour le pilote de périphérique. Le paramètre *lpInitData* doit avoir la valeur null si le pilote de périphérique doit utiliser l’initialisation par défaut (le cas échéant) spécifiée par l’utilisateur via le panneau de configuration. Pour `CreateDC` plus d’informations sur l’initialisation spécifique à l’appareil, consultez.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Le contexte d’information fournit un moyen rapide d’obtenir des informations sur l’appareil sans créer de contexte de périphérique.

Les noms des appareils respectent les conventions suivantes : un signe deux-points de fin ( :) est recommandé, mais facultatif. Windows supprime le signe deux-points de fin de manière à ce qu’un nom de périphérique se terminant par un signe deux-points soit mappé sur le même port que le même nom, sans le signe deux-points. Les noms de pilote et de port ne doivent pas contenir d’espaces de début ou de fin. Les fonctions de sortie GDI ne peuvent pas être utilisées avec des contextes d’informations.

##  <a name="deletedc"></a>  CDC::DeleteDC

En général, n’appelez pas cette fonction. le destructeur le fera pour vous.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la fonction s’est terminée avec succès ; Sinon, 0.

### <a name="remarks"></a>Notes

La `DeleteDC` fonction membre supprime les contextes `m_hDC` de périphérique Windows qui sont associés à dans l’objet `CDC` actuel. Si cet `CDC` objet est le dernier contexte de périphérique actif pour un appareil donné, le périphérique est notifié et toutes les ressources de stockage et système utilisées par l’appareil sont libérées.

Une application ne doit pas `DeleteDC` appeler si des objets ont été sélectionnés dans le contexte de périphérique. Vous devez d’abord sélectionner des objets en dehors du contexte de périphérique avant de les supprimer.

Une application ne doit pas supprimer un contexte de périphérique (Device Context) dont le handle a été obtenu en appelant [CWnd :: GetDC](../../mfc/reference/cwnd-class.md#getdc). Au lieu de cela, il doit appeler [CWnd :: ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) pour libérer le contexte de périphérique. Les classes [CClientDC](../../mfc/reference/cclientdc-class.md) et [CWindowDC](../../mfc/reference/cwindowdc-class.md) sont fournies pour encapsuler cette fonctionnalité.

La `DeleteDC` fonction est généralement utilisée pour supprimer des contextes de périphérique créés avec [CreateDC](#createdc), [Create](#createic)ou [CreateCompatibleDC](#createcompatibledc).

### <a name="example"></a>Exemples

  Consultez l’exemple de [CPrintDialog :: GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

##  <a name="deletetempmap"></a>  CDC::DeleteTempMap

Appelée automatiquement par le `CWinApp` gestionnaire de temps d’inactivité, `DeleteTempMap` supprime tous `CDC` les objets temporaires `FromHandle`créés par, mais ne détruit pas les handles `hDC`de contexte de périphérique temporairement associés à l' objet`CDC` objets.

```
static void PASCAL DeleteTempMap();
```

##  <a name="detach"></a>  CDC::Detach

Appelez cette fonction pour `m_hDC` détacher (le contexte de périphérique de sortie) de l’objet et définir à la `CDC` fois `m_hDC` et `m_hAttribDC` avec la valeur null.

```
HDC Detach();
```

### <a name="return-value"></a>Valeur de retour

Contexte de périphérique Windows.

##  <a name="dptohimetric"></a>  CDC::DPtoHIMETRIC

Utilisez cette fonction lorsque vous donnez des tailles de HIMETRIC à OLE, convertissant les pixels en HIMETRIC.

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*lpSize*<br/>
Pointe vers une structure de [taille](/windows/win32/api/windef/ns-windef-size) ou un objet [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Notes

Si le mode de mappage de l’objet de contexte de périphérique est MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC ou MM_HIMETRIC, la conversion est basée sur le nombre de pixels du pouce physique. Si le mode de mappage est l’un des autres modes non restreints (par exemple, MM_TEXT), la conversion est basée sur le nombre de pixels du pouce logique.

##  <a name="dptolp"></a>  CDC::DPtoLP

Convertit les unités d’appareil en unités logiques.

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*lpPoints*<br/>
Pointe vers un tableau de structures [point](/windows/win32/api/windef/ns-windef-point) ou d’objets [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

*nCount*<br/>
Nombre de points dans le tableau.

*lpRect*<br/>
Pointe vers une structure [Rect](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) . Ce paramètre est utilisé pour le cas simple de conversion d’un rectangle des points de périphérique en points logiques.

*lpSize*<br/>
Pointe vers une structure de [taille](/windows/win32/api/windef/ns-windef-size) ou un objet [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Notes

La fonction mappe les coordonnées de chaque point, ou dimension d’une taille, du système de coordonnées du périphérique au système de coordonnées logiques de GDI. La conversion dépend du mode de mappage actuel et des paramètres de l’origine et des étendues de la fenêtre et de la fenêtre d’affichage de l’appareil.

##  <a name="draw3drect"></a>  CDC::Draw3dRect

Appelez cette fonction membre pour dessiner un rectangle tridimensionnel.

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer un pointeur vers une structure [Rect](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

*clrTopLeft*<br/>
Spécifie la couleur des côtés supérieur et gauche du rectangle tridimensionnel.

*clrBottomRight*<br/>
Spécifie la couleur des côtés inférieur et droit du rectangle tridimensionnel.

*x*<br/>
Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle tridimensionnel.

*y*<br/>
Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle tridimensionnel.

*cx*<br/>
Spécifie la largeur du rectangle tridimensionnel.

*cy*<br/>
Spécifie la hauteur du rectangle tridimensionnel.

### <a name="remarks"></a>Notes

Le rectangle est dessiné avec les côtés supérieur et gauche dans la couleur spécifiée par *clrTopLeft* et les côtés inférieur et droit dans la couleur spécifiée par *clrBottomRight*.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

##  <a name="drawdragrect"></a>  CDC::DrawDragRect

Appelez cette fonction membre à plusieurs reprises pour redessiner un rectangle de glissement.

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Pointe vers une structure [Rect](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui spécifie les coordonnées logiques d’un rectangle, dans ce cas, la position de fin du rectangle redessiné.

*size*<br/>
Spécifie le déplacement à partir du coin supérieur gauche de la bordure externe vers l’angle supérieur gauche de la bordure interne (autrement dit, l’épaisseur de la bordure) d’un rectangle.

*lpRectLast*<br/>
Pointe vers une structure [Rect](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui spécifie les coordonnées logiques de la position d’un rectangle, dans ce cas, la position d’origine du rectangle redessiné.

*sizeLast*<br/>
Spécifie le déplacement à partir du coin supérieur gauche de la bordure externe vers l’angle supérieur gauche de la bordure interne (autrement dit, l’épaisseur de la bordure) du rectangle d’origine qui est redessiné.

*pBrush*<br/>
Pointeur vers un objet Brush. Affectez la valeur NULL pour utiliser le pinceau en demi-teinte par défaut.

*pBrushLast*<br/>
Pointeur vers le dernier objet Brush utilisé. Affectez la valeur NULL pour utiliser le pinceau en demi-teinte par défaut.

### <a name="remarks"></a>Notes

Appelez-le dans une boucle lorsque vous échantillonnez la position de la souris, afin d’obtenir des commentaires visuels. Lorsque vous appelez `DrawDragRect`, le rectangle précédent est effacé et un nouveau est dessiné. Par exemple, lorsque l’utilisateur fait glisser un rectangle sur l’écran, `DrawDragRect` efface le rectangle d’origine et redessine un nouveau rectangle à sa nouvelle position. Par défaut, `DrawDragRect` dessine le rectangle à l’aide d’un pinceau en demi-teinte pour éliminer le scintillement et pour créer l’apparence d’un rectangle de déplacement fluide.

La première fois que vous `DrawDragRect`appelez, le paramètre *lpRectLast* doit avoir la valeur null.

##  <a name="drawedge"></a>  CDC::DrawEdge

Appelez cette fonction membre pour dessiner les bords d’un rectangle du type et du style spécifiés.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Pointeur vers une `RECT` structure qui contient les coordonnées logiques du rectangle.

*nEdge*<br/>
Spécifie le type de bord interne et externe à dessiner. Ce paramètre doit être une combinaison d’un indicateur de bordure interne et d’un indicateur de bordure externe. Consultez [DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) dans le SDK Windows pour obtenir un tableau des types du paramètre.

*nFlags*<br/>
Indicateurs qui spécifient le type de bordure à dessiner. Consultez `DrawEdge` dans la SDK Windows pour obtenir un tableau des valeurs du paramètre. Pour les lignes diagonales, les indicateurs BF_RECT spécifient le point de terminaison du vecteur délimité par le paramètre rectangle.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

##  <a name="drawescape"></a>  CDC::DrawEscape

Accède aux fonctionnalités de dessin d’un affichage vidéo qui ne sont pas directement disponibles via l’interface GDI (Graphics Device Interface).

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Paramètres

*nEscape*<br/>
Spécifie la fonction d’échappement à exécuter.

*nInputSize*<br/>
Spécifie le nombre d’octets de données vers lequel pointe le paramètre *lpszInputData* .

*lpszInputData*<br/>
Pointe vers la structure d’entrée requise pour l’échappement spécifié.

### <a name="return-value"></a>Valeur de retour

Spécifie le résultat de la fonction. Supérieur à zéro en cas de réussite, à l’exception de l’échappement de dessin QUERYESCSUPPORT, qui vérifie uniquement l’implémentation ; ou zéro si l’échappement n’est pas implémenté ; ou est inférieur à zéro si une erreur s’est produite.

### <a name="remarks"></a>Notes

Lorsqu’une application appelle `DrawEscape`, les données identifiées par *nInputSize* et *lpszInputData* sont transmises directement au pilote d’affichage spécifié.

##  <a name="drawfocusrect"></a>  CDC::DrawFocusRect

Dessine un rectangle dans le style utilisé pour indiquer que le rectangle a le focus.

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Pointe vers une structure [Rect](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui spécifie les coordonnées logiques du rectangle à dessiner.

### <a name="remarks"></a>Notes

Étant donné qu’il s’agit d’une fonction XOR booléenne, l’appel de cette fonction une deuxième fois avec le même rectangle supprime le rectangle de l’affichage. Impossible de faire défiler le Rectangle dessiné par cette fonction. Pour faire défiler une zone contenant un Rectangle dessiné par cette fonction `DrawFocusRect` , appelez d’abord pour supprimer le rectangle de l’affichage, puis faites défiler la zone, puis rappelez `DrawFocusRect` pour dessiner le rectangle à la nouvelle position.

> [!CAUTION]
> `DrawFocusRect`fonctionne uniquement en mode MM_TEXT. Dans d’autres modes, cette fonction ne dessine pas correctement le rectangle de focus, mais elle ne retourne pas de valeurs d’erreur.

##  <a name="drawframecontrol"></a>  CDC::DrawFrameControl

Appelez cette fonction membre pour dessiner un contrôle Frame du type et du style spécifiés.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Pointeur vers une `RECT` structure qui contient les coordonnées logiques du rectangle.

*nType*<br/>
Spécifie le type de contrôle Frame à dessiner. Consultez le paramètre *uType* dans [DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol) dans le SDK Windows pour obtenir la liste des valeurs possibles de ce paramètre.

*nState*<br/>
Spécifie l’état initial du contrôle Frame. Il peut s’agir d’une ou plusieurs des valeurs décrites pour le paramètre `DrawFrameControl` uState dans la SDK Windows. Utilisez la valeur *NSTATE* DFCS_ADJUSTRECT pour ajuster le rectangle englobant pour exclure le bord environnant du bouton de commande.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Dans plusieurs cas, *nState* dépend du paramètre *ndéclarations* . La liste suivante montre la relation entre les quatre valeurs *ndéclarations* et *nState*:

- DFC_BUTTON

    - Bouton DFCS_BUTTON3STATE trois États

    - Case à cocher DFCS_BUTTONCHECK

    - Bouton de commande DFCS_BUTTONPUSH

    - Case d’option DFCS_BUTTONRADIO

    - Image DFCS_BUTTONRADIOIMAGE pour la case d’option (image besoins non carrés)

    - Masque DFCS_BUTTONRADIOMASK pour la case d’option (masque des besoins non carrés)

- DFC_CAPTION

    - DFCS_CAPTIONCLOSE bouton Fermer

    - Bouton d’aide DFCS_CAPTIONHELP

    - Bouton d’agrandissement DFCS_CAPTIONMAX

    - Bouton réduire DFCS_CAPTIONMIN

    - Bouton Restaurer DFCS_CAPTIONRESTORE

- DFC_MENU

    - Flèche du sous-menu DFCS_MENUARROW

    - Puce DFCS_MENUBULLET

    - Coche DFCS_MENUCHECK

- DFC_SCROLL

    - Barre de défilement de la zone de liste déroulante DFCS_SCROLLCOMBOBOX

    - DFCS_SCROLLDOWN flèche vers le bas de la barre de défilement

    - DFCS_SCROLLLEFT flèche gauche de la barre de défilement

    - DFCS_SCROLLRIGHT flèche droite de la barre de défilement

    - Poignée de la taille de DFCS_SCROLLSIZEGRIP dans le coin inférieur droit de la fenêtre

    - DFCS_SCROLLUP flèche haut de la barre de défilement

### <a name="example"></a>Exemple

Ce code dessine le redimensionnement de taille dans le coin inférieur droit de votre fenêtre. Il est approprié pour le `OnPaint` gestionnaire d’une boîte de dialogue, qui n’a pas de styles et qui ne contient normalement pas d’autres contrôles (comme une barre d’État) qui peuvent lui attribuer une taille.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

##  <a name="drawicon"></a>  CDC::DrawIcon

Dessine une icône sur l’appareil représenté par l' `CDC` objet actuel.

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique de l’angle supérieur gauche de l’icône.

*y*<br/>
Spécifie la coordonnée y logique de l’angle supérieur gauche de l’icône.

*hIcon*<br/>
Identifie le handle de l’icône à dessiner.

*point*<br/>
Spécifie les coordonnées x et y logiques de l’angle supérieur gauche de l’icône. Vous pouvez passer une structure [point](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la fonction s’est terminée avec succès ; Sinon, 0.

### <a name="remarks"></a>Notes

La fonction place l’angle supérieur gauche de l’icône à l’emplacement spécifié par *x* et *y*. L’emplacement est soumis au mode de mappage actuel du contexte de périphérique.

La ressource icône doit avoir été précédemment chargée à l’aide des `CWinApp::LoadIcon`fonctions `CWinApp::LoadStandardIcon`, ou `CWinApp::LoadOEMIcon`. Le `MM_TEXT` mode de mappage doit être sélectionné avant d’utiliser cette fonction.

### <a name="example"></a>Exemple

  Consultez l’exemple de [CWnd :: IsIconic](../../mfc/reference/cwnd-class.md#isiconic).

##  <a name="drawstate"></a>  CDC::DrawState

Appelez cette fonction membre pour afficher une image et appliquer un effet visuel pour indiquer un État, tel qu’un état désactivé ou par défaut.

> [!NOTE]
>  Pour tous les États *tous* à l’exception de DSS_NORMAL, l’image est convertie en monochrome avant l’application de l’effet visuel.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Paramètres

*pt*<br/>
Spécifie l’emplacement de l’image.

*size*<br/>
Spécifie la taille de l’image.

*hBitmap*<br/>
Handle d’une bitmap.

*nFlags*<br/>
Indicateurs qui spécifient le type et l’état de l’image. Consultez [DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) dans le SDK Windows pour connaître les types et les États *nFlags* possibles.

*hBrush*<br/>
Handle d’un pinceau.

*pBitmap*<br/>
Pointeur vers un objet CBitmap.

*pBrush*<br/>
Pointeur vers un objet CBrush.

*hIcon*<br/>
Handle d’une icône.

*lpszText*<br/>
Pointeur vers du texte.

*bPrefixText*<br/>
Texte qui peut contenir un mnémonique d’accélérateur. Le paramètre *lData* spécifie l’adresse de la chaîne, tandis que le paramètre *nTextLen* spécifie la longueur. Si *nTextLen* a la valeur 0, la chaîne est supposée se terminer par un caractère null.

*nTextLen*<br/>
Longueur de la chaîne de texte vers laquelle pointe *lpszText*. Si *nTextLen* a la valeur 0, la chaîne est supposée se terminer par un caractère null.

*lpDrawProc*<br/>
Pointeur vers une fonction de rappel utilisée pour restituer une image. Ce paramètre est obligatoire si le type d’image dans *nFlags* est DST_COMPLEX. Elle est facultative et peut être NULL si le type d’image est DST_TEXT. Pour tous les autres types d’images, ce paramètre est ignoré. Pour plus d’informations sur la fonction de rappel, consultez la fonction [DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc) dans la SDK Windows.

*lData*<br/>
Spécifie des informations sur l’image. La signification de ce paramètre dépend du type d’image.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

##  <a name="drawtext"></a>  CDC::DrawText

Appelez cette fonction membre pour mettre en forme le texte dans le rectangle donné. Pour spécifier des options de mise en forme supplémentaires, utilisez [CDC ::D rawtextex](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Paramètres

*lpszString*<br/>
Pointe vers la chaîne à dessiner. Si *nCount* a la valeur-1, la chaîne doit se terminer par un caractère null.

*nCount*<br/>
Spécifie le nombre de caractères dans la chaîne. Si *nCount* a la valeur-1, *lpszString* est supposé être un long pointeur vers une chaîne terminée par le caractère null `DrawText` et calcule le nombre de caractères automatiquement.

*lpRect*<br/>
Pointe vers une structure [Rect](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui contient le rectangle (en coordonnées logiques) dans lequel le texte doit être mis en forme.

*str*<br/>
Objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) qui contient les caractères spécifiés à dessiner.

*nFormat*<br/>
Spécifie la méthode de mise en forme du texte. Il peut s’agir de n’importe quelle combinaison des valeurs décrites pour le paramètre *uFormat* dans [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) dans le SDK Windows. (Combinez à l’aide de l’opérateur or au niveau du bit) :

> [!NOTE]
>  Certaines combinaisons d’indicateurs *uFormat* peuvent entraîner la modification de la chaîne passée. L’utilisation de DT_MODIFYSTRING avec DT_END_ELLIPSIS ou DT_PATH_ELLIPSIS peut entraîner la modification de la chaîne, ce qui provoque une `CString` assertion dans la substitution. Les valeurs DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP et DT_NOPREFIX ne peuvent pas être utilisées avec la valeur DT_TABSTOP.

### <a name="return-value"></a>Valeur de retour

Hauteur du texte si la fonction réussit.

### <a name="remarks"></a>Notes

Il met en forme le texte en développant les onglets dans les espaces appropriés, en alignant le texte à gauche, à droite ou au centre du rectangle donné et en fractionnant le texte en lignes qui tiennent dans le rectangle donné. Le type de mise en forme est spécifié par *nFormat*.

Cette fonction membre utilise la police, la couleur de texte et la couleur d’arrière-plan sélectionnées du contexte de périphérique pour dessiner le texte. À moins que le format DT_NOCLIP ne `DrawText` soit utilisé, découpe le texte afin que le texte n’apparaisse pas à l’extérieur du rectangle donné. Toute la mise en forme est supposée avoir plusieurs lignes, sauf si le format DT_SINGLELINE est donné.

Si la police sélectionnée est trop grande pour le rectangle spécifié, la `DrawText` fonction membre ne tente pas de remplacer une police plus petite.

Si l’indicateur DT_CALCRECT est spécifié, le rectangle spécifié par *lpRect* sera mis à jour pour refléter la largeur et la hauteur nécessaires au dessin du texte.

Si l’indicateur d’alignement de texte TA_UPDATECP a été défini (voir [CDC :: SetTextAlign](#settextalign)) `DrawText` , affichera le texte à partir de la position actuelle, plutôt qu’à gauche du rectangle donné. `DrawText`le texte n’est pas renvoyé à la ligne lorsque l’indicateur TA_UPDATECP a été défini (autrement dit, l’indicateur DT_WORDBREAK n’a aucun effet).

La couleur de texte peut être définie par [CDC :: SetTextColor](#settextcolor).

##  <a name="drawtextex"></a>  CDC::DrawTextEx

Met en forme le texte dans le rectangle donné.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Paramètres

*lpszString*<br/>
Pointe vers la chaîne à dessiner. Si *nCount* a la valeur-1, la chaîne doit se terminer par null.

*nCount*<br/>
Spécifie le nombre de caractères dans la chaîne. Si *nCount* a la valeur-1, *lpszString* est supposé être un long pointeur vers une chaîne terminée par le caractère null `DrawText` et calcule le nombre de caractères automatiquement.

*lpRect*<br/>
Pointe vers une structure [Rect](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui contient le rectangle (en coordonnées logiques) dans lequel le texte doit être mis en forme.

*str*<br/>
Objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) qui contient les caractères spécifiés à dessiner.

*nFormat*<br/>
Spécifie la méthode de mise en forme du texte. Il peut s’agir de n’importe quelle combinaison des valeurs décrites pour le paramètre *uFormat* dans [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) dans le SDK Windows. (Combinez à l' **aide de l’opérateur or** au niveau du bit) :

> [!NOTE]
>  Certaines combinaisons d’indicateurs *uFormat* peuvent entraîner la modification de la chaîne passée. L’utilisation de DT_MODIFYSTRING avec DT_END_ELLIPSIS ou DT_PATH_ELLIPSIS peut entraîner la modification de la chaîne, ce qui provoque une `CString` assertion dans la substitution. Les valeurs DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP et DT_NOPREFIX ne peuvent pas être utilisées avec la valeur DT_TABSTOP.

*lpDTParams*<br/>
Pointeur vers une structure [DRAWTEXTPARAMS](/windows/win32/api/winuser/ns-winuser-drawtextparams) qui spécifie des options de mise en forme supplémentaires. Ce paramètre peut avoir la valeur NULL.

### <a name="remarks"></a>Notes

Il met en forme le texte en développant les onglets dans les espaces appropriés, en alignant le texte à gauche, à droite ou au centre du rectangle donné et en fractionnant le texte en lignes qui tiennent dans le rectangle donné. Le type de mise en forme est spécifié par *nFormat* et *lpDTParams*. Pour plus d’informations, voir [CDC ::D rawtext](#drawtext) et [DrawTextEx](/windows/win32/api/winuser/nf-winuser-drawtextexw) dans le SDK Windows.

La couleur de texte peut être définie par [CDC :: SetTextColor](#settextcolor).

##  <a name="ellipse"></a>  CDC::Ellipse

Dessine une ellipse.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle englobant de l’ellipse.

*y1*<br/>
Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle englobant de l’ellipse.

*x2*<br/>
Spécifie la coordonnée x logique du coin inférieur droit du rectangle englobant de l’ellipse.

*y2*<br/>
Spécifie la coordonnée y logique du coin inférieur droit du rectangle englobant de l’ellipse.

*lpRect*<br/>
Spécifie le rectangle englobant de l’ellipse. Vous pouvez également passer un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le centre de l’ellipse est le centre du rectangle englobant spécifié par *x1*, *Y1*, *x2*, et *Y2*, ou *lpRect*. L’ellipse est dessinée avec le stylet actuel et son intérieur est rempli avec le pinceau actuel.

La figure dessinée par cette fonction prend en compte jusqu’à, mais n’inclut pas les coordonnées droite et inférieure. Cela signifie que la hauteur de la figure est *Y2* - *Y1* et que la largeur de la figure est *x2* - *x1*.

Si la largeur ou la hauteur du rectangle englobant est égale à 0, aucune ellipse n’est dessinée.

##  <a name="enddoc"></a>  CDC::EndDoc

Met fin à un travail d’impression Démarré par un appel à la fonction membre [StartDoc](#startdoc) .

```
int EndDoc();
```

### <a name="return-value"></a>Valeur de retour

Supérieur ou égal à 0 si la fonction réussit, ou une valeur négative si une erreur s’est produite.

### <a name="remarks"></a>Notes

Cette fonction membre remplace l’échappement d’imprimante ENDDOC et doit être appelée immédiatement après la fin d’une tâche d’impression réussie.

Si une application rencontre une erreur d’impression ou une opération d’impression annulée, elle ne doit pas tenter de mettre fin à l’opération `EndDoc` à l’aide de ou de [AbortDoc](#abortdoc). GDI termine automatiquement l’opération avant de retourner la valeur d’erreur.

Cette fonction ne doit pas être utilisée dans les fichiers de fichier.

### <a name="example"></a>Exemple

  Consultez l’exemple pour [CDC :: StartDoc](#startdoc).

##  <a name="endpage"></a>  CDC::EndPage

Informe l’appareil que l’application a fini d’écrire sur une page.

```
int EndPage();
```

### <a name="return-value"></a>Valeur de retour

Supérieur ou égal à 0 si la fonction réussit, ou une valeur négative si une erreur s’est produite.

### <a name="remarks"></a>Notes

Cette fonction membre est généralement utilisée pour indiquer au pilote de périphérique d’avancer vers une nouvelle page.

Cette fonction membre remplace l’échappement d’imprimante NEWFRAME. Contrairement à NEWFRAME, cette fonction est toujours appelée après l’impression d’une page.

### <a name="example"></a>Exemple

  Consultez l’exemple pour [CDC :: StartDoc](#startdoc).

##  <a name="endpath"></a>  CDC::EndPath

Ferme un crochet de tracé et sélectionne le chemin d’accès défini par le crochet dans le contexte de périphérique.

```
BOOL EndPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="example"></a>Exemple

  Consultez l’exemple pour [CDC :: BeginPath](#beginpath).

##  <a name="enumobjects"></a>  CDC::EnumObjects

Énumère les stylets et les pinceaux disponibles dans un contexte de périphérique.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Paramètres

*nObjectType*<br/>
Spécifie le type d’objet. Il peut avoir les valeurs OBJ_BRUSH ou OBJ_PEN.

*lpfn*<br/>
Est l’adresse d’instance de procédure de la fonction de rappel fournie par l’application. Consultez la section « Notes » ci-dessous.

*lpData*<br/>
Pointe vers les données fournies par l’application. Les données sont passées à la fonction de rappel avec les informations sur l’objet.

### <a name="return-value"></a>Valeur de retour

Spécifie la dernière valeur retournée par la [fonction de rappel](callback-functions-used-by-mfc.md#enum_objects). Sa signification est définie par l’utilisateur.

### <a name="remarks"></a>Notes

Pour chaque objet d’un type donné, la fonction de rappel que vous transmettez est appelée avec les informations de cet objet. Le système appelle la fonction de rappel jusqu’à ce qu’il n’y ait plus d’objets ou que la fonction de rappel retourne 0.

Notez que les nouvelles fonctionnalités de Microsoft C++ Visual vous permettent d’utiliser une fonction ordinaire en tant que `EnumObjects`fonction transmise à. L’adresse passée à `EnumObjects` est un pointeur vers une fonction exportée avec **Export** et avec la Convention d’appel Pascal. Dans les applications en mode protégé, il n’est pas nécessaire de créer cette fonction avec la fonction MakeProcInstance de Windows ou de libérer la fonction après l’avoir utilisée avec la fonction Windows FreeProcInstance.

Vous n’avez pas non plus besoin d’exporter le nom de la fonction dans une instruction **exports** dans le fichier de définition de module de votre application. Vous pouvez utiliser à la place le modificateur de fonction d' **exportation** , comme dans

**exportation de rappel int** AFunction **(LPSTR**, **LPSTR);**

pour forcer le compilateur à émettre l’enregistrement d’exportation approprié pour l’exportation par nom sans alias. Cela fonctionne pour la plupart des besoins. Dans certains cas spéciaux, tels que l’exportation d’une fonction par ordinal ou l’utilisation d’un alias pour l’exportation, vous devez toujours utiliser une instruction **exports** dans un fichier de définition de module.

Pour compiler les programmes Microsoft Foundation, vous utiliserez normalement les options de compilateur/GA et/GEs. L’option de compilateur/GW n’est pas utilisée avec Microsoft Foundation classes. (Si vous utilisez la fonction `MakeProcInstance`Windows, vous devrez effectuer un cast explicite du pointeur de fonction retourné à partir de FARPROC vers le type requis dans cette API.) Les interfaces d’inscription de rappel sont désormais de type sécurisé (vous devez passer un pointeur de fonction qui pointe vers le type de fonction approprié pour le rappel spécifique).

Notez également que toutes les fonctions de rappel doivent intercepter les exceptions Microsoft Foundation avant de retourner à Windows, car les exceptions ne peuvent pas être levées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, consultez l’article [exceptions](../../mfc/exception-handling-in-mfc.md).

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

##  <a name="escape"></a>  CDC::Escape

Cette fonction membre est pratiquement obsolète pour la programmation Win32.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Paramètres

*nEscape*<br/>
Spécifie la fonction d’échappement à exécuter.

Pour obtenir la liste complète des fonctions d’échappement, consultez la section [Escape](/windows/win32/api/wingdi/nf-wingdi-escape) dans le SDK Windows.

*nCount*<br/>
Spécifie le nombre d’octets de données vers lequel pointe *lpszInData*.

*lpszInData*<br/>
Pointe vers la structure de données d’entrée requise pour cette séquence d’échappement.

*lpOutData*<br/>
Pointe vers la structure qui doit recevoir la sortie de cette séquence d’échappement. Le paramètre *lpOutData* a la valeur null si aucune donnée n’est retournée.

*nInputSize*<br/>
Spécifie le nombre d’octets de données vers lequel pointe le paramètre *lpszInputData* .

*lpszInputData*<br/>
Pointe vers la structure d’entrée requise pour l’échappement spécifié.

*nOutputSize*<br/>
Spécifie le nombre d’octets de données vers lequel pointe le paramètre *lpszOutputData* .

*lpszOutputData*<br/>
Pointe vers la structure qui reçoit la sortie de cette séquence d’échappement. Ce paramètre doit avoir la valeur NULL si aucune donnée n’est retournée.

### <a name="return-value"></a>Valeur de retour

Une valeur positive est retournée si la fonction réussit, à l’exception de l’échappement QUERYESCSUPPORT, qui vérifie uniquement l’implémentation. La valeur zéro est retournée si l’échappement n’est pas implémenté. Une valeur négative est retournée si une erreur s’est produite. Les valeurs d’erreur courantes sont les suivantes :

- Erreur générale SP_ERROR.

- SP_OUTOFDISK espace disque insuffisant est actuellement disponible pour la mise en file d’attente, et aucun espace supplémentaire n’est disponible.

- SP_OUTOFMEMORY mémoire disponible est insuffisante pour la mise en file d’attente.

- L’utilisateur SP_USERABORT a terminé le travail par le biais du gestionnaire d’impression.

### <a name="remarks"></a>Notes

De l’échappement d’origine de l’imprimante, seul QUERYESCSUPPORT est pris en charge pour les applications Win32. Toutes les autres séquences d’échappement d’imprimante sont obsolètes et sont prises en charge uniquement pour la compatibilité avec les applications 16 bits.

Pour la programmation Win32 `CDC` , fournit désormais six fonctions membres qui remplacent les séquences d’échappement correspondantes de l’imprimante :

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

De plus, [CDC :: GetDeviceCaps](#getdevicecaps) prend en charge les index Win32 qui remplacent d’autres séquences d’échappement d’imprimante. Pour plus d’informations, consultez [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) dans le SDK Windows.

Cette fonction membre permet aux applications d’accéder aux fonctionnalités d’un appareil particulier qui ne sont pas directement disponibles via GDI.

Utilisez la première version si votre application utilise des valeurs d’échappement prédéfinies. Utilisez la deuxième version si votre application définit des valeurs d’échappement privées. Pour plus d’informations sur la deuxième version, consultez [ExtEscape](/windows/win32/api/wingdi/nf-wingdi-extescape) dans le SDK Windows.

##  <a name="excludecliprect"></a>  CDC::ExcludeClipRect

Crée une nouvelle zone de découpage qui se compose de la région de découpage existante moins le rectangle spécifié.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle.

*y1*<br/>
Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle.

*x2*<br/>
Spécifie la coordonnée x logique du coin inférieur droit du rectangle.

*y2*<br/>
Spécifie la coordonnée y logique du coin inférieur droit du rectangle.

*lpRect*<br/>
Spécifie le rectangle. Peut également être un `CRect` objet.

### <a name="return-value"></a>Valeur de retour

Spécifie le type de la nouvelle zone de découpage. Il peut s’agir de l’une des valeurs suivantes :

- COMPLEXREGION la région a des bordures qui se chevauchent.

- ERREUR aucune région n’a été créée.

- NULLREGION la région est vide.

- SIMPLEREGION la région n’a pas de bordures se chevauchant.

### <a name="remarks"></a>Notes

La largeur du rectangle, spécifiée par la valeur absolue de *x2* - *x1*, ne doit pas dépasser 32 767 unités. Cette limite s’applique également à la hauteur du rectangle.

##  <a name="excludeupdatergn"></a>  CDC::ExcludeUpdateRgn

Empêche le dessin dans des zones non valides d’une fenêtre en excluant une région mise à jour dans la fenêtre `CDC` de la zone de découpage associée à l’objet.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Paramètres

*pWnd*<br/>
Pointe vers l’objet de fenêtre dont la fenêtre est mise à jour.

### <a name="return-value"></a>Valeur de retour

Type de la région exclue. Il peut s’agir de l’une des valeurs suivantes :

- COMPLEXREGION la région a des bordures qui se chevauchent.

- ERREUR aucune région n’a été créée.

- NULLREGION la région est vide.

- SIMPLEREGION la région n’a pas de bordures se chevauchant.

##  <a name="extfloodfill"></a>  CDC::ExtFloodFill

Remplit une zone de la surface d’affichage avec le pinceau actuel.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique du point où le remplissage commence.

*y*<br/>
Spécifie la coordonnée y logique du point où le remplissage commence.

*crColor*<br/>
Spécifie la couleur de la limite ou de la zone à remplir. L’interprétation de *crColor* dépend de la valeur de *nFillType*.

*nFillType*<br/>
Spécifie le type de remplissage de saturation à effectuer. Il doit s’agir de l’une des valeurs suivantes :

- FLOODFILLBORDER la zone de remplissage est délimitée par la couleur spécifiée par *crColor*. Ce style est identique au remplissage effectué par `FloodFill`.

- FLOODFILLSURFACE la zone de remplissage est définie par la couleur spécifiée par *crColor*. Le remplissage continue vers l’extérieur dans toutes les directions tant que la couleur est rencontrée. Ce style est utile pour remplir des zones avec des limites multicolores.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la fonction réussit ; Sinon, 0 si le remplissage n’a pas pu être effectué, si le point donné a la couleur limite spécifiée par *crColor* (si FLOODFILLBORDER a été demandé), si le point donné n’a pas la couleur spécifiée par *CRCOLOR* (si FLOODFILLSURFACE était demandé) ou si le point se trouve à l’extérieur de la zone de découpage.

### <a name="remarks"></a>Notes

Cette fonction membre offre plus de souplesse `FloodFill` que parce que vous pouvez spécifier un type de remplissage dans *nFillType*.

Si *nFillType* a la valeur FLOODFILLBORDER, la zone est supposée être complètement limitée par la couleur spécifiée par *crColor*. La fonction commence au point spécifié par *x* et *y* et remplit toutes les directions jusqu’à la limite de couleur.

Si *nFillType* a la valeur FLOODFILLSURFACE, la fonction commence au point spécifié par *x* et *y* et continue dans toutes les directions, en remplissant toutes les zones adjacentes contenant la couleur spécifiée par *crColor*.

Seuls les contextes de périphérique mémoire et les appareils qui prennent en charge la technologie `ExtFloodFill`raster-Display prennent en charge. Pour plus d’informations, consultez la fonction membre [GetDeviceCaps](#getdevicecaps) .

##  <a name="exttextout"></a>  CDC::ExtTextOut

Appelez cette fonction membre pour écrire une chaîne de caractères dans une zone rectangulaire à l’aide de la police actuellement sélectionnée.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique de la cellule de caractère pour le premier caractère de la chaîne spécifiée.

*y*<br/>
Spécifie la coordonnée y logique du haut de la cellule de caractère pour le premier caractère de la chaîne spécifiée.

*nOptions*<br/>
Spécifie le type de rectangle. Ce paramètre peut être un, les deux ou aucune des valeurs suivantes :

- ETO_CLIPPED spécifie que le texte est coupé en rectangle.

- ETO_OPAQUE spécifie que la couleur d’arrière-plan actuelle remplit le rectangle. (Vous pouvez définir et interroger la couleur d’arrière-plan actuelle avec les fonctions membres [SetBkColor](#setbkcolor) et [GetBkColor](#getbkcolor) .)

*lpRect*<br/>
Pointe vers une structure [Rect](/windows/win32/api/windef/ns-windef-rect) qui détermine les dimensions du rectangle. Ce paramètre peut avoir la valeur NULL. Vous pouvez également passer un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

*lpszString*<br/>
Pointe vers la chaîne de caractères spécifiée à dessiner. Vous pouvez également passer un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) pour ce paramètre.

*nCount*<br/>
Spécifie le nombre de caractères de la chaîne.

*lpDxWidths*<br/>
Pointe vers un tableau de valeurs qui indiquent la distance entre les origines des cellules de caractères adjacentes. Par exemple, les unités logiques *lpDxWidths*[ *i*] séparent les origines de la cellule de caractère *i* et de la cellule de caractère *i* + 1. Si *lpDxWidths* a la valeur `ExtTextOut` null, utilise l’espacement par défaut entre les caractères.

*str*<br/>
`CString` Objet qui contient les caractères spécifiés à dessiner.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

La zone rectangulaire peut être opaque (remplie avec la couleur d’arrière-plan actuelle) et il peut s’agir d’une zone de découpage.

Si *nOptions* a la valeur 0 et que *lpRect* a la valeur null, la fonction écrit du texte dans le contexte de périphérique sans utiliser de zone rectangulaire. Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction. Si une application doit mettre à jour la position actuelle lorsqu’elle `ExtTextOut`appelle, l’application peut appeler `CDC` la fonction membre [SetTextAlign](#settextalign) avec *nFlags* défini sur TA_UPDATECP. Lorsque cet indicateur est défini, Windows ignore *x* et *y* lors des appels suivants `ExtTextOut` à et utilise la position actuelle à la place. Quand une application utilise TA_UPDATECP pour mettre à jour la position `ExtTextOut` actuelle, définit la position actuelle à la fin de la ligne de texte précédente ou à la position spécifiée par le dernier élément du tableau pointé par *lpDxWidths*, selon le cas supérieur.

##  <a name="fillpath"></a>  CDC::FillPath

Ferme toutes les figures ouvertes dans le chemin d’accès actuel et remplit l’intérieur du tracé à l’aide du pinceau actuel et du mode de remplissage du polygone.

```
BOOL FillPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Une fois que son intérieur est rempli, le chemin d’accès est ignoré du contexte de périphérique.

##  <a name="fillrect"></a>  CDC::FillRect

Appelez cette fonction membre pour remplir un rectangle donné à l’aide du pinceau spécifié.

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Pointe vers une structure [Rect](/windows/win32/api/windef/ns-windef-rect) qui contient les coordonnées logiques du rectangle à remplir. Vous pouvez également passer un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) pour ce paramètre.

*pBrush*<br/>
Identifie le pinceau utilisé pour remplir le rectangle.

### <a name="remarks"></a>Notes

La fonction remplit le rectangle complet, y compris les bordures gauche et supérieure, mais ne remplit pas les bordures droite et inférieure.

Le pinceau doit être créé à l’aide des fonctions membres [CBrush](../../mfc/reference/cbrush-class.md) [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush) et [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush), ou récupéré par la fonction Windows `GetStockObject`.

Lors du remplissage du rectangle spécifié `FillRect` , n’inclut pas les côtés droit et inférieur du rectangle. GDI remplit un rectangle jusqu’à, mais n’inclut pas, la colonne de droite et la ligne inférieure, quel que soit le mode de mappage actuel. `FillRect`compare les `top`valeurs des membres `left`, `bottom`, et `right` du rectangle spécifié. Si `bottom` est inférieur ou égal à `top`, ou si `right` est inférieur ou égal à `left`, le rectangle n’est pas dessiné.

`FillRect`est semblable à [CDC :: FillSolidRect](#fillsolidrect); Toutefois, `FillRect` prend un pinceau et peut donc être utilisé pour remplir un rectangle avec une couleur unie, une couleur tramée, des pinceaux hachurés ou un motif. `FillSolidRect`utilise uniquement des couleurs unies (indiquées par un paramètre COLORREF). `FillRect`est généralement plus lent `FillSolidRect`que.

##  <a name="fillrgn"></a>  CDC::FillRgn

Remplit la région spécifiée par *pRgn* avec le pinceau spécifié par *pBrush*.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Paramètres

*pRgn*<br/>
Pointeur vers la zone à remplir. Les coordonnées de la région donnée sont spécifiées en unités logiques.

*pBrush*<br/>
Identifie le pinceau à utiliser pour remplir la région.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le pinceau doit être créé à l’aide `CBrush` des fonctions `CreateHatchBrush`membres `CreatePatternBrush`, `CreateSolidBrush`, ou être récupéré par `GetStockObject`.

### <a name="example"></a>Exemples

  Consultez l’exemple de [CRgn :: CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

##  <a name="fillsolidrect"></a>  CDC::FillSolidRect

Appelez cette fonction membre pour remplir le rectangle donné avec la couleur unie spécifiée.

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Spécifie le rectangle englobant (en unités logiques). Vous pouvez passer un pointeur vers une structure de données [Rect](/windows/win32/api/windef/ns-windef-rect) ou un `CRect` objet pour ce paramètre.

*CLR* Spécifie la couleur à utiliser pour remplir le rectangle.

*x*<br/>
Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle.

*y*<br/>
Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle de destination.

*cx*<br/>
Spécifie la largeur du rectangle.

*cy*<br/>
Spécifie la hauteur du rectangle.

### <a name="remarks"></a>Notes

`FillSolidRect`est très similaire à la capture de données [modifiées :: fillRect](#fillrect); Toutefois, `FillSolidRect` utilise uniquement des couleurs unies (indiquées par le paramètre COLORREF), `FillRect` tandis que prend un pinceau et peut donc être utilisé pour remplir un rectangle avec une couleur unie, une couleur tramée, des pinceaux hachurés ou un motif. `FillSolidRect`est généralement plus rapide `FillRect`que.

> [!NOTE]
>  Lorsque vous appelez `FillSolidRect`, la couleur d’arrière-plan, définie précédemment à l’aide de [SetBkColor](#setbkcolor), est définie sur la couleur indiquée par le *CLR*.

##  <a name="flattenpath"></a>  CDC::FlattenPath

Transforme toutes les courbes dans le tracé sélectionné dans le contexte de périphérique actuel et convertit chaque courbe en une séquence de lignes.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

##  <a name="floodfill"></a>  CDC::FloodFill

Remplit une zone de la surface d’affichage avec le pinceau actuel.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique du point où le remplissage commence.

*y*<br/>
Spécifie la coordonnée y logique du point où le remplissage commence.

*crColor*<br/>
Spécifie la couleur de la limite.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la fonction réussit ; Sinon, la valeur 0 est retournée si le remplissage n’a pas pu être effectué, si le point donné a la couleur limite spécifiée par *crColor*ou si le point se trouve à l’extérieur de la zone de découpage.

### <a name="remarks"></a>Notes

La zone est supposée être liée comme spécifié par *crColor*. La `FloodFill` fonction commence au point spécifié par *x* et *y* et continue dans toutes les directions jusqu’à la limite de couleur.

Seuls les contextes de périphérique mémoire et les appareils qui prennent en charge la technologie raster `FloodFill` -Display prennent en charge la fonction membre. Pour plus d’informations sur la fonctionnalité RC_BITBLT `GetDeviceCaps` , consultez la fonction membre.

La `ExtFloodFill` fonction offre des fonctionnalités similaires, mais une plus grande flexibilité.

##  <a name="framerect"></a>  CDC::FrameRect

Dessine une bordure autour du rectangle spécifié par *lpRect*.

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Pointe vers une structure [Rect](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui contient les coordonnées logiques des angles supérieur gauche et inférieur droit du rectangle. Vous pouvez également passer un `CRect` objet pour ce paramètre.

*pBrush*<br/>
Identifie le pinceau à utiliser pour le tramage du rectangle.

### <a name="remarks"></a>Notes

La fonction utilise le pinceau donné pour dessiner la bordure. La largeur et la hauteur de la bordure sont toujours 1 unité logique.

Si `bottom` la coordonnée du rectangle est inférieure ou égale à `top`, ou `right` si est inférieur ou égal à `left`, le rectangle n’est pas dessiné.

La bordure dessinée `FrameRect` par est à la même position qu’une bordure dessinée `Rectangle` par la fonction membre en utilisant les mêmes `Rectangle` coordonnées (si utilise un stylet de 1 unité logique). L’intérieur du rectangle n’est pas rempli par `FrameRect`.

##  <a name="framergn"></a>  CDC::FrameRgn

Dessine une bordure autour de la zone spécifiée par *pRgn* à l’aide du pinceau spécifié par *pBrush*.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Paramètres

*pRgn*<br/>
Pointe vers l' `CRgn` objet qui identifie la zone à placer dans une bordure. Les coordonnées de la région donnée sont spécifiées en unités logiques.

*pBrush*<br/>
Pointe vers l' `CBrush` objet qui identifie le pinceau à utiliser pour dessiner la bordure.

*nWidth*<br/>
Spécifie la largeur de la bordure dans les traits de pinceau verticaux en unités de périphérique.

*nHeight*<br/>
Spécifie la hauteur de la bordure dans les traits de pinceau horizontaux en unités de périphérique.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="example"></a>Exemple

  Consultez l’exemple de [CRgn :: CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

##  <a name="fromhandle"></a>  CDC::FromHandle

Retourne un pointeur vers un `CDC` objet en fonction d’un handle vers un contexte de périphérique (Device Context).

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Paramètres

*hDC*<br/>
Contient un handle vers un contexte de périphérique Windows.

### <a name="return-value"></a>Valeur de retour

Le pointeur peut être temporaire et ne doit pas être stocké au-delà de l’utilisation immédiate.

### <a name="remarks"></a>Notes

Si aucun objet `CDC` n'est attaché au handle, un objet `CDC` temporaire est créé et attaché.

### <a name="example"></a>Exemples

  Consultez l’exemple de [CPrintDialog :: GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

##  <a name="getarcdirection"></a>  CDC::GetArcDirection

Retourne la direction actuelle de l’arc pour le contexte de périphérique.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Valeur de retour

Spécifie la direction actuelle de l’arc, en cas de réussite. Les valeurs de retour valides sont les suivantes :

- AD_COUNTERCLOCKWISE arcs et rectangles dessinés dans le sens inverse des aiguilles d’une passe.

- AD_CLOCKWISE arcs et rectangles dessinés dans le sens des aiguilles d’une montre.

Si une erreur se produit, la valeur de retour est zéro.

### <a name="remarks"></a>Notes

Les fonctions arc et rectangle utilisent la direction de l’arc.

##  <a name="getaspectratiofilter"></a>  CDC::GetAspectRatioFilter

Récupère le paramètre pour le filtre de rapport d’aspect actuel.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Valeur de retour

`CSize` Objet représentant le rapport hauteur/largeur utilisé par le filtre de proportions actuel.

### <a name="remarks"></a>Notes

Les proportions sont le rapport formé par la largeur et la hauteur en pixels d’un appareil. Des informations sur les proportions d’un appareil sont utilisées dans la création, la sélection et l’affichage des polices. Windows fournit un filtre spécial, le filtre de rapport hauteur/largeur, pour sélectionner les polices conçues pour un rapport hauteur/largeur particulier à partir de toutes les polices disponibles. Le filtre utilise les proportions spécifiées `SetMapperFlags` par la fonction membre.

##  <a name="getbkcolor"></a>  CDC::GetBkColor

Retourne la couleur d’arrière-plan actuelle.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Valeur de retour

Valeur de couleur RVB.

### <a name="remarks"></a>Notes

Si le mode d’arrière-plan est OPAQUE, le système utilise la couleur d’arrière-plan pour remplir les espaces dans les lignes stylisées, les intervalles entre les lignes hachurées dans les pinceaux et l’arrière-plan dans les cellules de caractères. Le système utilise également la couleur d’arrière-plan lors de la conversion de bitmaps entre des contextes de périphérique de couleur et monochrome.

##  <a name="getbkmode"></a>  CDC::GetBkMode

Retourne le mode d’arrière-plan.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Valeur de retour

Mode d’arrière-plan actuel, qui peut être OPAQUE ou TRANSPARENT.

### <a name="remarks"></a>Notes

Le mode arrière-plan définit si le système supprime les couleurs d’arrière-plan existantes sur la surface de dessin avant de dessiner du texte, des pinceaux hachurés ou n’importe quel style de stylet qui n’est pas une ligne pleine.

##  <a name="getboundsrect"></a>  CDC::GetBoundsRect

Retourne le rectangle englobant cumulé actuel pour le contexte de périphérique spécifié.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Paramètres

*lpRectBounds*<br/>
Pointe vers une mémoire tampon qui recevra le rectangle englobant actuel. Le rectangle est retourné en coordonnées logiques.

*flags*<br/>
Spécifie si le rectangle englobant doit être effacé après avoir été retourné. Ce paramètre doit être égal à zéro ou défini sur la valeur suivante :

- DCB_RESET force l’effacement du rectangle englobant après qu’il a été retourné.

### <a name="return-value"></a>Valeur de retour

Spécifie l’état actuel du rectangle englobant si la fonction réussit. Il peut s’agir d’une combinaison des valeurs suivantes :

- L’accumulation du rectangle englobant DCB_ACCUMULATE se produit.

- Le rectangle englobant DCB_RESET est vide.

- Le rectangle englobant DCB_SET n’est pas vide.

- L’accumulation de limites DCB_ENABLE est activée.

- L’accumulation de limites DCB_DISABLE est désactivée.

##  <a name="getbrushorg"></a>  CDC::GetBrushOrg

Récupère l’origine (en unités de périphérique) du pinceau actuellement sélectionné pour le contexte de périphérique.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Valeur de retour

Origine actuelle du pinceau (en unités de périphérique) en tant qu’objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

### <a name="remarks"></a>Notes

L’origine initiale du pinceau est le (0, 0) de la zone cliente. La valeur de retour spécifie ce point dans les unités de périphérique par rapport à l’origine de la fenêtre du bureau.

##  <a name="getcharacterplacement"></a>  CDC::GetCharacterPlacement

Récupère différents types d’informations sur une chaîne de caractères.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Paramètres

*lpString*<br/>
Pointeur vers la chaîne de caractères à traiter.

*nCount*<br/>
Spécifie la longueur de la chaîne. Pour la version ANSI, il s’agit d’un nombre d’octets et, pour la fonction Unicode, il s’agit d’un nombre de mots. Pour plus d’informations, consultez [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw).

*nMaxExtent*<br/>
Spécifie l’étendue maximale (en unités logiques) à laquelle la chaîne est traitée. Les caractères qui, s’ils sont traités, dépasseraient cette étendue sont ignorés. Les calculs pour tous les tableaux de tri ou de glyphes requis s’appliquent uniquement aux caractères inclus. Ce paramètre est utilisé uniquement si la valeur GCP_MAXEXTENT est spécifiée dans le paramètre *dwFlags* . À mesure que la fonction traite la chaîne d’entrée, chaque caractère et son étendue sont ajoutés à la sortie, à l’étendue et aux autres tableaux uniquement si l’étendue totale n’a pas encore dépassé la valeur maximale. Une fois la limite atteinte, le traitement s’arrête.

*lpResults*<br/>
Pointeur vers une structure [GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw) qui reçoit les résultats de la fonction.

*dwFlags*<br/>
Spécifie comment traiter la chaîne dans les tableaux requis. Ce paramètre peut être une ou plusieurs des valeurs listées dans la section *dwFlags* de la rubrique [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw) .

*str*<br/>
Pointeur vers un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) à traiter.

### <a name="return-value"></a>Valeur de retour

Si la fonction est réussie, la valeur de retour est la largeur et la hauteur de la chaîne en unités logiques.

Si la fonction échoue, la valeur de retour est égale à zéro.

### <a name="remarks"></a>Notes

Cette fonction membre émule les fonctionnalités de la fonction [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw), comme décrit dans la SDK Windows.

##  <a name="getcharabcwidths"></a>  CDC::GetCharABCWidths

Récupère la largeur des caractères consécutifs dans une plage spécifiée à partir de la police TrueType actuelle.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Paramètres

*nFirstChar*<br/>
Spécifie le premier caractère de la plage de caractères de la police actuelle pour laquelle les largeurs de caractères sont retournées.

*nLastChar*<br/>
Spécifie le dernier caractère de la plage de caractères de la police actuelle pour laquelle les largeurs de caractères sont retournées.

*lpabc*<br/>
Pointe vers un tableau de structures [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) qui reçoivent les largeurs de caractères lorsque la fonction retourne. Ce tableau doit contenir au moins `ABC` autant de structures qu’il y a de caractères dans la plage spécifiée par les paramètres *nFirstChar* et *nLastChar* .

*lpABCF*<br/>
Pointe vers une mémoire tampon fournie par l’application avec un tableau de structures [abcfloat,](/windows/win32/api/wingdi/ns-wingdi-abcfloat) pour recevoir les largeurs de caractères quand la fonction retourne une valeur. Les largeurs retournées par cette fonction sont au format à virgule flottante IEEE.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Les largeurs sont retournées en unités logiques. Cette fonction ne fonctionne qu’avec les polices TrueType.

Le rastériseur TrueType fournit un espacement de caractères « ABC » après la sélection d’une taille de point spécifique. L’espacement « a » est la distance qui est ajoutée à la position actuelle avant de placer le glyphe. L’espacement « B » correspond à la largeur de la partie noire du glyphe. L’espacement « C » est ajouté à la position actuelle pour tenir compte de l’espace blanc à droite du glyphe. La largeur totale avancée est donnée par A + B + C.

Lorsque la `GetCharABCWidths` fonction membre récupère des largeurs « A » ou « C » négatives pour un caractère, ce caractère comprend des sous-blocages ou des surblocages.

Pour convertir les largeurs ABC en unités de conception de police, une application doit créer une police dont la hauteur (telle `lfHeight` que spécifiée dans le membre de la structure [LOGFONT](/windows/win32/api/wingdi/ns-wingdi-logfontw) ) est égale à la `ntmSizeEM` valeur stockée dans le membre du [NEWTEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw) arborescence. (La valeur du `ntmSizeEM` membre peut être récupérée en appelant la fonction Windows [EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) .)

Les largeurs ABC du caractère par défaut sont utilisées pour les caractères qui se trouvent en dehors de la plage de la police actuellement sélectionnée.

Pour récupérer les largeurs de caractères dans les polices non TrueType, les applications doivent utiliser la fonction Windows [GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) .

##  <a name="getcharabcwidthsi"></a>  CDC::GetCharABCWidthsI

Récupère les largeurs, en unités logiques, d’index de glyphe consécutifs dans une plage spécifiée à partir de la police TrueType actuelle.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Paramètres

*giFirst*<br/>
Spécifie le premier index de glyphe dans le groupe d’index de glyphes consécutifs de la police actuelle. Ce paramètre est utilisé uniquement si le paramètre *IGP* a la valeur null.

*cgi*<br/>
Spécifie le nombre d’index de glyphes.

*pgi*<br/>
Pointeur vers un tableau contenant des index de glyphes. Si la valeur est NULL, le paramètre *giFirst* est utilisé à la place. Le paramètre *CGI* spécifie le nombre d’index de glyphes dans ce tableau.

*lpabc*<br/>
Pointeur vers un tableau de structures [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) recevant la largeur des caractères. Ce tableau doit contenir au moins `ABC` autant de structures qu’il y a d’index de glyphes spécifiés par le paramètre *CGI* .

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction membre émule les fonctionnalités de la fonction [GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi), comme décrit dans la SDK Windows.

##  <a name="getcharwidth"></a>  CDC::GetCharWidth

Récupère les largeurs des caractères individuels dans un groupe consécutif de caractères à partir de la police actuelle, `m_hAttribDC`à l’aide du contexte de périphérique d’entrée.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Paramètres

*nFirstChar*<br/>
Spécifie le premier caractère d’un groupe de caractères consécutifs dans la police actuelle.

*nLastChar*<br/>
Spécifie le dernier caractère d’un groupe de caractères consécutifs dans la police actuelle.

*lpBuffer*<br/>
Pointe vers une mémoire tampon qui reçoit les valeurs de largeur pour un groupe consécutif de caractères dans la police actuelle.

*lpFloatBuffer*<br/>
Pointe vers une mémoire tampon pour recevoir la largeur des caractères. Les largeurs retournées sont au format à virgule flottante IEEE 32 bits. (Les largeurs sont mesurées le long de la ligne de base des caractères.)

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Par exemple, si *nFirstChar* identifie la lettre « a » et *nLastChar* identifie la lettre « z », la fonction récupère les largeurs de tous les caractères minuscules.

La fonction stocke les valeurs dans la mémoire tampon vers laquelle pointe *lpBuffer*. Cette mémoire tampon doit être suffisamment grande pour contenir toutes les largeurs. Autrement dit, il doit y avoir au moins 26 entrées dans l’exemple donné.

Si un caractère du groupe de caractères consécutif n’existe pas dans une police particulière, la valeur de largeur du caractère par défaut lui est assignée.

##  <a name="getcharwidthi"></a>  CDC::GetCharWidthI

Récupère les largeurs, en coordonnées logiques, d’index de glyphe consécutifs dans une plage spécifiée à partir de la police actuelle.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Paramètres

*giFirst*<br/>
Spécifie le premier index de glyphe dans le groupe d’index de glyphes consécutifs de la police actuelle. Ce paramètre est utilisé uniquement si le paramètre *IGP* a la valeur null.

*cgi*<br/>
Spécifie le nombre d’index de glyphes.

*pgi*<br/>
Pointeur vers un tableau contenant des index de glyphes. Si la valeur est NULL, le paramètre *giFirst* est utilisé à la place. Le paramètre *CGI* spécifie le nombre d’index de glyphes dans ce tableau.

*lpBuffer*<br/>
Pointeur vers une mémoire tampon qui reçoit les largeurs.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction membre émule les fonctionnalités de la fonction [GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi), comme décrit dans la SDK Windows.

##  <a name="getclipbox"></a>  CDC::GetClipBox

Récupère les dimensions du rectangle englobant le plus étroit autour de la limite de découpage actuelle.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Pointe vers la structure [Rect](/windows/win32/api/windef/ns-windef-rect) ou l’objet [CRect](../../atl-mfc-shared/reference/crect-class.md) qui doit recevoir les dimensions du rectangle.

### <a name="return-value"></a>Valeur de retour

Type de la zone de découpage. Il peut s’agir de l’une des valeurs suivantes :

- La région de découpage COMPLEXREGION a des bordures qui se chevauchent.

- Le contexte de périphérique d’erreur n’est pas valide.

- La région de découpage NULLREGION est vide.

- La région de découpage SIMPLEREGION n’a pas de bordures se chevauchant.

### <a name="remarks"></a>Notes

Les dimensions sont copiées dans la mémoire tampon vers laquelle pointe *lpRect*.

##  <a name="getcoloradjustment"></a>  CDC::GetColorAdjustment

Récupère les valeurs de réglage des couleurs pour le contexte de périphérique.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Paramètres

*lpColorAdjust*<br/>
Pointe vers une structure de données [coloradjustment,](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) pour recevoir les valeurs de réglage des couleurs.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

##  <a name="getcurrentbitmap"></a>  CDC::GetCurrentBitmap

Retourne un pointeur vers l’objet actuellement `CBitmap` sélectionné.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers un `CBitmap` objet, en cas de réussite ; sinon, null.

### <a name="remarks"></a>Notes

Cette fonction membre peut retourner des objets temporaires.

##  <a name="getcurrentbrush"></a>  CDC::GetCurrentBrush

Retourne un pointeur vers l’objet actuellement `CBrush` sélectionné.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers un `CBrush` objet, en cas de réussite ; sinon, null.

### <a name="remarks"></a>Notes

Cette fonction membre peut retourner des objets temporaires.

##  <a name="getcurrentfont"></a>  CDC::GetCurrentFont

Retourne un pointeur vers l’objet actuellement `CFont` sélectionné.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers un `CFont` objet, en cas de réussite ; sinon, null.

### <a name="remarks"></a>Notes

Cette fonction membre peut retourner des objets temporaires.

##  <a name="getcurrentpalette"></a>  CDC::GetCurrentPalette

Retourne un pointeur vers l’objet actuellement `CPalette` sélectionné.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers un `CPalette` objet, en cas de réussite ; sinon, null.

### <a name="remarks"></a>Notes

Cette fonction membre peut retourner des objets temporaires.

##  <a name="getcurrentpen"></a>  CDC::GetCurrentPen

Retourne un pointeur vers l’objet actuellement `CPen` sélectionné.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers un `CPen` objet, en cas de réussite ; sinon, null.

### <a name="remarks"></a>Notes

Cette fonction membre peut retourner des objets temporaires.

##  <a name="getcurrentposition"></a>  CDC::GetCurrentPosition

Récupère la position actuelle (en coordonnées logiques).

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Valeur de retour

Position actuelle en tant qu' `CPoint` objet.

### <a name="remarks"></a>Notes

La position actuelle peut être définie avec la `MoveTo` fonction membre.

##  <a name="getdcbrushcolor"></a>  CDC::GetDCBrushColor

Récupère la couleur actuelle du pinceau.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Valeur de retour

Si la fonction est réussie, la valeur de retour est la valeur [COLORREF](/windows/win32/gdi/colorref) pour la couleur actuelle du pinceau.

Si la fonction échoue, la valeur de retour est CLR_INVALID.

### <a name="remarks"></a>Notes

Cette fonction membre émule les fonctionnalités de la fonction [GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor), comme décrit dans la SDK Windows.

##  <a name="getdcpencolor"></a>  CDC::GetDCPenColor

Récupère la couleur actuelle du stylet.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Valeur de retour

Si la fonction est réussie, la valeur de retour est la valeur [COLORREF](/windows/win32/gdi/colorref) pour la couleur actuelle du stylet.

Si la fonction échoue, la valeur de retour est CLR_INVALID.

### <a name="remarks"></a>Notes

Cette fonction membre utilise la fonction Win32 [GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor), comme décrit dans la SDK Windows.

##  <a name="getdevicecaps"></a>  CDC::GetDeviceCaps

Récupère un large éventail d’informations spécifiques à l’appareil sur le périphérique d’affichage.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
Spécifie le type d’informations à retourner. Pour obtenir la liste des valeurs, consultez [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) dans le SDK Windows.

### <a name="return-value"></a>Valeur de retour

Valeur de la fonctionnalité demandée si la fonction réussit.

### <a name="example"></a>Exemple

  Consultez l’exemple de [CPrintDialog :: GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

##  <a name="getfontdata"></a>  CDC::GetFontData

Récupère des informations de police métrique à partir d’un fichier de police Scalable.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Paramètres

*dwTable*<br/>
Spécifie le nom de la table de métriques à retourner. Ce paramètre peut être l’une des tables de métriques décrites dans la spécification des fichiers de polices TrueType publiée par Microsoft Corporation. Si ce paramètre a la valeur 0, les informations sont récupérées à partir du début du fichier de police.

*dwOffset*<br/>
Spécifie le décalage à partir du début de la table à partir duquel commencer la récupération des informations. Si ce paramètre a la valeur 0, les informations sont récupérées à partir du début de la table spécifiée par le paramètre *dwTable* . Si cette valeur est supérieure ou égale à la taille de la table, `GetFontData` retourne 0.

*lpData*<br/>
Pointe vers une mémoire tampon qui reçoit les informations de police. Si cette valeur est NULL, la fonction retourne la taille de la mémoire tampon requise pour les données de police spécifiées dans le paramètre *dwTable* .

*cbData*<br/>
Spécifie la longueur, en octets, des informations à récupérer. Si ce paramètre a la valeur `GetFontData` 0, retourne la taille des données spécifiées dans le paramètre *dwTable* .

### <a name="return-value"></a>Valeur de retour

Spécifie le nombre d’octets retournés dans la mémoire tampon vers laquelle pointe *lpData* si la fonction réussit ; sinon-1.

### <a name="remarks"></a>Notes

Les informations à récupérer sont identifiées en spécifiant un décalage dans le fichier de police et la longueur des informations à retourner.

Une application peut parfois utiliser la `GetFontData` fonction membre pour enregistrer une police TrueType avec un document. Pour ce faire, l’application détermine si la police peut être incorporée, puis récupère la totalité du fichier de police, en spécifiant 0 pour les paramètres *dwTable*, *dwOffset*et *cbData* .

Les applications peuvent déterminer si une police peut être incorporée en `otmfsType` vérifiant le membre de la structure [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) . Si le bit 1 `otmfsType` de est défini, l’incorporation n’est pas autorisée pour la police. Si le bit 1 est clair, la police peut être incorporée. Si le bit 2 est défini, l’incorporation est en lecture seule.

Si une application tente d’utiliser cette fonction pour récupérer des informations pour une police non TrueType, la `GetFontData` fonction membre retourne-1.

##  <a name="getfontlanguageinfo"></a>  CDC::GetFontLanguageInfo

Retourne des informations sur la police actuellement sélectionnée pour le contexte d’affichage spécifié.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Valeur de retour

La valeur de retour identifie les caractéristiques de la police actuellement sélectionnée. Pour obtenir la liste complète des valeurs possibles, consultez [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Notes

Cette fonction membre émule les fonctionnalités de la fonction [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo), comme décrit dans la SDK Windows.

##  <a name="getglyphoutline"></a>  CDC::GetGlyphOutline

Récupère la courbe ou l’image bitmap du plan d’un caractère de contour dans la police actuelle.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Paramètres

*nChar*<br/>
Spécifie le caractère dont les informations doivent être retournées.

*nFormat*<br/>
Spécifie le format dans lequel la fonction doit retourner des informations. Il peut s’agir de l’une des valeurs suivantes, ou 0 :

|Valeur|Signification|
|-----------|-------------|
|GGO_BITMAP|Retourne la bitmap de glyphe. Quand la fonction retourne, la mémoire tampon vers laquelle pointe *lpBuffer* contient une bitmap de 1 bit par pixel dont les lignes commencent par des limites de mot double.|
|GGO_NATIVE|Retourne les points de données de la courbe dans le format natif de rastériseur, à l’aide d’unités de périphérique. Lorsque cette valeur est spécifiée, toute transformation spécifiée dans *lpmat2* est ignorée.|

Lorsque la valeur de *nFormat* est 0, la fonction remplit une structure [GLYPHMETRICS](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics) , mais ne retourne pas de données de contour de glyphes.

*lpgm*<br/>
Pointe vers une structure GLYPHMETRICS qui décrit l’emplacement du glyphe dans la cellule de caractère.

*cbBuffer*<br/>
Spécifie la taille de la mémoire tampon dans laquelle la fonction copie les informations relatives au caractère de contour. Si cette valeur est égale à 0 et que le paramètre *nFormat* est GGO_BITMAP ou GGO_NATIVE, la fonction retourne la taille requise de la mémoire tampon.

*lpBuffer*<br/>
Pointe vers une mémoire tampon dans laquelle la fonction copie des informations sur le caractère de contour. Si *nFormat* spécifie la valeur GGO_NATIVE, les informations sont copiées sous la forme de structures TTPOLYGONHEADER et TTPOLYCURVE. Si cette valeur est NULL et que *nFormat* est la valeur GGO_BITMAP ou GGO_NATIVE, la fonction retourne la taille requise de la mémoire tampon.

*lpmat2*<br/>
Pointe vers une structure [MAT2](/windows/win32/api/wingdi/ns-wingdi-mat2) qui contient une matrice de transformation pour le caractère. Ce paramètre ne peut pas être NULL, même si la valeur GGO_NATIVE est spécifiée pour *nFormat*.

### <a name="return-value"></a>Valeur de retour

Taille, en octets, de la mémoire tampon requise pour les informations récupérées si *cbBuffer* a la valeur 0 ou si la valeur de *lpBuffer* est null. Dans le cas contraire, il s’agit d’une valeur positive si la fonction réussit, ou-1 en cas d’erreur.

### <a name="remarks"></a>Notes

Une application peut faire pivoter les caractères récupérés au format bitmap en spécifiant une matrice de transformation 2 par 2 dans la structure vers laquelle pointe *lpmat2*.

Une structure de glyphe est retournée sous la forme d’une série de contournements. Chaque profil est défini par une structure [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) suivie `TTPOLYCURVE` de autant de structures que nécessaire pour le décrire. Tous les points sont retournés en tant que structures [POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx) et représentent des positions absolues, et non des déplacements relatifs. Le point de départ donné par `pfxStart` le membre de la structure [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) est le point auquel commence le contour d’un contour. Les structures [TTPOLYCURVE](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve) qui suivent peuvent être des enregistrements de type polyligne ou des enregistrements de spline. Les enregistrements Polyline sont une série de points. les lignes dessinées entre les points décrivent le contour du caractère. Les enregistrements splines représentent les courbes quadratiques utilisées par TrueType (c’est-à-dire, quadratiques b-splines).

##  <a name="getgraphicsmode"></a>  CDC::GetGraphicsMode

Récupère le mode graphique actuel pour le contexte de périphérique spécifié.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Valeur de retour

Retourne le mode graphique en cours en cas de réussite. Pour obtenir la liste des valeurs que cette méthode peut retourner, consultez [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

Retourne 0 en cas d’échec.

Pour afficher les informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Notes

Cette méthode encapsule la fonction Windows GDI [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

##  <a name="gethalftonebrush"></a>  CDC::GetHalftoneBrush

Appelez cette fonction membre pour récupérer un pinceau en demi-teinte.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers un `CBrush` objet en cas de réussite ; sinon, null.

### <a name="remarks"></a>Notes

Un pinceau en demi-teinte affiche des pixels qui sont également des couleurs de premier plan et d’arrière-plan pour créer un modèle tramé. Voici un exemple de modèle tramé créé par un pinceau en demi-teinte.

![Détail d’un trait de plume](../../mfc/reference/media/vc318s1.gif "Détail d’un trait de plume")

##  <a name="getkerningpairs"></a>  CDC::GetKerningPairs

Récupère les paires de crénage de caractères pour la police actuellement sélectionnée dans le contexte de périphérique spécifié.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Paramètres

*nPairs*<br/>
Spécifie le nombre de structures [KERNINGPAIR](/windows/win32/api/wingdi/ns-wingdi-kerningpair) pointées par *lpkrnpair*. La fonction ne copiera pas plus de paires de crénage que ce qui est spécifié par *nPairs*.

*lpkrnpair*<br/>
Pointe vers un tableau de `KERNINGPAIR` structures qui reçoivent les paires de crénage quand la fonction retourne. Ce tableau doit contenir au moins autant de structures que ce qui est spécifié par *nPairs*. Si ce paramètre a la valeur NULL, la fonction retourne le nombre total de paires de crénage pour la police.

### <a name="return-value"></a>Valeur de retour

Spécifie le nombre de paires de crénage récupérées ou le nombre total de paires de crénage dans la police, si la fonction réussit. La valeur zéro est retournée si la fonction échoue ou s’il n’existe aucune paire de crénage pour la police.

##  <a name="getlayout"></a>  CDC::GetLayout

Appelez cette fonction membre pour déterminer la disposition du texte et des graphiques pour un contexte de périphérique, tel qu’une imprimante ou un métafichier.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Valeur de retour

En cas de réussite, les indicateurs de disposition du contexte de périphérique actuel. Sinon, GDI_ERROR. Pour obtenir des informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror). Pour obtenir la liste des indicateurs de disposition, consultez [CDC :: setLayout](#setlayout).

### <a name="remarks"></a>Notes

La disposition par défaut est de gauche à droite.

##  <a name="getmapmode"></a>  CDC::GetMapMode

Récupère le mode de mappage actuel.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Valeur de retour

Mode de mappage.

### <a name="remarks"></a>Notes

Pour obtenir une description des modes de mappage, consultez `SetMapMode` la fonction membre.

> [!NOTE]
>  Si vous appelez [setLayout](#setlayout) pour changer la disposition du contrôleur de l’affichage de droite à `SetLayout` gauche, change automatiquement le mode de mappage en MM_ISOTROPIC. Par conséquent, tout appel ultérieur `GetMapMode` à retourne MM_ISOTROPIC.

##  <a name="getmiterlimit"></a>  CDC::GetMiterLimit

Retourne la limite d’angle pour le contexte de périphérique.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

La limite de pointe est utilisée lors du dessin de lignes géométriques qui ont des jointures mitres.

##  <a name="getnearestcolor"></a>  CDC::GetNearestColor

Retourne la couleur unie qui correspond le mieux à une couleur logique spécifiée.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Paramètres

*crColor*<br/>
Spécifie la couleur à mettre en correspondance.

### <a name="return-value"></a>Valeur de retour

Valeur de couleur RVB (rouge, vert, bleu) qui définit la couleur unie la plus proche de la valeur *crColor* que l’appareil peut représenter.

### <a name="remarks"></a>Notes

L’appareil donné doit être en mesure de représenter cette couleur.

##  <a name="getoutlinetextmetrics"></a>  CDC::GetOutlineTextMetrics

Récupère des informations sur les métriques pour les polices TrueType.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Paramètres

*lpotm*<br/>
Pointe vers un tableau de structures [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) . Si ce paramètre a la valeur NULL, la fonction retourne la taille de la mémoire tampon requise pour les données de métriques récupérées.

*cbData*<br/>
Spécifie la taille, en octets, de la mémoire tampon dans laquelle les informations sont retournées.

*lpotm*<br/>
Pointe vers une `OUTLINETEXTMETRIC` structure. Si ce paramètre a la valeur NULL, la fonction retourne la taille de la mémoire tampon requise pour les informations de métrique récupérées.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

La structure [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) contient la plupart des informations de métriques de police fournies avec le format TrueType, y compris une structure [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) . Les quatre derniers membres de la `OUTLINETEXTMETRIC` structure sont des pointeurs vers des chaînes. Les applications doivent allouer de l’espace pour ces chaînes en plus de l’espace requis pour les autres membres. Étant donné qu’il n’existe aucune limite imposée par le système à la taille des chaînes, la méthode la plus simple pour allouer de la mémoire consiste à récupérer la taille requise en spécifiant null pour *lpotm* dans le premier appel à la `GetOutlineTextMetrics` fonction.

##  <a name="getoutputcharwidth"></a>  CDC::GetOutputCharWidth

Utilise le contexte de périphérique de `m_hDC`sortie, et récupère la largeur des caractères individuels dans un groupe consécutif de caractères à partir de la police actuelle.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Paramètres

*nFirstChar*<br/>
Spécifie le premier caractère d’un groupe de caractères consécutifs dans la police actuelle.

*nLastChar*<br/>
Spécifie le dernier caractère d’un groupe de caractères consécutifs dans la police actuelle.

*lpBuffer*<br/>
Pointe vers une mémoire tampon qui reçoit les valeurs de largeur pour un groupe consécutif de caractères dans la police actuelle.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Par exemple, si *nFirstChar* identifie la lettre « a » et *nLastChar* identifie la lettre « z », la fonction récupère les largeurs de tous les caractères minuscules.

La fonction stocke les valeurs dans la mémoire tampon vers laquelle pointe *lpBuffer*. Cette mémoire tampon doit être suffisamment grande pour contenir toutes les largeurs ; autrement dit, il doit y avoir au moins 26 entrées dans l’exemple donné.

Si un caractère du groupe de caractères consécutif n’existe pas dans une police particulière, la valeur de largeur du caractère par défaut lui est assignée.

##  <a name="getoutputtabbedtextextent"></a>  CDC::GetOutputTabbedTextExtent

Appelez cette fonction membre pour calculer la largeur et la hauteur d’une chaîne de caractères à l’aide de [m_hDC](#m_hdc), le contexte de périphérique de sortie.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Paramètres

*lpszString*<br/>
Pointe vers une chaîne de caractères à mesurer. Vous pouvez également passer un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) pour ce paramètre.

*nCount*<br/>
Spécifie la [longueur de la chaîne](/windows/win32/gdi/specifying-length-of-text-output-string) vers laquelle pointe *lpszString*.

*nTabPositions*<br/>
Spécifie le nombre de positions de taquet de tabulation dans le tableau pointé par *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Pointe vers un tableau d’entiers contenant la position des taquets de tabulation dans les unités logiques. Les taquets de tabulation doivent être triés par ordre de tri ; la plus petite valeur x doit être le premier élément du tableau. Les onglets arrière ne sont pas autorisés.

*str*<br/>
`CString` Objet qui contient les caractères spécifiés à mesurer.

### <a name="return-value"></a>Valeur de retour

Dimensions de la chaîne (en unités logiques) dans un objet [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Notes

Si la chaîne contient un ou plusieurs caractères de tabulation, la largeur de la chaîne est basée sur les taquets de tabulation spécifiés par *lpnTabStopPositions*. La fonction utilise la police actuellement sélectionnée pour calculer les dimensions de la chaîne.

La zone de découpage actuelle ne décale pas la largeur et `GetOutputTabbedTextExtent` la hauteur retournées par la fonction.

Étant donné que certains appareils ne placent pas de caractères dans les tableaux de cellules ordinaires (c’est-à-dire qu’ils crénageent les caractères), la somme des étendues des caractères dans une chaîne peut ne pas être égale à l’étendue de la chaîne.

Si *nTabPositions* a la valeur 0 et que *lpnTabStopPositions* a la valeur null, les tabulations sont développées à huit largeurs de caractères moyennes. Si *nTabPositions* a la valeur 1, les taquets de tabulation sont séparés par la distance spécifiée par la première valeur dans le tableau auquel *lpnTabStopPositions* pointe. Si *lpnTabStopPositions* pointe vers plus d’une valeur unique, un taquet de tabulation est défini pour chaque valeur du tableau, jusqu’au nombre spécifié par *nTabPositions*.

##  <a name="getoutputtextextent"></a>  CDC::GetOutputTextExtent

Appelez cette fonction membre pour utiliser le contexte de périphérique de sortie, [m_hDC](#m_hdc), et calculez la largeur et la hauteur d’une ligne de texte à l’aide de la police actuelle.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Paramètres

*lpszString*<br/>
Pointe vers une chaîne de caractères. Vous pouvez également passer un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) pour ce paramètre.

*nCount*<br/>
Spécifie la [longueur de la chaîne](/windows/win32/gdi/specifying-length-of-text-output-string) vers laquelle pointe *lpszString*.

*str*<br/>
`CString` Objet qui contient les caractères spécifiés à mesurer.

### <a name="return-value"></a>Valeur de retour

Dimensions de la chaîne (en unités logiques) retournées dans un objet [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Notes

La zone de découpage actuelle n’affecte pas la largeur et `GetOutputTextExtent`la hauteur retournées par.

Étant donné que certains appareils ne placent pas de caractères dans les tableaux de cellules ordinaires (c’est-à-dire qu’ils effectuent un crénage), la somme des étendues des caractères dans une chaîne peut ne pas être égale à l’étendue de la chaîne.

##  <a name="getoutputtextmetrics"></a>  CDC::GetOutputTextMetrics

Récupère les métriques pour la police en cours à `m_hDC`l’aide de, le contexte de périphérique de sortie.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Paramètres

*lpMetrics*<br/>
Pointe vers la structure [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) qui reçoit les métriques.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

##  <a name="getpath"></a>  CDC::GetPath

Récupère les coordonnées qui définissent les points de terminaison de lignes et les points de contrôle des courbes trouvées dans le chemin d’accès sélectionné dans le contexte de périphérique.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Paramètres

*lpPoints*<br/>
Pointe vers un tableau de structures de données [POINT](/windows/win32/api/windef/ns-windef-point) ou d’objets `CPoint` où les points de terminaison de ligne et les points de contrôle de courbe sont placés.

*lpTypes*<br/>
Pointe vers un tableau d’octets où les types vertex sont placés. Les valeurs sont l’une des suivantes :

- PT_MOVETO spécifie que le point correspondant dans *lpPoints* démarre une figure disjointe.

- PT_LINETO spécifie que le point précédent et le point correspondant dans *lpPoints* sont les points de terminaison d’une ligne.

- PT_BEZIERTO spécifie que le point correspondant dans *lpPoints* est un point de contrôle ou un point de terminaison pour une courbe Bzier.

Les types PT_BEZIERTO se produisent toujours dans des ensembles de trois. Le point dans le tracé qui le précède immédiatement définit le point de départ de la courbe Bzier. Les deux premiers points PT_BEZIERTO sont les points de contrôle et le troisième point PT_BEZIERTO est le point de terminaison (s’il est codé en dur).

   Un type PT_LINETO ou PT_BEZIERTO peut être combiné avec l’indicateur suivant (à l’aide de l’opérateur au niveau du bit **ou**) pour indiquer que le point correspondant est le dernier point d’une figure et que la figure doit être fermée :

- PT_CLOSEFIGURE spécifie que la figure est fermée automatiquement après que la ligne ou la courbe correspondante est dessinée. La figure est fermée en dessinant une ligne à partir du point de terminaison de ligne ou de courbe jusqu’au point correspondant au dernier PT_MOVETO.

*nCount*<br/>
Spécifie le nombre total de structures de données de [point](/windows/win32/api/windef/ns-windef-point) qui peuvent être placées dans le tableau *lpPoints* . Cette valeur doit être identique au nombre d’octets qui peuvent être placés dans le tableau *lpTypes* .

### <a name="return-value"></a>Valeur de retour

Si le paramètre *nCount* est différent de zéro, le nombre de points est énuméré. Si *nCount* a la valeur 0, le nombre total de points dans le chemin `GetPath` d’accès (et n’écrit rien dans les mémoires tampons). Si *nCount* est différent de zéro et est inférieur au nombre de points dans le chemin d’accès, la valeur de retour est-1.

### <a name="remarks"></a>Notes

Le contexte de périphérique doit contenir un chemin d’accès fermé. Les points du chemin d’accès sont retournés en coordonnées logiques. Les points étant stockés dans le chemin d’accès en coordonnées `GetPath` de périphérique, change les points des coordonnées de périphérique en coordonnées logiques à l’aide de l’inverse de la transformation actuelle. La `FlattenPath` fonction membre peut être appelée avant `GetPath`, pour convertir toutes les courbes du tracé en segments de ligne.

### <a name="example"></a>Exemples

  Consultez l’exemple pour [CDC :: BeginPath](#beginpath).

##  <a name="getpixel"></a>  CDC::GetPixel

Récupère la valeur de couleur RVB du pixel au point spécifié par *x* et *y*.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique du point à examiner.

*y*<br/>
Spécifie la coordonnée y logique du point à examiner.

*point*<br/>
Spécifie les coordonnées x et y logiques du point à examiner.

### <a name="return-value"></a>Valeur de retour

Pour les deux versions de la fonction, une valeur de couleur RVB pour la couleur du point donné. Elle est-1 si les coordonnées ne spécifient pas de point dans la zone de découpage.

### <a name="remarks"></a>Notes

Le point doit se trouver dans la zone de découpage. Si le point n’est pas dans la zone de découpage, la fonction n’a aucun effet et retourne-1.

La fonction `GetPixel` n'est pas prise en charge par tous les périphériques. Pour plus d’informations, consultez la fonctionnalité raster RC_BITBLT sous la fonction membre [GetDeviceCaps](#getdevicecaps) .

La `GetPixel` fonction membre a deux formes. La première prend deux valeurs de coordonnée ; la seconde prend soit une structure [point](/windows/win32/api/windef/ns-windef-point) , soit un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

##  <a name="getpolyfillmode"></a>  CDC::GetPolyFillMode

Récupère le mode de remplissage de polygone actuel.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Valeur de retour

Le mode actuel rempli par le polygone, le remplacement ou l’enroulement, si la fonction réussit.

### <a name="remarks"></a>Notes

Pour obtenir `SetPolyFillMode` une description des modes de remplissage des polygones, consultez la fonction membre.

##  <a name="getrop2"></a>  CDC::GetROP2

Récupère le mode de dessin actuel.

```
int GetROP2() const;
```

### <a name="return-value"></a>Valeur de retour

Mode dessin. Pour obtenir la liste des valeurs du mode dessin, consultez `SetROP2` la fonction membre.

### <a name="remarks"></a>Notes

Le mode dessin spécifie la manière dont les couleurs du stylet et de l’intérieur des objets remplis sont combinées avec la couleur déjà présente dans la surface d’affichage.

##  <a name="getsafehdc"></a>  CDC::GetSafeHdc

Appelez cette fonction membre pour accéder à [m_hDC](#m_hdc), le contexte de périphérique de sortie.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Valeur de retour

Handle de contexte de périphérique.

### <a name="remarks"></a>Notes

Cette fonction membre fonctionne également avec des pointeurs null.

##  <a name="getstretchbltmode"></a>  CDC::GetStretchBltMode

Récupère le mode d’étirement de l’image en cours.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Valeur de retour

La valeur de retour spécifie le mode d’étirement de bitmap actuel (STRETCH_ANDSCANS, STRETCH_DELETESCANS ou STRETCH_ORSCANS) si la fonction réussit.

### <a name="remarks"></a>Notes

Le mode d’étirement bitmap définit la manière dont les informations sont supprimées des bitmaps qui sont étirées ou compressées par la `StretchBlt` fonction membre.

Les modes STRETCH_ANDSCANS et STRETCH_ORSCANS sont généralement utilisés pour conserver les pixels de premier plan dans les images bitmap monochrome. Le mode STRETCH_DELETESCANS est généralement utilisé pour conserver la couleur dans les bitmaps de couleur.

##  <a name="gettabbedtextextent"></a>  CDC::GetTabbedTextExtent

Appelez cette fonction membre pour calculer la largeur et la hauteur d’une chaîne de caractères à l’aide de [m_hAttribDC](#m_hattribdc), le contexte de périphérique de l’attribut.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Paramètres

*lpszString*<br/>
Pointe vers une chaîne de caractères. Vous pouvez également passer un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) pour ce paramètre.

*nCount*<br/>
Spécifie la [longueur de la chaîne](/windows/win32/gdi/specifying-length-of-text-output-string) vers laquelle pointe *lpszString*.

*nTabPositions*<br/>
Spécifie le nombre de positions de taquet de tabulation dans le tableau pointé par *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Pointe vers un tableau d’entiers contenant la position des taquets de tabulation dans les unités logiques. Les taquets de tabulation doivent être triés par ordre de tri ; la plus petite valeur x doit être le premier élément du tableau. Les onglets arrière ne sont pas autorisés.

*str*<br/>
`CString` Objet qui contient les caractères spécifiés à dessiner.

### <a name="return-value"></a>Valeur de retour

Dimensions de la chaîne (en unités logiques) dans un objet [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Notes

Si la chaîne contient un ou plusieurs caractères de tabulation, la largeur de la chaîne est basée sur les taquets de tabulation spécifiés par *lpnTabStopPositions*. La fonction utilise la police actuellement sélectionnée pour calculer les dimensions de la chaîne.

La zone de découpage actuelle ne décale pas la largeur et `GetTabbedTextExtent` la hauteur retournées par la fonction.

Étant donné que certains appareils ne placent pas de caractères dans les tableaux de cellules ordinaires (c’est-à-dire qu’ils crénageent les caractères), la somme des étendues des caractères dans une chaîne peut ne pas être égale à l’étendue de la chaîne.

Si *nTabPositions* a la valeur 0 et que *lpnTabStopPositions* a la valeur null, les tabulations sont développées à huit fois la largeur moyenne des caractères. Si *nTabPositions* a la valeur 1, les taquets de tabulation sont séparés par la distance spécifiée par la première valeur dans le tableau auquel *lpnTabStopPositions* pointe. Si *lpnTabStopPositions* pointe vers plus d’une valeur unique, un taquet de tabulation est défini pour chaque valeur du tableau, jusqu’au nombre spécifié par *nTabPositions*.

##  <a name="gettextalign"></a>  CDC::GetTextAlign

Récupère l’état des indicateurs d’alignement de texte pour le contexte de périphérique.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Valeur de retour

État des indicateurs d’alignement de texte. La valeur de retour est une ou plusieurs des valeurs suivantes :

- TA_BASELINE spécifie l’alignement de l’axe x et de la ligne de base de la police choisie dans le rectangle englobant.

- TA_BOTTOM spécifie l’alignement de l’axe x et du bas du rectangle englobant.

- TA_CENTER spécifie l’alignement de l’axe des y et le centre du rectangle englobant.

- TA_LEFT spécifie l’alignement de l’axe y et du côté gauche du rectangle englobant.

- TA_NOUPDATECP spécifie que la position actuelle n’est pas mise à jour.

- TA_RIGHT spécifie l’alignement de l’axe y et du côté droit du rectangle englobant.

- TA_TOP spécifie l’alignement de l’axe x et du haut du rectangle englobant.

- TA_UPDATECP spécifie que la position actuelle est mise à jour.

### <a name="remarks"></a>Notes

Les indicateurs d’alignement de texte déterminent `TextOut` comment `ExtTextOut` les fonctions membres et alignent une chaîne de texte par rapport au point de départ de la chaîne. Les indicateurs d’alignement de texte ne sont pas nécessairement des indicateurs à un bit et peuvent être égaux à 0. Pour tester si un indicateur est défini, une application doit suivre les étapes suivantes :

1. Appliquez l’opérateur or au niveau du bit à l’indicateur et à ses indicateurs associés, regroupés comme suit :

    - TA_LEFT, TA_CENTER et TA_RIGHT

    - TA_BASELINE, TA_BOTTOM et TA_TOP

    - TA_NOUPDATECP et TA_UPDATECP

1. Appliquez l’opérateur de bits AND au résultat et la valeur de retour de `GetTextAlign`.

1. Testez l’égalité de ce résultat et l’indicateur.

##  <a name="gettextcharacterextra"></a>  CDC::GetTextCharacterExtra

Récupère le paramètre actuel pour la quantité d’espacement entre les caractères.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Valeur de retour

Quantité d’espacement entre les caractères.

### <a name="remarks"></a>Notes

GDI ajoute cet espacement à chaque caractère, y compris les caractères de saut, lorsqu’il écrit une ligne de texte dans le contexte de périphérique.

La valeur par défaut de la quantité d’espacement entre les caractères est 0.

##  <a name="gettextcolor"></a>  CDC::GetTextColor

Récupère la couleur de texte actuelle.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Valeur de retour

Couleur de texte actuelle en tant que valeur de couleur RVB.

### <a name="remarks"></a>Notes

La couleur de texte est la couleur de premier plan des caractères dessinés à l’aide des fonctions membres de sortie de texte GDI [TextOut](#textout), [ExtTextOut](#exttextout)et [TabbedTextOut](#tabbedtextout).

##  <a name="gettextextent"></a>  CDC::GetTextExtent

Appelez cette fonction membre pour calculer la largeur et la hauteur d’une ligne de texte à l’aide de la police actuelle pour déterminer les dimensions.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Paramètres

*lpszString*<br/>
Pointe vers une chaîne de caractères. Vous pouvez également passer un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) pour ce paramètre.

*nCount*<br/>
Spécifie le nombre de caractères de la chaîne.

*str*<br/>
`CString` Objet qui contient les caractères spécifiés.

### <a name="return-value"></a>Valeur de retour

Dimensions de la chaîne (en unités logiques) dans un objet [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Notes

Les informations sont extraites de [m_hAttribDC](#m_hattribdc), le contexte de périphérique de l’attribut.

Par défaut, `GetTextExtent` suppose que le texte pour lequel il récupère la dimension est défini sur une ligne horizontale (autrement dit, si l’échappement est égal à 0). Si vous créez une police spécifiant une échappement différente de zéro, vous devez convertir explicitement l’angle du texte pour obtenir les dimensions de la chaîne.

La zone de découpage actuelle n’affecte pas la largeur et `GetTextExtent`la hauteur retournées par.

Étant donné que certains appareils ne placent pas de caractères dans les tableaux de cellules ordinaires (c’est-à-dire qu’ils effectuent un crénage), la somme des étendues des caractères dans une chaîne peut ne pas être égale à l’étendue de la chaîne.

##  <a name="gettextextentexpointi"></a>  CDC::GetTextExtentExPointI

Récupère le nombre de caractères dans une chaîne spécifiée qui tiennent dans un espace spécifié et remplit un tableau avec l’étendue du texte pour chacun de ces caractères.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*pgiIn*<br/>
Pointeur vers un tableau d’index de glyphes pour lesquels les extensions doivent être récupérées.

*cgi*<br/>
Spécifie le nombre de glyphes dans le tableau pointé par *pgiIn*.

*nMaxExtent*<br/>
Spécifie la largeur maximale autorisée, en unités logiques, de la chaîne mise en forme.

*lpnFit*<br/>
Pointeur vers un entier qui reçoit le nombre maximal de caractères qui tiennent dans l’espace spécifié par *nMaxExtent*. Lorsque *lpnFit* a la valeur null, *nMaxExtent* est ignoré.

*alpDx*<br/>
Pointeur vers un tableau d’entiers qui reçoit des extensions de glyphe partielles. Chaque élément du tableau donne la distance, en unités logiques, entre le début du tableau d’index de glyphe et l’un des glyphes qui tiennent dans l’espace spécifié par *nMaxExtent*. Bien que ce tableau doit avoir au moins autant d’éléments que les index de glyphes spécifiés par *CGI*, la fonction remplit le tableau avec des étendues uniquement pour autant d’index de glyphes que ceux spécifiés par *lpnFit*. Si *lpnDx* a la valeur null, la fonction ne calcule pas les largeurs de chaîne partielles.

*lpSize*<br/>
Pointeur vers une structure de [taille](/windows/win32/api/windef/ns-windef-size) qui reçoit les dimensions du tableau d’index de glyphes, en unités logiques. Cette valeur ne peut pas être NULL.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction membre émule les fonctionnalités de la fonction [GetTextExtentExPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi), comme décrit dans la SDK Windows.

##  <a name="gettextextentpointi"></a>  CDC::GetTextExtentPointI

Récupère la largeur et la hauteur du tableau spécifié d’index de glyphes.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*pgiIn*<br/>
Pointeur vers un tableau d’index de glyphes pour lesquels les extensions doivent être récupérées.

*cgi*<br/>
Spécifie le nombre de glyphes dans le tableau pointé par *pgiIn*.

*lpSize*<br/>
Pointeur vers une structure de [taille](/windows/win32/api/windef/ns-windef-size) qui reçoit les dimensions du tableau d’index de glyphes, en unités logiques. Cette valeur ne peut pas être NULL.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction membre émule les fonctionnalités de la fonction [GetTextExtentPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi), comme décrit dans la SDK Windows.

##  <a name="gettextface"></a>  CDC::GetTextFace

Appelez cette fonction membre pour copier le nom de police de la police actuelle dans une mémoire tampon.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Paramètres

*nCount*<br/>
Spécifie la taille de la mémoire tampon (en octets). Si le nom de la police est plus long que le nombre d’octets spécifié par ce paramètre, le nom est tronqué.

*lpszFacename*<br/>
Pointe vers la mémoire tampon pour le nom de la police.

*rString*<br/>
Référence à un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) .

### <a name="return-value"></a>Valeur de retour

Nombre d’octets copiés dans la mémoire tampon, à l’exclusion du caractère null de fin. La valeur est 0 si une erreur se produit.

### <a name="remarks"></a>Notes

Le nom de type de caractères est copié sous la forme d’une chaîne terminée par le caractère null.

##  <a name="gettextmetrics"></a>  CDC::GetTextMetrics

Récupère les métriques de la police actuelle à l’aide du contexte de périphérique d’attribut.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Paramètres

*lpMetrics*<br/>
Pointe vers la structure [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) qui reçoit les métriques.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

##  <a name="getviewportext"></a>  CDC::GetViewportExt

Récupère les étendues x et y de la fenêtre d’affichage du contexte de périphérique.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Valeur de retour

Les étendues x et y (en unités de périphérique) en tant qu' `CSize` objet.

##  <a name="getviewportorg"></a>  CDC::GetViewportOrg

Récupère les coordonnées x et y de l’origine de la fenêtre d’affichage associée au contexte de périphérique.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Valeur de retour

Origine de la fenêtre d’affichage (en coordonnées d’appareil) `CPoint` en tant qu’objet.

##  <a name="getwindow"></a>  CDC::GetWindow

Retourne la fenêtre associée au contexte de périphérique d’affichage.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers un `CWnd` objet en cas de réussite ; sinon, null.

### <a name="remarks"></a>Notes

Il s’agit d’une fonction avancée. Par exemple, cette fonction membre peut ne pas retourner la fenêtre d’affichage lors de l’impression ou en mode aperçu avant impression. Elle retourne toujours la fenêtre associée à la sortie. Les fonctions de sortie qui utilisent le DC donné dessinent dans cette fenêtre.

##  <a name="getwindowext"></a>  CDC::GetWindowExt

Récupère les étendues x et y de la fenêtre associée au contexte de périphérique.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Valeur de retour

Les étendues x et y (en unités logiques) en tant qu' `CSize` objet.

##  <a name="getwindoworg"></a>  CDC::GetWindowOrg

Récupère les coordonnées x et y de l’origine de la fenêtre associée au contexte de périphérique.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Valeur de retour

Origine de la fenêtre (en coordonnées logiques) en tant `CPoint` qu’objet.

##  <a name="getworldtransform"></a>  CDC::GetWorldTransform

Récupère l’espace universel actuel pour la transformation d’espace de page.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Paramètres

*rXform*<br/>
Référence à une structure [XForm](/windows/win32/api/wingdi/ns-wingdi-xform) qui reçoit l’espace universel actuel pour la transformation d’espace de page.

### <a name="return-value"></a>Valeur de retour

Retourne une valeur différente de zéro en cas de réussite.

Retourne 0 en cas d’échec.

Pour afficher les informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Notes

Cette méthode encapsule la fonction Windows GDI [GetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform).

##  <a name="gradientfill"></a>  CDC::GradientFill

Appelez cette fonction membre pour remplir les structures des rectangles et des triangles avec une couleur qui s’estompe facilement d’un côté à l’autre.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Paramètres

*pVertices*<br/>
Pointeur vers un tableau de structures de [TRIVERTEX](/windows/win32/api/wingdi/ns-wingdi-trivertex) qui définissent chacune un vertex de triangle.

*nVertices*<br/>
Nombre de vertex.

*pMesh*<br/>
Tableau de structures [GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle) en mode triangulaire, ou tableau de structures [GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect) en mode rectangle.

*nMeshElements*<br/>
Nombre d’éléments (triangles ou rectangles) dans *pMesh*.

*dwMode*<br/>
Spécifie le mode de remplissage dégradé. Pour obtenir la liste des valeurs possibles, consultez [GradientFill](/windows/win32/api/wingdi/nf-wingdi-gradientfill) dans le SDK Windows.

### <a name="return-value"></a>Valeur de retour

TRUE en cas de réussite, sinon FALSE.

### <a name="remarks"></a>Notes

Pour plus d’informations, `GradientFill` consultez dans la SDK Windows.

##  <a name="graystring"></a>  CDC::GrayString

Dessine le texte grisé à l’emplacement donné en écrivant le texte dans une image bitmap de mémoire, en le diquise en grisé, puis en copiant l’image bitmap à l’écran.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Paramètres

*pBrush*<br/>
Identifie le pinceau à utiliser pour la luminosité (en grisé).

*lpfnOutput*<br/>
Spécifie l’adresse d’instance de procédure de la fonction de rappel fournie par l’application qui dessinera la chaîne. Pour plus d’informations, consultez la description de la `OutputFunc` [fonction de rappel](callback-functions-used-by-mfc.md#graystring)Windows. Si ce paramètre a la valeur null, le système utilise `TextOut` la fonction Windows pour dessiner la chaîne, et *lpData* est supposé être un long pointeur vers la chaîne de caractères à sortir.

*lpData*<br/>
Spécifie un pointeur Far vers les données à passer à la fonction de sortie. Si *lpfnOutput* a la valeur null, *lpData* doit être un long pointeur vers la chaîne à sortir.

*nCount*<br/>
Spécifie le nombre de caractères à générer. Si ce paramètre a la valeur `GrayString` 0, calcule la longueur de la chaîne (en supposant que *lpData* est un pointeur vers la chaîne). Si *nCount* a la valeur 1 et que la fonction vers laquelle pointe *lpfnOutput* retourne 0, l’image est affichée mais pas grisée.

*x*<br/>
Spécifie la coordonnée x logique de la position de départ du rectangle qui englobe la chaîne.

*y*<br/>
Spécifie la coordonnée y logique de la position de départ du rectangle qui englobe la chaîne.

*nWidth*<br/>
Spécifie la largeur (en unités logiques) du rectangle qui englobe la chaîne. Si *nWidth* a la valeur `GrayString` 0, calcule la largeur de la zone, en supposant que *lpData* est un pointeur vers la chaîne.

*nHeight*<br/>
Spécifie la hauteur (en unités logiques) du rectangle qui englobe la chaîne. Si *nHeight* a la valeur `GrayString` 0, calcule la hauteur de la zone, en supposant que *lpData* est un pointeur vers la chaîne.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro si la chaîne est dessinée, ou 0 `TextOut` si la fonction ou la fonction de sortie fournie par l’application a retourné la valeur 0, ou si la mémoire est insuffisante pour créer une image bitmap de mémoire pour la mise en grisé.

### <a name="remarks"></a>Notes

La fonction estompe le texte quel que soit le pinceau et l’arrière-plan sélectionnés. La `GrayString` fonction membre utilise la police actuellement sélectionnée. Le mode de mappage MM_TEXT doit être sélectionné avant d’utiliser cette fonction.

Une application peut dessiner des chaînes grisées sur des appareils qui prennent en charge une couleur grise unie sans appeler `GrayString` la fonction membre. La couleur système COLOR_GRAYTEXT est la couleur système grise unie utilisée pour dessiner du texte désactivé. L’application peut appeler la `GetSysColor` fonction Windows pour récupérer la valeur de couleur de COLOR_GRAYTEXT. Si la couleur est différente de 0 (noir), l’application peut appeler la `SetTextColor` fonction membre pour définir la couleur de texte sur la valeur de couleur, puis dessiner directement la chaîne. Si la couleur Récupérée est noire, l’application doit appeler `GrayString` le texte Dim (gris).

Si *lpfnOutput* a la valeur null, GDI utilise la fonction [TextOut](/windows/win32/api/wingdi/nf-wingdi-textoutw) de Windows, et *lpData* est supposé être un pointeur Far vers le caractère à générer. Si les caractères à générer ne peuvent pas être traités par `TextOut` la fonction membre (par exemple, la chaîne est stockée en tant que bitmap), l’application doit fournir sa propre fonction de sortie.

Notez également que toutes les fonctions de rappel doivent intercepter les exceptions Microsoft Foundation avant de retourner à Windows, car les exceptions ne peuvent pas être levées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, consultez l’article [exceptions](../../mfc/exception-handling-in-mfc.md).

La fonction de rappel passée `GrayString` à doit utiliser `__stdcall` la Convention d’appel et doit être `__declspec`exportée avec.

Lorsque l’infrastructure est en mode aperçu, un appel à la `GrayString` fonction membre est traduit `TextOut` en appel et la fonction de rappel n’est pas appelée.

##  <a name="himetrictodp"></a>CDC :: HIMETRICtoDP

Utilisez cette fonction lorsque vous convertissez des tailles de HIMETRIC à partir d’OLE en pixels.

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*lpSize*<br/>
Pointe vers une structure de [taille](/windows/win32/api/windef/ns-windef-size) ou un objet [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Notes

Si le mode de mappage de l’objet de contexte de périphérique est MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC ou MM_HIMETRIC, la conversion est basée sur le nombre de pixels du pouce physique. Si le mode de mappage est l’un des autres modes non restreints (par exemple, MM_TEXT), la conversion est basée sur le nombre de pixels du pouce logique.

##  <a name="himetrictolp"></a>CDC :: HIMETRICtoLP

Appelez cette fonction pour convertir des unités HIMETRIC en unités logiques.

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*lpSize*<br/>
Pointe vers une structure de [taille](/windows/win32/api/windef/ns-windef-size) ou un objet [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Notes

Utilisez cette fonction lorsque vous récupérez des tailles de HIMETRIC à partir d’OLE et souhaitez les convertir en mode de mappage naturel de votre application.

Pour effectuer la conversion, convertissez d’abord les unités HIMETRIC en pixels, puis convertissez ces unités en unités logiques à l’aide des unités de mappage actuelles du contexte de périphérique. Notez que les étendues de la fenêtre et de la fenêtre d’affichage de l’appareil affectent le résultat.

##  <a name="intersectcliprect"></a>  CDC::IntersectClipRect

Crée une nouvelle zone de découpage en formant l’intersection de la région actuelle et du rectangle spécifié par *x1*, *Y1*, *x2*et *Y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle.

*y1*<br/>
Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle.

*x2*<br/>
Spécifie la coordonnée x logique du coin inférieur droit du rectangle.

*y2*<br/>
Spécifie la coordonnée y logique du coin inférieur droit du rectangle.

*lpRect*<br/>
Spécifie le rectangle. Vous pouvez passer un `CRect` objet ou un pointeur vers une `RECT` structure pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Type de la nouvelle zone de découpage. Il peut s’agir de l’une des valeurs suivantes :

- COMPLEXREGION nouvelle zone de découpage a des bordures qui se chevauchent.

- Le contexte de périphérique d’erreur n’est pas valide.

- NULLREGION nouvelle zone de découpage est vide.

- SIMPLEREGION nouvelle zone de découpage n’a pas de bordures se chevauchant.

### <a name="remarks"></a>Notes

GDI détourne toutes les sorties suivantes à intégrer dans la nouvelle limite. La largeur et la hauteur ne doivent pas dépasser 32 767.

##  <a name="invertrect"></a>  CDC::InvertRect

Inverse le contenu du rectangle donné.

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Pointe vers un `RECT` qui contient les coordonnées logiques du rectangle à inverser. Vous pouvez également passer un `CRect` objet pour ce paramètre.

### <a name="remarks"></a>Notes

Inversion est une opération NOT logique et retourne les bits de chaque pixel. Sur les affichages monochrome, la fonction fait en sorte que les pixels blancs sont noirs et noirs. Sur les affichages de couleur, l’inversion dépend de la manière dont les couleurs sont générées pour l’affichage. L' `InvertRect` appel de deux fois avec le même rectangle restaure l’affichage à ses couleurs précédentes.

Si le rectangle est vide, rien n’est dessiné.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

##  <a name="invertrgn"></a>  CDC::InvertRgn

Inverse les couleurs de la zone spécifiée par *pRgn*.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Paramètres

*pRgn*<br/>
Identifie la région à inverser. Les coordonnées de la région sont spécifiées en unités logiques.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Sur les affichages monochrome, la fonction fait en sorte que les pixels blancs sont noirs et noirs. Sur les affichages de couleur, l’inversion dépend de la façon dont les couleurs sont générées pour l’affichage.

##  <a name="isprinting"></a>  CDC::IsPrinting

Détermine si le contexte de périphérique est utilisé pour l’impression.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si `CDC` l’objet est un contrôleur de l’imprimante ; sinon, 0.

##  <a name="lineto"></a>  CDC::LineTo

Dessine une ligne à partir de la position actuelle jusqu’à, mais sans l’inclure, le point spécifié par *x* et *y* (ou *point*).

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique du point de terminaison de la ligne.

*y*<br/>
Spécifie la coordonnée y logique du point de terminaison de la ligne.

*point*<br/>
Spécifie le point de terminaison de la ligne. Vous pouvez passer une `POINT` structure ou un `CPoint` objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la ligne est dessinée ; Sinon, 0.

### <a name="remarks"></a>Notes

La ligne est dessinée avec le stylet sélectionné. La position actuelle est définie sur *x*, *y* ou *pointer*.

### <a name="example"></a>Exemple

  Consultez l’exemple pour [CRect :: Centerpoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

##  <a name="lptodp"></a>  CDC::LPtoDP

Convertit les unités logiques en unités de périphérique.

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*lpPoints*<br/>
Pointe vers un tableau de points. Chaque point du tableau est une structure de [points](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

*nCount*<br/>
Nombre de points dans le tableau.

*lpRect*<br/>
Pointe vers une structure [Rect](/windows/win32/api/windef/ns-windef-rect) ou un objet [CRect](../../atl-mfc-shared/reference/crect-class.md) . Ce paramètre est utilisé pour le cas courant de mappage d’un rectangle d’unités logiques à des unités de périphérique.

*lpSize*<br/>
Pointe vers une structure de [taille](/windows/win32/api/windef/ns-windef-size) ou un objet [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Notes

La fonction mappe les coordonnées de chaque point, ou les dimensions d’une taille, du système de coordonnées logiques de GDI au système de coordonnées de l’appareil. La conversion dépend du mode de mappage actuel et des paramètres de l’origine et des étendues de la fenêtre et de la fenêtre d’affichage de l’appareil.

Les coordonnées x et y des points sont des entiers signés sur 2 octets dans la plage comprise entre-32 768 et 32 767. Dans les cas où le mode de mappage entraînerait des valeurs supérieures à ces limites, le système définit les valeurs sur-32 768 et 32 767, respectivement.

##  <a name="lptohimetric"></a>  CDC::LPtoHIMETRIC

Appelez cette fonction pour convertir des unités logiques en unités HIMETRIC.

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Paramètres

*lpSize*<br/>
Pointe vers une `SIZE` structure ou un `CSize` objet.

### <a name="remarks"></a>Notes

Utilisez cette fonction lorsque vous donnez des tailles de HIMETRIC à OLE, en convertissant le mode de mappage naturel de votre application. Notez que les étendues de la fenêtre et de la fenêtre d’affichage de l’appareil affectent le résultat.

Pour effectuer la conversion, convertissez d’abord les unités logiques en pixels à l’aide des unités de mappage actuelles du contexte de périphérique, puis convertissez ces unités en unités HIMETRIC.

##  <a name="m_hattribdc"></a>  CDC::m_hAttribDC

Attribut de contexte de périphérique pour `CDC` cet objet.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Notes

Par défaut, ce contexte de périphérique est égal `m_hDC`à. En général, `CDC` les appels GDI qui demandent des informations à partir du contexte de `m_hAttribDC`périphérique sont dirigés vers. Consultez la description de la classe [CDC](../../mfc/reference/cdc-class.md) pour plus d’informations sur l’utilisation de ces deux contextes de périphérique.

##  <a name="m_hdc"></a>  CDC::m_hDC

Contexte de périphérique de sortie pour `CDC` cet objet.

```
HDC m_hDC;
```

### <a name="remarks"></a>Notes

Par défaut, `m_hDC` est égal à `m_hAttribDC`, l’autre contexte de périphérique encapsulé `CDC`par. En général, `CDC` les appels GDI qui créent la sortie sont `m_hDC` dirigés vers le contexte de périphérique. Vous pouvez initialiser `m_hDC` et `m_hAttribDC` pointer vers différents appareils. Consultez la description de la classe [CDC](../../mfc/reference/cdc-class.md) pour plus d’informations sur l’utilisation de ces deux contextes de périphérique.

##  <a name="maskblt"></a>  CDC::MaskBlt

Combine les données de couleur pour les bitmaps sources et de destination à l’aide du masque et de l’opération Raster donnés.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle de destination.

*y*<br/>
Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle de destination.

*nWidth*<br/>
Spécifie la largeur, en unités logiques, du rectangle de destination et de la bitmap source.

*nHeight*<br/>
Spécifie la hauteur, en unités logiques, du rectangle de destination et de la bitmap source.

*pSrcDC*<br/>
Identifie le contexte de périphérique à partir duquel la bitmap doit être copiée. Elle doit être égale à zéro si le paramètre *dwRop* spécifie une opération Raster qui n’inclut pas de source.

*xSrc*<br/>
Spécifie la coordonnée x logique de l’angle supérieur gauche de l’image bitmap source.

*ySrc*<br/>
Spécifie la coordonnée y logique de l’angle supérieur gauche de l’image bitmap source.

*maskBitmap*<br/>
Identifie la bitmap de masque monochrome associée à la bitmap de couleur dans le contexte de périphérique source.

*xMask*<br/>
Spécifie le décalage de pixel horizontal pour la bitmap de masque spécifiée par le paramètre *maskBitmap* .

*yMask*<br/>
Spécifie le décalage de pixel vertical pour la bitmap de masque spécifiée par le paramètre *maskBitmap* .

*dwRop*<br/>
Spécifie les codes d’opération Raster de premier plan et d’arrière-plan, que la fonction utilise pour contrôler la combinaison des données source et de destination. Le code d’opération Raster d’arrière-plan est stocké dans l’octet de poids fort du mot de poids fort de cette valeur ; le code d’opération Raster de premier plan est stocké dans l’octet de poids faible du mot de poids fort de cette valeur ; le mot de poids faible de cette valeur est ignoré et doit être égal à zéro. La macro MAKEROP4 crée de telles combinaisons de codes d’opération Raster de premier plan et d’arrière-plan. Consultez la section Notes pour une discussion sur le premier plan et l’arrière-plan dans le contexte de cette fonction. Pour obtenir `BitBlt` la liste des codes d’opération Raster les plus courants, consultez la fonction membre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

La valeur 1 dans le masque spécifié par *maskBitmap* indique que le code d’opération Raster de premier plan spécifié par *dwRop* doit être appliqué à cet emplacement. La valeur 0 dans le masque indique que le code d’opération Raster d’arrière-plan spécifié par *dwRop* doit être appliqué à cet emplacement. Si les opérations raster requièrent une source, le rectangle de masque doit couvrir le rectangle source. Si ce n’est pas le cas, la fonction échoue. Si les opérations raster ne nécessitent pas de source, le rectangle de masque doit couvrir le rectangle de destination. Si ce n’est pas le cas, la fonction échoue.

Si une transformation de rotation ou de cisaillement est en vigueur pour le contexte de périphérique source lorsque cette fonction est appelée, une erreur se produit. Toutefois, d’autres types de transformations sont autorisés.

Si les formats de couleurs des bitmaps de source, de modèle et de destination diffèrent, cette fonction convertit le modèle ou le format source, ou les deux, pour correspondre au format de destination. Si la bitmap de masque n’est pas une image bitmap monochrome, une erreur se produit. Lorsqu’un métafichier amélioré est enregistré, une erreur se produit (et la fonction retourne 0) si le contexte de périphérique source identifie un contexte de périphérique de métafichier amélioré. Tous les appareils ne `MaskBlt`prennent pas en charge. Une application doit appeler `GetDeviceCaps` pour déterminer si un appareil prend en charge cette fonction. Si aucune bitmap de masque n’est fournie, cette fonction se comporte exactement `BitBlt`comme, en utilisant le code d’opération Raster de premier plan. Les décalages de pixels dans l’image bitmap de masque sont mappés au point (0,0) dans le bitmap du contexte de périphérique source. Cela est utile dans les cas où une image bitmap de masque contient un ensemble de masques. une application peut facilement appliquer l’une d’entre elles à une tâche Mask-blitting en ajustant les décalages de pixels et les `MaskBlt`tailles de rectangle envoyées à.

##  <a name="modifyworldtransform"></a>  CDC::ModifyWorldTransform

Modifie la transformation universelle d’un contexte de périphérique à l’aide du mode spécifié.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Paramètres

*rXform*<br/>
Référence à une structure [XForm](/windows/win32/api/wingdi/ns-wingdi-xform) utilisée pour modifier la transformation universelle pour le contexte de périphérique donné.

*iMode*<br/>
Spécifie la manière dont les données de transformation modifient la transformation universelle actuelle. Pour obtenir la liste des valeurs que ce paramètre peut prendre, consultez [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Valeur de retour

Retourne une valeur différente de zéro en cas de réussite.

Retourne 0 en cas d’échec.

Pour afficher les informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Notes

Cette méthode encapsule la fonction Windows GDI [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

##  <a name="moveto"></a>  CDC::MoveTo

Déplace la position actuelle jusqu’au point spécifié par *x* et *y* (ou par *point*).

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique du nouvel emplacement.

*y*<br/>
Spécifie la coordonnée y logique de la nouvelle position.

*point*<br/>
Spécifie la nouvelle position. Vous pouvez passer une `POINT` structure ou un `CPoint` objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Coordonnées x et y de la position précédente sous la forme d’un `CPoint` objet.

### <a name="example"></a>Exemple

  Consultez l’exemple pour [CRect :: Centerpoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

##  <a name="offsetcliprgn"></a>  CDC::OffsetClipRgn

Déplace la zone de découpage du contexte de périphérique selon les décalages spécifiés.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie le nombre d’unités logiques à déplacer vers la gauche ou vers la droite.

*y*<br/>
Spécifie le nombre d’unités logiques à déplacer vers le haut ou vers le haut.

*size*<br/>
Spécifie la quantité à décaler.

### <a name="return-value"></a>Valeur de retour

Type de la nouvelle région. Il peut s’agir de l’une des valeurs suivantes :

- La région de découpage COMPLEXREGION a des bordures qui se chevauchent.

- Le contexte de périphérique d’erreur n’est pas valide.

- La région de découpage NULLREGION est vide.

- La région de découpage SIMPLEREGION n’a pas de bordures se chevauchant.

### <a name="remarks"></a>Notes

La fonction déplace les unités de la région *x* sur les unités de l’axe x et *y* le long de l’axe y.

##  <a name="offsetviewportorg"></a>  CDC::OffsetViewportOrg

Modifie les coordonnées de l’origine de la fenêtre d’affichage par rapport aux coordonnées de l’origine de la fenêtre d’affichage actuelle.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Paramètres

*nWidth*<br/>
Spécifie le nombre d’unités de périphérique à ajouter à la coordonnée x de l’origine actuelle.

*nHeight*<br/>
Spécifie le nombre d’unités de périphérique à ajouter à la coordonnée y de l’origine actuelle.

### <a name="return-value"></a>Valeur de retour

Origine de la fenêtre d’affichage précédente (en coordonnées d' `CPoint` appareil) en tant qu’objet.

##  <a name="offsetwindoworg"></a>  CDC::OffsetWindowOrg

Modifie les coordonnées de l’origine de la fenêtre par rapport aux coordonnées de l’origine de la fenêtre active.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Paramètres

*nWidth*<br/>
Spécifie le nombre d’unités logiques à ajouter à la coordonnée x de l’origine actuelle.

*nHeight*<br/>
Spécifie le nombre d’unités logiques à ajouter à la coordonnée y de l’origine actuelle.

### <a name="return-value"></a>Valeur de retour

Origine de la fenêtre précédente (en coordonnées logiques) `CPoint` en tant qu’objet.

##  <a name="operator_hdc"></a>CDC :: Operator HDC

Utilisez cet opérateur pour récupérer le handle de contexte de périphérique `CDC` de l’objet.

```
operator HDC() const;
```

### <a name="return-value"></a>Valeur de retour

En cas de réussite, handle de l’objet de contexte de périphérique ; Sinon, NULL.

### <a name="remarks"></a>Notes

Vous pouvez utiliser le handle pour appeler des API Windows directement.

##  <a name="paintrgn"></a>  CDC::PaintRgn

Remplit la région spécifiée par *pRgn* à l’aide du pinceau actuel.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Paramètres

*pRgn*<br/>
Identifie la zone à remplir. Les coordonnées de la région donnée sont spécifiées en unités logiques.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

##  <a name="patblt"></a>  CDC::PatBlt

Crée un modèle binaire sur l’appareil.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique de l’angle supérieur gauche du rectangle qui doit recevoir le modèle.

*y*<br/>
Spécifie la coordonnée y logique de l’angle supérieur gauche du rectangle qui doit recevoir le modèle.

*nWidth*<br/>
Spécifie la largeur (en unités logiques) du rectangle qui doit recevoir le modèle.

*nHeight*<br/>
Spécifie la hauteur (en unités logiques) du rectangle qui doit recevoir le modèle.

*dwRop*<br/>
Spécifie le code d’opération Raster. Les codes d’opération Raster (trame-Operation code) définissent la façon dont GDI combine les couleurs dans les opérations de sortie qui impliquent un pinceau actuel, une bitmap source possible et une bitmap de destination. Ce paramètre peut prendre l’une des valeurs suivantes :

- PATCOPY copie le modèle dans le bitmap de destination.

- PATINVERT combine le bitmap de destination et le modèle à l’aide de l’opérateur booléen XOR.

- DSTINVERT inverse le bitmap de destination.

- L’effet de noir permet de transformer tout le noir de sortie.

- La couleur blanche permet de transformer la sortie en blanc.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le modèle est une combinaison du pinceau sélectionné et du modèle déjà présent sur l’appareil. Le code d’opération Raster spécifié par *dwRop* définit la manière dont les modèles doivent être combinés. Les opérations raster répertoriées pour cette fonction sont un sous-ensemble limité de l’ensemble des codes d’opération Raster 256 ternaires. en particulier, un code d’opération Raster qui fait référence à une source ne peut pas être utilisé.

Tous les contextes d’appareil ne `PatBlt` prennent pas en charge la fonction. Pour déterminer si un contexte de périphérique `PatBlt`prend en charge `GetDeviceCaps` , appelez la fonction membre avec l’index RasterCaps et vérifiez la valeur de retour de l’indicateur RC_BITBLT.

##  <a name="pie"></a>  CDC::Pie

Dessine une partie en secteurs en dessinant un arc elliptique dont le centre et les deux points de terminaison sont joints par lignes.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la coordonnée x de l’angle supérieur gauche du rectangle englobant (en unités logiques).

*y1*<br/>
Spécifie la coordonnée y de l’angle supérieur gauche du rectangle englobant (en unités logiques).

*x2*<br/>
Spécifie la coordonnée x du coin inférieur droit du rectangle englobant (en unités logiques).

*y2*<br/>
Spécifie la coordonnée y du coin inférieur droit du rectangle englobant (en unités logiques).

*x3*<br/>
Spécifie la coordonnée x du point de départ de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc.

*y3*<br/>
Spécifie la coordonnée y du point de départ de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc.

*x4*<br/>
Spécifie la coordonnée x du point de terminaison de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc.

*y4*<br/>
Spécifie la coordonnée y du point de terminaison de l’arc (en unités logiques). Ce point ne doit pas nécessairement se trouver exactement sur l’arc.

*lpRect*<br/>
Spécifie le rectangle englobant. Vous pouvez passer un `CRect` objet ou un pointeur vers une `RECT` structure pour ce paramètre.

*ptStart*<br/>
Spécifie le point de départ de l’arc. Ce point ne doit pas nécessairement se trouver exactement sur l’arc. Vous pouvez passer une structure [point](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) pour ce paramètre.

*ptEnd*<br/>
Spécifie le point de terminaison de l’arc. Ce point ne doit pas nécessairement se trouver exactement sur l’arc. Vous pouvez passer une `POINT` structure ou un `CPoint` objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le centre de l’arc est le centre du rectangle englobant spécifié par *x1*, *Y1*, *x2*et *Y2* (ou par *lpRect*). Les points de début et de fin de l’arc sont spécifiés par *x3*, *Y3*, *x4*et *Y4* (ou par *ptStart* et *ptEnd*).

L’arc est dessiné avec le stylet sélectionné, en se déplaçant dans le sens inverse des aiguilles d’une passe. Deux lignes supplémentaires sont tracées à partir de chaque point de terminaison vers le centre de l’arc. La zone en forme de secteur est remplie avec le pinceau actuel. Si *x3* est égal *à x4* et que *Y3* est égal à *Y4*, le résultat est une ellipse avec une seule ligne à partir du centre de l’ellipse jusqu’au point ( *x3*, *Y3*) ou ( *x4*, *Y4*).

La figure dessinée par cette fonction s’étend jusqu’à, mais n’inclut pas les coordonnées droite et inférieure. Cela signifie que la hauteur de la figure est *Y2* - *Y1* et que la largeur de la figure est *x2* - *x1*. La largeur et la hauteur du rectangle englobant doivent être supérieures à 2 unités et inférieures à 32 767 unités.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

##  <a name="playmetafile"></a>  CDC::PlayMetaFile

Lit le contenu du métafichier spécifié sur le contexte de périphérique.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Paramètres

*hMF*<br/>
Identifie le métafichier à lire.

*hEnhMetaFile*<br/>
Identifie le métafichier amélioré.

*lpBounds*<br/>
Pointe vers une `RECT` structure ou un `CRect` objet qui contient les coordonnées du rectangle englobant utilisé pour afficher l’image. Les coordonnées sont spécifiées en unités logiques.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le métafichier peut être lu un nombre quelconque de fois.

La deuxième version de `PlayMetaFile` affiche l’image stockée dans le métafichier de format amélioré donné. Quand une application appelle la deuxième version de `PlayMetaFile`, Windows utilise le cadre d’image dans l’en-tête de métafichier amélioré pour mapper l’image sur le rectangle vers lequel pointe le paramètre *lpBounds* . (Cette image peut être inclinée ou pivotée en définissant la transformation universelle dans le périphérique de sortie `PlayMetaFile`avant d’appeler.) Les points situés le long des bords du rectangle sont inclus dans l’image. Une image de métafichier amélioré peut être coupée en définissant la zone de découpage dans l’appareil de sortie avant de lancer le métafichier amélioré.

Si un métafichier amélioré contient une palette facultative, une application peut obtenir des couleurs cohérentes en configurant une palette de couleurs sur le périphérique de sortie avant d' `PlayMetaFile`appeler la deuxième version de. Pour récupérer la palette facultative, utilisez la `GetEnhMetaFilePaletteEntries` fonction Windows. Un métafichier amélioré peut être incorporé dans un métafichier amélioré nouvellement créé en appelant la deuxième version `PlayMetaFile` de et en lisant le métafichier amélioré source dans le contexte de périphérique pour le nouveau métafichier amélioré.

Les États du contexte de périphérique de sortie sont conservés par cette fonction. Tout objet créé mais non supprimé dans le métafichier amélioré est supprimé par cette fonction. Pour arrêter cette fonction, une application peut appeler la `CancelDC` fonction Windows à partir d’un autre thread pour mettre fin à l’opération. Dans ce cas, la fonction retourne zéro.

##  <a name="plgblt"></a>  CDC::PlgBlt

Effectue le transfert par bloc de bits des bits des données de couleur du rectangle spécifié dans le contexte de périphérique source vers le parallélogramme spécifié dans le contexte de périphérique donné.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Paramètres

*lpPoint*<br/>
Pointe vers un tableau de trois points dans l’espace logique qui identifie trois angles du parallélogramme de destination. L’angle supérieur gauche du rectangle source est mappé au premier point de ce tableau, au coin supérieur droit au deuxième point de ce tableau, et au troisième point situé à gauche du coin inférieur gauche. L’angle inférieur droit du rectangle source est mappé au quatrième point implicite du parallélogramme.

*pSrcDC*<br/>
Identifie le contexte de périphérique source.

*xSrc*<br/>
Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle source.

*ySrc*<br/>
Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle source.

*nWidth*<br/>
Spécifie la largeur, en unités logiques, du rectangle source.

*nHeight*<br/>
Spécifie la hauteur, en unités logiques, du rectangle source.

*maskBitmap*<br/>
Identifie une image bitmap monochrome facultative qui est utilisée pour masquer les couleurs du rectangle source.

*xMask*<br/>
Spécifie la coordonnée x de l’angle supérieur gauche de l’image bitmap monochrome.

*yMask*<br/>
Spécifie la coordonnée y de l’angle supérieur gauche de l’image bitmap monochrome.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Si le descripteur de masque de bits donné identifie une image bitmap monochrome valide, la fonction utilise cette bitmap pour masquer les bits des données de couleur du rectangle source.

Le quatrième vertex du parallélogramme (D) est défini par le traitement des trois premiers points (A, B et C) en tant que vecteurs et calcul D = B + C-A.

Si le masque de réapparaîtance existe, la valeur 1 dans le masque indique que la couleur de pixel source doit être copiée vers la destination. La valeur 0 dans le masque indique que la couleur de pixel de destination ne doit pas être modifiée.

Si le rectangle de masque est plus petit que le rectangle source et le rectangle de destination, la fonction réplique le modèle de masque.

Les transformations de mise à l’échelle, de traduction et de réflexion sont autorisées dans le contexte de périphérique source ; Toutefois, les transformations de rotation et d’inclinaison ne le sont pas. Si la bitmap de masque n’est pas une image bitmap monochrome, une erreur se produit. Le mode d’étirement du contexte de périphérique de destination est utilisé pour déterminer comment étirer ou compresser les pixels, si nécessaire. Lorsqu’un métafichier amélioré est enregistré, une erreur se produit si le contexte de périphérique source identifie un contexte de périphérique de métafichier amélioré.

Les coordonnées de destination sont transformées en fonction du contexte du périphérique de destination ; les coordonnées sources sont transformées en fonction du contexte du périphérique source. Si la transformation source a une rotation ou une inclinaison, une erreur est retournée. Si les rectangles de destination et sources n’ont pas le même format de `PlgBlt` couleur, convertit le rectangle source pour qu’il corresponde au rectangle de destination. Tous les appareils ne `PlgBlt`prennent pas en charge. Pour plus d’informations, consultez la description de la fonctionnalité raster RC_BITBLT dans la `CDC::GetDeviceCaps` fonction membre.

Si les contextes de périphérique source et de destination représentent des appareils `PlgBlt` incompatibles, retourne une erreur.

##  <a name="polybezier"></a>  CDC::PolyBezier

Dessine une ou plusieurs splines Bzier.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints*<br/>
Pointe vers un tableau de structures de données [point](/windows/win32/api/windef/ns-windef-point) qui contiennent les points de terminaison et les points de contrôle de la ou des splines.

*nCount*<br/>
Spécifie le nombre de points dans le tableau *lpPoints* . Cette valeur doit être supérieure à trois fois le nombre de splines à dessiner, car chaque spline Bzier requiert deux points de contrôle et un point de terminaison, et la spline initiale requiert un point de départ supplémentaire.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction dessine les splines Bzier cubiques à l’aide des points de terminaison et des points de contrôle spécifiés par le paramètre *lpPoints* . La première spline est dessinée du premier point au quatrième point en utilisant les deuxième et troisième points comme points de contrôle. Chaque spline suivante de la séquence nécessite exactement trois points supplémentaires : le point de terminaison de la spline précédente est utilisé comme point de départ, les deux points suivants de la séquence sont des points de contrôle et le troisième est le point de terminaison.

La position actuelle n’est ni utilisée ni mise à `PolyBezier` jour par la fonction. La figure n’est pas remplie. Cette fonction dessine des lignes à l’aide du stylet actuel.

##  <a name="polybezierto"></a>  CDC::PolyBezierTo

Dessine une ou plusieurs splines Bzier.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints*<br/>
Pointe vers un tableau de structures de données [point](/windows/win32/api/windef/ns-windef-point) qui contient les points de terminaison et les points de contrôle.

*nCount*<br/>
Spécifie le nombre de points dans le tableau *lpPoints* . Cette valeur doit être trois fois le nombre de splines à dessiner, car chaque spline Bzier requiert deux points de contrôle et un point de terminaison.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction dessine les splines Bzier cubiques à l’aide des points de contrôle spécifiés par le paramètre *lpPoints* . La première spline est tirée de la position actuelle jusqu’au troisième point en utilisant les deux premiers points comme points de contrôle. Pour chaque spline suivante, la fonction a besoin d’exactement trois points supplémentaires et utilise le point de terminaison de la spline précédente comme point de départ pour la suivante. `PolyBezierTo`déplace la position actuelle jusqu’au point de terminaison de la dernière spline Bzier. La figure n’est pas remplie. Cette fonction dessine des lignes à l’aide du stylet actuel.

### <a name="example"></a>Exemples

  Consultez l’exemple pour [CDC :: BeginPath](#beginpath).

##  <a name="polydraw"></a>  CDC::PolyDraw

Dessine un ensemble de segments de ligne et de splines Bzier.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints*<br/>
Pointe vers un tableau de structures de données [point](/windows/win32/api/windef/ns-windef-point) qui contient les points de terminaison pour chaque segment de ligne et les points de terminaison et points de contrôle pour chaque spline Bzier.

*lpTypes*<br/>
Pointe vers un tableau qui spécifie la façon dont chaque point du tableau *lpPoints* est utilisé. Les valeurs peuvent être l’une des suivantes :

- PT_MOVETO spécifie que ce point démarre une figure disjointe. Ce point devient la nouvelle position actuelle.

- PT_LINETO spécifie qu’une ligne doit être dessinée de la position actuelle à ce point, qui devient alors la nouvelle position actuelle.

- PT_BEZIERTO spécifie que ce point est un point de contrôle ou un point de terminaison pour une spline Bzier.

Les types PT_BEZIERTO se produisent toujours dans des ensembles de trois. La position actuelle définit le point de départ pour la spline Bzier. Les deux premiers points PT_BEZIERTO sont les points de contrôle et le troisième point PT_BEZIERTO est le point de fin. Le point de fin devient la nouvelle position actuelle. S’il n’y a pas trois points PT_BEZIERTO consécutifs, une erreur se produit.

   Un type PT_LINETO ou PT_BEZIERTO peut être combiné avec la constante suivante à l’aide de l’opérateur au niveau du bit ou pour indiquer que le point correspondant est le dernier point d’une figure et que la figure est fermée :

- PT_CLOSEFIGURE spécifie que la figure est fermée automatiquement après que le type PT_LINETO ou PT_BEZIERTO pour ce point est terminé. Une ligne est dessinée à partir de ce point jusqu’au PT_MOVETO `MoveTo` ou point le plus récent.

   Cet indicateur est combiné avec le type PT_LINETO pour une ligne, ou avec le type PT_BEZIERTO de point de fin pour une spline Bzier, à l’aide de **l’opérateur de bits or.** La position actuelle est définie sur le point de fin de la ligne de fermeture.

*nCount*<br/>
Spécifie le nombre total de points dans le tableau *lpPoints* , le même que le nombre d’octets dans le tableau *lpTypes* .

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction peut être utilisée pour dessiner des figures disjointes à la place des `CDC::MoveTo`appels `CDC::LineTo`consécutifs `CDC::PolyBezierTo` aux fonctions membres, et. Les lignes et les splines sont dessinées à l’aide du stylet actuel et les figures ne sont pas remplies. Si un chemin d’accès actif est démarré en appelant `CDC::BeginPath` la fonction membre `PolyDraw` , ajoute au chemin d’accès. Les points contenus dans le tableau *lpPoints* et dans *lpTypes* indiquent si chaque point fait partie d' `CDC::MoveTo` `CDC::LineTo`un, d’une ou d' `CDC::BezierTo` une opération. Il est également possible de fermer des figures. Cette fonction met à jour la position actuelle.

### <a name="example"></a>Exemple

  Consultez l’exemple pour [CDC :: BeginPath](#beginpath).

##  <a name="polygon"></a>  CDC::Polygon

Dessine un polygone constitué d’au moins deux points (sommets) reliés par des lignes, à l’aide du stylet actuel.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints*<br/>
Pointe vers un tableau de points qui spécifie les vertex du polygone. Chaque point du tableau est une `POINT` structure ou un `CPoint` objet.

*nCount*<br/>
Spécifie le nombre de vertex dans le tableau.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le système ferme automatiquement le polygone, si nécessaire, en dessinant une ligne du dernier vertex jusqu’au premier.

Le mode de remplissage de polygone actuel peut être récupéré ou défini à l' `GetPolyFillMode` aide `SetPolyFillMode` des fonctions membres et.

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

##  <a name="polyline"></a>  CDC::Polyline

Dessine un ensemble de segments de ligne reliant les points spécifiés par *lpPoints*.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints*<br/>
Pointe vers un tableau de `POINT` structures ou `CPoint` d’objets à connecter.

*nCount*<br/>
Spécifie le nombre de points dans le tableau. Cette valeur doit être au moins égale à 2.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Les lignes sont dessinées à partir du premier point à travers les points suivants à l’aide du stylet actuel. Contrairement à `LineTo` la fonction membre, `Polyline` la fonction n’utilise pas et ne met pas à jour la position actuelle.

Pour plus d’informations, consultez [PolyLine](/windows/win32/api/wingdi/nf-wingdi-polyline) dans le SDK Windows.

##  <a name="polylineto"></a>  CDC::PolylineTo

Dessine une ou plusieurs lignes droites.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints*<br/>
Pointe vers un tableau de structures de données de [point](/windows/win32/api/windef/ns-windef-point) qui contient les vertex de la ligne.

*nCount*<br/>
Spécifie le nombre de points dans le tableau.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Une ligne est dessinée de la position actuelle jusqu’au premier point spécifié par le paramètre *lpPoints* à l’aide du stylet actuel. Pour chaque ligne supplémentaire, la fonction dessine à partir du point de terminaison de la ligne précédente jusqu’au point suivant spécifié par *lpPoints*. `PolylineTo`déplace la position actuelle jusqu’au point de fin de la dernière ligne. Si les segments de ligne dessinés par cette fonction forment une figure fermée, la figure n’est pas remplie.

##  <a name="polypolygon"></a>  CDC::PolyPolygon

Crée deux polygones ou plus qui sont remplis à l’aide du mode de remplissage de polygone actuel.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints*<br/>
Pointe vers un tableau de `POINT` structures ou `CPoint` d’objets qui définissent les vertex des polygones.

*lpPolyCounts*<br/>
Pointe vers un tableau d’entiers, chacun d’entre eux spécifiant le nombre de points dans l’un des polygones du tableau *lpPoints* .

*nCount*<br/>
Nombre d’entrées dans le tableau *lpPolyCounts* . Ce nombre spécifie le nombre de polygones à dessiner. Cette valeur doit être au moins égale à 2.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Les polygones peuvent être disjoints ou se chevaucher.

Chaque polygone spécifié dans un appel à la `PolyPolygon` fonction doit être fermé. Contrairement aux polygones créés `Polygon` par la fonction membre, les polygones créés par `PolyPolygon` ne sont pas fermés automatiquement.

La fonction crée deux polygones ou plus. Pour créer un polygone unique, une application doit utiliser la `Polygon` fonction membre.

Le mode de remplissage de polygone actuel peut être récupéré ou défini à l' `GetPolyFillMode` aide `SetPolyFillMode` des fonctions membres et.

##  <a name="polypolyline"></a>  CDC::PolyPolyline

Dessine plusieurs séries de segments de ligne connectés.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Paramètres

*lpPoints*<br/>
Pointe vers un tableau de structures qui contient les vertex des polylignes. Les polylignes sont spécifiées de façon consécutive.

*lpPolyPoints*<br/>
Pointe vers un tableau de variables spécifiant le nombre de points dans le tableau *lpPoints* pour le polygone correspondant. Chaque entrée doit être supérieure ou égale à 2.

*nCount*<br/>
Spécifie le nombre total de nombres dans le tableau *lpPolyPoints* .

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Les segments de ligne sont dessinés à l’aide du stylet actuel. Les chiffres formés par les segments ne sont pas remplis. La position actuelle n’est ni utilisée ni mise à jour par cette fonction.

##  <a name="ptvisible"></a>  CDC::PtVisible

Détermine si le point donné se trouve dans la zone de découpage du contexte de périphérique.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique du point.

*y*<br/>
Spécifie la coordonnée y logique du point.

*point*<br/>
Spécifie le point à vérifier dans les coordonnées logiques. Vous pouvez passer une `POINT` structure ou un `CPoint` objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le point spécifié se trouve dans la zone de découpage ; Sinon, 0.

##  <a name="queryabort"></a>  CDC::QueryAbort

Appelle la fonction d’abandon installée par la fonction membre [SETABORTPROC](#setabortproc) pour une application d’impression et demande si l’impression doit être terminée.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Valeur de retour

La valeur de retour est différente de zéro si l’impression doit se poursuivre ou s’il n’existe aucune procédure d’abandon. Elle est égale à 0 si le travail d’impression doit être arrêté. La valeur de retour est fournie par la fonction Abort.

##  <a name="realizepalette"></a>  CDC::RealizePalette

Mappe les entrées de la palette logique actuelle à la palette du système.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Valeur de retour

Indique le nombre d’entrées dans la palette logique qui ont été mappées à des entrées différentes dans la palette système. Ce nombre représente le nombre d’entrées remappées par cette fonction pour prendre en compte les modifications apportées à la palette système depuis la dernière réalisation de la palette logique.

### <a name="remarks"></a>Notes

Une palette de couleurs logique agit comme une mémoire tampon entre les applications gourmandes en couleurs et le système, ce qui permet à une application d’utiliser autant de couleurs que nécessaire sans interférer avec ses propres couleurs affichées ou avec les couleurs affichées par d’autres fenêtres.

Quand une fenêtre a le focus d’entrée et `RealizePalette`appelle, Windows s’assure que la fenêtre affiche toutes les couleurs demandées, jusqu’au nombre maximal de fois disponible sur l’écran. Windows affiche également les couleurs introuvables dans la palette de la fenêtre en les faisant correspondre aux couleurs disponibles.

En outre, Windows fait correspondre les couleurs demandées par les fenêtres inactives qui appellent la fonction le plus fidèlement possible aux couleurs disponibles. Cela réduit considérablement les modifications indésirables dans les couleurs affichées dans les fenêtres inactives.

##  <a name="rectangle"></a>  CDC::Rectangle

Dessine un rectangle à l’aide du stylet actuel.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la coordonnée x de l’angle supérieur gauche du rectangle (en unités logiques).

*y1*<br/>
Spécifie la coordonnée y de l’angle supérieur gauche du rectangle (en unités logiques).

*x2*<br/>
Spécifie la coordonnée x du coin inférieur droit du rectangle (en unités logiques).

*y2*<br/>
Spécifie la coordonnée y du coin inférieur droit du rectangle (en unités logiques).

*lpRect*<br/>
Spécifie le rectangle en unités logiques. Vous pouvez passer un `CRect` objet ou un pointeur vers une `RECT` structure pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

L’intérieur du rectangle est rempli à l’aide du pinceau actuel.

Le rectangle s’étend jusqu’à, mais n’inclut pas les coordonnées droites et inférieures. Cela signifie que la hauteur du rectangle est *Y2* - *Y1* et que la largeur du rectangle est *x2* - *x1*. La largeur et la hauteur d’un rectangle doivent être supérieures à 2 unités et inférieures à 32 767 unités.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

##  <a name="rectvisible"></a>  CDC::RectVisible

Détermine si une partie du rectangle donné se trouve dans la zone de découpage du contexte d’affichage.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Paramètres

*lpRect*<br/>
Pointe vers une `RECT` structure ou un `CRect` objet qui contient les coordonnées logiques du rectangle spécifié.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si une partie du rectangle donné se trouve dans la zone de découpage ; Sinon, 0.

##  <a name="releaseattribdc"></a>  CDC::ReleaseAttribDC

Appelez cette fonction membre pour affecter `m_hAttribDC` à la valeur null.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Notes

Cela n’entraîne pas la `Detach` survenue d’un. Seul le contexte de périphérique de sortie est attaché `CDC` à l’objet et seul il peut être détaché.

##  <a name="releaseoutputdc"></a>  CDC::ReleaseOutputDC

Appelez cette fonction membre pour affecter la `m_hDC` valeur null au membre.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Notes

Cette fonction membre ne peut pas être appelée lorsque le contexte de périphérique de sortie `CDC` est attaché à l’objet. Utilisez la `Detach` fonction membre pour détacher le contexte de périphérique de sortie.

##  <a name="resetdc"></a>  CDC::ResetDC

Appelez cette fonction membre pour mettre à jour le contexte de périphérique `CDC` encapsulé par l’objet.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Paramètres

*lpDevMode*<br/>
Pointeur vers une structure Windows `DEVMODE` .

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le contexte de périphérique (Device Context) est mis à jour `DEVMODE` à partir des informations spécifiées dans la structure Windows. Cette fonction membre réinitialise uniquement le contexte de périphérique d’attribut.

Une application utilise généralement la `ResetDC` fonction membre lorsqu’une fenêtre traite un `WM_DEVMODECHANGE` message. Vous pouvez également utiliser cette fonction membre pour modifier l’orientation du papier ou les bacs de papier lors de l’impression d’un document.

Vous ne pouvez pas utiliser cette fonction membre pour modifier le nom du pilote, le nom de l’appareil ou le port de sortie. Lorsque l’utilisateur modifie le nom de la connexion de port ou du périphérique, vous devez supprimer le contexte de périphérique d’origine et créer un nouveau contexte de périphérique avec les nouvelles informations.

Avant d’appeler cette fonction membre, vous devez vous assurer que tous les objets (autres que les objets stock) qui ont été sélectionnés dans le contexte de périphérique ont été sélectionnés.

##  <a name="restoredc"></a>  CDC::RestoreDC

Restaure le contexte de périphérique (Device Context) à l’état précédent identifié par *nSavedDC*.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Paramètres

*nSavedDC*<br/>
Spécifie le contexte de périphérique à restaurer. Il peut s’agir d’une valeur retournée `SaveDC` par un appel de fonction précédent. Si *nSavedDC* est-1, le dernier contexte de périphérique enregistré est restauré.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le contexte spécifié a été restauré ; Sinon, 0.

### <a name="remarks"></a>Notes

`RestoreDC`restaure le contexte de périphérique en dépilant les informations d’état d’une pile créée par des `SaveDC` appels antérieurs à la fonction membre.

La pile peut contenir les informations d’état de plusieurs contextes de périphérique. Si le contexte spécifié par *nSavedDC* n’est pas en haut de la pile, `RestoreDC` supprime toutes les informations d’État entre le contexte de périphérique spécifié par *nSavedDC* et le haut de la pile. Les informations supprimées sont perdues.

##  <a name="roundrect"></a>  CDC::RoundRect

Dessine un rectangle avec des angles arrondis à l’aide du stylet actuel.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Paramètres

*x1*<br/>
Spécifie la coordonnée x de l’angle supérieur gauche du rectangle (en unités logiques).

*y1*<br/>
Spécifie la coordonnée y de l’angle supérieur gauche du rectangle (en unités logiques).

*x2*<br/>
Spécifie la coordonnée x du coin inférieur droit du rectangle (en unités logiques).

*y2*<br/>
Spécifie la coordonnée y du coin inférieur droit du rectangle (en unités logiques).

*x3*<br/>
Spécifie la largeur de l’ellipse utilisée pour dessiner les angles arrondis (en unités logiques).

*y3*<br/>
Spécifie la hauteur de l’ellipse utilisée pour dessiner les angles arrondis (en unités logiques).

*lpRect*<br/>
Spécifie le rectangle englobant en unités logiques. Vous pouvez passer un `CRect` objet ou un pointeur vers une `RECT` structure pour ce paramètre.

*point*<br/>
La coordonnée x du *point* spécifie la largeur de l’ellipse pour dessiner les angles arrondis (en unités logiques). La coordonnée y du *point* spécifie la hauteur de l’ellipse pour dessiner les angles arrondis (en unités logiques). Vous pouvez passer une `POINT` structure ou un `CPoint` objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

L’intérieur du rectangle est rempli à l’aide du pinceau actuel.

La figure que cette fonction dessine s’étend jusqu’à, mais n’inclut pas les coordonnées droite et inférieure. Cela signifie que la hauteur de la figure est *Y2* - *Y1* et que la largeur de la figure est *x2* - *x1*. La hauteur et la largeur du rectangle englobant doivent être supérieures à 2 unités et inférieures à 32 767 unités.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

##  <a name="savedc"></a>  CDC::SaveDC

Enregistre l’état actuel du contexte de périphérique en copiant les informations d’État (telles que la zone de découpage, les objets sélectionnés et le mode de mappage) dans une pile de contexte gérée par Windows.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Valeur de retour

Entier identifiant le contexte de périphérique enregistré. La valeur est 0 si une erreur se produit. Cette valeur de retour peut être utilisée pour restaurer le contexte de périphérique `RestoreDC`en appelant.

### <a name="remarks"></a>Notes

Le contexte de périphérique enregistré peut être restauré ultérieurement à `RestoreDC`l’aide de.

`SaveDC`peut être utilisé un nombre quelconque de fois pour enregistrer un nombre quelconque d’États de contexte de périphérique.

##  <a name="scaleviewportext"></a>  CDC::ScaleViewportExt

Modifie les étendues de la fenêtre d’affichage par rapport aux valeurs actuelles.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Paramètres

*xNum*<br/>
Spécifie la quantité de multiplication de l’étendue x actuelle.

*xDenom*<br/>
Spécifie la quantité par laquelle diviser le résultat de la multiplication de l’étendue x actuelle par la valeur du paramètre *xNum* .

*yNum*<br/>
Spécifie la quantité de multiplication de l’étendue y actuelle.

*yDenom*<br/>
Spécifie la quantité par laquelle diviser le résultat de la multiplication de l’étendue y actuelle par la valeur du paramètre *yNum* .

### <a name="return-value"></a>Valeur de retour

Étendues de la fenêtre d’affichage précédente (en unités d' `CSize` appareil) en tant qu’objet.

### <a name="remarks"></a>Notes

Les formules sont écrites comme suit :

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

Les nouvelles étendues de la fenêtre d’affichage sont calculées en multipliant les étendues actuelles par le numérateur donné, puis en divisant par le dénominateur donné.

##  <a name="scalewindowext"></a>  CDC::ScaleWindowExt

Modifie les étendues de fenêtre par rapport aux valeurs actuelles.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Paramètres

*xNum*<br/>
Spécifie la quantité de multiplication de l’étendue x actuelle.

*xDenom*<br/>
Spécifie la quantité par laquelle diviser le résultat de la multiplication de l’étendue x actuelle par la valeur du paramètre *xNum* .

*yNum*<br/>
Spécifie la quantité de multiplication de l’étendue y actuelle.

*yDenom*<br/>
Spécifie la quantité par laquelle diviser le résultat de la multiplication de l’étendue y actuelle par la valeur du paramètre *yNum* .

### <a name="return-value"></a>Valeur de retour

Étendues de fenêtre précédentes (en unités logiques) en `CSize` tant qu’objet.

### <a name="remarks"></a>Notes

Les formules sont écrites comme suit :

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

Les nouvelles étendues de fenêtre sont calculées en multipliant les étendues actuelles par le numérateur donné, puis en divisant par le dénominateur donné.

##  <a name="scrolldc"></a>  CDC::ScrollDC

Fait défiler un rectangle de bits horizontalement et verticalement.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Paramètres

*dx*<br/>
Spécifie le nombre d’unités de défilement horizontales.

*dy*<br/>
Spécifie le nombre d’unités de défilement vertical.

*lpRectScroll*<br/>
Pointe vers la `RECT` structure ou `CRect` l’objet qui contient les coordonnées du rectangle de défilement.

*lpRectClip*<br/>
Pointe vers la `RECT` structure ou `CRect` l’objet qui contient les coordonnées du rectangle de découpage. Quand ce rectangle est plus petit que le rectangle d’origine pointé par *lpRectScroll*, le défilement se produit uniquement dans le rectangle plus petit.

*pRgnUpdate*<br/>
Identifie la région non couverte par le processus de défilement. La `ScrollDC` fonction définit cette région ; il ne s’agit pas nécessairement d’un rectangle.

*lpRectUpdate*<br/>
Pointe vers la `RECT` structure ou `CRect` l’objet qui reçoit les coordonnées du rectangle qui délimite la zone de mise à jour de défilement. Il s’agit de la plus grande zone rectangulaire qui requiert un redessin. Les valeurs de la structure ou de l’objet lorsque la fonction est retournée sont exprimées en coordonnées clientes, quel que soit le mode de mappage du contexte de périphérique donné.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro si le défilement est exécuté ; Sinon, 0.

### <a name="remarks"></a>Notes

Si *lpRectUpdate* a la valeur null, Windows ne calcule pas le rectangle de mise à jour. Si *pRgnUpdate* et *lpRectUpdate* ont tous les deux la valeur null, Windows ne calcule pas la région de mise à jour. Si *pRgnUpdate* n’a pas la valeur null, Windows suppose qu’il contient un pointeur valide vers la région non couverte par le processus de défilement (défini par `ScrollDC` la fonction membre). La région de mise à jour retournée dans lpRectUpdate `CWnd::InvalidateRgn` peut être passée à si nécessaire.

Une application doit utiliser la `ScrollWindow` fonction membre de la `CWnd` classe quand il est nécessaire de faire défiler la totalité de la zone client d’une fenêtre. Dans le cas contraire, `ScrollDC`elle doit utiliser.

##  <a name="selectclippath"></a>  CDC::SelectClipPath

Sélectionne le chemin d’accès actuel comme zone de découpage pour le contexte de périphérique, en combinant la nouvelle région avec une région de découpage existante à l’aide du mode spécifié.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Paramètres

*nMode*<br/>
Spécifie la façon d’utiliser le chemin d’accès. Les valeurs suivantes sont autorisées :

- RGN_AND la nouvelle zone de découpage comprend l’intersection (zones qui se chevauchent) de la zone de découpage actuelle et du chemin d’accès actuel.

- RGN_COPY la nouvelle zone de découpage est le chemin d’accès actuel.

- RGN_DIFF la nouvelle zone de découpage comprend les zones de la zone de découpage active et celles du chemin d’accès actuel sont exclues.

- RGN_OR la nouvelle zone de découpage comprend l’Union (zones combinées) de la zone de découpage actuelle et le chemin d’accès actuel.

- RGN_XOR la nouvelle zone de découpage comprend l’Union de la zone de découpage actuelle et du chemin d’accès actuel, mais sans les zones qui se chevauchent.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le contexte de périphérique identifié doit contenir un chemin d’accès fermé.

##  <a name="selectcliprgn"></a>  CDC::SelectClipRgn

Sélectionne la région donnée comme zone de découpage actuelle pour le contexte de périphérique.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Paramètres

*pRgn*<br/>
Identifie la région à sélectionner.

- Pour la première version de cette fonction, si cette valeur est NULL, la totalité de la zone client est sélectionnée et la sortie est encore tronquée dans la fenêtre.

- Pour la deuxième version de cette fonction, ce descripteur peut être NULL uniquement lorsque le mode RGN_COPY est spécifié.

*nMode*<br/>
Spécifie l’opération à effectuer. Il doit s’agir de l’une des valeurs suivantes :

- RGN_AND la nouvelle zone de découpage associe les zones qui se chevauchent de la zone de découpage actuelle et la région identifiée par *pRgn*.

- RGN_COPY la nouvelle zone de découpage est une copie de la région identifiée par *pRgn*. Cette fonctionnalité est identique à la première version de `SelectClipRgn`. Si la région identifiée par *pRgn* est null, la nouvelle zone de découpage devient la zone de découpage par défaut (une région null).

- RGN_DIFF la nouvelle région de découpage associe les zones de la région de découpage actuelle aux zones exclues de la région identifiée par *pRgn*.

- RGN_OR la nouvelle région de découpage associe la zone de découpage actuelle et la région identifiée par *pRgn*.

- RGN_XOR la nouvelle région de découpage associe la zone de découpage actuelle et la région identifiée par *pRgn* , mais exclut toutes les zones qui se chevauchent.

### <a name="return-value"></a>Valeur de retour

Type de la région. Il peut s’agir de l’une des valeurs suivantes :

- COMPLEXREGION nouvelle zone de découpage a des bordures qui se chevauchent.

- Le contexte ou la région de l’appareil d’erreur n’est pas valide.

- NULLREGION nouvelle zone de découpage est vide.

- SIMPLEREGION nouvelle zone de découpage n’a pas de bordures se chevauchant.

### <a name="remarks"></a>Notes

Seule une copie de la région sélectionnée est utilisée. La région elle-même peut être sélectionnée pour un nombre quelconque d’autres contextes de périphérique, ou elle peut être supprimée.

La fonction suppose que les coordonnées de la région donnée sont spécifiées en unités de périphérique. Certains périphériques d’impression prennent en charge la sortie de texte à une résolution supérieure à celle des graphiques en sortie afin de conserver la précision nécessaire pour exprimer les mesures de texte. Ces appareils signalent les unités de périphérique à la résolution supérieure, c’est-à-dire en unités de texte. Ces appareils adaptent ensuite les coordonnées des graphiques de sorte que plusieurs unités de périphérique signalées correspondent uniquement à 1 unité graphique. Vous devez toujours appeler la `SelectClipRgn` fonction à l’aide d’unités de texte.

Les applications qui doivent prendre la mise à l’échelle des objets Graphics dans le GDI peuvent utiliser l’échappement de l’imprimante GETSCALINGFACTOR pour déterminer le facteur d’échelle. Ce facteur d’échelle affecte le découpage. Si une région est utilisée pour découper des graphiques, GDI divise les coordonnées par le facteur d’échelle. Si la région est utilisée pour découper du texte, GDI n’effectue aucun ajustement de mise à l’échelle. Un facteur d’échelle de 1 entraîne le fractionnement des coordonnées par 2 ; un facteur d’échelle de 2 entraîne le fractionnement des coordonnées par 4 ; et ainsi de suite.

##  <a name="selectobject"></a>  CDC::SelectObject

Sélectionne un objet dans le contexte de périphérique.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Paramètres

*pPen*<br/>
Pointeur vers un objet [CPen](../../mfc/reference/cpen-class.md) à sélectionner.

*pBrush*<br/>
Pointeur vers un objet [CBrush](../../mfc/reference/cbrush-class.md) à sélectionner.

*pFont*<br/>
Pointeur vers un objet [CFont](../../mfc/reference/cfont-class.md) à sélectionner.

*pBitmap*<br/>
Pointeur vers un objet [CBitmap](../../mfc/reference/cbitmap-class.md) à sélectionner.

*pRgn*<br/>
Pointeur vers un objet [CRgn](../../mfc/reference/crgn-class.md) à sélectionner.

*pObject*<br/>
Pointeur vers un objet [CGdiObject](../../mfc/reference/cgdiobject-class.md) à sélectionner.

### <a name="return-value"></a>Valeur de retour

Pointeur vers l’objet qui est remplacé. Il s’agit d’un pointeur vers un objet de l’une des classes `CGdiObject`dérivées de `CPen`, telles que, en fonction de la version de la fonction qui est utilisée. La valeur de retour est NULL en cas d’erreur. Cette fonction peut retourner un pointeur vers un objet temporaire. Cet objet temporaire n’est valide que pendant le traitement d’un message Windows. Pour plus d'informations, consultez `CGdiObject::FromHandle`.

La version de la fonction membre qui prend un paramètre region effectue la même tâche que la `SelectClipRgn` fonction membre. Sa valeur de retour peut être l’une des suivantes :

- COMPLEXREGION nouvelle zone de découpage a des bordures qui se chevauchent.

- Le contexte ou la région de l’appareil d’erreur n’est pas valide.

- NULLREGION nouvelle zone de découpage est vide.

- SIMPLEREGION nouvelle zone de découpage n’a pas de bordures se chevauchant.

### <a name="remarks"></a>Notes

La `CDC` classe fournit cinq versions spécialisées pour des genres particuliers d’objets GDI, y compris des stylets, des pinceaux, des polices, des bitmaps et des régions. Le nouvel objet sélectionné remplace l’objet précédent du même type. Par exemple, si *pObject* de la version générale de `SelectObject` pointe vers un objet [CPen](../../mfc/reference/cpen-class.md) , la fonction remplace le stylet actuel par le stylet spécifié par *pObject*.

Une application peut sélectionner une image bitmap dans des contextes de périphérique mémoire uniquement et dans un seul contexte de périphérique de mémoire à la fois. Le format de la bitmap doit être monochrome ou compatible avec le contexte de périphérique. Si ce n’est pas `SelectObject` le cas, retourne une erreur.

Pour Windows 3,1 et versions ultérieures `SelectObject` , la fonction retourne la même valeur, qu’elle soit utilisée dans un métafichier ou non. Dans les versions précédentes de Windows `SelectObject` , a retourné une valeur différente de zéro pour Success et 0 en cas d’échec lors de son utilisation dans un métafichier.

##  <a name="selectpalette"></a>  CDC::SelectPalette

Sélectionne la palette logique spécifiée par *pPalette* comme objet palette sélectionné du contexte de périphérique.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Paramètres

*pPalette*<br/>
Identifie la palette logique à sélectionner. Cette palette doit déjà avoir été créée à l' `CPalette` aide de la fonction membre [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).

*bForceBackground*<br/>
Spécifie si la palette logique est forcée à être une palette d’arrière-plan. Si *bForceBackground* est différent de zéro, la palette sélectionnée est toujours une palette d’arrière-plan, même si la fenêtre a le focus d’entrée. Si *bForceBackground* a la valeur 0 et que le contexte de périphérique est attaché à une fenêtre, la palette logique est une palette de premier plan lorsque la fenêtre a le focus d’entrée.

### <a name="return-value"></a>Valeur de retour

Pointeur vers un `CPalette` objet identifiant la palette logique remplacée par la palette spécifiée par *pPalette*. La valeur est NULL en cas d’erreur.

### <a name="remarks"></a>Notes

La nouvelle palette devient l’objet palette utilisé par GDI pour contrôler les couleurs affichées dans le contexte de périphérique et remplace la palette précédente.

Une application peut sélectionner une palette logique dans plusieurs contextes de périphérique. Toutefois, les modifications apportées à une palette logique affectent tous les contextes de l’appareil pour lesquels elle est sélectionnée. Si une application sélectionne une palette dans plus d’un contexte de périphérique, les contextes de périphérique doivent tous appartenir au même appareil physique.

##  <a name="selectstockobject"></a>  CDC::SelectStockObject

Sélectionne un objet [CGdiObject](../../mfc/reference/cgdiobject-class.md) qui correspond à l’un des stylets, pinceaux ou polices prédéfinis.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
Spécifie le type d’objet stock souhaité. Il peut s’agir de l’une des valeurs suivantes:

- Pinceau noir BLACK_BRUSH.

- Pinceau gris foncé DKGRAY_BRUSH.

- Pinceau gris GRAY_BRUSH.

- Pinceau creux HOLLOW_BRUSH.

- Pinceau gris clair LTGRAY_BRUSH.

- Pinceau null NULL_BRUSH.

- Pinceau blanc WHITE_BRUSH.

- Stylet noir BLACK_PEN.

- NULL_PEN stylet null.

- Crayon blanc WHITE_PEN.

- Police système fixe ANSI ANSI_FIXED_FONT.

- Police système de variable ANSI ANSI_VAR_FONT.

- DEVICE_DEFAULT_FONT police dépendante de l’appareil.

- Police fixe dépendante de OEM_FIXED_FONT OEM.

- SYSTEM_FONT la police système. Par défaut, Windows utilise la police système pour dessiner des menus, des contrôles de boîte de dialogue et d’autres textes. Toutefois, il est préférable de ne pas compter sur SYSTEM_FONT pour obtenir la police utilisée par les boîtes de dialogue et les fenêtres. Utilisez plutôt la `SystemParametersInfo` fonction avec le paramètre SPI_GETNONCLIENTMETRICS pour récupérer la police actuelle. `SystemParametersInfo`prend en compte le thème actuel et fournit des informations de police pour les légendes, les menus et les boîtes de dialogue de message.

- SYSTEM_FIXED_FONT la police système de largeur fixe utilisée dans Windows antérieures à la version 3,0. Cet objet est disponible pour la compatibilité avec les versions antérieures de Windows.

- PALETTE de couleurs par défaut DEFAULT_PALETTE. Cette palette se compose des 20 couleurs statiques dans la palette du système.

### <a name="return-value"></a>Valeur de retour

Pointeur vers l' `CGdiObject` objet qui a été remplacé si la fonction réussit. L’objet réel pointé est un objet [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md)ou [CFont](../../mfc/reference/cfont-class.md) . Si l’appel échoue, la valeur de retour est NULL.

##  <a name="setabortproc"></a>  CDC::SetAbortProc

Installe la procédure d’abandon pour le travail d’impression.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Paramètres

*lpfn*<br/>
Pointeur vers la fonction Abort à installer comme procédure d’abandon. Pour plus d’informations sur la fonction de rappel, consultez [fonction de rappel pour CDC :: SETABORTPROC](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Valeur de retour

Spécifie le résultat de `SetAbortProc` la fonction. Certaines des valeurs suivantes sont plus probables que d’autres, mais toutes sont possibles.

- Erreur générale SP_ERROR.

- SP_OUTOFDISK espace disque insuffisant est actuellement disponible pour la mise en file d’attente, et aucun espace supplémentaire n’est disponible.

- SP_OUTOFMEMORY mémoire disponible est insuffisante pour la mise en file d’attente.

- L’utilisateur SP_USERABORT a terminé le travail par le biais du gestionnaire d’impression.

### <a name="remarks"></a>Notes

Si une application est autorisée à annuler le travail d’impression pendant la mise en file d’attente, elle doit définir la fonction Abort avant le démarrage du travail d’impression avec la fonction membre [StartDoc](#startdoc) . Le gestionnaire d’impression appelle la fonction d’abandon pendant la mise en file d’attente pour permettre à l’application d’annuler le travail d’impression ou de traiter des conditions d’espace disque insuffisant. Si aucune fonction d’abandon n’est définie, le travail d’impression échoue s’il n’y a pas assez d’espace disque pour la mise en file d’attente.

Notez que les fonctionnalités de Microsoft Visual C++ simplifient la création de la fonction de rappel `SetAbortProc`transmise à. L’adresse passée à la `EnumObjects` fonction membre est un pointeur vers une fonction exportée avec `__declspec(dllexport)` et `__stdcall` avec la Convention d’appel.

Vous n’avez pas non plus besoin d’exporter le nom de la fonction dans une instruction **exports** dans le fichier de définition de module de votre application. Vous pouvez utiliser à la place le modificateur de fonction d' **exportation** , comme dans

**bool-exporter le rappel** AFunction ( **HDC**, `int` **);**

pour forcer le compilateur à émettre l’enregistrement d’exportation approprié pour l’exportation par nom sans alias. Cela fonctionne pour la plupart des besoins. Dans certains cas spéciaux, tels que l’exportation d’une fonction par ordinal ou l’utilisation d’un alias pour l’exportation, vous devez toujours utiliser une instruction **exports** dans un fichier de définition de module.

Les interfaces d’inscription de rappel sont désormais de type sécurisé (vous devez passer un pointeur de fonction qui pointe vers le type de fonction approprié pour le rappel spécifique).

Notez également que toutes les fonctions de rappel doivent intercepter les exceptions Microsoft Foundation avant de retourner à Windows, car les exceptions ne peuvent pas être levées au-delà des limites de rappel. Pour plus d’informations sur les exceptions, consultez l’article [exceptions](../../mfc/exception-handling-in-mfc.md).

##  <a name="setarcdirection"></a>  CDC::SetArcDirection

Définit la direction de dessin à utiliser pour les fonctions d’arc et de rectangle.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Paramètres

*nArcDirection*<br/>
Spécifie la nouvelle direction de l’arc. Ce paramètre peut prendre l’une des valeurs suivantes :

- AD_COUNTERCLOCKWISE dessinées à gauche.

- AD_CLOCKWISE dessinées dans le sens des aiguilles d’une montre.

### <a name="return-value"></a>Valeur de retour

Spécifie l’ancien sens de l’arc, en cas de réussite ; Sinon, 0.

### <a name="remarks"></a>Notes

La direction par défaut est le sens inverse des aiguilles d’une passe. La `SetArcDirection` fonction spécifie le sens dans lequel les fonctions suivantes dessinent :

|Arc|Graphique à secteurs|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

##  <a name="setattribdc"></a>  CDC::SetAttribDC

Appelez cette fonction pour définir le contexte de périphérique d' `m_hAttribDC`attribut,.

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Paramètres

*hDC*<br/>
Contexte de périphérique Windows.

### <a name="remarks"></a>Notes

Cette fonction membre n’attache pas le contexte de périphérique à `CDC` l’objet. Seul le contexte de périphérique de sortie est attaché `CDC` à un objet.

##  <a name="setbkcolor"></a>  CDC::SetBkColor

Affecte la couleur spécifiée à la couleur d’arrière-plan actuelle.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*crColor*<br/>
Spécifie la nouvelle couleur d’arrière-plan.

### <a name="return-value"></a>Valeur de retour

Couleur d’arrière-plan précédente sous la forme d’une valeur de couleur RVB. Si une erreur se produit, la valeur de retour est 0x80000000.

### <a name="remarks"></a>Notes

Si le mode d’arrière-plan est OPAQUE, le système utilise la couleur d’arrière-plan pour remplir les espaces dans les lignes stylisées, les intervalles entre les lignes hachurées dans les pinceaux et l’arrière-plan dans les cellules de caractères. Le système utilise également la couleur d’arrière-plan lors de la conversion de bitmaps entre des contextes de périphérique de couleur et monochrome.

Si l’appareil ne peut pas afficher la couleur spécifiée, le système définit la couleur d’arrière-plan sur la couleur physique la plus proche.

##  <a name="setbkmode"></a>  CDC::SetBkMode

Définit le mode d’arrière-plan.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Paramètres

*nBkMode*<br/>
Spécifie le mode à définir. Ce paramètre peut prendre l’une des valeurs suivantes :

- L’arrière-plan OPAQUE est rempli avec la couleur d’arrière-plan actuelle avant le dessin du texte, du pinceau hachuré ou du stylet. Il s’agit du mode d’arrière-plan par défaut.

- L’arrière-plan TRANSPARENT n’est pas modifié avant le dessin.

### <a name="return-value"></a>Valeur de retour

Mode d’arrière-plan précédent.

### <a name="remarks"></a>Notes

Le mode arrière-plan définit si le système supprime les couleurs d’arrière-plan existantes sur la surface de dessin avant de dessiner du texte, des pinceaux hachurés ou n’importe quel style de stylet qui n’est pas une ligne pleine.

### <a name="example"></a>Exemple

  Consultez l’exemple de [CWnd :: OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

##  <a name="setboundsrect"></a>  CDC::SetBoundsRect

Contrôle l’accumulation des informations de rectangle englobant pour le contexte de périphérique spécifié.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Paramètres

*lpRectBounds*<br/>
Pointe vers une `RECT` structure ou `CRect` un objet utilisé pour définir le rectangle englobant. Les dimensions du rectangle sont indiquées en coordonnées logiques. Ce paramètre peut avoir la valeur NULL.

*flags*<br/>
Spécifie la manière dont le nouveau rectangle sera combiné avec le rectangle accumulé. Ce paramètre peut être une combinaison des valeurs suivantes :

- DCB_ACCUMULATE ajouter le rectangle spécifié par *lpRectBounds* au rectangle englobant (à l’aide d’une opération d’Union rectangle).

- DCB_DISABLE désactive l’accumulation de limites.

- DCB_ENABLE activer l’accumulation de limites. (Le paramètre par défaut pour l’accumulation de limites est désactivé.)

### <a name="return-value"></a>Valeur de retour

État actuel du rectangle englobant, si la fonction réussit. Comme les *indicateurs*, la valeur de retour peut être une combinaison de valeurs **DCB_** :

- DCB_ACCUMULATE le rectangle englobant n’est pas vide. Cette valeur sera toujours définie.

- L’accumulation de limites DCB_DISABLE est désactivée.

- L’accumulation de limites DCB_ENABLE est activée.

### <a name="remarks"></a>Notes

Windows peut conserver un rectangle englobant pour toutes les opérations de dessin. Ce rectangle peut être interrogé et réinitialisé par l’application. Les limites de dessin sont utiles pour l’invalidation des caches bitmap.

##  <a name="setbrushorg"></a>  CDC::SetBrushOrg

Spécifie l’origine que GDI assignera au pinceau suivant que l’application sélectionne dans le contexte de périphérique.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x (en unités de périphérique) de la nouvelle origine. Cette valeur doit être comprise dans la plage 0-7.

*y*<br/>
Spécifie la coordonnée y (en unités de périphérique) de la nouvelle origine. Cette valeur doit être comprise dans la plage 0-7.

*point*<br/>
Spécifie les coordonnées x et y de la nouvelle origine. Chaque valeur doit être comprise dans la plage 0-7. Vous pouvez passer une `POINT` structure ou un `CPoint` objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Origine précédente du pinceau dans les unités de périphérique.

### <a name="remarks"></a>Notes

Les coordonnées par défaut de l’origine du pinceau sont (0,0). Pour modifier l’origine d’un pinceau, appelez la `UnrealizeObject` fonction pour l' `CBrush` objet, appelez `SetBrushOrg`, puis appelez la `SelectObject` fonction membre pour sélectionner le pinceau dans le contexte de périphérique.

N’utilisez `SetBrushOrg` pas avec des `CBrush` objets stock.

##  <a name="setcoloradjustment"></a>  CDC::SetColorAdjustment

Définit les valeurs de réglage des couleurs pour le contexte de périphérique à l’aide des valeurs spécifiées.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Paramètres

*lpColorAdjust*<br/>
Pointe vers une structure de données [coloradjustment,](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) contenant les valeurs de réglage des couleurs.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Les valeurs de réglage des couleurs sont utilisées pour ajuster la couleur d’entrée de la bitmap source pour `CDC::StretchBlt` les appels à la fonction membre lorsque le mode de demi-teinte est défini.

##  <a name="setdcbrushcolor"></a>  CDC::SetDCBrushColor

Définit la couleur actuelle du pinceau de contexte de périphérique (DC) sur la valeur de couleur spécifiée.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*crColor*<br/>
Spécifie la nouvelle couleur du pinceau.

### <a name="return-value"></a>Valeur de retour

Si la fonction est réussie, la valeur de retour spécifie la couleur de pinceau DC précédente comme valeur COLORREF.

Si la fonction échoue, la valeur de retour est CLR_INVALID.

### <a name="remarks"></a>Notes

Cette méthode émule les fonctionnalités de la fonction [SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor), comme décrit dans la SDK Windows.

##  <a name="setdcpencolor"></a>  CDC::SetDCPenColor

Définit la couleur du stylet du contexte de périphérique (DC) actuel sur la valeur de couleur spécifiée.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*crColor*<br/>
Spécifie la nouvelle couleur du stylet.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction membre utilise la fonction Win32 [SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor), comme décrit dans la SDK Windows.

##  <a name="setgraphicsmode"></a>  CDC::SetGraphicsMode

Définit le mode graphique pour le contexte de périphérique spécifié.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Paramètres

*iMode*<br/>
Spécifie le mode graphique. Pour obtenir la liste des valeurs que ce paramètre peut prendre, consultez [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Valeur de retour

Retourne l’ancien mode graphique en cas de réussite.

Retourne 0 en cas d’échec. Pour afficher les informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Notes

Cette méthode encapsule la fonction Windows GDI [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

##  <a name="setlayout"></a>  CDC::SetLayout

Appelez cette fonction membre pour modifier la disposition du texte et des graphiques d’un contexte de périphérique de droite à gauche, la disposition standard pour les cultures telles que l’arabe et l’hébreu.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Paramètres

*dwLayout*<br/>
Indicateurs de contrôle de la disposition du contexte de périphérique et du bitmap. Il peut s’agir d’une combinaison des valeurs suivantes.

|Valeur|Signification|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Désactive toute réflexion pour les appels à [CDC :: BitBlt](#bitblt) et [CDC :: StretchBlt](#stretchblt).|
|LAYOUT_RTL|Définit la disposition horizontale par défaut de droite à gauche.|
|LAYOUT_LTR|Définit la disposition par défaut de gauche à droite.|

### <a name="return-value"></a>Valeur de retour

En cas de réussite, la disposition précédente du contexte de périphérique.

En cas d’échec, GDI_ERROR. Pour afficher les informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Notes

Normalement, vous n’appelez `SetLayout` pas pour une fenêtre. Au lieu de cela, vous contrôlez la disposition de droite à gauche dans une fenêtre en définissant les [styles de fenêtre étendus](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) , tels que WS_EX_RTLREADING. Un contexte de périphérique, tel qu’une imprimante ou un métafichier, n’hérite pas de cette disposition. La seule façon de définir le contexte de périphérique pour une disposition de droite à gauche consiste à appeler `SetLayout`.

Si vous appelez **setLayout (LAYOUT_RTL** ), `SetLayout` remplace automatiquement le mode de mappage par MM_ISOTROPIC. Par conséquent, un appel ultérieur à [GetMapMode](#getmapmode) retourne MM_ISOTROPIC au lieu de MM_TEXT.

Dans certains cas, par exemple, avec de nombreuses bitmaps, vous souhaiterez peut-être conserver la disposition de gauche à droite. Dans ces cas, affichez l’image en `BitBlt` appelant `StretchBlt`ou, puis définissez l’indicateur de contrôle bitmap pour *dwLayout* sur LAYOUT_BITMAPORIENTATIONPRESERVED.

Une fois que vous avez modifié la disposition avec l’indicateur LAYOUT_RTL, les indicateurs qui spécifient la droite ou la gauche sont inversés. Pour éviter toute confusion, vous souhaiterez peut-être définir des noms de remplacement pour les indicateurs standard. Pour obtenir la liste des noms d’autres indicateurs suggérés, consultez [setLayout](/windows/win32/api/wingdi/nf-wingdi-setlayout) dans le SDK Windows.

##  <a name="setmapmode"></a>  CDC::SetMapMode

Définit le mode de mappage.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Paramètres

*nMapMode*<br/>
Spécifie le nouveau mode de mappage. Il peut s’agir de l’une des valeurs suivantes :

- Les unités logiques MM_ANISOTROPIC sont converties en unités arbitraires à l’aide d’axes arbitrairement mis à l’échelle. Le fait de définir le mode de mappage sur MM_ANISOTROPIC ne modifie pas les paramètres de fenêtre ou de fenêtre d’affichage en cours. Pour modifier les unités, l’orientation et la mise à l’échelle, appelez les fonctions membres [SetWindowExt](#setwindowext) et [SetViewportExt](#setviewportext) .

- MM_HIENGLISH chaque unité logique est convertie en 0,001 de pouce. Le x positif est à droite ; y positif est vers le haut.

- MM_HIMETRIC chaque unité logique est convertie en 0,01 millimètres. Le x positif est à droite ; y positif est vers le haut.

- Les unités logiques MM_ISOTROPIC sont converties en unités arbitraires avec des axes identiques mis à l’échelle ; autrement dit, 1 unité le long de l’axe des x est égal à 1 unité le long de l’axe y. Utilisez les `SetWindowExt` fonctions `SetViewportExt` membres et pour spécifier les unités souhaitées et l’orientation des axes. GDI effectue les réglages nécessaires pour s’assurer que les unités x et y restent de la même taille.

- MM_LOENGLISH chaque unité logique est convertie en 0,01 de pouce. Le x positif est à droite ; y positif est vers le haut.

- MM_LOMETRIC chaque unité logique est convertie en 0,1 millimètres. Le x positif est à droite ; y positif est vers le haut.

- MM_TEXT chaque unité logique est convertie en un pixel d’appareil. Le x positif est à droite ; le positif y est inactif.

- MM_TWIPS chaque unité logique est convertie en 1/20 d’un point. (Étant donné qu’un point est 1/72 pouce, un TWIP est de 1/1440 pouce.) Le x positif est à droite ; y positif est vers le haut.

### <a name="return-value"></a>Valeur de retour

Mode de mappage précédent.

### <a name="remarks"></a>Notes

Le mode de mappage définit l’unité de mesure utilisée pour convertir les unités logiques en unités de périphérique. Il définit également l’orientation des axes x et y de l’appareil. GDI utilise le mode de mappage pour convertir les coordonnées logiques en coordonnées d’appareil appropriées. Le mode MM_TEXT permet aux applications de fonctionner en pixels de périphérique, où 1 unité est égale à 1 pixel. La taille physique d’un pixel varie d’un appareil à l’appareil.

Les modes MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC et MM_TWIPS sont utiles pour les applications qui doivent dessiner dans des unités physiquement explicites (telles que des pouces ou des millimètres). Le mode MM_ISOTROPIC garantit un proportions de 1:1, ce qui est utile quand il est important de conserver la forme exacte d’une image. Le mode MM_ANISOTROPIC permet d’ajuster les coordonnées x et y indépendamment.

> [!NOTE]
>  Si vous appelez [setLayout](#setlayout) pour remplacer le contrôleur de périphérique (DC) par une disposition de droite à gauche `SetLayout` , change automatiquement le mode de mappage en MM_ISOTROPIC.

### <a name="example"></a>Exemple

  Consultez l’exemple pour [CView :: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setmapperflags"></a>  CDC::SetMapperFlags

Modifie la méthode utilisée par le mappeur de polices lorsqu’il convertit une police logique en une police physique.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Paramètres

*dwFlag*<br/>
Spécifie si le mappeur de polices tente de faire correspondre la hauteur et la largeur de l’aspect de la police à l’appareil. Lorsque cette valeur est ASPECT_FILTERING, le Mappeur sélectionne uniquement les polices dont l’aspect x et l’aspect y correspondent exactement à ceux du périphérique spécifié.

### <a name="return-value"></a>Valeur de retour

Valeur précédente de l’indicateur de mappage de police.

### <a name="remarks"></a>Notes

Une application peut utiliser `SetMapperFlags` pour faire en sorte que le mappeur de polices tente de choisir uniquement une police physique qui correspond exactement aux proportions de l’appareil spécifié.

Une application qui utilise uniquement des polices Raster peut utiliser la `SetMapperFlags` fonction pour garantir que la police sélectionnée par le mappeur de polices est attrayante et lisible sur l’appareil spécifié. Les applications qui utilisent des polices dimensionnables (TrueType) n’utilisent `SetMapperFlags`généralement pas.

Si aucune police physique n’a un proportions qui correspond à la spécification dans la police logique, GDI choisit un nouveau proportions et sélectionne une police qui correspond à ces nouveaux proportions.

##  <a name="setmiterlimit"></a>  CDC::SetMiterLimit

Définit la limite de la longueur des jointures mitres pour le contexte de périphérique.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Paramètres

*fMiterLimit*<br/>
Spécifie la nouvelle limite d’angle pour le contexte de périphérique.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

La longueur de l’onglet est définie comme la distance à partir de l’intersection des parois de ligne à l’intérieur de la jointure jusqu’à l’intersection des parois de ligne à l’extérieur de la jointure. La limite d’angle est le rapport maximal autorisé de la longueur de l’onglet à la largeur de la ligne. La limite de pointe par défaut est 10,0.

##  <a name="setoutputdc"></a>  CDC::SetOutputDC

Appelez cette fonction membre pour définir le contexte de périphérique de `m_hDC`sortie,.

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Paramètres

*hDC*<br/>
Contexte de périphérique Windows.

### <a name="remarks"></a>Notes

Cette fonction membre peut uniquement être appelée lorsqu’un contexte de périphérique n’a pas été attaché `CDC` à l’objet. Cette fonction membre définit `m_hDC` mais n’attache pas le contexte de périphérique à `CDC` l’objet.

##  <a name="setpixel"></a>  CDC::SetPixel

Définit le pixel au point spécifié sur l’approximation la plus proche de la couleur spécifiée par *crColor*.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique du point à définir.

*y*<br/>
Spécifie la coordonnée y logique du point à définir.

*crColor*<br/>
Valeur RVB COLORREF qui spécifie la couleur utilisée pour peindre le point. Pour obtenir une description de cette valeur, consultez [COLORREF](/windows/win32/gdi/colorref) dans le SDK Windows.

*point*<br/>
Spécifie les coordonnées x et y logiques du point à définir. Vous pouvez passer une `POINT` structure ou un `CPoint` objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Valeur RVB pour la couleur que le point est effectivement peinte. Cette valeur peut être différente de celle spécifiée par *crColor* si une approximation de cette couleur est utilisée. Si la fonction échoue (si le point est en dehors de la zone de découpage), la valeur de retour est-1.

### <a name="remarks"></a>Notes

Le point doit se trouver dans la zone de découpage. Si le point n’est pas dans la zone de découpage, la fonction ne fait rien.

La fonction `SetPixel` n'est pas prise en charge par tous les périphériques. Pour déterminer si un appareil prend `SetPixel`en charge, `GetDeviceCaps` appelez la fonction membre avec l’index RasterCaps et vérifiez la valeur de retour de l’indicateur RC_BITBLT.

##  <a name="setpixelv"></a>  CDC::SetPixelV

Définit le pixel aux coordonnées spécifiées sur l’approximation la plus proche de la couleur spécifiée.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x, en unités logiques, du point à définir.

*y*<br/>
Spécifie la coordonnée y, en unités logiques, du point à définir.

*crColor*<br/>
Spécifie la couleur à utiliser pour peindre le point.

*point*<br/>
Spécifie les coordonnées x et y logiques du point à définir. Vous pouvez passer une structure de données de [point](/windows/win32/api/windef/ns-windef-point) ou un objet [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le point doit être à la fois dans la zone de découpage et dans la partie visible de la surface de l’appareil. Tous les appareils ne prennent pas en charge la fonction membre. Pour plus d’informations, consultez la fonctionnalité RC_BITBLT dans `CDC::GetDeviceCaps` la fonction membre. `SetPixelV`est plus rapide `SetPixel` que parce qu’il n’a pas besoin de retourner la valeur de couleur du point réellement peint.

##  <a name="setpolyfillmode"></a>  CDC::SetPolyFillMode

Définit le mode de remplissage du polygone.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Paramètres

*nPolyFillMode*<br/>
Spécifie le nouveau mode de remplissage. Cette valeur peut être alternative ou enroulement. Le mode par défaut défini dans Windows est alternatif.

### <a name="return-value"></a>Valeur de retour

Mode de remplissage précédent, en cas de réussite ; Sinon, 0.

### <a name="remarks"></a>Notes

Lorsque le mode de remplissage polygone est alternatif, le système remplit la zone entre les côtés de polygones numérotés et pairs sur chaque ligne de numérisation. Autrement dit, le système remplit la zone entre le premier et le deuxième côté, entre le troisième et le quatrième côté, et ainsi de suite. Ce mode est le mode par défaut.

Lorsque le mode de remplissage de polygone est en cours d’enroulement, le système utilise la direction dans laquelle une figure a été dessinée pour déterminer s’il faut remplir une zone. Chaque segment de ligne d’un polygone est dessiné dans le sens horaire ou dans le sens inverse des aiguilles d’une montre. Chaque fois qu’une ligne imaginaire dessinée à partir d’une zone fermée à l’extérieur d’une figure passe par un segment de ligne dans le sens des aiguilles d’une montre, un nombre est incrémenté. Lorsque la ligne passe par un segment de ligne dans le sens inverse, le nombre est décrémenté. La zone est remplie si le nombre est différent de zéro lorsque la ligne atteint l’extérieur de la figure.

##  <a name="setrop2"></a>  CDC::SetROP2

Définit le mode de dessin actuel.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Paramètres

*nDrawMode*<br/>
Spécifie le nouveau mode dessin. Il peut s’agir de l’une des valeurs suivantes :

- R2_BLACK pixel est toujours noir.

- R2_WHITE pixel est toujours blanc.

- R2_NOP pixel reste inchangé.

- R2_NOT pixel est l’inverse de la couleur de l’écran.

- R2_COPYPEN pixel est la couleur du stylet.

- R2_NOTCOPYPEN pixel est l’inverse de la couleur du stylet.

- R2_MERGEPENNOT pixel est une combinaison de la couleur du stylet et de l’inverse de la couleur de l’écran (pixel final = (pas de pixels de l’écran) ou du stylet).

- R2_MASKPENNOT pixel est une combinaison des couleurs communes au stylet et à l’inverse de l’écran (pixel final = (et non pas à l’écran) et Pen).

- R2_MERGENOTPEN pixel est une combinaison de la couleur de l’écran et de l’inverse de la couleur du stylet (pixel final = (non Pen) ou pixel de l’écran).

- R2_MASKNOTPEN pixel est une combinaison de couleurs communes à l’écran et à l’inverse du stylet (pixel final = (et non Pen) et pixel d’écran).

- R2_MERGEPEN pixel est une combinaison de la couleur du stylet et de la couleur de l’écran (pixel final = stylet ou pixel de l’écran).

- R2_NOTMERGEPEN pixel est l’inverse de la couleur de R2_MERGEPEN (pixel final = NOT (Pen ou Screen pixel)).

- R2_MASKPEN pixel est une combinaison de couleurs communes à la plume et à l’écran (pixel final = stylet et pixel d’écran).

- R2_NOTMASKPEN pixel est l’inverse de la couleur R2_MASKPEN (pixel final = NOT (stylet et pixel de l’écran)).

- R2_XORPEN pixel est une combinaison des couleurs qui se trouvent dans le stylet ou dans l’écran, mais pas dans les deux (pixel final = pixel XOR de l’écran).

- R2_NOTXORPEN pixel est l’inverse de la couleur de R2_XORPEN (pixel final = NOT (pixel XOR Screen pixel)).

### <a name="return-value"></a>Valeur de retour

Mode de dessin précédent.

Il peut s’agir de l’une des valeurs indiquées dans la SDK Windows.

### <a name="remarks"></a>Notes

Le mode dessin spécifie la manière dont les couleurs du stylet et de l’intérieur des objets remplis sont combinées avec la couleur déjà présente dans la surface d’affichage.

Le mode dessin est destiné aux appareils raster uniquement. elle ne s’applique pas aux périphériques vectoriels. Les modes de dessin sont des codes d’opération Raster binaires représentant toutes les combinaisons booléennes possibles de deux variables, à l’aide des opérateurs binaires et, ou, et XOR (exclusif ou), et l’opération unaire ne l’est pas.

##  <a name="setstretchbltmode"></a>  CDC::SetStretchBltMode

Définit le mode d’étirement de bitmap `StretchBlt` pour la fonction membre.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Paramètres

*nStretchMode*<br/>
Spécifie le mode d’étirement. Il peut s’agir de l’une des valeurs suivantes :

|Valeur|Description|
|-----------|-----------------|
|BLACKONWHITE|Effectue une opération booléenne AND à l’aide des valeurs de couleur pour les pixels supprimés et existants. Si la bitmap est une bitmap monochrome, ce mode conserve les pixels noirs aux dépens des pixels blancs.|
|COLORONCOLOR|Supprime les pixels. Ce mode supprime toutes les lignes de pixels éliminées sans essayer de conserver leurs informations.|
|-|Mappe les pixels du rectangle source à des blocs de pixels dans le rectangle de destination. La couleur moyenne sur le bloc de destination des pixels est proche de la couleur des pixels sources.|
||Après avoir défini le mode d’étirement de la demi-TEINTe, une application doit appeler la fonction Win32 [SetBrushOrgEx](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex) pour définir l’origine du pinceau. En cas d’échec, l’alignement du pinceau se produit.|
|STRETCH_ANDSCANS|**Windows 95/98**: Identique à BLACKONWHITE|
|STRETCH_DELETESCANS|**Windows 95/98**: Identique à COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: Identique à la demi-TEINTe.|
|STRETCH_ORSCANS|**Windows 95/98**: Identique à WHITEONBLACK|
|WHITEONBLACK|Exécute une opération OR booléenne en utilisant les valeurs de couleur pour les pixels supprimés et existants. Si la bitmap est une bitmap monochrome, ce mode conserve les pixels blancs aux dépens des pixels noirs.|

### <a name="return-value"></a>Valeur de retour

Mode d’étirement précédent. Il peut s’agir de STRETCH_ANDSCANS, STRETCH_DELETESCANS ou STRETCH_ORSCANS.

### <a name="remarks"></a>Notes

Le mode d’étirement bitmap définit la manière dont les informations sont supprimées des bitmaps compressées à l’aide de la fonction.

Les modes BLACKONWHITE (STRETCH_ANDSCANS) et WHITEONBLACK (STRETCH_ORSCANS) sont généralement utilisés pour conserver les pixels de premier plan dans les images bitmap monochrome. Le mode COLORONCOLOR (STRETCH_DELETESCANS) est généralement utilisé pour conserver la couleur dans les bitmaps de couleur.

Le mode de demi-TEINTe nécessite plus de traitement de l’image source que les trois autres modes ; elle est plus lente que les autres, mais produit des images de qualité supérieure. Notez également que `SetBrushOrgEx` doit être appelé après avoir défini le mode de demi-teinte pour éviter un mauvais alignement de pinceau.

Des modes d’étirement supplémentaires peuvent également être disponibles en fonction des fonctionnalités du pilote de périphérique.

##  <a name="settextalign"></a>  CDC::SetTextAlign

Définit les indicateurs d’alignement du texte.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Paramètres

*nFlags*<br/>
Spécifie des indicateurs d’alignement de texte. Les indicateurs spécifient la relation entre un point et un rectangle qui délimitent le texte. Le point peut être soit la position actuelle, soit les coordonnées spécifiées par une fonction de sortie de texte. Le rectangle qui délimite le texte est défini par les cellules de caractères adjacentes dans la chaîne de texte. Le paramètre *nFlags* peut être un ou plusieurs indicateurs des trois catégories suivantes. Choisissez un seul indicateur dans chaque catégorie. La première catégorie affecte l’alignement du texte sur l’axe x :

- TA_CENTER aligne le point sur le centre horizontal du rectangle englobant.

- TA_LEFT aligne le point sur le côté gauche du rectangle englobant. Il s’agit du paramètre par défaut.

- TA_RIGHT aligne le point par le côté droit du rectangle englobant.

La deuxième catégorie affecte l’alignement du texte dans l’axe y :

- TA_BASELINE aligne le point par la ligne de base de la police choisie.

- TA_BOTTOM aligne le point par le bas du rectangle englobant.

- TA_TOP aligne le point sur le haut du rectangle englobant. Il s’agit du paramètre par défaut.

La troisième catégorie détermine si la position actuelle est mise à jour lorsque le texte est écrit :

- TA_NOUPDATECP ne met pas à jour la position actuelle après chaque appel à une fonction de sortie de texte. Il s’agit du paramètre par défaut.

- TA_UPDATECP met à jour la position x actuelle après chaque appel à une fonction de sortie de texte. La nouvelle position se trouve à droite du rectangle englobant du texte. Lorsque cet indicateur est défini, les coordonnées spécifiées dans les appels `TextOut` à la fonction membre sont ignorées.

### <a name="return-value"></a>Valeur de retour

Le paramètre d’alignement de texte précédent, en cas de réussite. L’octet de poids faible contient le paramètre horizontal et l’octet de poids fort contient le paramètre vertical ; Sinon, 0.

### <a name="remarks"></a>Notes

Les `TextOut` fonctions `ExtTextOut` membres et utilisent ces indicateurs lors du positionnement d’une chaîne de texte sur un affichage ou un périphérique. Les indicateurs spécifient la relation entre un point spécifique et un rectangle qui délimite le texte. Les coordonnées de ce point sont passées en tant que paramètres `TextOut` à la fonction membre. Le rectangle qui délimite le texte est formé par les cellules de caractères adjacentes dans la chaîne de texte.

##  <a name="settextcharacterextra"></a>  CDC::SetTextCharacterExtra

Définit la quantité d’espacement entre les caractères.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Paramètres

*nCharExtra*<br/>
Spécifie la quantité d’espace supplémentaire (en unités logiques) à ajouter à chaque caractère. Si le mode de mappage actuel n' `MM_TEXT`est pas, *nCharExtra* est transformé et arrondi au pixel le plus proche.

### <a name="return-value"></a>Valeur de retour

Quantité de l’espacement entre les caractères précédent.

### <a name="remarks"></a>Notes

GDI ajoute cet espacement à chaque caractère, y compris les caractères de saut, lorsqu’il écrit une ligne de texte dans le contexte de périphérique. La valeur par défaut de la quantité d’espacement entre les caractères est 0.

##  <a name="settextcolor"></a>  CDC::SetTextColor

Affecte la couleur spécifiée à la couleur du texte.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Paramètres

*crColor*<br/>
Spécifie la couleur du texte sous la forme d’une valeur de couleur RVB.

### <a name="return-value"></a>Valeur de retour

Valeur RVB pour la couleur de texte précédente.

### <a name="remarks"></a>Notes

Le système utilise cette couleur de texte lors de l’écriture de texte dans ce contexte de périphérique et également lors de la conversion de bitmaps entre des contextes de périphérique de couleur et monochrome.

Si l’appareil ne peut pas représenter la couleur spécifiée, le système définit la couleur du texte sur la couleur physique la plus proche. La couleur d’arrière-plan d’un caractère est `SetBkColor` spécifiée `SetBkMode` par les fonctions membres et.

### <a name="example"></a>Exemple

  Consultez l’exemple de [CWnd :: OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

##  <a name="settextjustification"></a>  CDC::SetTextJustification

Ajoute de l’espace aux caractères de saut de ligne dans une chaîne.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Paramètres

*nBreakExtra*<br/>
Spécifie l’espace total supplémentaire à ajouter à la ligne de texte (en unités logiques). Si le mode de mappage actuel n' `MM_TEXT`est pas, la valeur donnée par ce paramètre est convertie en mode de mappage actuel et arrondie à l’unité de périphérique la plus proche.

*nBreakCount*<br/>
Spécifie le nombre de caractères de saut dans la ligne.

### <a name="return-value"></a>Valeur de retour

Un si la fonction réussit ; Sinon, 0.

### <a name="remarks"></a>Notes

Une application peut utiliser les `GetTextMetrics` fonctions membres pour récupérer un caractère de saut de police.

Une fois `SetTextJustification` la fonction membre appelée, un appel à une fonction de sortie de texte (telle `TextOut`que) répartit uniformément l’espace supplémentaire spécifié entre le nombre spécifié de caractères de saut. Le caractère de saut de ligne est généralement l’espace (ASCII 32), mais peut être défini par une police comme un autre caractère.

La fonction `GetTextExtent` membre est généralement utilisée avec `SetTextJustification`. `GetTextExtent`calcule la largeur d’une ligne donnée avant l’alignement. Une application peut déterminer la quantité d’espace à spécifier dans le paramètre *nBreakExtra* en soustrayant la valeur `GetTextExtent` retournée par à partir de la largeur de la chaîne après l’alignement.

La `SetTextJustification` fonction peut être utilisée pour aligner une ligne qui contient plusieurs exécutions dans différentes polices. Dans ce cas, la ligne doit être créée fragmentaire en alignant et en écrivant chaque série séparément.

Étant donné que des erreurs d’arrondi peuvent se produire pendant l’alignement, le système conserve un terme d’erreur en cours d’exécution qui définit l’erreur actuelle. Lors de l’alignement d’une ligne qui contient plusieurs `GetTextExtent` exécutions, utilise automatiquement ce terme d’erreur lorsqu’il calcule l’étendue de la prochaine exécution. Cela permet à la fonction Text-OUTPUT de fusionner l’erreur dans la nouvelle exécution.

Une fois que chaque ligne a été alignée, ce terme d’erreur doit être effacé pour empêcher son incorporation dans la ligne suivante. Le terme peut être effacé en appelant `SetTextJustification` avec *nBreakExtra* défini sur 0.

##  <a name="setviewportext"></a>  CDC::SetViewportExt

Définit les étendues x et y de la fenêtre d’affichage du contexte de périphérique.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Paramètres

*cx*<br/>
Spécifie l’étendue x de la fenêtre d’affichage (en unités de périphérique).

*cy*<br/>
Spécifie l’étendue y de la fenêtre d’affichage (en unités de périphérique).

*size*<br/>
Spécifie les étendues x et y de la fenêtre d’affichage (en unités de périphérique).

### <a name="return-value"></a>Valeur de retour

Les étendues précédentes de la fenêtre d’affichage sous la forme d’un objet [CSize](../../atl-mfc-shared/reference/csize-class.md) . Lorsqu’une erreur se produit, les coordonnées x et y de l’objet retourné `CSize` ont toutes les deux la valeur 0.

### <a name="remarks"></a>Notes

La fenêtre d’affichage, ainsi que la fenêtre de contexte de périphérique, définissent la façon dont GDI mappe les points du système de coordonnées logiques aux points dans le système de coordonnées du périphérique réel. En d’autres termes, ils définissent comment GDI convertit les coordonnées logiques en coordonnées d’appareil.

Lorsque les modes de mappage suivants sont définis, les `SetWindowExt` appels `SetViewportExt` à et sont ignorés :

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

Quand le mode MM_ISOTROPIC est défini, une application doit appeler `SetWindowExt` la fonction membre avant `SetViewportExt`d’appeler.

### <a name="example"></a>Exemple

  Consultez l’exemple pour [CView :: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setviewportorg"></a>  CDC::SetViewportOrg

Définit l’origine de la fenêtre d’affichage du contexte de périphérique.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x (en unités de périphérique) de l’origine de la fenêtre d’affichage. La valeur doit être comprise dans la plage du système de coordonnées de l’appareil.

*y*<br/>
Spécifie la coordonnée y (en unités de périphérique) de l’origine de la fenêtre d’affichage. La valeur doit être comprise dans la plage du système de coordonnées de l’appareil.

*point*<br/>
Spécifie l’origine de la fenêtre d’affichage. Les valeurs doivent être comprises dans la plage du système de coordonnées de l’appareil. Vous pouvez passer une `POINT` structure ou un `CPoint` objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Origine précédente de la fenêtre d’affichage (en coordonnées d’appareil) `CPoint` en tant qu’objet.

### <a name="remarks"></a>Notes

La fenêtre d’affichage, ainsi que la fenêtre de contexte de périphérique, définissent la façon dont GDI mappe les points du système de coordonnées logiques aux points dans le système de coordonnées du périphérique réel. En d’autres termes, ils définissent comment GDI convertit les coordonnées logiques en coordonnées d’appareil.

L’origine de la fenêtre d’affichage marque le point dans le système de coordonnées de l’appareil auquel GDI mappe l’origine de la fenêtre, un point `SetWindowOrg` dans le système de coordonnées logiques spécifié par la fonction membre. GDI mappe tous les autres points en suivant le même processus que celui requis pour mapper l’origine de la fenêtre à l’origine de la fenêtre d’affichage. Par exemple, tous les points d’un cercle autour du point de l’origine de la fenêtre se trouvent dans un cercle autour du point à l’origine de la fenêtre d’affichage. De même, tous les points d’une ligne qui passent par l’origine de la fenêtre se trouvent dans une ligne qui passe par l’origine de la fenêtre d’affichage.

### <a name="example"></a>Exemple

  Consultez l’exemple pour [CView :: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setwindowext"></a>  CDC::SetWindowExt

Définit les étendues x et y de la fenêtre associée au contexte de périphérique.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Paramètres

*cx*<br/>
Spécifie l’étendue x (en unités logiques) de la fenêtre.

*cy*<br/>
Spécifie l’étendue y (en unités logiques) de la fenêtre.

*size*<br/>
Spécifie les étendues x et y (en unités logiques) de la fenêtre.

### <a name="return-value"></a>Valeur de retour

Étendues précédentes de la fenêtre (en unités logiques) en tant `CSize` qu’objet. Si une erreur se produit, les coordonnées x et y de l’objet retourné `CSize` ont toutes les deux la valeur 0.

### <a name="remarks"></a>Notes

La fenêtre, ainsi que la fenêtre d’affichage du contexte de l’appareil, définissent la façon dont GDI mappe les points du système de coordonnées logiques aux points dans le système de coordonnées de l’appareil.

Lorsque les modes de mappage suivants sont définis, les `SetWindowExt` appels `SetViewportExt` aux fonctions et sont ignorés :

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

Quand le mode MM_ISOTROPIC est défini, une application doit appeler `SetWindowExt` la fonction membre avant `SetViewportExt`d’appeler.

### <a name="example"></a>Exemples

  Consultez l’exemple pour [CView :: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setwindoworg"></a>  CDC::SetWindowOrg

Définit l’origine de la fenêtre du contexte de périphérique.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique de la nouvelle origine de la fenêtre.

*y*<br/>
Spécifie la coordonnée y logique de la nouvelle origine de la fenêtre.

*point*<br/>
Spécifie les coordonnées logiques de la nouvelle origine de la fenêtre. Vous pouvez passer une `POINT` structure ou un `CPoint` objet pour ce paramètre.

### <a name="return-value"></a>Valeur de retour

Origine précédente de la fenêtre sous la forme `CPoint` d’un objet.

### <a name="remarks"></a>Notes

La fenêtre, ainsi que la fenêtre d’affichage du contexte de l’appareil, définissent la façon dont GDI mappe les points du système de coordonnées logiques aux points dans le système de coordonnées de l’appareil.

L’origine de la fenêtre marque le point dans le système de coordonnées logiques à partir duquel GDI mappe l’origine de la fenêtre d’affichage, un `SetWindowOrg` point dans le système de coordonnées du périphérique spécifié par la fonction. GDI mappe tous les autres points en suivant le même processus que celui requis pour mapper l’origine de la fenêtre à l’origine de la fenêtre d’affichage. Par exemple, tous les points d’un cercle autour du point de l’origine de la fenêtre se trouvent dans un cercle autour du point à l’origine de la fenêtre d’affichage. De même, tous les points d’une ligne qui passent par l’origine de la fenêtre se trouvent dans une ligne qui passe par l’origine de la fenêtre d’affichage.

##  <a name="setworldtransform"></a>  CDC::SetWorldTransform

Définit une transformation linéaire à deux dimensions entre l’espace universel et l’espace de page pour le contexte de périphérique spécifié. Cette transformation peut être utilisée pour mettre à l’échelle, faire pivoter, déformer ou traduire la sortie graphique.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Paramètres

*rXform*<br/>
Référence à une structure [XForm](/windows/win32/api/wingdi/ns-wingdi-xform) qui contient les données de transformation.

### <a name="return-value"></a>Valeur de retour

Retourne une valeur différente de zéro en cas de réussite.

Retourne 0 en cas d’échec.

Pour afficher les informations d’erreur étendues, appelez [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Notes

Cette méthode encapsule la fonction Windows GDI [SetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform).

##  <a name="startdoc"></a>  CDC::StartDoc

Informe le pilote de périphérique qu’un nouveau travail d’impression démarre et que tous les `StartPage` `EndPage` appels suivants doivent être mis en attente sous le même travail jusqu’à `EndDoc` ce qu’un appel se produise.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Paramètres

*lpDocInfo*<br/>
Pointe vers une structure [docinfo](/windows/win32/api/wingdi/ns-wingdi-docinfow) contenant le nom du fichier de document et le nom du fichier de sortie.

*lpszDocName*<br/>
Pointeur vers une chaîne contenant le nom du fichier de document.

### <a name="return-value"></a>Valeur de retour

Si la fonction est réussie, la valeur de retour est supérieure à zéro. Cette valeur correspond à l’identificateur du travail d’impression du document.

Si la fonction échoue, la valeur de retour est inférieure ou égale à zéro.

### <a name="remarks"></a>Notes

Cela permet de s’assurer que les documents d’une longueur supérieure à une page ne sont pas intercalés avec d’autres travaux.

Pour les versions 3,1 et ultérieures de Windows, cette fonction remplace l’échappement d’imprimante STARTDOC. L’utilisation de cette fonction garantit que les documents contenant plusieurs pages ne sont pas intercalés avec d’autres travaux d’impression.

`StartDoc`ne doit pas être utilisé dans les fichiers de fichier.

### <a name="example"></a>Exemple

Ce fragment de code obtient l’imprimante par défaut, ouvre un travail d’impression et met en file d’attente une page avec « Hello, World ! » sur celui-ci. Étant donné que le texte imprimé par ce code n’est pas mis à l’échelle vers les unités logiques de l’imprimante, le texte de sortie peut se trouver dans des lettres minuscules que le résultat est illisible. Les fonctions de mise à l’échelle CDC `SetMapMode`, `SetViewportOrg`telles que `SetWindowExt`, et, peuvent être utilisées pour corriger la mise à l’échelle.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

##  <a name="startpage"></a>  CDC::StartPage

Appelez cette fonction membre pour préparer le pilote d’imprimante à recevoir des données.

```
int StartPage();
```

### <a name="return-value"></a>Valeur de retour

Supérieur ou égal à 0 si la fonction réussit, ou une valeur négative si une erreur s’est produite.

### <a name="remarks"></a>Notes

`StartPage`remplace les séquences d’échappement NEWFRAME et BANDINFO.

Pour obtenir une vue d’ensemble de la séquence d’appels d’impression, consultez la fonction membre [StartDoc](#startdoc) .

Le système désactive la fonction membre `ResetDC` entre les appels à `StartPage` et `EndPage`.

### <a name="example"></a>Exemples

  Consultez l’exemple pour [CDC :: StartDoc](#startdoc).

##  <a name="stretchblt"></a>  CDC::StretchBlt

Copie une image bitmap depuis un rectangle source vers un rectangle de destination, en étirant ou en compressant le bitmap si nécessaire pour l'adapter aux dimensions du rectangle de destination.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x (en unités logiques) de l'angle supérieur gauche du rectangle de destination.

*y*<br/>
Spécifie la coordonnée y (en unités logiques) de l'angle supérieur gauche du rectangle de destination.

*nWidth*<br/>
Spécifie la largeur (en unités logiques) du rectangle de destination.

*nHeight*<br/>
Spécifie la hauteur (en unités logiques) du rectangle de destination.

*pSrcDC*<br/>
Spécifie le contexte du périphérique source.

*xSrc*<br/>
Spécifie la coordonnée x (en unités logiques) de l'angle supérieur gauche du rectangle source.

*ySrc*<br/>
Spécifie la coordonnée y (en unités logiques) de l'angle supérieur gauche du rectangle source.

*nSrcWidth*<br/>
Spécifie la largeur (en unités logiques) du rectangle source.

*nSrcHeight*<br/>
Spécifie la hauteur (en unités logiques) du rectangle source.

*dwRop*<br/>
Spécifie l'opération de rastérisation à effectuer. Le code d'une opération de rastérisation définit la façon dont GDI associe les couleurs dans les opérations de sortie qui impliquent le pinceau actuel, un éventuel bitmap source et un bitmap de destination. Ce paramètre peut avoir l'une des valeurs suivantes :

- L’effet de noir permet de transformer tout le noir de sortie.

- DSTINVERT inverse le bitmap de destination.

- MERGECOPY combine le modèle et le bitmap source à l’aide de l’opérateur booléen AND.

- MERGEPAINT combine le bitmap source inversé et le bitmap de destination à l’aide de l’opérateur booléen OR.

- NOTSRCCOPY copie le bitmap source inversé vers la destination.

- NOTSRCERASE inverse le résultat de la combinaison des bitmaps de destination et source à l’aide de l’opérateur booléen OR.

- PATCOPY copie le modèle dans le bitmap de destination.

- PATINVERT associe le bitmap de destination au modèle à l’aide de l’opérateur booléen XOR.

- PATPAINT combine le bitmap source inversé et le modèle à l’aide de l’opérateur booléen OR. Associe le résultat de cette opération au bitmap de destination à l'aide de l'opérateur booléen OR.

- SRCAND combine les pixels des bitmaps de destination et sources à l’aide de l’opérateur booléen AND.

- SRCCOPY copie le bitmap source dans le bitmap de destination.

- SRCERASE inverse le bitmap de destination et combine le résultat avec le bitmap source à l’aide de l’opérateur booléen AND.

- SRCINVERT combine les pixels des bitmaps de destination et sources à l’aide de l’opérateur booléen XOR.

- SRCPAINT combine les pixels des bitmaps de destination et sources à l’aide de l’opérateur booléen OR.

- La couleur blanche permet de transformer la sortie en blanc.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si le bitmap est dessiné ; sinon, 0.

### <a name="remarks"></a>Notes

La fonction utilise le mode d'étirement du contexte du périphérique de destination (défini par `SetStretchBltMode`) afin de savoir comment étirer ou compresser le bitmap.

La `StretchBlt` fonction déplace le bitmap à partir de l’appareil source donné par *pSrcDC* vers l’appareil de destination représenté par l’objet de contexte de périphérique dont la fonction membre est appelée. Les paramètres *xSrc*, *ySrc*, *nSrcWidth*et *nSrcHeight* définissent l’angle supérieur gauche et les dimensions du rectangle source. Les paramètres *x*, *y*, *nWidth*et *nHeight* donnent l’angle supérieur gauche et les dimensions du rectangle de destination. L’opération Raster spécifiée par *dwRop* définit la manière dont la bitmap source et les bits déjà présents sur l’appareil de destination sont combinés.

La `StretchBlt` fonction crée une image miroir d’une image bitmap si les signes des paramètres *nSrcWidth* et *nWidth* ou *nSrcHeight* et *nHeight* diffèrent. Si *nSrcWidth* et *nWidth* ont des signes différents, la fonction crée une image miroir de la bitmap le long de l’axe x. Si *nSrcHeight* et *nHeight* ont des signes différents, la fonction crée une image miroir de la bitmap le long de l’axe y.

La fonction `StretchBlt` étire ou compresse le bitmap source en mémoire, puis copie le résultat vers la destination. Si un modèle doit être fusionné avec le résultat, il ne le sera pas tant que le bitmap source étiré n'est pas copié vers la destination. Si un pinceau est utilisé, il s'agira du pinceau sélectionné dans le contexte de périphérique de destination. Les coordonnées de destination sont transformées en fonction du contexte du périphérique de destination ; les coordonnées sources sont transformées en fonction du contexte du périphérique source.

Si les bitmaps sources, les bitmaps de destination et les bitmaps de modèle n'ont pas le même format de couleur, `StretchBlt` convertit les bitmaps sources et les bitmaps de modèle pour qu'ils correspondent aux bitmaps de destination. Les couleurs de premier plan et d'arrière-plan du contexte du périphérique de destination sont utilisées dans la conversion.

Si `StretchBlt` doit convertir un bitmap monochrome en bitmap de couleur, il définit les bits blancs (1) sur la couleur d'arrière-plan et les bits noirs (0) sur la couleur de premier plan. Pour convertir la couleur en monochrome, il définit les pixels qui correspondent à la couleur d'arrière-plan sur blanc (1) et définit tous les autres pixels sur noir (0). Les couleurs de premier plan et d'arrière-plan du contexte du périphérique coloré sont utilisées.

La fonction `StretchBlt` n'est pas prise en charge par tous les périphériques. Pour déterminer si un appareil prend `StretchBlt`en charge, `GetDeviceCaps` appelez la fonction membre avec l’index RasterCaps et vérifiez la valeur de retour de l’indicateur RC_STRETCHBLT.

##  <a name="strokeandfillpath"></a>  CDC::StrokeAndFillPath

Ferme toutes les figures ouvertes dans un tracé, contourne le contour du tracé à l’aide du stylet actuel et remplit son intérieur à l’aide du pinceau actuel.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le contexte de périphérique doit contenir un chemin d’accès fermé. La `StrokeAndFillPath` fonction membre a le même effet que la fermeture de toutes les figures ouvertes dans le tracé, et le découpage et le remplissage du tracé séparément, à la différence près que la région remplie ne chevauche pas la zone rayée, même si le stylet est étendu.

##  <a name="strokepath"></a>  CDC::StrokePath

Restitue le chemin d’accès spécifié à l’aide du stylet actuel.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Le contexte de périphérique doit contenir un chemin d’accès fermé.

##  <a name="tabbedtextout"></a>  CDC::TabbedTextOut

Appelez cette fonction membre pour écrire une chaîne de caractères à l’emplacement spécifié, en développant des onglets avec les valeurs spécifiées dans le tableau des positions de taquet de tabulation.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique du point de départ de la chaîne.

*y*<br/>
Spécifie la coordonnée y logique du point de départ de la chaîne.

*lpszString*<br/>
Pointe vers la chaîne de caractères à dessiner. Vous pouvez passer un pointeur vers un tableau de caractères ou un objet [CString](../../atl-mfc-shared/reference/cstringt-class.md) pour ce paramètre.

*nCount*<br/>
Spécifie la [longueur de la chaîne](/windows/win32/gdi/specifying-length-of-text-output-string) vers laquelle pointe *lpszString*.

*nTabPositions*<br/>
Spécifie le nombre de valeurs dans le tableau de positions de taquet de tabulation.

*lpnTabStopPositions*<br/>
Pointe vers un tableau qui contient les positions de taquet de tabulation (en unités logiques). Les taquets de tabulation doivent être triés par ordre de tri ; la plus petite valeur x doit être le premier élément du tableau.

*nTabOrigin*<br/>
Spécifie la coordonnée x de la position de départ à partir de laquelle les onglets sont développés (en unités logiques).

*str*<br/>
`CString` Objet qui contient les caractères spécifiés.

### <a name="return-value"></a>Valeur de retour

Dimensions de la chaîne (en unités logiques) en tant `CSize` qu’objet.

### <a name="remarks"></a>Notes

Le texte est écrit dans la police actuellement sélectionnée. Si *nTabPositions* a la valeur 0 et que *lpnTabStopPositions* a la valeur null, les tabulations sont développées à huit fois la largeur moyenne des caractères.

Si *nTabPositions* a la valeur 1, les taquets de tabulation sont séparés par la distance spécifiée par la première valeur dans le tableau *lpnTabStopPositions* . Si le tableau *lpnTabStopPositions* contient plus d’une valeur, un taquet de tabulation est défini pour chaque valeur du tableau, jusqu’au nombre spécifié par *nTabPositions*. Le paramètre *nTabOrigin* permet à une application d’appeler `TabbedTextOut` la fonction plusieurs fois pour une seule ligne. Si l’application appelle la fonction plusieurs fois avec le *nTabOrigin* défini sur la même valeur à chaque fois, la fonction développe tous les onglets par rapport à la position spécifiée par *nTabOrigin*.

Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction. Si une application doit mettre à jour la position actuelle lorsqu’elle appelle la fonction, l’application peut appeler la fonction membre [SetTextAlign](#settextalign) avec *NFLAGS* défini sur TA_UPDATECP. Lorsque cet indicateur est défini, Windows ignore les paramètres *x* et *y* lors des appels suivants `TabbedTextOut`à, à l’aide de la position actuelle à la place.

##  <a name="textout"></a>  CDC::TextOut

Écrit une chaîne de caractères à l'emplacement spécifié à l'aide de la police sélectionnée.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Paramètres

*x*<br/>
Spécifie la coordonnée x logique du point de départ du texte.

*y*<br/>
Spécifie la coordonnée y logique du point de départ du texte.

*lpszString*<br/>
Pointe vers la chaîne de caractères à ajouter.

*nCount*<br/>
Spécifie le nombre de caractères de la chaîne.

*str*<br/>
Objet `CString` qui contient les caractères à ajouter.

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

L'origine des caractères se trouve dans l'angle supérieur gauche de la cellule de caractère. Par défaut, la position actuelle n'est pas utilisée ni mise à jour par la fonction.

Si une application doit mettre à jour la position actuelle lorsqu’elle `TextOut`appelle, l’application peut appeler `SetTextAlign` la fonction membre avec *nFlags* défini sur TA_UPDATECP. Lorsque cet indicateur est défini, Windows ignore les paramètres *x* et *y* lors des appels suivants `TextOut`à, à l’aide de la position actuelle à la place.

### <a name="example"></a>Exemple

  Consultez l’exemple pour [CDC :: BeginPath](#beginpath).

##  <a name="transparentblt"></a>  CDC::TransparentBlt

Appelez cette fonction membre pour transférer un bloc de bits des données de couleur, qui correspond à un rectangle de pixels du contexte de périphérique source spécifié, dans un contexte de périphérique de destination.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Paramètres

*xDest*<br/>
Spécifie la coordonnée x, en unités logiques, de l’angle supérieur gauche du rectangle de destination.

*yDest*<br/>
Spécifie la coordonnée y, en unités logiques, de l’angle supérieur gauche du rectangle de destination.

*nDestWidth*<br/>
Spécifie la largeur, en unités logiques, du rectangle de destination.

*nDestHeight*<br/>
Spécifie la hauteur, en unités logiques, du rectangle de destination.

*pSrcDC*<br/>
Pointeur vers le contexte de périphérique source.

*xSrc*<br/>
Spécifie la coordonnée x, en unités logiques, du rectangle source.

*ySrc*<br/>
Spécifie la coordonnée y, en unités logiques, du rectangle source.

*nSrcWidth*<br/>
Spécifie la largeur, en unités logiques, du rectangle source.

*nSrcHeight*<br/>
Spécifie la hauteur, en unités logiques, du rectangle source.

*clrTransparent*<br/>
Couleur RVB de l’image bitmap source à traiter comme transparente.

### <a name="return-value"></a>Valeur de retour

TRUE en cas de réussite, sinon FALSE.

### <a name="remarks"></a>Notes

`TransparentBlt`autorise la transparence ; autrement dit, la couleur RVB indiquée par *clrTransparent* est rendue transparente pour le transfert.

Pour plus d’informations, consultez [TransparentBlt](/windows/win32/api/wingdi/nf-wingdi-transparentblt) dans le SDK Windows.

##  <a name="updatecolors"></a>  CDC::UpdateColors

Met à jour la zone cliente du contexte de périphérique en faisant correspondre les couleurs actuelles de la zone cliente à la palette du système pixel par pixel.

```
void UpdateColors();
```

### <a name="remarks"></a>Notes

Une fenêtre inactive avec une palette logique réalisée peut appeler `UpdateColors` comme alternative au redessin de sa zone cliente lorsque la palette système change.

Pour plus d’informations sur l’utilisation des palettes de couleurs, consultez [UpdateColors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) dans le SDK Windows.

La `UpdateColors` fonction membre met généralement à jour une zone cliente plus rapidement que le rafraîchissement de la zone. Toutefois, étant donné que la fonction effectue la translation de couleur en fonction de la couleur de chaque pixel avant la modification de la palette du système, chaque appel à cette fonction entraîne une perte de précision de la couleur.

##  <a name="widenpath"></a>  CDC::WidenPath

Redéfinit le chemin d’accès actuel comme zone qui serait peinte si le tracé était tracé à l’aide du stylet actuellement sélectionné dans le contexte de périphérique.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Valeur de retour

Une valeur différente de zéro si la fonction réussit ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction est réussie uniquement si le stylet actuel est un stylet géométrique créé par la deuxième `CreatePen` version de la fonction membre, ou si le stylet est créé avec `CreatePen` la première version de et a une largeur, en unités de périphérique, supérieure à 1. Le contexte de périphérique doit contenir un chemin d’accès fermé. Toutes les courbes Bzier dans le tracé sont converties en séquences de lignes droites approchant les courbes élargies. Par conséquent, aucune courbe Bzier n’est conservée dans `WidenPath` le chemin d’accès après l’appel de.

## <a name="see-also"></a>Voir aussi

[CObject, classe](../../mfc/reference/cobject-class.md)<br/>
[Graphique hiérarchique](../../mfc/hierarchy-chart.md)<br/>
[CPaintDC, classe](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC, classe](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC, classe](../../mfc/reference/cclientdc-class.md)<br/>
[CMetaFileDC, classe](../../mfc/reference/cmetafiledc-class.md)
