---
title: CWinApp, classe
ms.date: 07/15/2019
f1_keywords:
- CWinApp
- AFXWIN/CWinApp
- AFXWIN/CWinApp::CWinApp
- AFXWIN/CWinApp::AddDocTemplate
- AFXWIN/CWinApp::AddToRecentFileList
- AFXWIN/CWinApp::ApplicationRecoveryCallback
- AFXWIN/CWinApp::CloseAllDocuments
- AFXWIN/CWinApp::CreatePrinterDC
- AFXWIN/CWinApp::DelRegTree
- AFXWIN/CWinApp::DoMessageBox
- AFXWIN/CWinApp::DoWaitCursor
- AFXWIN/CWinApp::EnableD2DSupport
- AFXWIN/CWinApp::EnableHtmlHelp
- AFXWIN/CWinApp::EnableTaskbarInteraction
- AFXWIN/CWinApp::ExitInstance
- AFXWIN/CWinApp::GetApplicationRecoveryParameter
- AFXWIN/CWinApp::GetApplicationRecoveryPingInterval
- AFXWIN/CWinApp::GetApplicationRestartFlags
- AFXWIN/CWinApp::GetAppRegistryKey
- AFXWIN/CWinApp::GetDataRecoveryHandler
- AFXWIN/CWinApp::GetFirstDocTemplatePosition
- AFXWIN/CWinApp::GetHelpMode
- AFXWIN/CWinApp::GetNextDocTemplate
- AFXWIN/CWinApp::GetPrinterDeviceDefaults
- AFXWIN/CWinApp::GetProfileBinary
- AFXWIN/CWinApp::GetProfileInt
- AFXWIN/CWinApp::GetProfileString
- AFXWIN/CWinApp::GetSectionKey
- AFXWIN/CWinApp::HideApplication
- AFXWIN/CWinApp::HtmlHelp
- AFXWIN/CWinApp::InitInstance
- AFXWIN/CWinApp::IsTaskbarInteractionEnabled
- AFXWIN/CWinApp::LoadCursor
- AFXWIN/CWinApp::LoadIcon
- AFXWIN/CWinApp::LoadOEMCursor
- AFXWIN/CWinApp::LoadOEMIcon
- AFXWIN/CWinApp::LoadStandardCursor
- AFXWIN/CWinApp::LoadStandardIcon
- AFXWIN/CWinApp::OnDDECommand
- AFXWIN/CWinApp::OnIdle
- AFXWIN/CWinApp::OpenDocumentFile
- AFXWIN/CWinApp::ParseCommandLine
- AFXWIN/CWinApp::PreTranslateMessage
- AFXWIN/CWinApp::ProcessMessageFilter
- AFXWIN/CWinApp::ProcessShellCommand
- AFXWIN/CWinApp::ProcessWndProcException
- AFXWIN/CWinApp::Register
- AFXWIN/CWinApp::RegisterWithRestartManager
- AFXWIN/CWinApp::ReopenPreviousFilesAtRestart
- AFXWIN/CWinApp::RestartInstance
- AFXWIN/CWinApp::RestoreAutosavedFilesAtRestart
- AFXWIN/CWinApp::Run
- AFXWIN/CWinApp::RunAutomated
- AFXWIN/CWinApp::RunEmbedded
- AFXWIN/CWinApp::SaveAllModified
- AFXWIN/CWinApp::SelectPrinter
- AFXWIN/CWinApp::SetHelpMode
- AFXWIN/CWinApp::SupportsApplicationRecovery
- AFXWIN/CWinApp::SupportsAutosaveAtInterval
- AFXWIN/CWinApp::SupportsAutosaveAtRestart
- AFXWIN/CWinApp::SupportsRestartManager
- AFXWIN/CWinApp::Unregister
- AFXWIN/CWinApp::WinHelp
- AFXWIN/CWinApp::WriteProfileBinary
- AFXWIN/CWinApp::WriteProfileInt
- AFXWIN/CWinApp::WriteProfileString
- AFXWIN/CWinApp::EnableShellOpen
- AFXWIN/CWinApp::LoadStdProfileSettings
- AFXWIN/CWinApp::OnContextHelp
- AFXWIN/CWinApp::OnFileNew
- AFXWIN/CWinApp::OnFileOpen
- AFXWIN/CWinApp::OnFilePrintSetup
- AFXWIN/CWinApp::OnHelp
- AFXWIN/CWinApp::OnHelpFinder
- AFXWIN/CWinApp::OnHelpIndex
- AFXWIN/CWinApp::OnHelpUsing
- AFXWIN/CWinApp::RegisterShellFileTypes
- AFXWIN/CWinApp::SetAppID
- AFXWIN/CWinApp::SetRegistryKey
- AFXWIN/CWinApp::UnregisterShellFileTypes
- AFXWIN/CWinApp::m_bHelpMode
- AFXWIN/CWinApp::m_eHelpType
- AFXWIN/CWinApp::m_hInstance
- AFXWIN/CWinApp::m_lpCmdLine
- AFXWIN/CWinApp::m_nCmdShow
- AFXWIN/CWinApp::m_pActiveWnd
- AFXWIN/CWinApp::m_pszAppID
- AFXWIN/CWinApp::m_pszAppName
- AFXWIN/CWinApp::m_pszExeName
- AFXWIN/CWinApp::m_pszHelpFilePath
- AFXWIN/CWinApp::m_pszProfileName
- AFXWIN/CWinApp::m_pszRegistryKey
- AFXWIN/CWinApp::m_dwRestartManagerSupportFlags
- AFXWIN/CWinApp::m_nAutosaveInterval
- AFXWIN/CWinApp::m_pDataRecoveryHandler
helpviewer_keywords:
- CWinApp [MFC], CWinApp
- CWinApp [MFC], AddDocTemplate
- CWinApp [MFC], AddToRecentFileList
- CWinApp [MFC], ApplicationRecoveryCallback
- CWinApp [MFC], CloseAllDocuments
- CWinApp [MFC], CreatePrinterDC
- CWinApp [MFC], DelRegTree
- CWinApp [MFC], DoMessageBox
- CWinApp [MFC], DoWaitCursor
- CWinApp [MFC], EnableD2DSupport
- CWinApp [MFC], EnableHtmlHelp
- CWinApp [MFC], EnableTaskbarInteraction
- CWinApp [MFC], ExitInstance
- CWinApp [MFC], GetApplicationRecoveryParameter
- CWinApp [MFC], GetApplicationRecoveryPingInterval
- CWinApp [MFC], GetApplicationRestartFlags
- CWinApp [MFC], GetAppRegistryKey
- CWinApp [MFC], GetDataRecoveryHandler
- CWinApp [MFC], GetFirstDocTemplatePosition
- CWinApp [MFC], GetHelpMode
- CWinApp [MFC], GetNextDocTemplate
- CWinApp [MFC], GetPrinterDeviceDefaults
- CWinApp [MFC], GetProfileBinary
- CWinApp [MFC], GetProfileInt
- CWinApp [MFC], GetProfileString
- CWinApp [MFC], GetSectionKey
- CWinApp [MFC], HideApplication
- CWinApp [MFC], HtmlHelp
- CWinApp [MFC], InitInstance
- CWinApp [MFC], IsTaskbarInteractionEnabled
- CWinApp [MFC], LoadCursor
- CWinApp [MFC], LoadIcon
- CWinApp [MFC], LoadOEMCursor
- CWinApp [MFC], LoadOEMIcon
- CWinApp [MFC], LoadStandardCursor
- CWinApp [MFC], LoadStandardIcon
- CWinApp [MFC], OnDDECommand
- CWinApp [MFC], OnIdle
- CWinApp [MFC], OpenDocumentFile
- CWinApp [MFC], ParseCommandLine
- CWinApp [MFC], PreTranslateMessage
- CWinApp [MFC], ProcessMessageFilter
- CWinApp [MFC], ProcessShellCommand
- CWinApp [MFC], ProcessWndProcException
- CWinApp [MFC], Register
- CWinApp [MFC], RegisterWithRestartManager
- CWinApp [MFC], ReopenPreviousFilesAtRestart
- CWinApp [MFC], RestartInstance
- CWinApp [MFC], RestoreAutosavedFilesAtRestart
- CWinApp [MFC], Run
- CWinApp [MFC], RunAutomated
- CWinApp [MFC], RunEmbedded
- CWinApp [MFC], SaveAllModified
- CWinApp [MFC], SelectPrinter
- CWinApp [MFC], SetHelpMode
- CWinApp [MFC], SupportsApplicationRecovery
- CWinApp [MFC], SupportsAutosaveAtInterval
- CWinApp [MFC], SupportsAutosaveAtRestart
- CWinApp [MFC], SupportsRestartManager
- CWinApp [MFC], Unregister
- CWinApp [MFC], WinHelp
- CWinApp [MFC], WriteProfileBinary
- CWinApp [MFC], WriteProfileInt
- CWinApp [MFC], WriteProfileString
- CWinApp [MFC], EnableShellOpen
- CWinApp [MFC], LoadStdProfileSettings
- CWinApp [MFC], OnContextHelp
- CWinApp [MFC], OnFileNew
- CWinApp [MFC], OnFileOpen
- CWinApp [MFC], OnFilePrintSetup
- CWinApp [MFC], OnHelp
- CWinApp [MFC], OnHelpFinder
- CWinApp [MFC], OnHelpIndex
- CWinApp [MFC], OnHelpUsing
- CWinApp [MFC], RegisterShellFileTypes
- CWinApp [MFC], SetAppID
- CWinApp [MFC], SetRegistryKey
- CWinApp [MFC], UnregisterShellFileTypes
- CWinApp [MFC], m_bHelpMode
- CWinApp [MFC], m_eHelpType
- CWinApp [MFC], m_hInstance
- CWinApp [MFC], m_lpCmdLine
- CWinApp [MFC], m_nCmdShow
- CWinApp [MFC], m_pActiveWnd
- CWinApp [MFC], m_pszAppID
- CWinApp [MFC], m_pszAppName
- CWinApp [MFC], m_pszExeName
- CWinApp [MFC], m_pszHelpFilePath
- CWinApp [MFC], m_pszProfileName
- CWinApp [MFC], m_pszRegistryKey
- CWinApp [MFC], m_dwRestartManagerSupportFlags
- CWinApp [MFC], m_nAutosaveInterval
- CWinApp [MFC], m_pDataRecoveryHandler
ms.assetid: e426a3cd-0d15-40d6-bd55-beaa5feb2343
ms.openlocfilehash: 4bb1ade4182424cbdcbf0d7ba69af88bbb88abe6
ms.sourcegitcommit: 7a6116e48c3c11b97371b8ae4ecc23adce1f092d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/22/2020
ms.locfileid: "81750672"
---
# <a name="cwinapp-class"></a>CWinApp, classe

Classe de base à partir de laquelle vous dérivez un objet application Windows.

## <a name="syntax"></a>Syntaxe

```
class CWinApp : public CWinThread
```

## <a name="members"></a>Membres

### <a name="public-constructors"></a>Constructeurs publics

|Nom|Description|
|----------|-----------------|
|[CWinApp::CWinApp](#cwinapp)|Construit un objet `CWinApp`.|

### <a name="public-methods"></a>M&#233;thodes publiques

|Nom|Description|
|----------|-----------------|
|[CWinApp::AddDocTemplate](#adddoctemplate)|Ajoute un modèle de document à la liste des modèles de documents disponibles de l’application.|
|[CWinApp::AddToRecentFileList](#addtorecentfilelist)|Ajoute un nom de fichier à la liste de fichiers la plus récemment utilisée (MRU).|
|[CWinApp::ApplicationRecoveryCallback](#applicationrecoverycallback)|Appelé par le cadre lorsque l’application sort de façon inattendue.|
|[CWinApp::CloseAllDocuments](#closealldocuments)|Ferme tous les documents ouverts.|
|[CWinApp::CreatePrinterDC](#createprinterdc)|Crée un contexte d’appareil d’imprimante.|
|[CWinApp::DelRegTree](#delregtree)|Supprime une clé spécifiée et tous ses sous-clés.|
|[CWinApp::DoMessageBox](#domessagebox)|Implémente [AfxMessageBox](cstring-formatting-and-message-box-display.md#afxmessagebox) pour l’application.|
|[CWinApp::DoWaitCursor](#dowaitcursor)|Allume le curseur d’attente.|
|[CWinApp::EnableD2DSupport](#enabled2dsupport)|Permet le support D2D d’application. Appelez cette méthode avant que la fenêtre principale soit initialisée.|
|[CWinApp::EnableHtmlHelp](#enablehtmlhelp)|Implémente HTMLHelp pour l’application, plutôt que WinHelp.|
|[CWinApp::EnableTaskbarInteraction](#enabletaskbarinteraction)|Permet l’interaction avec la barre des tâches.|
|[CWinApp::ExitInstance](#exitinstance)|Remplacer pour nettoyer lorsque votre demande prend fin.|
|[CWinApp::GetApplicationRecoveryParameter](#getapplicationrecoveryparameter)|Récupère le paramètre d’entrée pour la méthode de récupération d’application.|
|[CWinApp::GetApplicationRecoveryPingInterval](#getapplicationrecoverypinginterval)|Retourne la durée pendant laquelle le gestionnaire de redémarrage attend le retour de la fonction de rappel de récupération.|
|[CWinApp::GetApplicationRestartFlags](#getapplicationrestartflags)|Retourne les drapeaux pour le directeur du redémarrage.|
|[CWinApp::GetAppRegistryKey](#getappregistrykey)|Retourne la clé pour\\HKEY_CURRENT_USER "Software"-RegistryKey-ProfileName.|
|[CWinApp::GetDataRecoveryHandler](#getdatarecoveryhandler)|Obtient le gestionnaire de récupération de données pour ce cas de l’application.|
|[CWinApp::GetFirstDocTemplatePosition](#getfirstdoctemplateposition)|Récupère la position du premier modèle de document.|
|[CWinApp::GetHelpMode](#gethelpmode)|Récupère le type d’aide utilisée par l’application.|
|[CWinApp::GetNextDocTemplate](#getnextdoctemplate)|Récupère la position d’un modèle de document. Peut être utilisé de façon récursive.|
|[CWinApp::GetPrinterDeviceDefaults](#getprinterdevicedefaults)|Récupère les défauts de l’appareil d’imprimante.|
|[CWinApp::GetProfileBinary](#getprofilebinary)|Récupère les données binaires d’une entrée dans l’application . Fichier INI.|
|[CWinApp::GetProfileInt](#getprofileint)|Récupère un intégrant à partir d’une entrée dans l’application . Fichier INI.|
|[CWinApp::GetProfileString](#getprofilestring)|Récupère une chaîne à partir d’une entrée dans l’application . Fichier INI.|
|[CWinApp::GetSectionKey](#getsectionkey)|Retourne la clé pour\\HKEY_CURRENT_USER "Software"-RegistryKey-AppName-lpszSection.|
|[CWinApp::HideApplication](#hideapplication)|Cache la demande avant de fermer tous les documents.|
|[CWinApp::HtmlHelp](#htmlhelp)|Appelle `HTMLHelp` la fonction Windows.|
|[CWinApp::InitInstance](#initinstance)|Remplacer pour effectuer la initialisation de l’instance Windows, comme la création d’objets de fenêtre.|
|[CWinApp::IsTaskbarInteractionEnabled](#istaskbarinteractionenabled)|Indique si l’interaction de barre des tâches de Windows 7 est activée.|
|[CWinApp::LoadCursor](#loadcursor)|Charge une ressource curseur.|
|[CWinApp::LoadIcon](#loadicon)|Charge une ressource d’icône.|
|[CWinApp::LoadOEMCursor](#loadoemcursor)|Charge un curseur prédéfini Windows OEM que les constantes **OCR_** spécifient dans WINDOWS. H.|
|[CWinApp::LoadOEMIcon](#loadoemicon)|Charge une icône prédéfinie Windows OEM que les constantes **OIC_** spécifient dans WINDOWS. H.|
|[CWinApp::LoadStandardCursor](#loadstandardcursor)|Charge un curseur prédéfini Windows que les constantes **IDC_** spécifient dans WINDOWS. H.|
|[CWinApp::LoadStandardIcon](#loadstandardicon)|Charge une icône prédéfinie Windows que les constantes **IDI_** spécifient dans WINDOWS. H.|
|[CWinApp::OnDDECommand](#onddecommand)|Appelé par le cadre en réponse à un échange dynamique de données (DDE) exécuter commande.|
|[CWinApp::OnIdle](#onidle)|Remplacement pour effectuer un traitement de temps d’inactivité spécifique à l’application.|
|[CWinApp::OpenDocumentFile](#opendocumentfile)|Appelé par le cadre pour ouvrir un document à partir d’un fichier.|
|[CWinApp::ParseCommandLine](#parsecommandline)|Parse les paramètres individuels et les drapeaux dans la ligne de commandement.|
|[CWinApp::PreTranslateMessage](#pretranslatemessage)|Filtre les messages avant d’être envoyés aux fonctions Windows [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage) et [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage).|
|[CWinApp::ProcessMessageFilter](#processmessagefilter)|Intercepte certains messages avant qu’ils n’atteignent l’application.|
|[CWinApp::ProcessShellCommand](#processshellcommand)|Gère les arguments et les drapeaux de la ligne de commande.|
|[CWinApp::ProcessWndProcException](#processwndprocexception)|Intercepte toutes les exceptions non gérées lancées par les gestionnaires de messages et de commandes de l’application.|
|[CWinApp::Enregistrement](#register)|Effectue l’enregistrement personnalisé.|
|[CWinApp::RegisterWithRestartManager](#registerwithrestartmanager)|Enregistre l’application auprès du gestionnaire du redémarrage.|
|[CWinApp::ReopenPreviousFilesAtRestart](#reopenpreviousfilesatrestart)|Détermine si le gestionnaire de redémarrage rouvre les dossiers qui étaient ouverts lorsque l’application est sortie de façon inattendue.|
|[CWinApp::RestartInstance](#restartinstance)|Gère un redémarrage d’application initié par le gestionnaire de redémarrage.|
|[CWinApp::RestoreAutosavedFilesAtRestart](#restoreautosavedfilesatrestart)|Détermine si le gestionnaire de redémarrage restaure les fichiers autosavés lorsqu’il redémarre l’application.|
|[CWinApp::Run](#run)|Exécute la boucle de message par défaut. Remplacement pour personnaliser la boucle de message.|
|[CWinApp::RunAutomated](#runautomated)|Teste la ligne de commande de l’application pour l’option **/Automation.** Obsolète. Au lieu de cela, utilisez la valeur dans [CCommandLineInfo:m_bRunAutomated](../../mfc/reference/ccommandlineinfo-class.md#m_brunautomated) après avoir appelé [ParseCommandLine](#parsecommandline).|
|[CWinApp::RunEmbedded](#runembedded)|Teste la ligne de commande de l’application pour l’option **/Embedding.** Obsolète. Au lieu de cela, utilisez la valeur dans [CCommandLineInfo:m_bRunEmbedded](../../mfc/reference/ccommandlineinfo-class.md#m_brunembedded) après avoir appelé [ParseCommandLine](#parsecommandline).|
|[CWinApp::SaveAllModified](#saveallmodified)|Invite l’utilisateur à enregistrer tous les documents modifiés.|
|[CWinApp::SelectPrinter](#selectprinter)|Sélectionne une imprimante précédemment indiquée par un utilisateur via une boîte de dialogue imprimée.|
|[CWinApp::SetHelpMode](#sethelpmode)|Définit et initialise le type d’aide utilisée par l’application.|
|[CWinApp::SupportsApplicationRecovery](#supportsapplicationrecovery)|Détermine si le gestionnaire de redémarrage récupère une application qui est sortie de façon inattendue.|
|[CWinApp::SupportsAutosaveAtInterval](#supportsautosaveatinterval)|Détermine si le gestionnaire de redémarrage s’autosave les documents ouverts à un intervalle régulier.|
|[CWinApp::SupportsAutosaveAtRestart](#supportsautosaveatrestart)|Détermine si le gestionnaire de redémarrage s’autosarait à l’aide de documents ouverts lorsque l’application redémarre.|
|[CWinApp::SupportsRestartManager](#supportsrestartmanager)|Détermine si l’application prend en charge le gestionnaire de redémarrage.|
|[CWinApp::Unregister](#unregister)|Désenregistre tout ce qui `CWinApp` est connu pour être enregistré par l’objet.|
|[CWinApp::WinHelp](#winhelp)|Appelle `WinHelp` la fonction Windows.|
|[CWinApp::WriteProfileBinary](#writeprofilebinary)|Écrit des données binaires à une entrée dans l’application . Fichier INI.|
|[CWinApp::WriteProfileInt](#writeprofileint)|Écrit un intégrer à une entrée dans l’application . Fichier INI.|
|[CWinApp::WriteProfileString](#writeprofilestring)|Écrit une chaîne à une entrée dans l’application . Fichier INI.|

### <a name="protected-methods"></a>Méthodes protégées

|Nom|Description|
|----------|-----------------|
|[CWinApp::EnableShellOpen](#enableshellopen)|Permet à l’utilisateur d’ouvrir des fichiers de données à partir du gestionnaire de fichiers Windows.|
|[CWinApp::LoadStdProfileSettings](#loadstdprofilesettings)|Charges standard . Paramètres de fichiers INI et permet la fonction de liste de fichiers MRU.|
|[CWinApp::OnContextHelp](#oncontexthelp)|Gère l’aide SHIFT-F1 dans l’application.|
|[CWinApp::OnFileNew](#onfilenew)|Implémente la commande ID_FILE_NEW.|
|[CWinApp::OnFileOpen](#onfileopen)|Implémente la commande ID_FILE_OPEN.|
|[CWinApp::OnFilePrintSetup](#onfileprintsetup)|Implémente la commande ID_FILE_PRINT_SETUP.|
|[CWinApp::OnHelp](#onhelp)|Gère l'aide F1 dans l'application (en utilisant le contexte actuel).|
|[CWinApp::OnHelpFinder](#onhelpfinder)|Gère les commandes ID_HELP_FINDER et ID_DEFAULT_HELP.|
|[CWinApp::OnHelpIndex](#onhelpindex)|Gère la commande ID_HELP_INDEX et fournit un sujet d’aide par défaut.|
|[CWinApp::OnHelpUsing](#onhelpusing)|Gère la commande ID_HELP_USING.|
|[CWinApp::RegisterShellFileTypes](#registershellfiletypes)|Enregistre tous les types de documents de l’application auprès du gestionnaire de fichiers Windows.|
|[CWinApp::SetAppID](#setappid)|Définit explicitement l’ID de modèle d’utilisateur d’application pour l’application. Cette méthode doit être appelée avant que toute interface utilisateur soit présentée à l’utilisateur (le meilleur endroit est le constructeur d’applications).|
|[CWinApp::SetRegistryKey](#setregistrykey)|Les paramètres d’application sont stockés dans le registre au lieu de . Fichiers INI.|
|[CWinApp::UnregisterShellFileTypes](#unregistershellfiletypes)|Désenregistre tous les types de documents de l’application avec le gestionnaire de fichiers Windows.|

### <a name="public-data-members"></a>Membres de données publics

|Nom|Description|
|----------|-----------------|
|[CWinApp::m_bHelpMode](#m_bhelpmode)|Indique si l’utilisateur est en mode contexte Help (généralement invoqué avec SHIFT-F1).|
|[CWinApp:m_eHelpType](#m_ehelptype)|Spécifie le type d’aide utilisée par l’application.|
|[CWinApp:m_hInstance](#m_hinstance)|Identifie l’instance actuelle de l’application.|
|[CWinApp:m_lpCmdLine](#m_lpcmdline)|Indique une chaîne non terminée qui spécifie la ligne de commande de l’application.|
|[CWinApp:m_nCmdShow](#m_ncmdshow)|Précise comment la fenêtre doit être montrée au départ.|
|[CWinApp::m_pActiveWnd](#m_pactivewnd)|Pointeur vers la fenêtre principale de l’application de conteneur lorsqu’un serveur OLE est actif.|
|[CWinApp::m_pszAppID](#m_pszappid)|Id modèle d’utilisateur d’application.|
|[CWinApp:m_pszAppName](#m_pszappname)|Spécifie le nom de l'application.|
|[CWinApp:m_pszExeName](#m_pszexename)|Nom du module de l’application.|
|[CWinApp::m_pszHelpFilePath](#m_pszhelpfilepath)|Le chemin vers le fichier d’aide de l’application.|
|[CWinApp:m_pszProfileName](#m_pszprofilename)|L’application . Nom de fichier INI.|
|[CWinApp::m_pszRegistryKey](#m_pszregistrykey)|Utilisé pour déterminer la clé de registre complète pour stocker les paramètres de profil d’application.|

### <a name="protected-data-members"></a>Membres de données protégés

|Nom|Description|
|----------|-----------------|
|[CWinApp::m_dwRestartManagerSupportFlags](#m_dwrestartmanagersupportflags)|Drapeaux qui déterminent le comportement du gestionnaire de redémarrage.|
|[CWinApp::m_nAutosaveInterval](#m_nautosaveinterval)|La durée en millisecondes entre les autosaves.|
|[CWinApp:m_pDataRecoveryHandler](#m_pdatarecoveryhandler)|Pointeur vers le gestionnaire de récupération de données pour l’application.|

## <a name="remarks"></a>Notes

Un objet d’application fournit aux membres des fonctions pour l’initialisation de votre application (et chaque instance de celui-ci) et pour l’exécution de l’application.

Chaque application qui utilise les classes microsoft Foundation `CWinApp`ne peut contenir qu’un seul objet dérivé de . Cet objet est construit lorsque d’autres objets mondiaux sont `WinMain` construits et est déjà disponible lorsque Windows appelle la fonction, qui est fournie par la Microsoft Foundation Class Library. Déclarez `CWinApp` votre objet dérivé au niveau mondial.

Lorsque vous dérivez `CWinApp`une classe d’application à partir de , remplacer la fonction membre [InitInstance](#initinstance) pour créer l’objet de fenêtre principal de votre application.

En plus `CWinApp` des fonctions des membres, la Microsoft Foundation Class `CWinApp` Library fournit les fonctions globales suivantes pour accéder à votre objet et à d’autres informations mondiales :

- [AfxGetApp (en)](application-information-and-management.md#afxgetapp) Obtient un pointeur `CWinApp` sur l’objet.

- [AfxGetInstanceHandle](application-information-and-management.md#afxgetinstancehandle) Obtient une poignée à l’instance de demande actuelle.

- [AfxGetResourceHandle AfxGetResourceHandle](application-information-and-management.md#afxgetresourcehandle) Obtient une poignée aux ressources de l’application.

- [AfxGetAppName](application-information-and-management.md#afxgetappname) Obtient un pointeur à une chaîne contenant le nom de l’application. Alternativement, si vous avez `CWinApp` un pointeur à l’objet, utilisez-le `m_pszExeName` pour obtenir le nom de l’application.

Voir [CWinApp: The Application](../../mfc/cwinapp-the-application-class.md) Class `CWinApp` pour en savoir plus sur la classe, y compris un aperçu de ce qui suit:

- `CWinApp`-code dérivé écrit par l’Assistant d’Application.

- `CWinApp`rôle dans la séquence d’exécution de votre application.

- `CWinApp`'implémentations de fonctions de membre par défaut.

- `CWinApp`'s key overridables.

Le `m_hPrevInstance` membre des données n’existe plus. Pour déterminer si une autre instance de l’application est en cours d’exécution, utilisez un mutex nommé. Si l’ouverture du mutex échoue, alors il n’y a pas d’autres cas de l’application en cours d’exécution.

## <a name="inheritance-hierarchy"></a>Hiérarchie d'héritage

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWinThread](../../mfc/reference/cwinthread-class.md)

`CWinApp`

## <a name="requirements"></a>Spécifications

**En-tête :** afxwin.h

## <a name="cwinappadddoctemplate"></a><a name="adddoctemplate"></a>CWinApp::AddDocTemplate

Appelez cette fonction de membre pour ajouter un modèle de document à la liste des modèles de documents disponibles que l’application maintient.

```cpp
void AddDocTemplate(CDocTemplate* pTemplate);
```

### <a name="parameters"></a>Paramètres

*pTemplate (en)*<br/>
Un pointeur `CDocTemplate` à l’ajouter.

### <a name="remarks"></a>Notes

Vous devez ajouter tous les modèles de documents à une application avant d’appeler [RegisterShellFileTypes](#registershellfiletypes).

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#35](../../mfc/reference/codesnippet/cpp/cwinapp-class_1.cpp)]

## <a name="cwinappaddtorecentfilelist"></a><a name="addtorecentfilelist"></a>CWinApp::AddToRecentFileList

Appelez cette fonction de membre pour ajouter *lpszPathName* à la liste de fichiers MRU.

```
virtual void AddToRecentFileList(LPCTSTR lpszPathName);
```

### <a name="parameters"></a>Paramètres

*lpszPathName (en)*<br/>
Chemin d’accès au fichier.

### <a name="remarks"></a>Notes

Vous devez appeler la fonction membre [LoadStdProfileSettings](#loadstdprofilesettings) pour charger la liste de fichiers MRU actuelle avant d’utiliser cette fonction de membre.

Le cadre appelle cette fonction de membre lorsqu’il ouvre un fichier ou exécute la commande Save As pour enregistrer un fichier avec un nouveau nom.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#36](../../mfc/reference/codesnippet/cpp/cwinapp-class_2.cpp)]

## <a name="cwinappapplicationrecoverycallback"></a><a name="applicationrecoverycallback"></a>CWinApp::ApplicationRecoveryCallback

Appelé par le cadre lorsque l’application sort de façon inattendue.

```
virtual DWORD ApplicationRecoveryCallback(LPVOID lpvParam);
```

### <a name="parameters"></a>Paramètres

*lpvParam (en)*<br/>
[in] Réservé pour une future utilisation.

### <a name="return-value"></a>Valeur de retour

0 si cette méthode est réussie; nonzero en cas d’erreur.

### <a name="remarks"></a>Notes

Si votre application prend en charge le gestionnaire de redémarrage, le cadre appelle cette fonction lorsque votre application quitte de façon inattendue.

La mise `ApplicationRecoveryCallback` en `CDataRecoveryHandler` œuvre par défaut des utilisations pour enregistrer la liste des documents actuellement ouverts au registre. Cette méthode n’autorise aucun fichier.

Pour personnaliser le comportement, remplacer cette fonction dans une [classe CWinApp](../../mfc/reference/cwinapp-class.md) dérivée ou passer votre propre méthode de récupération d’application comme paramètre à [CWinApp::RegisterWithRestartManager](#registerwithrestartmanager).

## <a name="cwinappclosealldocuments"></a><a name="closealldocuments"></a>CWinApp::CloseAllDocuments

Appelez cette fonction de membre pour fermer tous les documents ouverts avant de sortir.

```cpp
void CloseAllDocuments(BOOL bEndSession);
```

### <a name="parameters"></a>Paramètres

*bEndSession*<br/>
Précise si la session Windows est terminée ou non. Il est VRAI si la session est terminée; autrement FALSE.

### <a name="remarks"></a>Notes

Appelez [HideApplication](#hideapplication) `CloseAllDocuments`avant d’appeler .

## <a name="cwinappcreateprinterdc"></a><a name="createprinterdc"></a>CWinApp::CreatePrinterDC

Appelez cette fonction de membre pour créer un contexte d’appareil d’imprimante (DC) à partir de l’imprimante sélectionnée.

```
BOOL CreatePrinterDC(CDC& dc);
```

### <a name="parameters"></a>Paramètres

*Dc*<br/>
Une référence au contexte d’un périphérique d’imprimante.

### <a name="return-value"></a>Valeur de retour

Nonzero si le contexte de l’appareil d’imprimante est créé avec succès; sinon 0.

### <a name="remarks"></a>Notes

`CreatePrinterDC`initialise le contexte de l’appareil que vous transmettez par référence, de sorte que vous pouvez l’utiliser pour imprimer.

Si la fonction est réussie, lorsque vous avez fini d’imprimer, vous devez détruire le contexte de l’appareil. Vous pouvez laisser le destructeur de l’objet [CDC](../../mfc/reference/cdc-class.md) le faire, ou vous pouvez le faire explicitement en appelant [CDC::DeleteDC](../../mfc/reference/cdc-class.md#deletedc).

## <a name="cwinappcwinapp"></a><a name="cwinapp"></a>CWinApp::CWinApp

Construit un `CWinApp` objet et passe *lpszAppName* pour être stocké comme nom de l’application.

```
CWinApp(LPCTSTR lpszAppName = NULL);
```

### <a name="parameters"></a>Paramètres

*lpszAppName*<br/>
Une chaîne non terminée qui contient le nom d’application que Windows utilise. Si cet argument n’est `CWinApp` pas fourni ou est NULL, utilise la chaîne de ressources AFX_IDS_APP_TITLE ou le nom de fichier du fichier exécutable.

### <a name="remarks"></a>Notes

Vous devez construire un `CWinApp`objet global de votre classe dérivée. Vous ne pouvez `CWinApp` avoir qu’un seul objet dans votre application. Le constructeur stocke un `CWinApp` pointeur `WinMain` sur l’objet afin que l’on puisse appeler les fonctions du membre de l’objet pour initialiser et exécuter l’application.

## <a name="cwinappdelregtree"></a><a name="delregtree"></a>CWinApp::DelRegTree

Supprime une clé de registre spécifique et tous ses sous-clés.

```
LONG DelRegTree(
    HKEY hParentKey,
    const CString& strKeyName);

LONG DelRegTree(
    HKEY hParentKey,
    const CString& strKeyName,
    CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>Paramètres

*hParentKey (en)*<br/>
Gérer une clé de registre.

*strKeyName (en)*<br/>
Le nom de la clé de registre à supprimer.

*Ptm*<br/>
Pointeur à l’objet CAtlTransactionManager.

### <a name="return-value"></a>Valeur de retour

Si la fonction réussit, la valeur de rendement est ERROR_SUCCESS. Si la fonction échoue, la valeur de retour est un code d’erreur non zéro défini dans Winerror.h.

### <a name="remarks"></a>Notes

Appelez cette fonction pour supprimer la clé spécifiée et ses sous-clés.

## <a name="cwinappdomessagebox"></a><a name="domessagebox"></a>CWinApp::DoMessageBox

Le cadre appelle cette fonction membre à implémenter une boîte de message pour la fonction globale [AfxMessageBox](cstring-formatting-and-message-box-display.md#afxmessagebox).

```
virtual int DoMessageBox(
    LPCTSTR lpszPrompt,
    UINT nType,
    UINT nIDPrompt);
```

### <a name="parameters"></a>Paramètres

*lpszPrompt*<br/>
Adresse du texte dans la boîte à messages.

*nType*<br/>
Le [style](../../mfc/reference/styles-used-by-mfc.md#message-box-styles)boîte de message .

*nIDPrompt (en)*<br/>
Un index à une chaîne de contexte d’aide.

### <a name="return-value"></a>Valeur de retour

Retourne les mêmes `AfxMessageBox`valeurs que .

### <a name="remarks"></a>Notes

N’appelez pas cette fonction de membre pour ouvrir une boîte de message; utilisation `AfxMessageBox` à la place.

Remplacez cette fonction de membre pour personnaliser `AfxMessageBox` votre traitement des appels à l’échelle de l’application.

## <a name="cwinappdowaitcursor"></a><a name="dowaitcursor"></a>CWinApp::DoWaitCursor

Cette fonction de membre est appelée par le cadre pour implémenter [CWaitCursor](../../mfc/reference/cwaitcursor-class.md), [CCmdTarget::BeginWaitCursor](../../mfc/reference/ccmdtarget-class.md#beginwaitcursor), [CCmdTarget::EndWaitCursor](../../mfc/reference/ccmdtarget-class.md#endwaitcursor), et [CCmdTarget::RestoreWaitCursor](../../mfc/reference/ccmdtarget-class.md#restorewaitcursor).

```
virtual void DoWaitCursor(int nCode);
```

### <a name="parameters"></a>Paramètres

*nCode (en)*<br/>
Si ce paramètre est de 1, un curseur d’attente apparaît. Si 0, le curseur d’attente est restauré sans incrémenter le nombre de références. Si -1, le curseur d’attente se termine.

### <a name="remarks"></a>Notes

La valeur par défaut implémente un curseur de sablier. `DoWaitCursor`maintient un décompte des références. Lorsqu’il est positif, le curseur de sablier est affiché.

Bien que vous n’appeliez `DoWaitCursor` normalement pas directement, vous pourriez remplacer cette fonction de membre pour modifier le curseur d’attente ou pour effectuer un traitement supplémentaire pendant que le curseur d’attente est affiché.

Pour une façon plus facile et plus rationalisée de `CWaitCursor`mettre en œuvre un curseur d’attente, utilisez .

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#37](../../mfc/reference/codesnippet/cpp/cwinapp-class_3.cpp)]

## <a name="cwinappenabled2dsupport"></a><a name="enabled2dsupport"></a>CWinApp::EnableD2DSupport

Visual Studio 2010 SP1 est requis

Permet le support D2D d’application. Appelez cette méthode avant que la fenêtre principale soit initialisée.

```
BOOL EnableD2DSupport(
    D2D1_FACTORY_TYPE d2dFactoryType = D2D1_FACTORY_TYPE_SINGLE_THREADED,
    DWRITE_FACTORY_TYPE writeFactoryType = DWRITE_FACTORY_TYPE_SHARED);
```

### <a name="parameters"></a>Paramètres

*d2dFactoryType*<br/>
Le modèle de filetage de l’usine D2D et les ressources qu’elle crée.

*écrireFactoryType*<br/>
Une valeur qui précise si l’objet d’usine d’écriture sera partagé ou isolé

### <a name="return-value"></a>Valeur de retour

Retourne VRAI si le support D2D a été activé, FALSE - sinon

## <a name="cwinappenablehtmlhelp"></a><a name="enablehtmlhelp"></a>CWinApp::EnableHtmlHelp

Appelez cette fonction de membre à `CWinApp`partir du constructeur de votre classe dérivée pour utiliser HTMLHelp pour l’aide de votre application.

```cpp
void EnableHtmlHelp();
```

### <a name="remarks"></a>Notes

## <a name="cwinappenableshellopen"></a><a name="enableshellopen"></a>CWinApp::EnableShellOpen

Appelez cette fonction, `InitInstance` généralement à partir de votre remplacement, pour permettre aux utilisateurs de votre application d’ouvrir des fichiers de données lorsqu’ils doublent les fichiers à partir du gestionnaire de fichiers Windows.

```cpp
void EnableShellOpen();
```

### <a name="remarks"></a>Notes

Appelez `RegisterShellFileTypes` la fonction membre en conjonction avec cette fonction, ou fournissez un . Fichier REG avec votre demande d’enregistrement manuel des types de documents.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#38](../../mfc/reference/codesnippet/cpp/cwinapp-class_4.cpp)]

## <a name="cwinappenabletaskbarinteraction"></a><a name="enabletaskbarinteraction"></a>CWinApp::EnableTaskbarInteraction

Permet l’interaction avec la barre des tâches.

```
BOOL EnableTaskbarInteraction(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>Paramètres

*bEnable*<br/>
Précise si l’interaction avec la barre des tâches de Windows 7 doit être activée (TRUE), ou désactivée (FALSE).

### <a name="return-value"></a>Valeur de retour

Retourne VRAI si l’interaction avec la barre des tâches peut être activée ou désactivée.

### <a name="remarks"></a>Notes

Cette méthode doit être appelée avant la création de la fenêtre principale, sinon elle affirme et retourne FALSE.

## <a name="cwinappexitinstance"></a><a name="exitinstance"></a>CWinApp::ExitInstance

Appelé par le cadre `Run` de l’intérieur de la fonction membre de quitter cette instance de l’application.

```
virtual int ExitInstance();
```

### <a name="return-value"></a>Valeur de retour

Code de sortie de l’application; 0 n’indique aucune erreur, et les valeurs supérieures à 0 indiquent une erreur. Cette valeur est utilisée comme `WinMain`valeur de retour de .

### <a name="remarks"></a>Notes

N’appelez pas cette fonction de `Run` membre de n’importe où, mais dans la fonction de membre.

La mise en œuvre par défaut de cette fonction écrit des options-cadres à l’application . Fichier INI. Remplacez cette fonction pour nettoyer lorsque votre application prend fin.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#39](../../mfc/reference/codesnippet/cpp/cwinapp-class_5.cpp)]

## <a name="cwinappgetapplicationrecoveryparameter"></a><a name="getapplicationrecoveryparameter"></a>CWinApp::GetApplicationRecoveryParameter

Récupère le paramètre d’entrée pour la méthode de récupération d’application.

```
virtual LPVOID GetApplicationRecoveryParameter();
```

### <a name="return-value"></a>Valeur de retour

Le paramètre d’entrée par défaut pour la méthode de récupération d’application.

### <a name="remarks"></a>Notes

Le comportement par défaut de cette fonction retourne NULL.

Pour plus d’informations, voir [CWinApp::ApplicationRecoveryCallback](#applicationrecoverycallback).

## <a name="cwinappgetapplicationrecoverypinginterval"></a><a name="getapplicationrecoverypinginterval"></a>CWinApp::GetApplicationRecoveryPingInterval

Retourne la durée pendant laquelle le gestionnaire de redémarrage attend le retour de la fonction de rappel de récupération.

```
virtual DWORD GetApplicationRecoveryPingInterval();
```

### <a name="return-value"></a>Valeur de retour

La durée en millisecondes.

### <a name="remarks"></a>Notes

Lorsqu’une application enregistrée auprès du gestionnaire de redémarrage sort de façon inattendue, l’application tente d’enregistrer des documents ouverts et appelle la fonction de rappel de récupération. La fonction de rappel de récupération par défaut est [CWinApp::ApplicationRecoveryCallback](#applicationrecoverycallback).

La durée pendant laquelle le cadre attend le retour de la fonction de rappel de récupération est l’intervalle de ping. Vous pouvez personnaliser l’intervalle de `CWinApp::GetApplicationRecoveryPingInterval` ping en dominant `RegisterWithRestartManager`ou en fournissant une valeur personnalisée à .

## <a name="cwinappgetapplicationrestartflags"></a><a name="getapplicationrestartflags"></a>CWinApp::GetApplicationRestartFlags

Retourne les drapeaux pour le directeur du redémarrage.

```
virtual DWORD GetApplicationRestartFlags();
```

### <a name="return-value"></a>Valeur de retour

Les drapeaux pour le directeur du redémarrage. La implémentation par défaut renvoie 0.

### <a name="remarks"></a>Notes

Les drapeaux du gestionnaire de redémarrage n’ont aucun effet avec la mise en œuvre par défaut. Ils sont fournis pour une utilisation future.

Vous définissez les drapeaux lorsque vous enregistrez l’application auprès du gestionnaire de redémarrage en utilisant [CWinApp::RegisterWithRestartManager](#registerwithrestartmanager).

Les valeurs possibles pour les drapeaux du gestionnaire de redémarrage sont les suivantes :

- RESTART_NO_CRASH

- RESTART_NO_HANG

- RESTART_NO_PATCH

- RESTART_NO_REBOOT

## <a name="cwinappgetappregistrykey"></a><a name="getappregistrykey"></a>CWinApp::GetAppRegistryKey

Retourne la clé pour\\HKEY_CURRENT_USER "Software"-RegistryKey-ProfileName.

```
HKEY GetAppRegistryKey(CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>Paramètres

*Ptm*<br/>
Pointeur `CAtlTransactionManager` vers un objet.

### <a name="return-value"></a>Valeur de retour

Clé d’application si la fonction réussit; autrement NULL.

### <a name="remarks"></a>Notes

## <a name="cwinappgetdatarecoveryhandler"></a><a name="getdatarecoveryhandler"></a>CWinApp::GetDataRecoveryHandler

Obtient le gestionnaire de récupération de données pour ce cas de l’application.

```
virtual CDataRecoveryHandler *GetDataRecoveryHandler();
```

### <a name="return-value"></a>Valeur de retour

Le gestionnaire de récupération de données pour le cas de l’application.

### <a name="remarks"></a>Notes

Chaque application qui utilise le gestionnaire de redémarrage doit avoir une instance de la [classe CDataRecoveryHandler](../../mfc/reference/cdatarecoveryhandler-class.md). Cette classe est responsable de la surveillance des documents ouverts et des fichiers d’autosavage. Le comportement `CDataRecoveryHandler` de la dépend de la configuration du gestionnaire de redémarrage. Pour plus d’informations, voir [CDataRecoveryHandler Class](../../mfc/reference/cdatarecoveryhandler-class.md).

Cette méthode renvoie NULL sur les systèmes d’exploitation plus tôt que Windows Vista. Le gestionnaire de redémarrage n’est pas pris en charge sur les systèmes d’exploitation plus tôt que Windows Vista.

Si l’application n’a pas actuellement de gestionnaire de récupération de données, cette méthode en crée une et y renvoie un pointeur.

## <a name="cwinappgetfirstdoctemplateposition"></a><a name="getfirstdoctemplateposition"></a>CWinApp::GetFirstDocTemplatePosition

Obtient la position du premier modèle de document dans l’application.

```
POSITION GetFirstDocTemplatePosition() const;
```

### <a name="return-value"></a>Valeur de retour

Une valeur POSITION qui peut être utilisée pour l’itération ou la récupération de pointeurs d’objet; NULL si la liste est vide.

### <a name="remarks"></a>Notes

Utilisez la valeur POSITION retournée dans un appel à [GetNextDocTemplate](#getnextdoctemplate) pour obtenir le premier objet [CDocTemplate.](../../mfc/reference/cdoctemplate-class.md)

## <a name="cwinappgethelpmode"></a><a name="gethelpmode"></a>CWinApp::GetHelpMode

Récupère le type d’aide utilisée par l’application.

```
AFX_HELP_TYPE GetHelpMode();
```

### <a name="return-value"></a>Valeur de retour

Le type d’aide utilisé par l’application. Voir [CWinApp:m_eHelpType](#m_ehelptype) pour plus d’informations.

## <a name="cwinappgetnextdoctemplate"></a><a name="getnextdoctemplate"></a>CWinApp::GetNextDocTemplate

Obtient le modèle de document identifié par *pos,* puis définit *pos* à la valeur POSITION.

```
CDocTemplate* GetNextDocTemplate(POSITION& pos) const;
```

### <a name="parameters"></a>Paramètres

*Pos*<br/>
Une référence à une valeur POSITION `GetNextDocTemplate` retournée par un appel précédent à ou [GetFirstDocTemplatePosition](#getfirstdoctemplateposition). La valeur est mise à jour à la position suivante par cet appel.

### <a name="return-value"></a>Valeur de retour

Un pointeur sur un objet [CDocTemplate.](../../mfc/reference/cdoctemplate-class.md)

### <a name="remarks"></a>Notes

Vous pouvez `GetNextDocTemplate` utiliser dans une boucle d’itération vers l’avant si vous établissez la position initiale avec un appel à `GetFirstDocTemplatePosition`.

Vous devez vous assurer que votre valeur POSITION est valide. Si elle est invalide, la version Debug de la Microsoft Foundation Class Library affirme.

Si le modèle de document récupéré est le dernier disponible, alors la nouvelle valeur de *pos* est réglée à NULL.

## <a name="cwinappgetprinterdevicedefaults"></a><a name="getprinterdevicedefaults"></a>CWinApp::GetPrinterDeviceDefaults

Appelez cette fonction de membre pour préparer un contexte d’appareil d’imprimante pour l’impression.

```
BOOL GetPrinterDeviceDefaults(struct tagPDA* pPrintDlg);
```

### <a name="parameters"></a>Paramètres

*pPrintDlg*<br/>
Un pointeur vers une structure [PRINTDLG.](/windows/win32/api/commdlg/ns-commdlg-printdlga)

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Récupère les défauts d’imprimante actuels à partir de Windows . Fichier INI au besoin, ou utilise la dernière configuration d’imprimante définie par l’utilisateur dans Print Setup.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#40](../../mfc/reference/codesnippet/cpp/cwinapp-class_6.cpp)]

## <a name="cwinappgetprofilebinary"></a><a name="getprofilebinary"></a>CWinApp::GetProfileBinary

Appelez cette fonction de membre pour récupérer des données binaires à partir d’une entrée dans une section spécifiée du registre de l’application ou . Fichier INI.

```
BOOL GetProfileBinary(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Indique une chaîne non terminée qui spécifie la section contenant l’entrée.

*lpszEntry (en)*<br/>
Indique une chaîne non terminée qui contient l’entrée dont la valeur doit être récupérée.

*ppData (en)*<br/>
Indique un pointeur qui recevra l’adresse des données.

*pBytes (en)*<br/>
Indique un UINT qui recevra la taille des données (dans les octets).

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction de membre n’est pas sensible au cas, de sorte que les chaînes dans les paramètres *lpszSection* et *lpszEntry* peuvent différer dans le cas.

> [!NOTE]
> `GetProfileBinary`alloue un tampon et \* retourne son adresse en *ppData*. L’appelant est responsable de la libération du tampon à l’aide **de supprimer []**.

> [!IMPORTANT]
> Les données retournées par cette fonction ne sont pas nécessairement annulées, et l’appelant doit effectuer la validation. Pour plus d’informations, consultez [Solutions contre les dépassements de mémoire tampon](/windows/win32/SecBP/avoiding-buffer-overruns).

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#41](../../mfc/reference/codesnippet/cpp/cwinapp-class_7.cpp)]

Pour un autre exemple, voir [CWinApp::WriteProfileBinary](#writeprofilebinary).

## <a name="cwinappgetprofileint"></a><a name="getprofileint"></a>CWinApp::GetProfileInt

Appelez cette fonction de membre pour récupérer la valeur d’un intégrant à partir d’une entrée dans une section spécifiée du registre de la demande ou . Fichier INI.

```
UINT GetProfileInt(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    int nDefault);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Indique une chaîne non terminée qui spécifie la section contenant l’entrée.

*lpszEntry (en)*<br/>
Indique une chaîne non terminée qui contient l’entrée dont la valeur doit être récupérée.

*nDefault (en)*<br/>
Spécifie la valeur par défaut à retourner si le cadre ne peut pas trouver l’entrée.

### <a name="return-value"></a>Valeur de retour

La valeur integer de la chaîne qui suit l’entrée spécifiée si la fonction est réussie. La valeur de retour est la valeur du paramètre *nDefault* si la fonction ne trouve pas l’entrée. La valeur de retour est de 0 si la valeur qui correspond à l’entrée spécifiée n’est pas un intégré.

Cette fonction membre prend en charge la notation hexadecimal pour la valeur dans le . Fichier INI. Lorsque vous récupérez un intégrer signé, vous devez jeter la valeur dans un **int**.

### <a name="remarks"></a>Notes

Cette fonction de membre n’est pas sensible au cas, de sorte que les chaînes dans les paramètres *lpszSection* et *lpszEntry* peuvent différer dans le cas.

> [!IMPORTANT]
> Les données retournées par cette fonction ne sont pas nécessairement annulées, et l’appelant doit effectuer la validation. Pour plus d’informations, consultez [Solutions contre les dépassements de mémoire tampon](/windows/win32/SecBP/avoiding-buffer-overruns).

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#42](../../mfc/reference/codesnippet/cpp/cwinapp-class_8.cpp)]

Pour un autre exemple, voir [CWinApp::WriteProfileInt](#writeprofileint).

## <a name="cwinappgetprofilestring"></a><a name="getprofilestring"></a>CWinApp::GetProfileString

Appelez cette fonction de membre pour récupérer la chaîne associée à une entrée dans la section spécifiée dans le registre de l’application ou . Fichier INI.

```
CString GetProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault = NULL);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Indique une chaîne non terminée qui spécifie la section contenant l’entrée.

*lpszEntry (en)*<br/>
Indique une corde non terminée qui contient l’entrée dont la chaîne doit être récupérée. Cette valeur ne doit pas être NULL.

*lpszDefault*<br/>
Indique la valeur de la chaîne par défaut pour l’entrée donnée si l’entrée ne peut pas être trouvée dans le fichier de initialisation.

### <a name="return-value"></a>Valeur de retour

La valeur de retour est la chaîne de l’application . Fichier INI ou *lpszDefault* si la ficelle ne peut pas être trouvée. La longueur maximale de la chaîne supportée par le cadre est _MAX_PATH. Si *lpszDefault* est NULL, la valeur de retour est une chaîne vide.

### <a name="remarks"></a>Notes

> [!IMPORTANT]
> Les données retournées par cette fonction ne sont pas nécessairement annulées, et l’appelant doit effectuer la validation. Pour plus d’informations, consultez [Solutions contre les dépassements de mémoire tampon](/windows/win32/SecBP/avoiding-buffer-overruns).

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

Pour un autre exemple, voir l’exemple pour [CWinApp::GetProfileInt](#getprofileint).

## <a name="cwinappgetsectionkey"></a><a name="getsectionkey"></a>CWinApp::GetSectionKey

Retourne la clé pour\\HKEY_CURRENT_USER "Software"-RegistryKey-AppName-lpszSection.

```
HKEY GetSectionKey(
    LPCTSTR lpszSection,
    CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Le nom de la clé à obtenir.

*Ptm*<br/>
Pointeur `CAtlTransactionManager` vers un objet.

### <a name="return-value"></a>Valeur de retour

Clé de section si la fonction réussit; autrement NULL.

### <a name="remarks"></a>Notes

## <a name="cwinapphideapplication"></a><a name="hideapplication"></a>CWinApp::HideApplication

Appelez cette fonction de membre pour masquer une application avant de fermer les documents ouverts.

```cpp
void HideApplication();
```

## <a name="cwinapphtmlhelp"></a><a name="htmlhelp"></a>CWinApp::HtmlHelp

Appelez cette fonction de membre pour invoquer l’application HTMLHelp.

```
virtual void HtmlHelp(
    DWORD_PTR dwData,
    UINT nCmd = 0x000F);
```

### <a name="parameters"></a>Paramètres

*dwData dwData*<br/>
Spécifie des données supplémentaires. La valeur utilisée dépend de la valeur du paramètre *nCmd.* Défauts `0x000F` à ce qui signifie [HH_HELP_CONTEXT](/previous-versions/windows/desktop/htmlhelp/hh-help-context-command).

*nCmd (en)*<br/>
Spécifie le type d’aide demandée. Pour une liste des valeurs possibles et comment elles affectent le paramètre *dwData,* voir le paramètre *uCommand* décrit dans les fonctions [HtmlHelpW](/windows/win32/api/htmlhelp/nf-htmlhelp-htmlhelpw) ou [HtmlHelpA](/windows/win32/api/htmlhelp/nf-htmlhelp-htmlhelpa) API dans le SDK Windows.

### <a name="remarks"></a>Notes

Le cadre appelle également cette fonction à invoquer l’application HTMLHelp.

Le cadre fermera automatiquement l’application HTMLHelp lorsque votre application prendra fin.

## <a name="cwinappinitinstance"></a><a name="initinstance"></a>CWinApp::InitInstance

Windows permet à plusieurs exemplaires d’un même programme de s’exécuter en même temps.

```
virtual BOOL InitInstance();
```

### <a name="return-value"></a>Valeur de retour

Nonzero si l’initialisation est réussie; sinon 0.

### <a name="remarks"></a>Notes

L’initialisation de l’application est conceptuellement divisée en deux sections : la initialisation d’une demande unique qui se fait la première fois que le programme s’exécute, et la initialisation par exemple qui s’exécute chaque fois qu’une copie du programme s’exécute, y compris la première fois. La mise en `WinMain` œuvre de cette fonction par le cadre.

Remplacer `InitInstance` pour initialiser chaque nouvelle instance de votre application en cours d’exécution sous Windows. En règle générale, vous remplacez `InitInstance` pour `CWinThread::m_pMainWnd` construire votre objet de fenêtre principale et définissez le membre des données pour pointer vers cette fenêtre. Pour plus d’informations sur la suppression de cette fonction de membre, voir [CWinApp: The Application Class](../../mfc/cwinapp-the-application-class.md).

> [!NOTE]
> Les applications MFC doivent être paraminées en tant qu’appartement à filet unique (STA). Si vous appelez [CoInitializeEx](/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex) dans votre `InitInstance` remplacement, spécifiez COINIT_APARTMENTTHREADED (plutôt que COINIT_MULTITHREADED).

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCListView#9](../../atl/reference/codesnippet/cpp/cwinapp-class_10.cpp)]

## <a name="cwinappistaskbarinteractionenabled"></a><a name="istaskbarinteractionenabled"></a>CWinApp::IsTaskbarInteractionEnabled

Indique si l’interaction de barre des tâches de Windows 7 est activée.

```
virtual BOOL IsTaskbarInteractionEnabled();
```

### <a name="return-value"></a>Valeur de retour

Retourne VRAI `EnableTaskbarInteraction` si a été appelé et le système d’exploitation est Windows 7 ou plus.

### <a name="remarks"></a>Notes

L’interaction avec la barre des tâches signifie que l’application MDI affiche le contenu des enfants MDI dans des vignettes séparées qui apparaissent lorsque le pointeur de la souris est au-dessus du bouton de la barre des tâches d’application.

## <a name="cwinapploadcursor"></a><a name="loadcursor"></a>CWinApp::LoadCursor

Charge la ressource curseur nommée par *lpszResourceName* ou spécifiée par *nIDResource* à partir du fichier exécutable actuel.

```
HCURSOR LoadCursor(LPCTSTR lpszResourceName) const;  HCURSOR LoadCursor(UINT nIDResource) const;
```

### <a name="parameters"></a>Paramètres

*lpszResourceName (en)*<br/>
Indique une chaîne non terminée qui contient le nom de la ressource curseur. Vous pouvez `CString` utiliser un pour cet argument.

*nIDResource (en)*<br/>
ID de la ressource curseur. Pour une liste de ressources, voir [LoadCursor](/windows/win32/api/winuser/nf-winuser-loadcursorw) dans le SDK Windows.

### <a name="return-value"></a>Valeur de retour

Une poignée à un curseur en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

`LoadCursor`charge le curseur dans la mémoire seulement s’il n’a pas été chargé auparavant; autrement, il récupère une poignée de la ressource existante.

Utilisez la fonction [loadStandardCursor](#loadstandardcursor) ou [LoadOEMCursor](#loadoemcursor) pour accéder aux curseurs Windows prédéfinis.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#44](../../mfc/reference/codesnippet/cpp/cwinapp-class_11.cpp)]

## <a name="cwinapploadicon"></a><a name="loadicon"></a>CWinApp::LoadIcon

Charge la ressource iconée nommée par *lpszResourceName* ou spécifiée par *nIDResource* à partir du fichier exécutable.

```
HICON LoadIcon(LPCTSTR lpszResourceName) const;  HICON LoadIcon(UINT nIDResource) const;
```

### <a name="parameters"></a>Paramètres

*lpszResourceName (en)*<br/>
Indique une chaîne non terminée qui contient le nom de la ressource icône. Vous pouvez également `CString` utiliser un pour cet argument.

*nIDResource (en)*<br/>
Numéro d’identification de la ressource d’icône.

### <a name="return-value"></a>Valeur de retour

Une poignée à une icône en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

`LoadIcon`charge l’icône uniquement si elle n’a pas été préalablement chargée; autrement, il récupère une poignée de la ressource existante.

Vous pouvez utiliser la fonction [membre LoadStandardIcon](#loadstandardicon) ou [LoadOEMIcon](#loadoemicon) pour accéder aux icônes Windows prédéfinies.

> [!NOTE]
> Cette fonction membre appelle la fonction Win32 API [LoadIcon](/windows/win32/api/winuser/nf-winuser-loadiconw), qui ne peut charger qu’une icône dont la taille est conforme aux valeurs métriques SM_CXICON et SM_CYICON système.

## <a name="cwinapploadoemcursor"></a><a name="loadoemcursor"></a>CWinApp::LoadOEMCursor

Charge la ressource de curseur prédéfinie Windows spécifiée par *nIDCursor*.

```
HCURSOR LoadOEMCursor(UINT nIDCursor) const;
```

### <a name="parameters"></a>Paramètres

*nIDCursor (en)*<br/>
Un **OCR_** un identificateur constant manifeste qui spécifie un curseur Windows prédéfini. Vous devez `#define OEMRESOURCE` `#include \<afxwin.h>` avoir avant d’accéder aux constantes **OCR_** dans WINDOWS. H.

### <a name="return-value"></a>Valeur de retour

Une poignée à un curseur en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

Utilisez `LoadOEMCursor` la fonction membre [loadStandardCursor](#loadstandardcursor) pour accéder aux curseurs Windows prédéfinis.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#45](../../mfc/reference/codesnippet/cpp/cwinapp-class_12.h)]

[!code-cpp[NVC_MFCWindowing#46](../../mfc/reference/codesnippet/cpp/cwinapp-class_13.cpp)]

## <a name="cwinapploadoemicon"></a><a name="loadoemicon"></a>CWinApp::LoadOEMIcon

Charge la ressource d’icône prédéfinie Windows spécifiée par *nIDIcon*.

```
HICON LoadOEMIcon(UINT nIDIcon) const;
```

### <a name="parameters"></a>Paramètres

*nIDIcon (en)*<br/>
Un **OIC_** un identificateur constant manifeste qui spécifie une icône Windows prédéfinie. Vous devez `#define OEMRESOURCE` `#include \<afxwin.h>` avoir avant d’accéder aux constantes **OIC_** dans WINDOWS. H.

### <a name="return-value"></a>Valeur de retour

Une poignée à une icône en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

Utilisez `LoadOEMIcon` la fonction membre [ou LoadStandardIcon](#loadstandardicon) pour accéder aux icônes Windows prédéfinies.

## <a name="cwinapploadstandardcursor"></a><a name="loadstandardcursor"></a>CWinApp::LoadStandardCursor

Charge la ressource de curseur prédéfinie Windows que *lpszCursorName* spécifie.

```
HCURSOR LoadStandardCursor(LPCTSTR lpszCursorName) const;
```

### <a name="parameters"></a>Paramètres

*lpszCursorName*<br/>
Un **IDC_** un identificateur constant manifeste qui spécifie un curseur Windows prédéfini. Ces identificateurs sont définis dans WINDOWS. H. La liste suivante montre les valeurs et les significations prédéfinies possibles pour *lpszCursorName*:

- curseur de flèches IDC_ARROW Standard

- IDC_IBEAM Curseur d’insertion de texte standard

- IDC_WAIT curseur de sablier utilisé lorsque Windows effectue une tâche fastidieuse

- IDC_CROSS curseur de cheveux croisés pour la sélection

- IDC_UPARROW Flèche qui pointe droit vers le haut

- IDC_SIZE obsolète et non pris en soutien; utiliser IDC_SIZEALL

- IDC_SIZEALL Une flèche à quatre pointes. Le curseur à utiliser pour resize une fenêtre.

- IDC_ICON obsolète et non pris en soutien. Utilisez IDC_ARROW.

- IDC_SIZENWSE flèche à deux têtes avec des extrémités en haut à gauche et en bas à droite

- IDC_SIZENESW flèche à deux têtes avec des extrémités en haut à droite et en bas à gauche

- IDC_SIZEWE flèche horizontale à deux têtes

- IDC_SIZENS Flèche verticale à deux têtes

### <a name="return-value"></a>Valeur de retour

Une poignée à un curseur en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

Utilisez `LoadStandardCursor` la fonction membre [LoadOEMCursor](#loadoemcursor) pour accéder aux curseurs Windows prédéfinis.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#47](../../mfc/reference/codesnippet/cpp/cwinapp-class_14.cpp)]

## <a name="cwinapploadstandardicon"></a><a name="loadstandardicon"></a>CWinApp::LoadStandardIcon

Charge la ressource d’icône prédéfinie Windows que *lpszIconName* spécifie.

```
HICON LoadStandardIcon(LPCTSTR lpszIconName) const;
```

### <a name="parameters"></a>Paramètres

*lpszIconName (en)*<br/>
Un identifiant constant manifeste qui spécifie une icône Windows prédéfinie. Ces identificateurs sont définis dans WINDOWS. H. Pour une liste des valeurs prédéfinies possibles et de leurs descriptions, consultez le paramètre *lpIconName* dans [LoadIcon](/windows/win32/api/winuser/nf-winuser-loadiconw) dans windows SDK.

### <a name="return-value"></a>Valeur de retour

Une poignée à une icône en cas de succès; autrement NULL.

### <a name="remarks"></a>Notes

Utilisez `LoadStandardIcon` la fonction membre [ou LoadOEMIcon](#loadoemicon) pour accéder aux icônes Windows prédéfinies.

## <a name="cwinapploadstdprofilesettings"></a><a name="loadstdprofilesettings"></a>CWinApp::LoadStdProfileSettings

Appelez cette fonction membre à partir de la fonction membre [InitInstance](#initinstance) pour activer et charger la liste des fichiers les plus récemment utilisés (MRU) et dernier état de prévisualisation.

```cpp
void LoadStdProfileSettings(UINT nMaxMRU = _AFX_MRU_COUNT);
```

### <a name="parameters"></a>Paramètres

*nMaxMRU (en anglais seulement)*<br/>
Le nombre de fichiers récemment utilisés pour suivre.

### <a name="remarks"></a>Notes

Si *nMaxMRU* est 0, aucune liste MRU ne sera maintenue.

## <a name="cwinappm_bhelpmode"></a><a name="m_bhelpmode"></a>CWinApp::m_bHelpMode

VRAI si l’application est en mode contexte d’aide (conventionnellement invoquée avec SHIFT et F1); autrement FALSE.

```
BOOL m_bHelpMode;
```

### <a name="remarks"></a>Notes

En mode Contexte Help, le curseur devient un point d’interrogation et l’utilisateur peut le déplacer sur l’écran. Examinez ce drapeau si vous souhaitez implémenter une manipulation spéciale lorsque vous êtes en mode Aide. `m_bHelpMode`est une variable publique de type BOOL.

## <a name="cwinappm_dwrestartmanagersupportflags"></a><a name="m_dwrestartmanagersupportflags"></a>CWinApp::m_dwRestartManagerSupportFlags

Drapeaux qui déterminent le comportement du gestionnaire de redémarrage.

```
DWORD m_dwRestartManagerSupportFlags;
```

### <a name="remarks"></a>Notes

Pour activer le `m_dwRestartManagerSupportFlags` gestionnaire de redémarrage, définissez le comportement que vous voulez. Le tableau suivant montre les drapeaux disponibles.

|||
|-|-|
|Indicateur|Description|
|AFX_RESTART_MANAGER_SUPPORT_RESTART|L’application est enregistrée à l’aide de [CWinApp::RegisterWithRestartManager](#registerwithrestartmanager). Le gestionnaire de redémarrage est responsable du redémarrage de l’application si elle sort de façon inattendue.|
|- AFX_RESTART_MANAGER_SUPPORT_RECOVERY|L’application est enregistrée auprès du gestionnaire de redémarrage et le gestionnaire de redémarrage appelle la fonction de rappel de récupération lorsqu’il redémarre l’application. La fonction de rappel de récupération par défaut est [CWinApp::ApplicationRecoveryCallback](#applicationrecoverycallback).|
|- AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART|Autosave est activé et le gestionnaire de redémarrage permet d’éviter tout document ouvert lorsque l’application redémarre.|
|- AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL|Autosave est activé et le gestionnaire de redémarrage permet tous les documents ouverts à un intervalle régulier. L’intervalle est défini par [CWinApp:m_nAutosaveInterval](#m_nautosaveinterval).|
|- AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES|Le gestionnaire de redémarrage ouvre des documents précédemment ouverts après avoir redémarré l’application à partir d’une sortie inattendue. La [classe CDataRecoveryHandler s’occupe](../../mfc/reference/cdatarecoveryhandler-class.md) du stockage de la liste des documents ouverts et de leur restauration.|
|- AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES|Le gestionnaire de redémarrage invite l’utilisateur à restaurer les fichiers autosavés après le redémarrage de l’application. La `CDataRecoveryHandler` classe interroge l’utilisateur.|
|- AFX_RESTART_MANAGER_SUPPORT_NO_AUTOSAVE|Le syndicat des AFX_RESTART_MANAGER_SUPPORT_RESTART, AFX_RESTART_MANAGER_SUPPORT_RECOVER et AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES.|
|- AFX_RESTART_MANAGER_SUPPORT_ALL_ASPECTS|Le syndicat des AFX_RESTART_MANAGER_SUPPORT_NO_AUTOSAVE, AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART, AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL et AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES.|
|- AFX_RESTART_MANAGER_SUPPORT_RESTART_ASPECTS|Le syndicat des AFX_RESTART_MANAGER_SUPPORT_RESTART, AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART, AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES et AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES.|
|- AFX_RESTART_MANAGER_SUPPORT_RECOVERY_ASPECTS|Le syndicat ofAFX_RESTART_MANAGER_SUPPORT_RECOVERY, AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL, AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES et AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES.|

## <a name="cwinappm_ehelptype"></a><a name="m_ehelptype"></a>CWinApp:m_eHelpType

Le type de ce membre de données est le type énuméré `CWinApp` AFX_HELP_TYPE, qui est défini au sein de la classe.

```
AFX_HELP_TYPE m_eHelpType;
```

### <a name="remarks"></a>Notes

Le AFX_HELP_TYPE’énumération est défini comme suit :

```
enum AFX_HELP_TYPE {
    afxWinHelp = 0,
    afxHTMLHelp = 1
    };
```

- Pour définir l’aide de l’application à l’aide `afxHTMLHelp`HTML, appelez [SetHelpMode](#sethelpmode) et spécifiez .

- Pour définir l’aide de l’application `SetHelpMode` à `afxWinHelp`WinHelp, appelez et spécifiez .

## <a name="cwinappm_hinstance"></a><a name="m_hinstance"></a>CWinApp:m_hInstance

Correspond au *paramètre hInstance* passé `WinMain`par Windows à .

```
HINSTANCE m_hInstance;
```

### <a name="remarks"></a>Notes

Le `m_hInstance` membre des données est une poignée à l’exemple actuel de l’application en cours d’exécution sous Windows. Ceci est retourné par la fonction globale [AfxGetInstanceHandle](application-information-and-management.md#afxgetinstancehandle). `m_hInstance`est une variable publique de type HINSTANCE.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#55](../../mfc/reference/codesnippet/cpp/cwinapp-class_15.cpp)]

## <a name="cwinappm_lpcmdline"></a><a name="m_lpcmdline"></a>CWinApp:m_lpCmdLine

Correspond au *paramètre lpCmdLine* passé `WinMain`par Windows à .

```
LPTSTR m_lpCmdLine;
```

### <a name="remarks"></a>Notes

Indique une chaîne non terminée qui spécifie la ligne de commande de l’application. Utilisez `m_lpCmdLine` pour accéder à tous les arguments de ligne de commande que l’utilisateur a saisis lorsque l’application a été lancée. `m_lpCmdLine`est une variable publique de type LPTSTR.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#52](../../mfc/reference/codesnippet/cpp/cwinapp-class_16.cpp)]

## <a name="cwinappm_nautosaveinterval"></a><a name="m_nautosaveinterval"></a>CWinApp::m_nAutosaveInterval

La durée en millisecondes entre les autosaves.

```
int m_nAutosaveInterval;
```

### <a name="remarks"></a>Notes

Vous pouvez configurer le gestionnaire de redémarrage pour éviter les documents ouverts à intervalles fixes. Si votre application n’autorise pas les fichiers, ce paramètre n’a aucun effet.

## <a name="cwinappm_ncmdshow"></a><a name="m_ncmdshow"></a>CWinApp:m_nCmdShow

Correspond au paramètre *nCmdShow* passé `WinMain`par Windows à .

```
int m_nCmdShow;
```

### <a name="remarks"></a>Notes

Vous devez `m_nCmdShow` passer comme argument lorsque vous appelez [CWnd::ShowWindow](../../mfc/reference/cwnd-class.md#showwindow) pour la fenêtre principale de votre application. `m_nCmdShow`est une variable publique de type **int**.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#56](../../mfc/reference/codesnippet/cpp/cwinapp-class_17.cpp)]

## <a name="cwinappm_pactivewnd"></a><a name="m_pactivewnd"></a>CWinApp::m_pActiveWnd

Utilisez ce membre de données pour stocker un pointeur vers la fenêtre principale de l’application de conteneur OLE qui a votre application serveur OLE activée.

### <a name="remarks"></a>Notes

Si ce membre de données est NULL, l’application n’est pas active sur place.

Le cadre définit cette variable de membre lorsque la fenêtre de cadre est activée par une application de conteneur OLE.

## <a name="cwinappm_pdatarecoveryhandler"></a><a name="m_pdatarecoveryhandler"></a>CWinApp:m_pDataRecoveryHandler

Pointeur vers le gestionnaire de récupération de données pour l’application.

```
CDataRecoveryHandler* m_pDataRecoveryHandler;
```

### <a name="remarks"></a>Notes

Le gestionnaire de récupération de données d’une application surveille les documents ouverts et les autosave. Le cadre utilise le gestionnaire de récupération de données pour restaurer les fichiers autosavés lorsqu’une application redémarre après sa sortie inattendue. Pour plus d’informations, voir [CDataRecoveryHandler Class](../../mfc/reference/cdatarecoveryhandler-class.md).

## <a name="cwinappm_pszappname"></a><a name="m_pszappname"></a>CWinApp:m_pszAppName

Spécifie le nom de l'application.

```
LPCTSTR m_pszAppName;
```

### <a name="remarks"></a>Notes

Le nom de l’application peut provenir du paramètre transmis au constructeur [CWinApp,](#cwinapp) ou, s’il n’est pas spécifié, à la chaîne de ressources avec l’ID de AFX_IDS_APP_TITLE. Si le nom de la demande ne se trouve pas dans la ressource, il provient de celui du programme. Nom de fichier EXE.

Retourné par la fonction globale [AfxGetAppName](application-information-and-management.md#afxgetappname). `m_pszAppName`est une variable publique de type **const char**<strong>\*</strong>.

> [!NOTE]
> Si vous attribuez `m_pszAppName`une valeur à , il doit être alloué dynamiquement sur le tas. Le `CWinApp` destructeur appelle **libre**( ) avec ce pointeur. Vous beaucoup veulent `_tcsdup`utiliser la fonction de bibliothèque () de temps d’exécution pour faire l’allocation. En outre, libérer la mémoire associée au pointeur actuel avant d’attribuer une nouvelle valeur. Par exemple :

[!code-cpp[NVC_MFCWindowing#57](../../mfc/reference/codesnippet/cpp/cwinapp-class_18.cpp)]

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#65](../../mfc/reference/codesnippet/cpp/cwinapp-class_19.cpp)]

## <a name="cwinappm_pszexename"></a><a name="m_pszexename"></a>CWinApp:m_pszExeName

Contient le nom du fichier exécutable de l’application sans prolongation.

```
LPCTSTR m_pszExeName;
```

### <a name="remarks"></a>Notes

Contrairement à [m_pszAppName,](#m_pszappname)ce nom ne peut pas contenir de blancs. `m_pszExeName`est une variable publique de type **const char**<strong>\*</strong>.

> [!NOTE]
> Si vous attribuez `m_pszExeName`une valeur à , il doit être alloué dynamiquement sur le tas. Le `CWinApp` destructeur appelle **libre**( ) avec ce pointeur. Vous beaucoup veulent `_tcsdup`utiliser la fonction de bibliothèque () de temps d’exécution pour faire l’allocation. En outre, libérer la mémoire associée au pointeur actuel avant d’attribuer une nouvelle valeur. Par exemple :

[!code-cpp[NVC_MFCWindowing#58](../../mfc/reference/codesnippet/cpp/cwinapp-class_20.cpp)]

## <a name="cwinappm_pszhelpfilepath"></a><a name="m_pszhelpfilepath"></a>CWinApp::m_pszHelpFilePath

Contient le chemin vers le fichier d’aide de l’application.

```
LPCTSTR m_pszHelpFilePath;
```

### <a name="remarks"></a>Notes

Par défaut, le cadre `m_pszHelpFilePath` est parasé à la demande avec ". HLP" joint. Pour modifier le nom du `m_pszHelpFilePath` fichier d’aide, définissez une chaîne qui contient le nom complet du fichier d’aide souhaité. Un endroit pratique pour le faire est dans la fonction [InitInstance](#initinstance) de l’application. `m_pszHelpFilePath`est une variable publique de type **const char**<strong>\*</strong>.

> [!NOTE]
> Si vous attribuez `m_pszHelpFilePath`une valeur à , il doit être alloué dynamiquement sur le tas. Le `CWinApp` destructeur appelle **libre**( ) avec ce pointeur. Vous beaucoup veulent `_tcsdup`utiliser la fonction de bibliothèque () de temps d’exécution pour faire l’allocation. En outre, libérer la mémoire associée au pointeur actuel avant d’attribuer une nouvelle valeur. Par exemple :

[!code-cpp[NVC_MFCWindowing#59](../../mfc/reference/codesnippet/cpp/cwinapp-class_21.cpp)]

## <a name="cwinappm_pszprofilename"></a><a name="m_pszprofilename"></a>CWinApp:m_pszProfileName

Contient le nom de l’application . Fichier INI.

```
LPCTSTR m_pszProfileName;
```

### <a name="remarks"></a>Notes

`m_pszProfileName`est une variable publique de type **const char**<strong>\*</strong>.

> [!NOTE]
> Si vous attribuez `m_pszProfileName`une valeur à , il doit être alloué dynamiquement sur le tas. Le `CWinApp` destructeur appelle **libre**( ) avec ce pointeur. Vous beaucoup veulent `_tcsdup`utiliser la fonction de bibliothèque () de temps d’exécution pour faire l’allocation. En outre, libérer la mémoire associée au pointeur actuel avant d’attribuer une nouvelle valeur. Par exemple :

[!code-cpp[NVC_MFCWindowing#60](../../mfc/reference/codesnippet/cpp/cwinapp-class_22.cpp)]

## <a name="cwinappm_pszregistrykey"></a><a name="m_pszregistrykey"></a>CWinApp::m_pszRegistryKey

Utilisé pour déterminer où, dans le registre ou le fichier INI, les paramètres de profil d’application sont stockés.

```
LPCTSTR m_pszRegistryKey;
```

### <a name="remarks"></a>Notes

Normalement, ce membre de données est traité comme lu uniquement.

- La valeur est stockée à une clé de registre. Le nom du paramètre de profil d’application est joint à la clé de registre suivante : HKEY_CURRENT_USER/Software/LocalAppWizard-Generated/.

Si vous attribuez `m_pszRegistryKey`une valeur à , il doit être alloué dynamiquement sur le tas. Le `CWinApp` destructeur appelle **libre**( ) avec ce pointeur. Vous beaucoup veulent `_tcsdup`utiliser la fonction de bibliothèque () de temps d’exécution pour faire l’allocation. En outre, libérer la mémoire associée au pointeur actuel avant d’attribuer une nouvelle valeur. Par exemple :

[!code-cpp[NVC_MFCWindowing#61](../../mfc/reference/codesnippet/cpp/cwinapp-class_23.cpp)]

## <a name="cwinappm_pszappid"></a><a name="m_pszappid"></a>CWinApp::m_pszAppID

Id modèle d’utilisateur d’application.

```
LPCTSTR m_pszAppID;
```

### <a name="remarks"></a>Notes

## <a name="cwinapponcontexthelp"></a><a name="oncontexthelp"></a>CWinApp::OnContextHelp

Gère l’aide SHIFT-F1 dans l’application.

```
afx_msg void OnContextHelp();
```

### <a name="remarks"></a>Notes

Vous devez `ON_COMMAND( ID_CONTEXT_HELP, OnContextHelp )` ajouter une `CWinApp` déclaration à votre carte de message de classe et ajouter également une entrée de table d’accélérateur, généralement SHIFT-F1, pour activer cette fonction de membre.

`OnContextHelp`met l’application en mode Aide. Le curseur se transforme en flèche et un point d’interrogation, et l’utilisateur peut alors déplacer le pointeur de la souris et appuyer sur le bouton de la souris gauche pour sélectionner une boîte de dialogue, une fenêtre, un menu ou un bouton de commande. Cette fonction de membre récupère le contexte d’aide de l’objet sous le curseur et appelle la fonction Windows WinHelp avec cela Contexte d’aide.

## <a name="cwinapponddecommand"></a><a name="onddecommand"></a>CWinApp::OnDDECommand

Appelé par le cadre lorsque la fenêtre de cadre principale reçoit un message DDE exécuter.

```
virtual BOOL OnDDECommand(LPTSTR lpszCommand);
```

### <a name="parameters"></a>Paramètres

*lpszCommand (en)*<br/>
Points à une chaîne de commande DDE reçue par la demande.

### <a name="return-value"></a>Valeur de retour

Nonzero si la commande est manipulée; sinon 0.

### <a name="remarks"></a>Notes

La mise en œuvre par défaut vérifie si la commande est une demande d’ouverture d’un document et, dans l’affirmative, ouvre le document spécifié. Le gestionnaire de fichiers Windows envoie généralement de telles chaînes de commande DDE lorsque l’utilisateur double-clics d’un fichier de données. Remplacer cette fonction pour gérer d’autres commandes DDE exécuter, telles que la commande à imprimer.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#48](../../mfc/reference/codesnippet/cpp/cwinapp-class_24.cpp)]

## <a name="cwinapponfilenew"></a><a name="onfilenew"></a>CWinApp::OnFileNew

Implémente la commande ID_FILE_NEW.

```
afx_msg void OnFileNew();
```

### <a name="remarks"></a>Notes

Vous devez `ON_COMMAND( ID_FILE_NEW, OnFileNew )` ajouter une `CWinApp` déclaration à votre carte de message de classe pour activer cette fonction de membre. Si elle est activée, cette fonction gère l’exécution de la commande File New.

Voir [la note technique 22](../../mfc/tn022-standard-commands-implementation.md) pour obtenir des informations sur le comportement par défaut et les conseils sur la façon de remplacer cette fonction de membre.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

## <a name="cwinapponfileopen"></a><a name="onfileopen"></a>CWinApp::OnFileOpen

Implémente la commande ID_FILE_OPEN.

```
afx_msg void OnFileOpen();
```

### <a name="remarks"></a>Notes

Vous devez `ON_COMMAND( ID_FILE_OPEN, OnFileOpen )` ajouter une `CWinApp` déclaration à votre carte de message de classe pour activer cette fonction de membre. Si elle est activée, cette fonction gère l’exécution de la commande File Open.

Pour plus d’informations sur le comportement par défaut et les conseils sur la façon de remplacer cette fonction de membre, voir [Note technique 22](../../mfc/tn022-standard-commands-implementation.md).

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

## <a name="cwinapponfileprintsetup"></a><a name="onfileprintsetup"></a>CWinApp::OnFilePrintSetup

Implémente la commande ID_FILE_PRINT_SETUP.

```
afx_msg void OnFilePrintSetup();
```

### <a name="remarks"></a>Notes

Vous devez `ON_COMMAND( ID_FILE_PRINT_SETUP, OnFilePrintSetup )` ajouter une `CWinApp` déclaration à votre carte de message de classe pour activer cette fonction de membre. Si elle est activée, cette fonction gère l’exécution de la commande d’impression de fichier.

Pour plus d’informations sur le comportement par défaut et les conseils sur la façon de remplacer cette fonction de membre, voir [Note technique 22](../../mfc/tn022-standard-commands-implementation.md).

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

## <a name="cwinapponhelp"></a><a name="onhelp"></a>CWinApp::OnHelp

Gère l'aide F1 dans l'application (en utilisant le contexte actuel).

```
afx_msg void OnHelp();
```

### <a name="remarks"></a>Notes

Habituellement, vous ajouterez également une entrée à clé d’accélérateur pour la clé F1. L’activation de la clé F1 n’est qu’une convention, pas une exigence.

Vous devez `ON_COMMAND( ID_HELP, OnHelp )` ajouter une `CWinApp` déclaration à votre carte de message de classe pour activer cette fonction de membre. Si activé, appelé par le cadre lorsque l’utilisateur appuie sur la clé F1.

La mise en œuvre par défaut de cette fonction de gestionnaire de messages détermine le contexte d’aide qui correspond à la fenêtre actuelle, boîte de dialogue, ou élément de menu, puis appelle WINHELP. EXE, C’EST EXE. Si aucun contexte n’est actuellement disponible, la fonction utilise le contexte par défaut.

Remplacer cette fonction de membre pour définir le contexte d’aide à autre chose que la fenêtre, la boîte de dialogue, l’élément de menu, ou le bouton de barre d’outils qui a actuellement la mise au point. Appelez `WinHelp` avec l’ID de contexte d’aide désiré.

## <a name="cwinapponhelpfinder"></a><a name="onhelpfinder"></a>CWinApp::OnHelpFinder

Gère les commandes ID_HELP_FINDER et ID_DEFAULT_HELP.

```
afx_msg void OnHelpFinder();
```

### <a name="remarks"></a>Notes

Vous devez `ON_COMMAND( ID_HELP_FINDER, OnHelpFinder )` ajouter une `CWinApp` déclaration à votre carte de message de classe pour activer cette fonction de membre. Si activé, le cadre appelle cette fonction de gestionnaire de message lorsque l’utilisateur de votre application sélectionne la commande Help Finder à invoquer `WinHelp` avec le sujet **HELP_FINDER** standard.

## <a name="cwinapponhelpindex"></a><a name="onhelpindex"></a>CWinApp::OnHelpIndex

Gère la commande ID_HELP_INDEX et fournit un sujet d’aide par défaut.

```
afx_msg void OnHelpIndex();
```

### <a name="remarks"></a>Notes

Vous devez `ON_COMMAND( ID_HELP_INDEX, OnHelpIndex )` ajouter une `CWinApp` déclaration à votre carte de message de classe pour activer cette fonction de membre. Si activé, le cadre appelle cette fonction de gestionnaire de message lorsque `WinHelp` l’utilisateur de votre application sélectionne la commande Help Index à invoquer avec le sujet **HELP_INDEX** standard.

## <a name="cwinapponhelpusing"></a><a name="onhelpusing"></a>CWinApp::OnHelpUsing

Gère la commande ID_HELP_USING.

```
afx_msg void OnHelpUsing();
```

### <a name="remarks"></a>Notes

Vous devez `ON_COMMAND( ID_HELP_USING, OnHelpUsing )` ajouter une `CWinApp` déclaration à votre carte de message de classe pour activer cette fonction de membre. Le cadre appelle cette fonction de gestionnaire de message lorsque l’utilisateur `WinHelp` de votre application sélectionne la commande Help Using pour invoquer l’application avec le sujet **HELP_HELPONHELP** standard.

## <a name="cwinapponidle"></a><a name="onidle"></a>CWinApp::OnIdle

Remplacer cette fonction de membre pour effectuer un traitement au ralenti.

```
virtual BOOL OnIdle(LONG lCount);
```

### <a name="parameters"></a>Paramètres

*lCompte*<br/>
Un compteur incrémenté `OnIdle` à chaque fois est appelé lorsque la file d’attente du message de l’application est vide. Ce nombre est réinitialisé à 0 chaque fois qu’un nouveau message est traité. Vous pouvez utiliser le *paramètre lCount* pour déterminer la durée relative pendant laquelle l’application a été inactive sans traiter un message.

### <a name="return-value"></a>Valeur de retour

Nonzero pour recevoir plus de temps de traitement au ralenti; 0 si plus de temps d’inactivité n’est pas nécessaire.

### <a name="remarks"></a>Notes

`OnIdle`est appelé dans la boucle de message par défaut lorsque la file d’attente du message de l’application est vide. Utilisez votre remplacement pour appeler vos propres tâches de contrôle de ralenti.

`OnIdle`devrait retourner 0 pour indiquer qu’aucun temps de traitement inactif n’est nécessaire. Le *paramètre lCount* est incrémenté chaque fois `OnIdle` que la file d’attente est vide et se réinitialise à 0 chaque fois qu’un nouveau message est traité. Vous pouvez appeler vos différentes routines de ralenti en fonction de ce compte.

Ce qui suit résume le traitement de boucle au ralenti :

1. Si la boucle de message dans la Bibliothèque de classe de la `OnIdle` Fondation Microsoft vérifie la file d’attente du message et ne trouve aucun message en attente, elle appelle l’objet d’application et fournit 0 comme argument *lCount.*

2. `OnIdle`effectue un traitement et renvoie une valeur non zéro pour indiquer qu’il devrait être appelé à nouveau pour faire un traitement ultérieur.

3. La boucle de message vérifie à nouveau la file d’attente du message. Si aucun message n’est `OnIdle` en attente, il appelle à nouveau, incrémentant *l’argument lCount.*

4. Finalement, `OnIdle` termine le traitement de toutes ses tâches inactives et retourne 0. Cela indique à la `OnIdle` boucle de message d’arrêter d’appeler jusqu’à ce que le message suivant soit reçu de la file d’attente du message, à quel point le cycle de ralenti redémarre avec l’argument réglé à 0.

N’effectuez pas `OnIdle` de longues tâches pendant `OnIdle` parce que votre application ne peut pas traiter l’entrée de l’utilisateur jusqu’à ce que les retours.

> [!NOTE]
> La mise `OnIdle` en œuvre par défaut d’objets d’interface utilisateur de commande tels que les éléments de menu et les boutons de barre d’outils, et elle effectue le nettoyage interne de la structure de données. Par conséquent, si `OnIdle`vous remplacez, vous devez appeler `CWinApp::OnIdle` avec la `lCount` dans votre version annulée. Appelez d’abord tous les traitement au ralenti `OnIdle` de classe de base (c’est-à-dire jusqu’à ce que la classe de base revienne 0). Si vous avez besoin d’effectuer le travail avant la fin du traitement de la classe de base, examinez la mise en œuvre de la classe de base pour sélectionner le *bon lCount* pendant lequel faire votre travail.

Si vous ne `OnIdle` voulez pas être appelé chaque fois qu’un message est récupéré dans la file d’attente du message, vous pouvez passer outre le [CWinThreadIsIdleMessage](../../mfc/reference/cwinthread-class.md#isidlemessage). Si une application a défini une minuterie très courte, ou si le `OnIdle` système envoie le message WM_SYSTIMER, alors sera appelé à plusieurs reprises, et dégrader les performances.

### <a name="example"></a>Exemple

Les deux exemples suivants `OnIdle`montrent comment utiliser . Le premier exemple traite deux tâches inactives en utilisant *l’argument lCount* pour prioriser les tâches. La première tâche est hautement prioritaire, et vous devriez le faire chaque fois que c’est possible. La deuxième tâche est moins importante et ne doit être effectuée que lorsqu’il y a une longue pause dans l’entrée de l’utilisateur. Notez l’appel à la `OnIdle`version de base de . Le deuxième exemple gère un groupe de tâches inactives avec des priorités différentes.

[!code-cpp[NVC_MFCWindowing#51](../../mfc/reference/codesnippet/cpp/cwinapp-class_27.cpp)]

## <a name="cwinappopendocumentfile"></a><a name="opendocumentfile"></a>CWinApp::OpenDocumentFile

Le cadre appelle cette méthode pour ouvrir le fichier [CDocument](../../mfc/reference/cdocument-class.md) nommé pour la demande.

```
virtual CDocument* OpenDocumentFile(
    LPCTSTR lpszFileName
    BOOL bAddToMRU = TRUE);
```

### <a name="parameters"></a>Paramètres

*lpszFileName*<br/>
[dans] Le nom du fichier à ouvrir.

*bAddToMRU (en anglais seulement)*<br/>
[dans] TRUE indique que le document est l’un des fichiers les plus récents; FALSE indique que le document n’est pas l’un des fichiers les plus récents.

### <a name="return-value"></a>Valeur de retour

Un pointeur `CDocument` à un si réussi; autrement NULL.

### <a name="remarks"></a>Notes

Si un document qui a ce nom est déjà ouvert, la première fenêtre de cadre qui contient ce document sera mise au point. Si une application prend en charge plusieurs modèles de documents, le cadre utilise l’extension du nom de fichier pour trouver le modèle de document approprié pour tenter de charger le document. En cas de succès, le modèle de document crée alors une fenêtre de cadre et une vue pour le document.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#52](../../mfc/reference/codesnippet/cpp/cwinapp-class_16.cpp)]

## <a name="cwinappparsecommandline"></a><a name="parsecommandline"></a>CWinApp::ParseCommandLine

Appelez cette fonction de membre pour analyser la ligne de commande et envoyer les paramètres, un à la fois, à [CCommandLineInfo::ParseParam](../../mfc/reference/ccommandlineinfo-class.md#parseparam).

```cpp
void ParseCommandLine(CCommandLineInfo& rCmdInfo);
```

### <a name="parameters"></a>Paramètres

*rCmdInfo (en anglais)*<br/>
Une référence à un objet [CCommandLineInfo.](../../mfc/reference/ccommandlineinfo-class.md)

### <a name="remarks"></a>Notes

Lorsque vous démarrez un nouveau projet MFC à l’aide `CCommandLineInfo`de l’Assistant d’Application, l’Assistant d’Application créera une instance locale de , puis appelez `ProcessShellCommand` et `ParseCommandLine` dans la fonction membre [InitInstance.](#initinstance) Une ligne de commandement suit l’itinéraire décrit ci-dessous :

1. Après avoir `InitInstance`été `CCommandLineInfo` créé en `ParseCommandLine`, l’objet est passé à .

2. `ParseCommandLine`puis `CCommandLineInfo::ParseParam` appelle à plusieurs reprises, une fois pour chaque paramètre.

3. `ParseParam`remplit l’objet, `CCommandLineInfo` qui est ensuite passé à [ProcessShellCommand](#processshellcommand).

4. `ProcessShellCommand`gère les arguments et les drapeaux de la ligne de commandement.

Notez que `ParseCommandLine` vous pouvez appeler directement au besoin.

Pour une description des drapeaux de la ligne de commandement, voir [CCommandLineInfo:m_nShellCommand](../../mfc/reference/ccommandlineinfo-class.md#m_nshellcommand).

## <a name="cwinapppretranslatemessage"></a><a name="pretranslatemessage"></a>CWinApp::PreTranslateMessage

Remplacer cette fonction pour filtrer les messages de fenêtre avant qu’ils ne soient envoyés aux fonctions Windows [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage) et [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) La implémentation par défaut effectue une traduction à clé de l’accélérateur, de sorte que vous devez appeler la `CWinApp::PreTranslateMessage` fonction membre dans votre version primordiale.

```
virtual BOOL PreTranslateMessage(MSG* pMsg);
```

### <a name="parameters"></a>Paramètres

*pMsg*<br/>
Un pointeur vers une structure [MSG](/windows/win32/api/winuser/ns-winuser-msg) qui contient le message à traiter.

### <a name="return-value"></a>Valeur de retour

Nonzero si le message `PreTranslateMessage` a été entièrement traité et ne doit pas être traité plus loin. Zéro si le message doit être traité de la manière normale.

## <a name="cwinappprocessmessagefilter"></a><a name="processmessagefilter"></a>CWinApp::ProcessMessageFilter

La fonction de crochet du cadre appelle cette fonction de membre pour filtrer et répondre à certains messages Windows.

```
virtual BOOL ProcessMessageFilter(
    int code,
    LPMSG lpMsg);
```

### <a name="parameters"></a>Paramètres

*code*<br/>
Spécifie un code de crochet. Cette fonction membre utilise le code pour déterminer comment traiter *lpMsg.*

*lpMsg*<br/>
Un pointeur à une trêve [Windows MSG.](/windows/win32/api/winuser/ns-winuser-msg)

### <a name="return-value"></a>Valeur de retour

Nonzero si le message est traité; sinon 0.

### <a name="remarks"></a>Notes

Une fonction de crochet traite les événements avant qu’ils ne soient envoyés au traitement normal du message de l’application.

Si vous remplacez cette fonctionnalité avancée, assurez-vous d’appeler la version de base pour maintenir le traitement du crochet du cadre.

## <a name="cwinappprocessshellcommand"></a><a name="processshellcommand"></a>CWinApp::ProcessShellCommand

Cette fonction de membre est appelée par [InitInstance](#initinstance) pour accepter les paramètres passés à partir de l’objet `CCommandLineInfo` identifié par *rCmdInfo*, et effectuer l’action indiquée.

```
BOOL ProcessShellCommand(CCommandLineInfo& rCmdInfo);
```

### <a name="parameters"></a>Paramètres

*rCmdInfo (en anglais)*<br/>
Une référence à un objet [CCommandLineInfo.](../../mfc/reference/ccommandlineinfo-class.md)

### <a name="return-value"></a>Valeur de retour

Nonzero si la commande de coquille est traitée avec succès. Si 0, retournez FALSE [d’InitInstance](#initinstance).

### <a name="remarks"></a>Notes

Lorsque vous démarrez un nouveau projet MFC à l’aide `CCommandLineInfo`de l’Assistant d’Application, l’Assistant d’Application créera une instance locale de , puis appelez `ProcessShellCommand` et [ParseCommandLine](#parsecommandline) dans la `InitInstance` fonction membre. Une ligne de commandement suit l’itinéraire décrit ci-dessous :

1. Après avoir `InitInstance`été `CCommandLineInfo` créé en `ParseCommandLine`, l’objet est passé à .

2. `ParseCommandLine`appelle ensuite [CCommandLineInfo::ParseParam](../../mfc/reference/ccommandlineinfo-class.md#parseparam) à plusieurs reprises, une fois pour chaque paramètre.

3. `ParseParam`remplit l’objet, `CCommandLineInfo` qui est `ProcessShellCommand`ensuite passé à .

4. `ProcessShellCommand`gère les arguments et les drapeaux de la ligne de commandement.

Les membres des `CCommandLineInfo` données de l’objet, identifiés par [CCommandLineInfo:m_nShellCommand](../../mfc/reference/ccommandlineinfo-class.md#m_nshellcommand), sont du type `CCommandLineInfo` énuméré suivant, qui est défini au sein de la classe.

```
enum {
    FileNew,
    FileOpen,
    FilePrint,
    FilePrintTo,
    FileDDE
    };
```

Pour une brève description de chacune de ces valeurs, voir `CCommandLineInfo::m_nShellCommand`.

## <a name="cwinappprocesswndprocexception"></a><a name="processwndprocexception"></a>CWinApp::ProcessWndProcException

Le cadre appelle cette fonction de membre chaque fois que le gestionnaire n’attrape pas une exception lancée dans l’un des messages ou des gestionnaires de commande de votre application.

```
virtual LRESULT ProcessWndProcException(
    CException* e,
    const MSG* pMsg);
```

### <a name="parameters"></a>Paramètres

*E*<br/>
Un pointeur à une exception non tendue.

*pMsg*<br/>
Une trêve [MSG](/windows/win32/api/winuser/ns-winuser-msg)qui contient des informations sur le message Windows qui a causé le cadre de jeter une exception.

### <a name="return-value"></a>Valeur de retour

La valeur qui doit être retournée à Windows. Normalement, il s’agit de 0L pour les messages Windows, 1L ( TRUE) pour les messages de commande.

### <a name="remarks"></a>Notes

N’appelez pas directement cette fonction de membre.

La mise en œuvre par défaut de cette fonction membre crée une boîte de message. Si l’exception non marquée provient d’un menu, d’une barre d’outils ou d’une défaillance de commande d’accélérateur, la boîte de message affiche un message « Commande a échoué »; autrement, il affiche un message " Erreur d’application interne ".

Remplacez cette fonction de membre pour assurer la gestion globale de vos exceptions. N’appelez la fonctionnalité de base que si vous souhaitez que la boîte de message soit affichée.

## <a name="cwinappregister"></a><a name="register"></a>CWinApp::Enregistrement

Effectue toutes les tâches d’enregistrement non traitées par `RegisterShellFileTypes`.

```
virtual BOOL Register();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro en cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

La mise en œuvre par défaut renvoie simplement TRUE. Remplacez cette fonction pour fournir toutes les étapes d’enregistrement personnalisées.

## <a name="cwinappregistershellfiletypes"></a><a name="registershellfiletypes"></a>CWinApp::RegisterShellFileTypes

Appelez cette fonction de membre pour enregistrer tous les types de documents de votre application auprès du gestionnaire de fichiers Windows.

```cpp
void RegisterShellFileTypes(BOOL bCompat = FALSE);
```

### <a name="parameters"></a>Paramètres

*bCompat (en)*<br/>
[dans] TRUE ajoute des entrées d’enregistrement pour les commandes de coquille Imprimer et imprimer, permettant à un utilisateur d’imprimer des fichiers directement à partir de la coque, ou en faisant glisser le fichier vers un objet d’imprimante. Il ajoute également une clé DefaultIcon. Par défaut, ce paramètre est FALSE pour la compatibilité vers l’arrière.

### <a name="remarks"></a>Notes

Cela permet à l’utilisateur d’ouvrir un fichier de données créé par votre application en le cliquant en deux clics à partir de file Manager. Appelez `RegisterShellFileTypes` après avoir appelé [AddDocTemplate](#adddoctemplate) pour chacun des modèles de documents de votre application. Aussi appeler la fonction membre [EnableShellOpen](#enableshellopen) lorsque vous appelez `RegisterShellFileTypes`.

`RegisterShellFileTypes`itérations à travers la liste des objets [CDocTemplate](../../mfc/reference/cdoctemplate-class.md) que l’application maintient et, pour chaque modèle de document, ajoute des entrées à la base de données d’enregistrement que Windows maintient pour les associations de fichiers. File Manager utilise ces entrées pour ouvrir un fichier de données lorsque l’utilisateur le double.cliquez. Cela élimine la nécessité d’expédier un . Fichier REG avec votre demande.

> [!NOTE]
> `RegisterShellFileTypes`fonctionne uniquement si l’utilisateur exécute le programme avec les droits de l’administrateur. Si le programme n’a pas de droits d’administrateur, il ne peut pas modifier les clés du registre.

Si la base de données d’enregistrement associe déjà une extension donnée de nom de fichier à un autre type de fichier, aucune nouvelle association n’est créée. Consultez `CDocTemplate` la classe pour le format des chaînes nécessaires pour enregistrer ces informations.

## <a name="cwinappregisterwithrestartmanager"></a><a name="registerwithrestartmanager"></a>CWinApp::RegisterWithRestartManager

Enregistre l’application auprès du gestionnaire du redémarrage.

```
virtual HRESULT RegisterWithRestartManager(
    BOOL bRegisterRecoveryCallback,
    const CString& strRestartIdentifier);

virtual HRESULT RegisterWithRestartManager(
    LPCWSTR pwzCommandLineArgs,
    DWORD dwRestartFlags,
    APPLICATION_RECOVERY_CALLBACK pRecoveryCallback,
    LPVOID lpvParam,
    DWORD dwPingInterval,
    DWORD dwCallbackFlags);
```

### <a name="parameters"></a>Paramètres

|||
|-|-|
|Paramètre|Description|
|*bRegisterRecoveryCallback (en anglais seulement)*|[dans] TRUE indique que cette instance de l’application utilise une fonction de rappel de récupération; FALSE indique que ce n’est pas le cas. Le cadre appelle la fonction de rappel de récupération lorsque l’application sort de façon inattendue. Pour plus d’informations, voir [CWinApp::ApplicationRecoveryCallback](#applicationrecoverycallback).|
|*strRestartIdentifier*|[dans] La chaîne unique qui identifie cette instance du gestionnaire de redémarrage. L’identifiant de gestionnaire de redémarrage est unique pour chaque cas d’une application.|
|*pwzCommandLineArgs*|[dans] Une chaîne qui contient des arguments supplémentaires de la ligne de commande.|
|*dwRestartFlags dwRestartFlags dwRestartFlags dw*|[dans] Drapeaux optionnels pour le gestionnaire de redémarrage. Pour plus d'informations, consultez la section Notes.|
|*pRecoveryCallback*|[dans] La fonction de rappel de récupération. Cette fonction doit prendre un paramètre LPVOID comme entrée et retourner un DWORD. La fonction de rappel `CWinApp::ApplicationRecoveryCallback`de récupération par défaut est .|
|*lpvParam (en)*|[dans] Le paramètre d’entrée pour la fonction de rappel de récupération. Pour plus d’informations, voir [CWinApp::ApplicationRecoveryCallback](#applicationrecoverycallback).|
|*dwPingInterval*|[dans] La durée pendant laquelle le gestionnaire de redémarrage attend le retour de la fonction de rappel de récupération. Ce paramètre est en millisecondes.|
|*dwCallbackFlags dwCallbackFlags*|[dans] Drapeaux passés à la fonction de rappel de récupération. Réservé pour un usage futur.|

### <a name="return-value"></a>Valeur de retour

S_OK si la méthode est efficace; sinon un code d’erreur.

### <a name="remarks"></a>Notes

Si votre application utilise la implémentation MFC par défaut pour `RegisterWithRestartManager`les fichiers d’autosavage, vous devez utiliser la version simple de . Utilisez la version `RegisterWithRestartManager` complexe de si vous voulez personnaliser le comportement autosave de votre application.

Si vous appelez cette méthode avec une chaîne `RegisterWithRestartManager` vide pour *strRestartIdentifier*, crée une chaîne d’identification unique pour cet exemple du gestionnaire de redémarrage.

Lorsqu’une application sort de façon inattendue, le gestionnaire de redémarrage redémarre l’application à partir de la ligne de commande et fournit l’identifiant de redémarrage unique comme argument facultatif. Dans ce scénario, `RegisterWithRestartManager` le cadre appelle deux fois. Le premier appel vient de [CWinApp::InitInstance](#initinstance) avec une chaîne vide pour l’identifiant de chaîne. Ensuite, la méthode [CWinApp::ProcessShellCommand](#processshellcommand) `RegisterWithRestartManager` appelle avec l’identifiant de redémarrage unique.

Une fois que vous avez enregistré une demande auprès du gestionnaire de redémarrage, le gestionnaire de redémarrage surveille l’application. Si l’application sort de façon inattendue, le gestionnaire de redémarrage appelle la fonction de rappel de récupération pendant le processus d’arrêt. Le gestionnaire de redémarrage attend le *dwPingInterval* pour une réponse de la fonction de rappel de récupération. Si la fonction de rappel de récupération ne répond pas dans ce délai, l’application sort sans exécuter la fonction de rappel de récupération.

Par défaut, les dwRestartFlags ne sont pas pris en charge mais sont fournis pour une utilisation future. Les valeurs possibles pour *dwRestartFlags* sont les suivantes:

- RESTART_NO_CRASH

- RESTART_NO_HANG

- RESTART_NO_PATCH

- RESTART_NO_REBOOT

## <a name="cwinappreopenpreviousfilesatrestart"></a><a name="reopenpreviousfilesatrestart"></a>CWinApp::ReopenPreviousFilesAtRestart

Détermine si le gestionnaire de redémarrage rouvre les dossiers qui étaient ouverts lorsque l’application est sortie de façon inattendue.

```
virtual BOOL ReopenPreviousFilesAtRestart() const;
```

### <a name="return-value"></a>Valeur de retour

TRUE indique que le gestionnaire de redémarrage rouvre les fichiers précédemment ouverts; FALSE indique que le gestionnaire de redémarrage ne le fait pas.

## <a name="cwinapprestartinstance"></a><a name="restartinstance"></a>CWinApp::RestartInstance

Gère un redémarrage d’application initié par le gestionnaire de redémarrage.

```
virtual BOOL CWinApp::RestartInstance();
```

### <a name="return-value"></a>Valeur de retour

VRAI si le gestionnaire de récupération de données ouvre des documents précédemment ouverts; FALSE si le gestionnaire de récupération de données a une erreur ou s’il n’y a pas de documents déjà ouverts.

### <a name="remarks"></a>Notes

Lorsque le gestionnaire de redémarrage redémarre une application, le cadre appelle cette méthode. Cette méthode récupère le gestionnaire de récupération de données et restaure les fichiers autosavés. Cette méthode appelle [CDataRecoveryHandler::RestoreAutosavedDocuments](../../mfc/reference/cdatarecoveryhandler-class.md#restoreautosaveddocuments) pour déterminer si l’utilisateur veut restaurer les fichiers autosavés.

Cette méthode renvoie FALSE si le [CDataRecoveryHandler](../../mfc/reference/cdatarecoveryhandler-class.md) détermine qu’il n’y avait pas de documents ouverts. S’il n’y avait pas de documents ouverts, la demande commence normalement.

## <a name="cwinapprestoreautosavedfilesatrestart"></a><a name="restoreautosavedfilesatrestart"></a>CWinApp::RestoreAutosavedFilesAtRestart

Détermine si le gestionnaire de redémarrage restaure les fichiers autosavés lorsqu’il redémarre l’application.

```
virtual BOOL RestoreAutosavedFilesAtRestart() const;
```

### <a name="return-value"></a>Valeur de retour

TRUE indique que le gestionnaire de redémarrage restaure les fichiers autosavés; FALSE indique que le gestionnaire de redémarrage ne le fait pas.

## <a name="cwinapprun"></a><a name="run"></a>CWinApp::Run

Fournit une boucle de message par défaut.

```
virtual int Run();
```

### <a name="return-value"></a>Valeur de retour

Une valeur **int** qui `WinMain`est retournée par .

### <a name="remarks"></a>Notes

`Run`acquiert et envoie des messages Windows jusqu’à ce que l’application reçoive un message WM_QUIT. Si la file d’attente de `Run` message de l’application ne contient actuellement aucun message, appelle [OnIdle](#onidle) pour effectuer un traitement de temps d’inactivité. Les messages entrants vont à la fonction de membre [PreTranslateMessage](#pretranslatemessage) pour le traitement spécial, puis à la fonction `TranslateMessage` Windows pour la traduction standard du clavier; enfin, `DispatchMessage` la fonction Windows est appelée.

`Run`est rarement remplacé, mais vous pouvez l’emporter pour fournir un comportement spécial.

## <a name="cwinapprunautomated"></a><a name="runautomated"></a>CWinApp::RunAutomated

Appelez cette fonction pour déterminer si l’option " **/Automation**" ou " **-Automation**" est présente, ce qui indique si l’application serveur a été lancée par une application client.

```
BOOL RunAutomated();
```

### <a name="return-value"></a>Valeur de retour

Nonzero si l’option a été trouvée; sinon 0.

### <a name="remarks"></a>Notes

Si elle est présente, l’option est supprimée de la ligne de commande. Pour plus d’informations sur OLE Automation, voir l’article [Automation Servers](../../mfc/automation-servers.md).

## <a name="cwinapprunembedded"></a><a name="runembedded"></a>CWinApp::RunEmbedded

Appelez cette fonction pour déterminer si l’option " **/Embedding**" ou " **-Embedding**" est présente, ce qui indique si l’application serveur a été lancée par une application client.

```
BOOL RunEmbedded();
```

### <a name="return-value"></a>Valeur de retour

Nonzero si l’option a été trouvée; sinon 0.

### <a name="remarks"></a>Notes

Si elle est présente, l’option est supprimée de la ligne de commande. Pour plus d’informations sur l’intégration, voir l’article [Serveurs: Implémenter un serveur](../../mfc/servers-implementing-a-server.md).

## <a name="cwinappsaveallmodified"></a><a name="saveallmodified"></a>CWinApp::SaveAllModified

Appelé par le cadre pour enregistrer tous les documents lorsque la fenêtre de cadre principale de l’application doit être fermée, ou par un message WM_QUERYENDSESSION.

```
virtual BOOL SaveAllModified();
```

### <a name="return-value"></a>Valeur de retour

Nonzero si sûr de mettre fin à la demande; 0 s’il n’est pas sécuritaire de mettre fin à l’application.

### <a name="remarks"></a>Notes

La mise en œuvre par défaut de cette fonction membre appelle le [CDocument::SaveModified](../../mfc/reference/cdocument-class.md#savemodified) fonction membre à son tour pour tous les documents modifiés dans l’application.

## <a name="cwinappselectprinter"></a><a name="selectprinter"></a>CWinApp::SelectPrinter

Appelez cette fonction de membre pour sélectionner une imprimante spécifique, et relâchez l’imprimante qui a été précédemment sélectionnée dans la boîte de dialogue d’impression.

```cpp
void SelectPrinter(
    HANDLE hDevNames,
    HANDLE hDevMode,
    BOOL bFreeOld = TRUE);
```

### <a name="parameters"></a>Paramètres

*hDevNames (en)*<br/>
Une poignée à une tructure [DEVNAMES](/windows/win32/api/commdlg/ns-commdlg-devnames)qui identifie le nom du conducteur, de l’appareil et du port de sortie d’une imprimante spécifique.

*hDevMode*<br/>
Une poignée à une structure [DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea) qui spécifie des informations sur l’initialisation de l’appareil et l’environnement d’une imprimante.

*bFreeOld (en)*<br/>
Libère l’imprimante précédemment sélectionnée.

### <a name="remarks"></a>Notes

Si *hDevMode* et *hDevNames* `SelectPrinter` sont NULL, utilise l’imprimante par défaut actuelle.

## <a name="cwinappsethelpmode"></a><a name="sethelpmode"></a>CWinApp::SetHelpMode

Définit le type d’aide de l’application.

```cpp
void SetHelpMode(AFX_HELP_TYPE eHelpType);
```

### <a name="parameters"></a>Paramètres

*eHelpType (en)*<br/>
Spécifie le type d’aide à utiliser. Voir [CWinApp:m_eHelpType](#m_ehelptype) pour plus d’informations.

### <a name="remarks"></a>Notes

Définit le type d’aide de l’application.

Pour définir le type d’aide de votre application à HTMLHelp, vous pouvez appeler [EnableHTMLHelp](#enablehtmlhelp). Une fois `EnableHTMLHelp`que vous appelez, votre application doit utiliser HTMLHelp comme application d’aide. Si vous voulez changer pour utiliser WinHelp, vous pouvez `SetHelpMode` appeler `afxWinHelp`et définir *eHelpType* à .

## <a name="cwinappsetregistrykey"></a><a name="setregistrykey"></a>CWinApp::SetRegistryKey

Les paramètres d’application sont stockés dans le registre au lieu des fichiers INI.

```cpp
void SetRegistryKey(LPCTSTR lpszRegistryKey);
void SetRegistryKey(UINT nIDRegistryKey);
```

### <a name="parameters"></a>Paramètres

*lpszRegistryKey (en)*<br/>
Pointeur vers une chaîne contenant le nom de la clé.

*nIDRegistryKey (en)*<br/>
ID d’une ressource de chaîne contenant le nom de la clé de registre.

### <a name="remarks"></a>Notes

Cette fonction définit *m_pszRegistryKey*, qui est `GetProfileInt`ensuite `GetProfileString` `WriteProfileInt`utilisé `WriteProfileString` par le `CWinApp`, , , et les fonctions des membres de . Si cette fonction a été appelée, la liste des fichiers les plus utilisés récemment (MRU) est également stockée dans le registre. La clé de registre est généralement le nom d’une entreprise. Il est stocké dans une clé du formulaire suivant: HKEY_CURRENT_USER-Logiciel\\ \> \\<nom de\> \\ l’entreprise<\> \\ nom d’application\><nom de section<nom de valeur .

## <a name="cwinappsupportsapplicationrecovery"></a><a name="supportsapplicationrecovery"></a>CWinApp::SupportsApplicationRecovery

Détermine si le gestionnaire de redémarrage récupère une application qui est sortie de façon inattendue.

```
virtual BOOL SupportsApplicationRecovery() const;
```

### <a name="return-value"></a>Valeur de retour

TRUE indique que le gestionnaire de redémarrage récupère l’application; FALSE indique que le gestionnaire de redémarrage ne le fait pas.

## <a name="cwinappsupportsautosaveatinterval"></a><a name="supportsautosaveatinterval"></a>CWinApp::SupportsAutosaveAtInterval

Détermine si le gestionnaire de redémarrage s’autosave les documents ouverts à un intervalle régulier.

```
virtual BOOL SupportsAutosaveAtInterval() const;
```

### <a name="return-value"></a>Valeur de retour

TRUE indique que le gestionnaire de redémarrage autosaves documents ouverts; FALSE indique que le gestionnaire de redémarrage ne le fait pas.

## <a name="cwinappsupportsautosaveatrestart"></a><a name="supportsautosaveatrestart"></a>CWinApp::SupportsAutosaveAtRestart

Détermine si le gestionnaire de redémarrage s’autosarait à l’aide de documents ouverts lorsque l’application redémarre.

```
virtual BOOL SupportsAutosaveAtRestart() const;
```

### <a name="return-value"></a>Valeur de retour

TRUE indique que le gestionnaire de redémarrage autosaves documents ouverts lorsque l’application redémarre; FALSE indique que le gestionnaire de redémarrage ne le fait pas.

## <a name="cwinappsupportsrestartmanager"></a><a name="supportsrestartmanager"></a>CWinApp::SupportsRestartManager

Détermine si l’application prend en charge le gestionnaire de redémarrage.

```
virtual BOOL SupportsRestartManager() const;
```

### <a name="return-value"></a>Valeur de retour

TRUE indique que l’application prend en charge le gestionnaire de redémarrage; FALSE indique que l’application ne le fait pas.

## <a name="cwinappunregister"></a><a name="unregister"></a>CWinApp::Unregister

Désenregistrer tous les fichiers enregistrés par l’objet de la demande.

```
virtual BOOL Unregister();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro en cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

La `Unregister` fonction annule l’enregistrement effectué par l’objet de l’application et la fonction [Registre.](#register) Normalement, les deux fonctions sont appelées implicitement par MFC et n’apparaîtront donc pas dans votre code.

Remplacez cette fonction pour effectuer des étapes de non-enregistrement personnalisées.

## <a name="cwinappunregistershellfiletypes"></a><a name="unregistershellfiletypes"></a>CWinApp::UnregisterShellFileTypes

Appelez cette fonction de membre pour désinscrire tous les types de documents de votre application avec le gestionnaire de fichiers Windows.

```cpp
void UnregisterShellFileTypes();
```

## <a name="cwinappwinhelp"></a><a name="winhelp"></a>CWinApp::WinHelp

Appelez cette fonction de membre pour invoquer l’application WinHelp.

```
virtual void WinHelp(
    DWORD_PTR dwData,
    UINT nCmd = HELP_CONTEXT);
```

### <a name="parameters"></a>Paramètres

*dwData dwData*<br/>
Spécifie des données supplémentaires. La valeur utilisée dépend de la valeur du paramètre *nCmd.*

*nCmd (en)*<br/>
Spécifie le type d’aide demandée. Pour une liste des valeurs possibles et comment elles affectent le paramètre *dwData,* consultez la fonction [WinHelp](/windows/win32/api/winuser/nf-winuser-winhelpw) Windows.

### <a name="remarks"></a>Notes

Le cadre appelle également cette fonction à invoquer l’application WinHelp.

Le cadre fermera automatiquement l’application WinHelp lorsque votre demande prendra fin.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#53](../../mfc/reference/codesnippet/cpp/cwinapp-class_28.cpp)]

## <a name="cwinappwriteprofilebinary"></a><a name="writeprofilebinary"></a>CWinApp::WriteProfileBinary

Appelez cette fonction membre pour écrire des données binaires dans la section spécifiée du registre de l’application ou . Fichier INI.

```
BOOL WriteProfileBinary(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Indique une chaîne non terminée qui spécifie la section contenant l’entrée. Si l’article n’existe pas, il est créé. Le nom de l’article est indépendant; la ficelle peut être n’importe quelle combinaison de majuscules et de lettres minuscules.

*lpszEntry (en)*<br/>
Indique une chaîne non terminée qui contient l’entrée dans laquelle la valeur doit être écrite. Si l’entrée n’existe pas dans la section spécifiée, elle est créée.

*Pdata*<br/>
Indique les données à écrire.

*nBytes (en)*<br/>
Contient le nombre d’octets à écrire.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="example"></a>Exemple

Cet exemple `CWinApp* pApp = AfxGetApp();` utilise pour obtenir à la classe `WriteProfileBinary` CWinApp illustrant une façon qui et `GetProfileBinary` peut être utilisé à partir de n’importe quelle fonction dans une application MFC.

[!code-cpp[NVC_MFCWindowing#54](../../mfc/reference/codesnippet/cpp/cwinapp-class_29.cpp)]

Pour un autre exemple, voir l’exemple pour [CWinApp::GetProfileBinary](#getprofilebinary).

## <a name="cwinappwriteprofileint"></a><a name="writeprofileint"></a>CWinApp::WriteProfileInt

Appelez cette fonction membre pour écrire la valeur spécifiée dans la section spécifiée du registre de l’application ou . Fichier INI.

```
BOOL WriteProfileInt(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Indique une chaîne non terminée qui spécifie la section contenant l’entrée. Si l’article n’existe pas, il est créé. Le nom de l’article est indépendant; la ficelle peut être n’importe quelle combinaison de majuscules et de lettres minuscules.

*lpszEntry (en)*<br/>
Indique une chaîne non terminée qui contient l’entrée dans laquelle la valeur doit être écrite. Si l’entrée n’existe pas dans la section spécifiée, elle est créée.

*nValue (en)*<br/>
Contient la valeur à écrire.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="example"></a>Exemple

Cet exemple `CWinApp* pApp = AfxGetApp();` utilise pour obtenir à la classe `WriteProfileString`CWinApp illustrant une façon que , `WriteProfileInt`, `GetProfileString`et `GetProfileInt` peut être utilisé à partir de n’importe quelle fonction dans une application MFC.

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

Pour un autre exemple, voir l’exemple pour [CWinApp::GetProfileInt](#getprofileint).

## <a name="cwinappwriteprofilestring"></a><a name="writeprofilestring"></a>CWinApp::WriteProfileString

Appelez cette fonction membre pour écrire la chaîne spécifiée dans la section spécifiée du registre de l’application ou . Fichier INI.

```
BOOL WriteProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Indique une chaîne non terminée qui spécifie la section contenant l’entrée. Si l’article n’existe pas, il est créé. Le nom de l’article est indépendant; la ficelle peut être n’importe quelle combinaison de majuscules et de lettres minuscules.

*lpszEntry (en)*<br/>
Indique une chaîne non terminée qui contient l’entrée dans laquelle la valeur doit être écrite. Si l’entrée n’existe pas dans la section spécifiée, elle est créée. Si ce paramètre est NULL, la section spécifiée par *lpszSection* est supprimée.

*lpszValue*<br/>
Points à la chaîne à écrire. Si ce paramètre est NULL, l’entrée spécifiée par le paramètre *lpszEntry* est supprimée.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

Pour un autre exemple, voir l’exemple pour [CWinApp::GetProfileInt](#getprofileint).

## <a name="cwinappsetappid"></a><a name="setappid"></a>CWinApp::SetAppID

Définit explicitement l’ID de modèle d’utilisateur d’application pour l’application. Cette méthode doit être appelée avant que toute interface utilisateur soit présentée à l’utilisateur (le meilleur endroit est le constructeur d’applications).

```cpp
void SetAppID(LPCTSTR lpcszAppID);
```

### <a name="parameters"></a>Paramètres

*lpcszAppID*<br/>
Spécifie l’ID modèle d’utilisateur d’application.

### <a name="remarks"></a>Notes

## <a name="see-also"></a>Voir aussi

[Classe CWinThread](../../mfc/reference/cwinthread-class.md)<br/>
[Graphique hiérarchique](../../mfc/hierarchy-chart.md)<br/>
[Guide pratique pour ajouter la prise en charge du Gestionnaire de redémarrage](../../mfc/how-to-add-restart-manager-support.md)
