---
title: CWinApp (classe)
ms.date: 07/15/2019
f1_keywords:
- CWinApp
- AFXWIN/CWinApp
- AFXWIN/CWinApp::CWinApp
- AFXWIN/CWinApp::AddDocTemplate
- AFXWIN/CWinApp::AddToRecentFileList
- AFXWIN/CWinApp::ApplicationRecoveryCallback
- AFXWIN/CWinApp::CloseAllDocuments
- AFXWIN/CWinApp::CreatePrinterDC
- AFXWIN/CWinApp::DelRegTree
- AFXWIN/CWinApp::DoMessageBox
- AFXWIN/CWinApp::DoWaitCursor
- AFXWIN/CWinApp::EnableD2DSupport
- AFXWIN/CWinApp::EnableHtmlHelp
- AFXWIN/CWinApp::EnableTaskbarInteraction
- AFXWIN/CWinApp::ExitInstance
- AFXWIN/CWinApp::GetApplicationRecoveryParameter
- AFXWIN/CWinApp::GetApplicationRecoveryPingInterval
- AFXWIN/CWinApp::GetApplicationRestartFlags
- AFXWIN/CWinApp::GetAppRegistryKey
- AFXWIN/CWinApp::GetDataRecoveryHandler
- AFXWIN/CWinApp::GetFirstDocTemplatePosition
- AFXWIN/CWinApp::GetHelpMode
- AFXWIN/CWinApp::GetNextDocTemplate
- AFXWIN/CWinApp::GetPrinterDeviceDefaults
- AFXWIN/CWinApp::GetProfileBinary
- AFXWIN/CWinApp::GetProfileInt
- AFXWIN/CWinApp::GetProfileString
- AFXWIN/CWinApp::GetSectionKey
- AFXWIN/CWinApp::HideApplication
- AFXWIN/CWinApp::HtmlHelp
- AFXWIN/CWinApp::InitInstance
- AFXWIN/CWinApp::IsTaskbarInteractionEnabled
- AFXWIN/CWinApp::LoadCursor
- AFXWIN/CWinApp::LoadIcon
- AFXWIN/CWinApp::LoadOEMCursor
- AFXWIN/CWinApp::LoadOEMIcon
- AFXWIN/CWinApp::LoadStandardCursor
- AFXWIN/CWinApp::LoadStandardIcon
- AFXWIN/CWinApp::OnDDECommand
- AFXWIN/CWinApp::OnIdle
- AFXWIN/CWinApp::OpenDocumentFile
- AFXWIN/CWinApp::ParseCommandLine
- AFXWIN/CWinApp::PreTranslateMessage
- AFXWIN/CWinApp::ProcessMessageFilter
- AFXWIN/CWinApp::ProcessShellCommand
- AFXWIN/CWinApp::ProcessWndProcException
- AFXWIN/CWinApp::Register
- AFXWIN/CWinApp::RegisterWithRestartManager
- AFXWIN/CWinApp::ReopenPreviousFilesAtRestart
- AFXWIN/CWinApp::RestartInstance
- AFXWIN/CWinApp::RestoreAutosavedFilesAtRestart
- AFXWIN/CWinApp::Run
- AFXWIN/CWinApp::RunAutomated
- AFXWIN/CWinApp::RunEmbedded
- AFXWIN/CWinApp::SaveAllModified
- AFXWIN/CWinApp::SelectPrinter
- AFXWIN/CWinApp::SetHelpMode
- AFXWIN/CWinApp::SupportsApplicationRecovery
- AFXWIN/CWinApp::SupportsAutosaveAtInterval
- AFXWIN/CWinApp::SupportsAutosaveAtRestart
- AFXWIN/CWinApp::SupportsRestartManager
- AFXWIN/CWinApp::Unregister
- AFXWIN/CWinApp::WinHelp
- AFXWIN/CWinApp::WriteProfileBinary
- AFXWIN/CWinApp::WriteProfileInt
- AFXWIN/CWinApp::WriteProfileString
- AFXWIN/CWinApp::EnableShellOpen
- AFXWIN/CWinApp::LoadStdProfileSettings
- AFXWIN/CWinApp::OnContextHelp
- AFXWIN/CWinApp::OnFileNew
- AFXWIN/CWinApp::OnFileOpen
- AFXWIN/CWinApp::OnFilePrintSetup
- AFXWIN/CWinApp::OnHelp
- AFXWIN/CWinApp::OnHelpFinder
- AFXWIN/CWinApp::OnHelpIndex
- AFXWIN/CWinApp::OnHelpUsing
- AFXWIN/CWinApp::RegisterShellFileTypes
- AFXWIN/CWinApp::SetAppID
- AFXWIN/CWinApp::SetRegistryKey
- AFXWIN/CWinApp::UnregisterShellFileTypes
- AFXWIN/CWinApp::m_bHelpMode
- AFXWIN/CWinApp::m_eHelpType
- AFXWIN/CWinApp::m_hInstance
- AFXWIN/CWinApp::m_lpCmdLine
- AFXWIN/CWinApp::m_nCmdShow
- AFXWIN/CWinApp::m_pActiveWnd
- AFXWIN/CWinApp::m_pszAppID
- AFXWIN/CWinApp::m_pszAppName
- AFXWIN/CWinApp::m_pszExeName
- AFXWIN/CWinApp::m_pszHelpFilePath
- AFXWIN/CWinApp::m_pszProfileName
- AFXWIN/CWinApp::m_pszRegistryKey
- AFXWIN/CWinApp::m_dwRestartManagerSupportFlags
- AFXWIN/CWinApp::m_nAutosaveInterval
- AFXWIN/CWinApp::m_pDataRecoveryHandler
helpviewer_keywords:
- CWinApp [MFC], CWinApp
- CWinApp [MFC], AddDocTemplate
- CWinApp [MFC], AddToRecentFileList
- CWinApp [MFC], ApplicationRecoveryCallback
- CWinApp [MFC], CloseAllDocuments
- CWinApp [MFC], CreatePrinterDC
- CWinApp [MFC], DelRegTree
- CWinApp [MFC], DoMessageBox
- CWinApp [MFC], DoWaitCursor
- CWinApp [MFC], EnableD2DSupport
- CWinApp [MFC], EnableHtmlHelp
- CWinApp [MFC], EnableTaskbarInteraction
- CWinApp [MFC], ExitInstance
- CWinApp [MFC], GetApplicationRecoveryParameter
- CWinApp [MFC], GetApplicationRecoveryPingInterval
- CWinApp [MFC], GetApplicationRestartFlags
- CWinApp [MFC], GetAppRegistryKey
- CWinApp [MFC], GetDataRecoveryHandler
- CWinApp [MFC], GetFirstDocTemplatePosition
- CWinApp [MFC], GetHelpMode
- CWinApp [MFC], GetNextDocTemplate
- CWinApp [MFC], GetPrinterDeviceDefaults
- CWinApp [MFC], GetProfileBinary
- CWinApp [MFC], GetProfileInt
- CWinApp [MFC], GetProfileString
- CWinApp [MFC], GetSectionKey
- CWinApp [MFC], HideApplication
- CWinApp [MFC], HtmlHelp
- CWinApp [MFC], InitInstance
- CWinApp [MFC], IsTaskbarInteractionEnabled
- CWinApp [MFC], LoadCursor
- CWinApp [MFC], LoadIcon
- CWinApp [MFC], LoadOEMCursor
- CWinApp [MFC], LoadOEMIcon
- CWinApp [MFC], LoadStandardCursor
- CWinApp [MFC], LoadStandardIcon
- CWinApp [MFC], OnDDECommand
- CWinApp [MFC], OnIdle
- CWinApp [MFC], OpenDocumentFile
- CWinApp [MFC], ParseCommandLine
- CWinApp [MFC], PreTranslateMessage
- CWinApp [MFC], ProcessMessageFilter
- CWinApp [MFC], ProcessShellCommand
- CWinApp [MFC], ProcessWndProcException
- CWinApp [MFC], Register
- CWinApp [MFC], RegisterWithRestartManager
- CWinApp [MFC], ReopenPreviousFilesAtRestart
- CWinApp [MFC], RestartInstance
- CWinApp [MFC], RestoreAutosavedFilesAtRestart
- CWinApp [MFC], Run
- CWinApp [MFC], RunAutomated
- CWinApp [MFC], RunEmbedded
- CWinApp [MFC], SaveAllModified
- CWinApp [MFC], SelectPrinter
- CWinApp [MFC], SetHelpMode
- CWinApp [MFC], SupportsApplicationRecovery
- CWinApp [MFC], SupportsAutosaveAtInterval
- CWinApp [MFC], SupportsAutosaveAtRestart
- CWinApp [MFC], SupportsRestartManager
- CWinApp [MFC], Unregister
- CWinApp [MFC], WinHelp
- CWinApp [MFC], WriteProfileBinary
- CWinApp [MFC], WriteProfileInt
- CWinApp [MFC], WriteProfileString
- CWinApp [MFC], EnableShellOpen
- CWinApp [MFC], LoadStdProfileSettings
- CWinApp [MFC], OnContextHelp
- CWinApp [MFC], OnFileNew
- CWinApp [MFC], OnFileOpen
- CWinApp [MFC], OnFilePrintSetup
- CWinApp [MFC], OnHelp
- CWinApp [MFC], OnHelpFinder
- CWinApp [MFC], OnHelpIndex
- CWinApp [MFC], OnHelpUsing
- CWinApp [MFC], RegisterShellFileTypes
- CWinApp [MFC], SetAppID
- CWinApp [MFC], SetRegistryKey
- CWinApp [MFC], UnregisterShellFileTypes
- CWinApp [MFC], m_bHelpMode
- CWinApp [MFC], m_eHelpType
- CWinApp [MFC], m_hInstance
- CWinApp [MFC], m_lpCmdLine
- CWinApp [MFC], m_nCmdShow
- CWinApp [MFC], m_pActiveWnd
- CWinApp [MFC], m_pszAppID
- CWinApp [MFC], m_pszAppName
- CWinApp [MFC], m_pszExeName
- CWinApp [MFC], m_pszHelpFilePath
- CWinApp [MFC], m_pszProfileName
- CWinApp [MFC], m_pszRegistryKey
- CWinApp [MFC], m_dwRestartManagerSupportFlags
- CWinApp [MFC], m_nAutosaveInterval
- CWinApp [MFC], m_pDataRecoveryHandler
ms.assetid: e426a3cd-0d15-40d6-bd55-beaa5feb2343
ms.openlocfilehash: e65ad8b5d8b14ff747adc55b517d9e695d9cbb66
ms.sourcegitcommit: 2f96e2fda591d7b1b28842b2ea24e6297bcc3622
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/18/2019
ms.locfileid: "71095755"
---
# <a name="cwinapp-class"></a>CWinApp (classe)

Classe de base à partir de laquelle vous dérivez un objet application Windows.

## <a name="syntax"></a>Syntaxe

```
class CWinApp : public CWinThread
```

## <a name="members"></a>Membres

### <a name="public-constructors"></a>Constructeurs publics

|Nom|Description|
|----------|-----------------|
|[CWinApp::CWinApp](#cwinapp)|Construit un objet `CWinApp`.|

### <a name="public-methods"></a>M&#233;thodes publiques

|Nom|Description|
|----------|-----------------|
|[CWinApp::AddDocTemplate](#adddoctemplate)|Ajoute un modèle de document à la liste des modèles de document disponibles de l’application.|
|[CWinApp::AddToRecentFileList](#addtorecentfilelist)|Ajoute un nom de fichier à la liste des derniers fichiers utilisés (MRU).|
|[CWinApp::ApplicationRecoveryCallback](#applicationrecoverycallback)|Appelé par le Framework lorsque l’application se ferme de manière inattendue.|
|[CWinApp::CloseAllDocuments](#closealldocuments)|Ferme tous les documents ouverts.|
|[CWinApp::CreatePrinterDC](#createprinterdc)|Crée un contexte de périphérique d’impression.|
|[CWinApp::DelRegTree](#delregtree)|Supprime une clé spécifiée et toutes ses sous-clés.|
|[CWinApp::DoMessageBox](#domessagebox)|Implémente [AfxMessageBox](cstring-formatting-and-message-box-display.md#afxmessagebox) pour l’application.|
|[CWinApp::DoWaitCursor](#dowaitcursor)|Active et désactive le curseur d’attente.|
|[CWinApp::EnableD2DSupport](#enabled2dsupport)|Active la prise en charge D2D de l’application. Appelez cette méthode avant que la fenêtre principale soit initialisée.|
|[CWinApp::EnableHtmlHelp](#enablehtmlhelp)|Implémente HTMLHelp pour l’application, plutôt que WinHelp.|
|[CWinApp::EnableTaskbarInteraction](#enabletaskbarinteraction)|Active l’interaction de la barre des tâches.|
|[CWinApp::ExitInstance](#exitinstance)|Remplacez pour nettoyer quand votre application se termine.|
|[CWinApp::GetApplicationRecoveryParameter](#getapplicationrecoveryparameter)|Récupère le paramètre d’entrée pour la méthode de récupération de l’application.|
|[CWinApp::GetApplicationRecoveryPingInterval](#getapplicationrecoverypinginterval)|Retourne la durée pendant laquelle le gestionnaire de redémarrage attend que la fonction de rappel de récupération soit retournée.|
|[CWinApp::GetApplicationRestartFlags](#getapplicationrestartflags)|Retourne les indicateurs du gestionnaire de redémarrage.|
|[CWinApp::GetAppRegistryKey](#getappregistrykey)|Retourne la clé pour\\HKEY_CURRENT_USER « Software » \RegistryKey\ProfileName.|
|[CWinApp::GetDataRecoveryHandler](#getdatarecoveryhandler)|Obtient le gestionnaire de récupération de données pour cette instance de l’application.|
|[CWinApp::GetFirstDocTemplatePosition](#getfirstdoctemplateposition)|Récupère la position du premier modèle de document.|
|[CWinApp::GetHelpMode](#gethelpmode)|Récupère le type d’aide utilisé par l’application.|
|[CWinApp :: GetNextDocTemplate](#getnextdoctemplate)|Récupère la position d’un modèle de document. Peut être utilisé de manière récursive.|
|[CWinApp::GetPrinterDeviceDefaults](#getprinterdevicedefaults)|Récupère les valeurs par défaut du périphérique d’impression.|
|[CWinApp::GetProfileBinary](#getprofilebinary)|Récupère des données binaires d’une entrée dans l’application. Fichier INI.|
|[CWinApp::GetProfileInt](#getprofileint)|Récupère un entier à partir d’une entrée dans l’application. Fichier INI.|
|[CWinApp::GetProfileString](#getprofilestring)|Récupère une chaîne à partir d’une entrée dans le de l’application. Fichier INI.|
|[CWinApp::GetSectionKey](#getsectionkey)|Retourne la clé pour\\HKEY_CURRENT_USER « Software » \RegistryKey\AppName\lpszSection.|
|[CWinApp::HideApplication](#hideapplication)|Masque l’application avant de fermer tous les documents.|
|[CWinApp::HtmlHelp](#htmlhelp)|Appelle la `HTMLHelp` fonction Windows.|
|[CWinApp::InitInstance](#initinstance)|Substituez pour effectuer l’initialisation d’une instance Windows, telle que la création d’objets de fenêtre.|
|[CWinApp::IsTaskbarInteractionEnabled](#istaskbarinteractionenabled)|Indique si l’interaction de la barre des tâches Windows 7 est activée.|
|[CWinApp::LoadCursor](#loadcursor)|Charge une ressource de curseur.|
|[CWinApp::LoadIcon](#loadicon)|Charge une ressource icône.|
|[CWinApp::LoadOEMCursor](#loadoemcursor)|Charge un curseur prédéfini OEM Windows que les constantes **OCR_** spécifient dans Windows. Manutention.|
|[CWinApp::LoadOEMIcon](#loadoemicon)|Charge une icône prédéfinie OEM Windows que les constantes **OIC_** spécifient dans Windows. Manutention.|
|[CWinApp::LoadStandardCursor](#loadstandardcursor)|Charge un curseur prédéfini Windows que les constantes **IDC_** spécifient dans Windows. Manutention.|
|[CWinApp::LoadStandardIcon](#loadstandardicon)|Charge une icône Windows prédéfinie que les constantes **IDI_** spécifient dans Windows. Manutention.|
|[CWinApp::OnDDECommand](#onddecommand)|Appelée par l’infrastructure en réponse à une commande d’exécution DDE (Dynamic Data Exchange).|
|[CWinApp::OnIdle](#onidle)|Substituez pour effectuer un traitement du temps d’inactivité spécifique à l’application.|
|[CWinApp::OpenDocumentFile](#opendocumentfile)|Appelé par le Framework pour ouvrir un document à partir d’un fichier.|
|[CWinApp::ParseCommandLine](#parsecommandline)|Analyse des paramètres et des indicateurs individuels dans la ligne de commande.|
|[CWinApp::PreTranslateMessage](#pretranslatemessage)|Filtre les messages avant qu’ils ne soient distribués aux fonctions Windows [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage) et [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage).|
|[CWinApp::ProcessMessageFilter](#processmessagefilter)|Intercepte certains messages avant qu’ils n’atteignent l’application.|
|[CWinApp::ProcessShellCommand](#processshellcommand)|Gère les indicateurs et les arguments de ligne de commande.|
|[CWinApp::ProcessWndProcException](#processwndprocexception)|Intercepte toutes les exceptions non gérées levées par les gestionnaires de commandes et de messages de l’application.|
|[CWinApp::Register](#register)|Effectue une inscription personnalisée.|
|[CWinApp::RegisterWithRestartManager](#registerwithrestartmanager)|Inscrit l’application auprès du gestionnaire de redémarrage.|
|[CWinApp::ReopenPreviousFilesAtRestart](#reopenpreviousfilesatrestart)|Détermine si le gestionnaire de redémarrages ouvre à nouveau les fichiers qui étaient ouverts lorsque l’application s’est arrêtée de manière inattendue.|
|[CWinApp::RestartInstance](#restartinstance)|Gère le redémarrage de l’application initié par le gestionnaire de redémarrage.|
|[CWinApp::RestoreAutosavedFilesAtRestart](#restoreautosavedfilesatrestart)|Détermine si le gestionnaire de redémarrage restaure les fichiers enregistrés de façon automatique lorsqu’il redémarre l’application.|
|[CWinApp::Run](#run)|Exécute la boucle de message par défaut. Substituez pour personnaliser la boucle de message.|
|[CWinApp::RunAutomated](#runautomated)|Teste la ligne de commande de l’application pour l’option **/Automation** . Obsolète. Au lieu de cela, utilisez la valeur dans [CCommandLineInfo :: m_bRunAutomated](../../mfc/reference/ccommandlineinfo-class.md#m_brunautomated) après avoir appelé [ParseCommandLine](#parsecommandline).|
|[CWinApp::RunEmbedded](#runembedded)|Teste la ligne de commande de l’application pour l’option **/Embedding** . Obsolète. Au lieu de cela, utilisez la valeur dans [CCommandLineInfo :: m_bRunEmbedded](../../mfc/reference/ccommandlineinfo-class.md#m_brunembedded) après avoir appelé [ParseCommandLine](#parsecommandline).|
|[CWinApp::SaveAllModified](#saveallmodified)|Invite l’utilisateur à enregistrer tous les documents modifiés.|
|[CWinApp::SelectPrinter](#selectprinter)|Sélectionne une imprimante précédemment indiquée par un utilisateur par le biais d’une boîte de dialogue Imprimer.|
|[CWinApp::SetHelpMode](#sethelpmode)|Définit et initialise le type d’aide utilisé par l’application.|
|[CWinApp::SupportsApplicationRecovery](#supportsapplicationrecovery)|Détermine si le gestionnaire de redémarrage récupère une application qui s’est arrêtée de manière inattendue.|
|[CWinApp::SupportsAutosaveAtInterval](#supportsautosaveatinterval)|Détermine si le gestionnaire de redémarrage enregistre les documents ouverts de façon automatique à intervalles réguliers.|
|[CWinApp::SupportsAutosaveAtRestart](#supportsautosaveatrestart)|Détermine si le gestionnaire de redémarrage enregistre tous les documents ouverts lorsque l’application redémarre.|
|[CWinApp::SupportsRestartManager](#supportsrestartmanager)|Détermine si l’application prend en charge le gestionnaire de redémarrage.|
|[CWinApp::Unregister](#unregister)|Annule l’enregistrement de tous les éléments connus pour `CWinApp` être inscrits par l’objet.|
|[CWinApp::WinHelp](#winhelp)|Appelle la `WinHelp` fonction Windows.|
|[CWinApp::WriteProfileBinary](#writeprofilebinary)|Écrit des données binaires dans une entrée de l’application. Fichier INI.|
|[CWinApp::WriteProfileInt](#writeprofileint)|Écrit un entier dans une entrée de l’application. Fichier INI.|
|[CWinApp::WriteProfileString](#writeprofilestring)|Écrit une chaîne dans une entrée de l’application. Fichier INI.|

### <a name="protected-methods"></a>Méthodes protégées

|Nom|Description|
|----------|-----------------|
|[CWinApp::EnableShellOpen](#enableshellopen)|Permet à l’utilisateur d’ouvrir des fichiers de données à partir du gestionnaire de fichiers Windows.|
|[CWinApp::LoadStdProfileSettings](#loadstdprofilesettings)|Charge la norme. Les paramètres du fichier INI et activent la fonctionnalité liste des fichiers MRU.|
|[CWinApp::OnContextHelp](#oncontexthelp)|Gère l’aide de MAJ + F1 au sein de l’application.|
|[CWinApp::OnFileNew](#onfilenew)|Implémente la commande ID_FILE_NEW.|
|[CWinApp::OnFileOpen](#onfileopen)|Implémente la commande ID_FILE_OPEN.|
|[CWinApp::OnFilePrintSetup](#onfileprintsetup)|Implémente la commande ID_FILE_PRINT_SETUP.|
|[CWinApp::OnHelp](#onhelp)|Gère l'aide F1 dans l'application (en utilisant le contexte actuel).|
|[CWinApp::OnHelpFinder](#onhelpfinder)|Gère les commandes ID_HELP_FINDER et ID_DEFAULT_HELP.|
|[CWinApp::OnHelpIndex](#onhelpindex)|Gère la commande ID_HELP_INDEX et fournit une rubrique d’aide par défaut.|
|[CWinApp::OnHelpUsing](#onhelpusing)|Gère la commande ID_HELP_USING.|
|[CWinApp::RegisterShellFileTypes](#registershellfiletypes)|Inscrit tous les types de documents de l’application dans le gestionnaire de fichiers Windows.|
|[CWinApp::SetAppID](#setappid)|Définit explicitement l’ID du modèle utilisateur de l’application pour l’application. Cette méthode doit être appelée avant que toute interface utilisateur ne soit présentée à l’utilisateur (le meilleur emplacement est le constructeur d’application).|
|[CWinApp :: SetRegistryKey](#setregistrykey)|Entraîne le stockage des paramètres de l’application dans le registre au lieu de. Fichiers INI.|
|[CWinApp::UnregisterShellFileTypes](#unregistershellfiletypes)|Annule l’inscription de tous les types de documents de l’application dans le gestionnaire de fichiers Windows.|

### <a name="public-data-members"></a>Membres de données publics

|Nom|Description|
|----------|-----------------|
|[CWinApp::m_bHelpMode](#m_bhelpmode)|Indique si l’utilisateur est en mode de contexte d’aide (généralement appelé avec MAJ + F1).|
|[CWinApp::m_eHelpType](#m_ehelptype)|Spécifie le type d’aide utilisé par l’application.|
|[CWinApp::m_hInstance](#m_hinstance)|Identifie l’instance actuelle de l’application.|
|[CWinApp::m_lpCmdLine](#m_lpcmdline)|Pointe vers une chaîne se terminant par un caractère null qui spécifie la ligne de commande pour l’application.|
|[CWinApp::m_nCmdShow](#m_ncmdshow)|Spécifie le mode d’affichage initial de la fenêtre.|
|[CWinApp::m_pActiveWnd](#m_pactivewnd)|Pointeur vers la fenêtre principale de l’application conteneur lorsqu’un serveur OLE est actif sur place.|
|[CWinApp::m_pszAppID](#m_pszappid)|ID du modèle utilisateur de l’application.|
|[CWinApp::m_pszAppName](#m_pszappname)|Spécifie le nom de l’application.|
|[CWinApp :: m_pszExeName](#m_pszexename)|Nom du module de l’application.|
|[CWinApp::m_pszHelpFilePath](#m_pszhelpfilepath)|Chemin d’accès au fichier d’aide de l’application.|
|[CWinApp::m_pszProfileName](#m_pszprofilename)|De l’application. Nom de fichier INI.|
|[CWinApp::m_pszRegistryKey](#m_pszregistrykey)|Utilisé pour déterminer la clé de registre complète pour le stockage des paramètres de profil d’application.|

### <a name="protected-data-members"></a>Membres de données protégés

|Nom|Description|
|----------|-----------------|
|[CWinApp::m_dwRestartManagerSupportFlags](#m_dwrestartmanagersupportflags)|Indicateurs qui déterminent le comportement du gestionnaire de redémarrage.|
|[CWinApp::m_nAutosaveInterval](#m_nautosaveinterval)|Durée, en millisecondes, entre les sauvegardes automatique.|
|[CWinApp::m_pDataRecoveryHandler](#m_pdatarecoveryhandler)|Pointeur vers le gestionnaire de récupération de données pour l’application.|

## <a name="remarks"></a>Notes

Un objet d’application fournit des fonctions membres pour l’initialisation de votre application (et pour chaque instance de celle-ci) et pour l’exécution de l’application.

Chaque application qui utilise les classes Microsoft Foundation ne peut contenir qu’un seul objet `CWinApp`dérivé de. Cet objet est construit lorsque d' C++ autres objets globaux sont construits et est déjà disponible lorsque Windows `WinMain` appelle la fonction, qui est fournie par le bibliothèque MFC (Microsoft Foundation Class). Déclarez votre `CWinApp` objet dérivé au niveau global.

Quand vous dérivez une classe `CWinApp`d’application de, substituez la fonction membre [InitInstance](#initinstance) pour créer l’objet de fenêtre principale de votre application.

Outre les `CWinApp` fonctions membres, le bibliothèque MFC (Microsoft Foundation Class) fournit les fonctions globales suivantes pour accéder à votre `CWinApp` objet et à d’autres informations globales :

- [AfxGetApp](application-information-and-management.md#afxgetapp) Obtient un pointeur vers l' `CWinApp` objet.

- [AfxGetInstanceHandle](application-information-and-management.md#afxgetinstancehandle) Obtient un handle vers l’instance d’application actuelle.

- [AfxGetResourceHandle](application-information-and-management.md#afxgetresourcehandle) Obtient un handle vers les ressources de l’application.

- [AfxGetAppName](application-information-and-management.md#afxgetappname) Obtient un pointeur vers une chaîne contenant le nom de l’application. Sinon, si vous avez un pointeur vers l' `CWinApp` objet, utilisez `m_pszExeName` pour obtenir le nom de l’application.

Voir [CWinApp : La classe](../../mfc/cwinapp-the-application-class.md) d’application pour plus d' `CWinApp` informations sur la classe, y compris une vue d’ensemble des éléments suivants :

- `CWinApp`Code dérivé de écrit par l’Assistant Application.

- `CWinApp`rôle de la séquence d’exécution de votre application.

- `CWinApp`implémentations de la fonction membre par défaut de.

- `CWinApp`remplaçable clé de.

Le `m_hPrevInstance` membre de données n’existe plus. Pour déterminer si une autre instance de l’application est en cours d’exécution, utilisez un mutex nommé. Si l’ouverture du mutex échoue, aucune autre instance de l’application n’est en cours d’exécution.

## <a name="inheritance-hierarchy"></a>Hiérarchie d'héritage

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWinThread](../../mfc/reference/cwinthread-class.md)

`CWinApp`

## <a name="requirements"></a>Configuration requise

**En-tête :** afxwin.h

##  <a name="adddoctemplate"></a>  CWinApp::AddDocTemplate

Appelez cette fonction membre pour ajouter un modèle de document à la liste des modèles de document disponibles gérés par l’application.

```
void AddDocTemplate(CDocTemplate* pTemplate);
```

### <a name="parameters"></a>Paramètres

*pTemplate*<br/>
Pointeur vers le `CDocTemplate` à ajouter.

### <a name="remarks"></a>Notes

Vous devez ajouter tous les modèles de document à une application avant d’appeler [RegisterShellFileTypes](#registershellfiletypes).

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#35](../../mfc/reference/codesnippet/cpp/cwinapp-class_1.cpp)]

##  <a name="addtorecentfilelist"></a>  CWinApp::AddToRecentFileList

Appelez cette fonction membre pour ajouter *lpszPathName* à la liste des fichiers MRU.

```
virtual void AddToRecentFileList(LPCTSTR lpszPathName);
```

### <a name="parameters"></a>Paramètres

*lpszPathName*<br/>
Chemin d’accès au fichier.

### <a name="remarks"></a>Notes

Vous devez appeler la fonction membre [LoadStdProfileSettings](#loadstdprofilesettings) pour charger la liste des fichiers MRU actuels avant d’utiliser cette fonction membre.

L’infrastructure appelle cette fonction membre lorsqu’elle ouvre un fichier ou exécute la commande Enregistrer sous pour enregistrer un fichier sous un nouveau nom.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#36](../../mfc/reference/codesnippet/cpp/cwinapp-class_2.cpp)]

##  <a name="applicationrecoverycallback"></a>  CWinApp::ApplicationRecoveryCallback

Appelé par le Framework lorsque l’application se ferme de manière inattendue.

```
virtual DWORD ApplicationRecoveryCallback(LPVOID lpvParam);
```

### <a name="parameters"></a>Paramètres

*lpvParam*<br/>
dans Réservé pour une utilisation ultérieure.

### <a name="return-value"></a>Valeur de retour

0 si cette méthode réussit ; valeur différente de zéro si une erreur se produit.

### <a name="remarks"></a>Notes

Si votre application prend en charge le gestionnaire de redémarrage, l’infrastructure appelle cette fonction lorsque votre application se ferme de manière inattendue.

L’implémentation par défaut `ApplicationRecoveryCallback` de `CDataRecoveryHandler` utilise pour enregistrer la liste des documents actuellement ouverts dans le registre. Cette méthode n’enregistre pas les fichiers de façon automatique.

Pour personnaliser le comportement, remplacez cette fonction dans une [classe CWinApp](../../mfc/reference/cwinapp-class.md) dérivée ou passez votre propre méthode de récupération d’application en tant que paramètre à [CWinApp :: RegisterWithRestartManager](#registerwithrestartmanager).

##  <a name="closealldocuments"></a>  CWinApp::CloseAllDocuments

Appelez cette fonction membre pour fermer tous les documents ouverts avant de quitter.

```
void CloseAllDocuments(BOOL bEndSession);
```

### <a name="parameters"></a>Paramètres

*bEndSession*<br/>
Spécifie si la session Windows est terminée ou non. La valeur est TRUE si la session est terminée ; Sinon, FALSe.

### <a name="remarks"></a>Notes

Appelez [HideApplication](#hideapplication) avant d' `CloseAllDocuments`appeler.

##  <a name="createprinterdc"></a>  CWinApp::CreatePrinterDC

Appelez cette fonction membre pour créer un contexte de périphérique d’impression (DC) à partir de l’imprimante sélectionnée.

```
BOOL CreatePrinterDC(CDC& dc);
```

### <a name="parameters"></a>Paramètres

*dc*<br/>
Référence à un contexte de périphérique d’impression.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le contexte de périphérique d’impression est correctement créé ; Sinon, 0.

### <a name="remarks"></a>Notes

`CreatePrinterDC`Initialise le contexte de périphérique que vous transmettez par référence, ce qui vous permet de l’utiliser pour imprimer.

Si la fonction réussit, une fois l’impression terminée, vous devez détruire le contexte de périphérique. Vous pouvez laisser le destructeur de l’objet [CDC](../../mfc/reference/cdc-class.md) le faire, ou vous pouvez le faire explicitement en appelant [CDC ::D eletedc](../../mfc/reference/cdc-class.md#deletedc).

##  <a name="cwinapp"></a>  CWinApp::CWinApp

Construit un `CWinApp` objet et passe *lpszAppName* à stocker comme nom de l’application.

```
CWinApp(LPCTSTR lpszAppName = NULL);
```

### <a name="parameters"></a>Paramètres

*lpszAppName*<br/>
Chaîne terminée par le caractère null qui contient le nom de l’application que Windows utilise. Si cet argument n’est pas fourni ou si a `CWinApp` la valeur null, utilise la chaîne de ressource AFX_IDS_APP_TITLE ou le nom du fichier exécutable.

### <a name="remarks"></a>Notes

Vous devez construire un objet global de votre `CWinApp`classe dérivée de. Vous ne pouvez avoir qu' `CWinApp` un seul objet dans votre application. Le constructeur stocke un pointeur vers `CWinApp` l’objet afin `WinMain` que puisse appeler les fonctions membres de l’objet pour initialiser et exécuter l’application.

##  <a name="delregtree"></a>  CWinApp::DelRegTree

Supprime une clé de Registre spécifique et toutes ses sous-clés.

```
LONG DelRegTree(
    HKEY hParentKey,
    const CString& strKeyName);

LONG DelRegTree(
    HKEY hParentKey,
    const CString& strKeyName,
    CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>Paramètres

*hParentKey*<br/>
Handle à une clé de registre.

*strKeyName*<br/>
Nom de la clé de Registre à supprimer.

*pTM*<br/>
Pointeur vers l’objet CAtlTransactionManager.

### <a name="return-value"></a>Valeur de retour

Si la fonction est réussie, la valeur de retour est ERROR_SUCCESS. Si la fonction échoue, la valeur de retour est un code d’erreur différent de zéro défini dans Winerror. h.

### <a name="remarks"></a>Notes

Appelez cette fonction pour supprimer la clé spécifiée et ses sous-clés.

##  <a name="domessagebox"></a>  CWinApp::DoMessageBox

L’infrastructure appelle cette fonction membre pour implémenter une boîte de message pour la fonction globale [AfxMessageBox](cstring-formatting-and-message-box-display.md#afxmessagebox).

```
virtual int DoMessageBox(
    LPCTSTR lpszPrompt,
    UINT nType,
    UINT nIDPrompt);
```

### <a name="parameters"></a>Paramètres

*lpszPrompt*<br/>
Adresse du texte dans la boîte de message.

*nType*<br/>
[Style](../../mfc/reference/styles-used-by-mfc.md#message-box-styles)de la boîte de message.

*nIDPrompt*<br/>
Index d’une chaîne de contexte d’aide.

### <a name="return-value"></a>Valeur de retour

Retourne les mêmes valeurs que `AfxMessageBox`.

### <a name="remarks"></a>Notes

N’appelez pas cette fonction membre pour ouvrir une boîte de message. Utilisez `AfxMessageBox` à la place.

Substituez cette fonction membre pour personnaliser le traitement des appels à l' `AfxMessageBox` ensemble de l’application.

##  <a name="dowaitcursor"></a>  CWinApp::DoWaitCursor

Cette fonction membre est appelée par l’infrastructure pour implémenter [CWaitCursor](../../mfc/reference/cwaitcursor-class.md), [CCmdTarget :: BeginWaitCursor](../../mfc/reference/ccmdtarget-class.md#beginwaitcursor), [CCmdTarget :: EndWaitCursor](../../mfc/reference/ccmdtarget-class.md#endwaitcursor)et [CCmdTarget :: RestoreWaitCursor](../../mfc/reference/ccmdtarget-class.md#restorewaitcursor).

```
virtual void DoWaitCursor(int nCode);
```

### <a name="parameters"></a>Paramètres

*nCode*<br/>
Si ce paramètre est 1, un curseur d’attente s’affiche. Si la valeur est 0, le curseur d’attente est restauré sans incrémenter le décompte de références. Si-1, le curseur d’attente se termine.

### <a name="remarks"></a>Notes

La valeur par défaut implémente un curseur de sablier. `DoWaitCursor`conserve un décompte de références. Lorsqu’il est positif, le curseur sablier s’affiche.

Même si vous n’appelez `DoWaitCursor` pas directement, vous pouvez remplacer cette fonction membre pour modifier le curseur d’attente ou pour effectuer un traitement supplémentaire pendant que le curseur d’attente est affiché.

Pour une façon plus simple et rationalisée d’implémenter un curseur d’attente `CWaitCursor`, utilisez.

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCWindowing#37](../../mfc/reference/codesnippet/cpp/cwinapp-class_3.cpp)]

##  <a name="enabled2dsupport"></a>  CWinApp::EnableD2DSupport

Visual Studio 2010 SP1 est requis

Active la prise en charge D2D de l’application. Appelez cette méthode avant que la fenêtre principale soit initialisée.

```
BOOL EnableD2DSupport(
    D2D1_FACTORY_TYPE d2dFactoryType = D2D1_FACTORY_TYPE_SINGLE_THREADED,
    DWRITE_FACTORY_TYPE writeFactoryType = DWRITE_FACTORY_TYPE_SHARED);
```

### <a name="parameters"></a>Paramètres

*d2dFactoryType*<br/>
Le modèle de thread de la fabrique D2D et les ressources qu’il crée.

*writeFactoryType*<br/>
Valeur qui spécifie si l’objet de fabrique d’écriture sera partagé ou isolé

### <a name="return-value"></a>Valeur de retour

Retourne la valeur TRUE si la prise en charge D2D a été activée, FALSe dans le cas contraire

##  <a name="enablehtmlhelp"></a>  CWinApp::EnableHtmlHelp

Appelez cette fonction membre à partir du constructeur de votre `CWinApp`classe dérivée de pour utiliser HTMLHelp pour l’aide de votre application.

```
void EnableHtmlHelp();
```

### <a name="remarks"></a>Notes

##  <a name="enableshellopen"></a>  CWinApp::EnableShellOpen

Appelez cette fonction, généralement à partir `InitInstance` de votre remplacement, pour permettre aux utilisateurs de votre application d’ouvrir des fichiers de données lorsqu’ils double-cliquent sur les fichiers à partir du gestionnaire de fichiers Windows.

```
void EnableShellOpen();
```

### <a name="remarks"></a>Notes

Appelez la `RegisterShellFileTypes` fonction membre conjointement avec cette fonction ou fournissez un. Fichier REG avec votre application pour l’inscription manuelle des types de documents.

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCWindowing#38](../../mfc/reference/codesnippet/cpp/cwinapp-class_4.cpp)]

##  <a name="enabletaskbarinteraction"></a>  CWinApp::EnableTaskbarInteraction

Active l’interaction de la barre des tâches.

```
BOOL EnableTaskbarInteraction(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>Paramètres

*bEnable*<br/>
Spécifie si l’interaction avec la barre des tâches Windows 7 doit être activée (TRUE) ou désactivée (FALSe).

### <a name="return-value"></a>Valeur de retour

Retourne la valeur TRUE si l’interaction de la barre des tâches peut être activée ou désactivée.

### <a name="remarks"></a>Notes

Cette méthode doit être appelée avant la création de la fenêtre principale ; sinon, elle déclare et retourne FALSe.

##  <a name="exitinstance"></a>  CWinApp::ExitInstance

Appelée par l’infrastructure à partir de `Run` la fonction membre pour quitter cette instance de l’application.

```
virtual int ExitInstance();
```

### <a name="return-value"></a>Valeur de retour

Code de sortie de l’application ; 0 indique l’absence d’erreurs, et les valeurs supérieures à 0 indiquent une erreur. Cette valeur est utilisée comme valeur de retour de `WinMain`.

### <a name="remarks"></a>Notes

N’appelez pas cette fonction membre à partir de n’importe `Run` où, mais dans la fonction membre.

L’implémentation par défaut de cette fonction écrit les options du Framework dans le de l’application. Fichier INI. Remplacez cette fonction pour nettoyer quand votre application se termine.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#39](../../mfc/reference/codesnippet/cpp/cwinapp-class_5.cpp)]

##  <a name="getapplicationrecoveryparameter"></a>  CWinApp::GetApplicationRecoveryParameter

Récupère le paramètre d’entrée pour la méthode de récupération de l’application.

```
virtual LPVOID GetApplicationRecoveryParameter();
```

### <a name="return-value"></a>Valeur de retour

Paramètre d’entrée par défaut pour la méthode de récupération d’application.

### <a name="remarks"></a>Notes

Le comportement par défaut de cette fonction retourne la valeur NULL.

Pour plus d’informations, consultez [CWinApp :: ApplicationRecoveryCallback](#applicationrecoverycallback).

##  <a name="getapplicationrecoverypinginterval"></a>  CWinApp::GetApplicationRecoveryPingInterval

Retourne la durée pendant laquelle le gestionnaire de redémarrage attend que la fonction de rappel de récupération soit retournée.

```
virtual DWORD GetApplicationRecoveryPingInterval();
```

### <a name="return-value"></a>Valeur de retour

Durée en millisecondes.

### <a name="remarks"></a>Notes

Quand une application inscrite avec le gestionnaire de redémarrage s’arrête de manière inattendue, l’application tente d’enregistrer les documents ouverts et appelle la fonction de rappel de récupération. La fonction de rappel de récupération par défaut est [CWinApp :: ApplicationRecoveryCallback](#applicationrecoverycallback).

La durée pendant laquelle l’infrastructure attend le retour de la fonction de rappel de récupération est l’intervalle ping. Vous pouvez personnaliser l’intervalle de test ping en `CWinApp::GetApplicationRecoveryPingInterval` remplaçant ou en fournissant une valeur personnalisée `RegisterWithRestartManager`à.

##  <a name="getapplicationrestartflags"></a>  CWinApp::GetApplicationRestartFlags

Retourne les indicateurs du gestionnaire de redémarrage.

```
virtual DWORD GetApplicationRestartFlags();
```

### <a name="return-value"></a>Valeur de retour

Indicateurs du gestionnaire de redémarrage. L’implémentation par défaut retourne 0.

### <a name="remarks"></a>Notes

Les indicateurs du gestionnaire de redémarrage n’ont aucun effet avec l’implémentation par défaut. Elles sont fournies pour une utilisation ultérieure.

Vous définissez les indicateurs lorsque vous inscrivez l’application avec le gestionnaire de redémarrage à l’aide de [CWinApp :: RegisterWithRestartManager](#registerwithrestartmanager).

Les valeurs possibles pour les indicateurs du gestionnaire de redémarrage sont les suivantes :

- RESTART_NO_CRASH

- RESTART_NO_HANG

- RESTART_NO_PATCH

- RESTART_NO_REBOOT

##  <a name="getappregistrykey"></a>  CWinApp::GetAppRegistryKey

Retourne la clé pour HKEY_CURRENT_USER\\« Software » \RegistryKey\ProfileName.

```
HKEY GetAppRegistryKey(CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>Paramètres

*pTM*<br/>
Pointeur vers un `CAtlTransactionManager` objet.

### <a name="return-value"></a>Valeur de retour

Clé d’application si la fonction est réussie ; Sinon, NULL.

### <a name="remarks"></a>Notes

##  <a name="getdatarecoveryhandler"></a>  CWinApp::GetDataRecoveryHandler

Obtient le gestionnaire de récupération de données pour cette instance de l’application.

```
virtual CDataRecoveryHandler *GetDataRecoveryHandler();
```

### <a name="return-value"></a>Valeur de retour

Gestionnaire de récupération de données pour cette instance de l’application.

### <a name="remarks"></a>Notes

Chaque application qui utilise le gestionnaire de redémarrage doit avoir une instance de la [classe CDataRecoveryHandler](../../mfc/reference/cdatarecoveryhandler-class.md). Cette classe est responsable de la surveillance des documents ouverts et de l’enregistrement automatique des fichiers. Le comportement de `CDataRecoveryHandler` dépend de la configuration du gestionnaire de redémarrage. Pour plus d’informations, consultez [CDataRecoveryHandler, classe](../../mfc/reference/cdatarecoveryhandler-class.md).

Cette méthode retourne la valeur NULL sur les systèmes d’exploitation antérieurs à Windows Vista. Le gestionnaire de redémarrage n’est pas pris en charge sur les systèmes d’exploitation antérieurs à Windows Vista.

Si l’application n’a pas de gestionnaire de récupération de données, cette méthode en crée une et retourne un pointeur vers celle-ci.

##  <a name="getfirstdoctemplateposition"></a>  CWinApp::GetFirstDocTemplatePosition

Obtient la position du premier modèle de document dans l’application.

```
POSITION GetFirstDocTemplatePosition() const;
```

### <a name="return-value"></a>Valeur de retour

Valeur de POSITION qui peut être utilisée pour la récupération de l’itération ou du pointeur d’objet ; NULL si la liste est vide.

### <a name="remarks"></a>Notes

Utilisez la valeur de POSITION retournée dans un appel à [GetNextDocTemplate](#getnextdoctemplate) pour obtenir le premier objet [CDocTemplate](../../mfc/reference/cdoctemplate-class.md) .

##  <a name="gethelpmode"></a>  CWinApp::GetHelpMode

Récupère le type d’aide utilisé par l’application.

```
AFX_HELP_TYPE GetHelpMode();
```

### <a name="return-value"></a>Valeur de retour

Type d’aide utilisé par l’application. Pour plus d’informations, consultez [CWinApp :: m_eHelpType](#m_ehelptype) .

##  <a name="getnextdoctemplate"></a>  CWinApp::GetNextDocTemplate

Obtient le modèle de document identifié par *pos*, puis définit *pos* sur la valeur de position.

```
CDocTemplate* GetNextDocTemplate(POSITION& pos) const;
```

### <a name="parameters"></a>Paramètres

*imprim*<br/>
Référence à une valeur de position retournée par un appel précédent `GetNextDocTemplate` à ou [GetFirstDocTemplatePosition](#getfirstdoctemplateposition). La valeur est mise à jour à la position suivante par cet appel.

### <a name="return-value"></a>Valeur de retour

Pointeur vers un objet [CDocTemplate](../../mfc/reference/cdoctemplate-class.md) .

### <a name="remarks"></a>Notes

Vous pouvez utiliser `GetNextDocTemplate` dans une boucle d’itération directe si vous établissez la position initiale avec un `GetFirstDocTemplatePosition`appel à.

Vous devez vous assurer que votre valeur de POSITION est valide. S’il n’est pas valide, la version de débogage du bibliothèque MFC (Microsoft Foundation Class) Assert.

Si le modèle de document récupéré est le dernier disponible, la nouvelle valeur de *pos* est définie sur null.

##  <a name="getprinterdevicedefaults"></a>  CWinApp::GetPrinterDeviceDefaults

Appelez cette fonction membre pour préparer un contexte de périphérique d’impression pour l’impression.

```
BOOL GetPrinterDeviceDefaults(struct tagPDA* pPrintDlg);
```

### <a name="parameters"></a>Paramètres

*pPrintDlg*<br/>
Pointeur vers une structure [PRINTDLG](/windows/win32/api/commdlg/ns-commdlg-printdlga) .

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Récupère les valeurs par défaut de l’imprimante en cours à partir de Windows. INI, si nécessaire, ou utilise la dernière configuration d’imprimante définie par l’utilisateur lors de la configuration de l’impression.

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCWindowing#40](../../mfc/reference/codesnippet/cpp/cwinapp-class_6.cpp)]

##  <a name="getprofilebinary"></a>  CWinApp::GetProfileBinary

Appelez cette fonction membre pour récupérer des données binaires d’une entrée dans une section spécifiée du registre de l’application ou. Fichier INI.

```
BOOL GetProfileBinary(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Pointe vers une chaîne se terminant par un caractère null qui spécifie la section contenant l’entrée.

*lpszEntry*<br/>
Pointe vers une chaîne se terminant par un caractère null qui contient l’entrée dont la valeur doit être récupérée.

*ppData*<br/>
Pointe vers un pointeur qui reçoit l’adresse des données.

*pBytes*<br/>
Pointe vers un UINT qui recevra la taille des données (en octets).

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Cette fonction membre ne respecte pas la casse ; par conséquent, les chaînes dans les paramètres *lpszSection* et *lpszEntry* peuvent être différentes au niveau de la casse.

> [!NOTE]
> `GetProfileBinary`alloue une mémoire tampon et retourne son adresse dans \* *ppData*. L’appelant est responsable de la libération de la mémoire tampon à l’aide de **delete []** .

> [!IMPORTANT]
> Les données retournées par cette fonction ne sont pas nécessairement terminées par une valeur NULL, et l’appelant doit effectuer la validation. Pour plus d’informations, consultez [Solutions contre les dépassements de mémoire tampon](/windows/win32/SecBP/avoiding-buffer-overruns).

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCWindowing#41](../../mfc/reference/codesnippet/cpp/cwinapp-class_7.cpp)]

Pour obtenir un exemple supplémentaire, consultez [CWinApp :: WriteProfileBinary](#writeprofilebinary).

##  <a name="getprofileint"></a>  CWinApp::GetProfileInt

Appelez cette fonction membre pour récupérer la valeur d’un entier à partir d’une entrée dans une section spécifiée du registre de l’application ou. Fichier INI.

```
UINT GetProfileInt(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    int nDefault);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Pointe vers une chaîne se terminant par un caractère null qui spécifie la section contenant l’entrée.

*lpszEntry*<br/>
Pointe vers une chaîne se terminant par un caractère null qui contient l’entrée dont la valeur doit être récupérée.

*nDefault*<br/>
Spécifie la valeur par défaut à retourner si l’infrastructure ne peut pas trouver l’entrée.

### <a name="return-value"></a>Valeur de retour

Valeur entière de la chaîne qui suit l’entrée spécifiée si la fonction réussit. La valeur de retour est la valeur du paramètre *nDefault* si la fonction ne trouve pas l’entrée. La valeur de retour est 0 si la valeur qui correspond à l’entrée spécifiée n’est pas un entier.

Cette fonction membre prend en charge la notation hexadécimale pour la valeur dans le. Fichier INI. Lorsque vous récupérez un entier signé, vous devez effectuer un cast de la valeur en **int**.

### <a name="remarks"></a>Notes

Cette fonction membre ne respecte pas la casse ; par conséquent, les chaînes dans les paramètres *lpszSection* et *lpszEntry* peuvent être différentes au niveau de la casse.

> [!IMPORTANT]
> Les données retournées par cette fonction ne sont pas nécessairement terminées par une valeur NULL, et l’appelant doit effectuer la validation. Pour plus d’informations, consultez [Solutions contre les dépassements de mémoire tampon](/windows/win32/SecBP/avoiding-buffer-overruns).

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#42](../../mfc/reference/codesnippet/cpp/cwinapp-class_8.cpp)]

Pour obtenir un exemple supplémentaire, consultez [CWinApp :: WriteProfileInt](#writeprofileint).

##  <a name="getprofilestring"></a>  CWinApp::GetProfileString

Appelez cette fonction membre pour récupérer la chaîne associée à une entrée dans la section spécifiée dans le registre de l’application ou. Fichier INI.

```
CString GetProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault = NULL);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Pointe vers une chaîne se terminant par un caractère null qui spécifie la section contenant l’entrée.

*lpszEntry*<br/>
Pointe vers une chaîne se terminant par un caractère null qui contient l’entrée dont la chaîne doit être récupérée. Cette valeur ne doit pas être NULL.

*lpszDefault*<br/>
Pointe vers la valeur de chaîne par défaut pour l’entrée donnée si l’entrée est introuvable dans le fichier d’initialisation.

### <a name="return-value"></a>Valeur de retour

La valeur de retour est la chaîne du de l’application. Fichier INI ou *lpszDefault* si la chaîne est introuvable. La longueur de chaîne maximale prise en charge par l’infrastructure est _ MAX_PATH. Si *lpszDefault* a la valeur null, la valeur de retour est une chaîne vide.

### <a name="remarks"></a>Notes

> [!IMPORTANT]
> Les données retournées par cette fonction ne sont pas nécessairement terminées par une valeur NULL, et l’appelant doit effectuer la validation. Pour plus d’informations, consultez [Solutions contre les dépassements de mémoire tampon](/windows/win32/SecBP/avoiding-buffer-overruns).

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

Pour obtenir un autre exemple, consultez l’exemple pour [CWinApp :: GetProfileInt](#getprofileint).

##  <a name="getsectionkey"></a>  CWinApp::GetSectionKey

Retourne la clé pour HKEY_CURRENT_USER\\« Software » \RegistryKey\AppName\lpszSection.

```
HKEY GetSectionKey(
    LPCTSTR lpszSection,
    CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Nom de la clé à obtenir.

*pTM*<br/>
Pointeur vers un `CAtlTransactionManager` objet.

### <a name="return-value"></a>Valeur de retour

Clé de section si la fonction est réussie ; Sinon, NULL.

### <a name="remarks"></a>Notes

##  <a name="hideapplication"></a>  CWinApp::HideApplication

Appelez cette fonction membre pour masquer une application avant de fermer les documents ouverts.

```
void HideApplication();
```

##  <a name="htmlhelp"></a>  CWinApp::HtmlHelp

Appelez cette fonction membre pour appeler l’application HTMLHelp.

```
virtual void HtmlHelp(
    DWORD_PTR dwData,
    UINT nCmd = 0x000F);
```

### <a name="parameters"></a>Paramètres

*dwData*<br/>
Spécifie des données supplémentaires. La valeur utilisée dépend de la valeur du paramètre *nCmd* . La valeur par `0x000F` défaut correspond à [HH_HELP_CONTEXT](/previous-versions/windows/desktop/htmlhelp/hh-help-context-command).

*nCmd*<br/>
Spécifie le type d’aide demandée. Pour obtenir une liste des valeurs possibles et savoir comment elles affectent le paramètre *dwData* , consultez le paramètre *uCommand* décrit dans les fonctions de l’API [HtmlHelpW](/windows/win32/api/htmlhelp/nf-htmlhelp-htmlhelpw) ou [HtmlHelpA](/windows/win32/api/htmlhelp/nf-htmlhelp-htmlhelpa) dans la SDK Windows. 

### <a name="remarks"></a>Notes

L’infrastructure appelle également cette fonction pour appeler l’application HTMLHelp.

L’infrastructure ferme automatiquement l’application HTMLHelp lorsque votre application s’arrête.

##  <a name="initinstance"></a>  CWinApp::InitInstance

Windows permet l’exécution de plusieurs copies du même programme en même temps.

```
virtual BOOL InitInstance();
```

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro si l’initialisation réussit; Sinon, 0.

### <a name="remarks"></a>Notes

L’initialisation de l’application est divisée de manière conceptuelle en deux sections : l’initialisation d’une application unique qui est effectuée lors de la première exécution du programme et l’initialisation de l’instance qui s’exécute chaque fois qu’une copie du programme s’exécute, y compris la première fois. L’implémentation de l’infrastructure `WinMain` de appelle cette fonction.

Substituez `InitInstance` pour initialiser chaque nouvelle instance de votre application s’exécutant sous Windows. En règle générale, vous `InitInstance` remplacez pour construire votre objet de fenêtre principale et `CWinThread::m_pMainWnd` définir le membre de données pour qu’il pointe vers cette fenêtre. Pour plus d’informations sur la substitution de cette fonction membre [, consultez CWinApp : Classe](../../mfc/cwinapp-the-application-class.md)d’application.

> [!NOTE]
> Les applications MFC doivent être initialisées en tant que thread unique cloisonné (STA). Si vous appelez [CoInitializeEx](/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex) dans votre `InitInstance` remplacement, spécifiez COINIT_APARTMENTTHREADED (au lieu de COINIT_MULTITHREADED).

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCListView#9](../../atl/reference/codesnippet/cpp/cwinapp-class_10.cpp)]

##  <a name="istaskbarinteractionenabled"></a>  CWinApp::IsTaskbarInteractionEnabled

Indique si l’interaction de la barre des tâches Windows 7 est activée.

```
virtual BOOL IsTaskbarInteractionEnabled();
```

### <a name="return-value"></a>Valeur de retour

Retourne la valeur `EnableTaskbarInteraction` true si a été appelé et si le système d’exploitation est Windows 7 ou une version ultérieure.

### <a name="remarks"></a>Notes

L’interaction avec la barre des tâches signifie que l’application MDI affiche le contenu des enfants MDI dans des miniatures à onglets distinctes qui apparaissent lorsque le pointeur de la souris se trouve sur le bouton de la barre des tâches de l’application.

##  <a name="loadcursor"></a>  CWinApp::LoadCursor

Charge la ressource de curseur nommée par *lpszResourceName* ou spécifiée par *nIDResource* à partir du fichier exécutable actuel.

```
HCURSOR LoadCursor(LPCTSTR lpszResourceName) const;  HCURSOR LoadCursor(UINT nIDResource) const;
```

### <a name="parameters"></a>Paramètres

*lpszResourceName*<br/>
Pointe vers une chaîne se terminant par un caractère null qui contient le nom de la ressource curseur. Vous pouvez utiliser un `CString` pour cet argument.

*nIDResource*<br/>
ID de la ressource curseur. Pour obtenir la liste des ressources, consultez [LoadCursor](/windows/win32/api/winuser/nf-winuser-loadcursorw) dans le SDK Windows.

### <a name="return-value"></a>Valeur de retour

Handle vers un curseur en cas de réussite ; Sinon, NULL.

### <a name="remarks"></a>Notes

`LoadCursor`charge le curseur dans la mémoire uniquement s’il n’a pas été chargé précédemment ; dans le cas contraire, elle récupère un handle de la ressource existante.

Utilisez la fonction membre [LoadStandardCursor](#loadstandardcursor) ou [LoadOEMCursor](#loadoemcursor) pour accéder aux curseurs Windows prédéfinis.

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCWindowing#44](../../mfc/reference/codesnippet/cpp/cwinapp-class_11.cpp)]

##  <a name="loadicon"></a>  CWinApp::LoadIcon

Charge la ressource icône nommée par *lpszResourceName* ou spécifiée par *nIDResource* à partir du fichier exécutable.

```
HICON LoadIcon(LPCTSTR lpszResourceName) const;  HICON LoadIcon(UINT nIDResource) const;
```

### <a name="parameters"></a>Paramètres

*lpszResourceName*<br/>
Pointe vers une chaîne se terminant par un caractère null qui contient le nom de la ressource icône. Vous pouvez également utiliser un `CString` pour cet argument.

*nIDResource*<br/>
Numéro d’identification de la ressource icône.

### <a name="return-value"></a>Valeur de retour

Handle d’une icône en cas de réussite ; Sinon, NULL.

### <a name="remarks"></a>Notes

`LoadIcon`charge l’icône uniquement si elle n’a pas été précédemment chargée ; dans le cas contraire, elle récupère un handle de la ressource existante.

Vous pouvez utiliser la fonction membre [LoadStandardIcon](#loadstandardicon) ou [LoadOEMIcon](#loadoemicon) pour accéder aux icônes prédéfinies de Windows.

> [!NOTE]
> Cette fonction membre appelle la fonction d’API Win32 [LoadIcon](/windows/win32/api/winuser/nf-winuser-loadiconw), qui peut uniquement charger une icône dont la taille est conforme aux valeurs de métriques système SM_CXICON et SM_CYICON.

##  <a name="loadoemcursor"></a>  CWinApp::LoadOEMCursor

Charge la ressource de curseur prédéfinie Windows spécifiée par *nIDCursor*.

```
HCURSOR LoadOEMCursor(UINT nIDCursor) const;
```

### <a name="parameters"></a>Paramètres

*nIDCursor*<br/>
Identificateur de constante de manifeste **OCR_** qui spécifie un curseur Windows prédéfini. Vous devez disposer `#define OEMRESOURCE` de `#include \<afxwin.h>` avant pour accéder aux constantes **OCR_** dans Windows. Manutention.

### <a name="return-value"></a>Valeur de retour

Handle vers un curseur en cas de réussite ; Sinon, NULL.

### <a name="remarks"></a>Notes

Utilisez la `LoadOEMCursor` fonction membre ou [LoadStandardCursor](#loadstandardcursor) pour accéder aux curseurs Windows prédéfinis.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#45](../../mfc/reference/codesnippet/cpp/cwinapp-class_12.h)]

[!code-cpp[NVC_MFCWindowing#46](../../mfc/reference/codesnippet/cpp/cwinapp-class_13.cpp)]

##  <a name="loadoemicon"></a>  CWinApp::LoadOEMIcon

Charge la ressource icône prédéfinie Windows spécifiée par *nIDIcon*.

```
HICON LoadOEMIcon(UINT nIDIcon) const;
```

### <a name="parameters"></a>Paramètres

*nIDIcon*<br/>
Identificateur de constante de manifeste **OIC_** qui spécifie une icône Windows prédéfinie. Vous devez disposer `#define OEMRESOURCE` de `#include \<afxwin.h>` avant pour accéder aux constantes **OIC_** dans Windows. Manutention.

### <a name="return-value"></a>Valeur de retour

Handle d’une icône en cas de réussite ; Sinon, NULL.

### <a name="remarks"></a>Notes

Utilisez la `LoadOEMIcon` fonction membre ou [LoadStandardIcon](#loadstandardicon) pour accéder aux icônes prédéfinies de Windows.

##  <a name="loadstandardcursor"></a>  CWinApp::LoadStandardCursor

Charge la ressource de curseur prédéfinie Windows que *lpszCursorName* spécifie.

```
HCURSOR LoadStandardCursor(LPCTSTR lpszCursorName) const;
```

### <a name="parameters"></a>Paramètres

*lpszCursorName*<br/>
Identificateur de constante de manifeste **IDC_** qui spécifie un curseur Windows prédéfini. Ces identificateurs sont définis dans WINDOWS. Manutention. La liste suivante répertorie les valeurs prédéfinies et les significations possibles pour *lpszCursorName*:

- Curseur à flèche standard IDC_ARROW

- Curseur d’insertion de texte standard IDC_IBEAM

- Curseur IDC_WAIT sablier utilisé lorsque Windows effectue une tâche longue

- IDC_CROSS curseur réticule pour la sélection

- Flèche IDC_UPARROW pointant vers le haut

- IDC_SIZE obsolètes et non pris en charge ; utiliser IDC_SIZEALL

- IDC_SIZEALL une flèche à quatre pointes. Curseur à utiliser pour redimensionner une fenêtre.

- IDC_ICON obsolètes et non pris en charge. Utilisez IDC_ARROW.

- IDC_SIZENWSE flèche à deux pointes avec des extrémités en haut à gauche et en bas à droite

- IDC_SIZENESW flèche à deux pointes avec des extrémités en haut à droite et en bas à gauche

- IDC_SIZEWE flèche horizontale à deux pointes

- IDC_SIZENS flèche verticale à deux pointes

### <a name="return-value"></a>Valeur de retour

Handle vers un curseur en cas de réussite ; Sinon, NULL.

### <a name="remarks"></a>Notes

Utilisez la `LoadStandardCursor` fonction membre ou [LoadOEMCursor](#loadoemcursor) pour accéder aux curseurs Windows prédéfinis.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#47](../../mfc/reference/codesnippet/cpp/cwinapp-class_14.cpp)]

##  <a name="loadstandardicon"></a>  CWinApp::LoadStandardIcon

Charge la ressource d’icône prédéfinie Windows que *lpszIconName* spécifie.

```
HICON LoadStandardIcon(LPCTSTR lpszIconName) const;
```

### <a name="parameters"></a>Paramètres

*lpszIconName*<br/>
Identificateur de constante de manifeste qui spécifie une icône Windows prédéfinie. Ces identificateurs sont définis dans WINDOWS. Manutention. Pour obtenir la liste des valeurs prédéfinies possibles et leurs descriptions, consultez le paramètre *lpIconName* dans [LoadIcon](/windows/win32/api/winuser/nf-winuser-loadiconw) dans le SDK Windows.

### <a name="return-value"></a>Valeur de retour

Handle d’une icône en cas de réussite ; Sinon, NULL.

### <a name="remarks"></a>Notes

Utilisez la `LoadStandardIcon` fonction membre ou [LoadOEMIcon](#loadoemicon) pour accéder aux icônes prédéfinies de Windows.

##  <a name="loadstdprofilesettings"></a>  CWinApp::LoadStdProfileSettings

Appelez cette fonction membre à partir de la fonction membre [InitInstance](#initinstance) pour activer et charger la liste des derniers fichiers utilisés (MRU) et du dernier état d’aperçu.

```
void LoadStdProfileSettings(UINT nMaxMRU = _AFX_MRU_COUNT);
```

### <a name="parameters"></a>Paramètres

*nMaxMRU*<br/>
Nombre de fichiers récemment utilisés pour le suivi.

### <a name="remarks"></a>Notes

Si *nMaxMRU* est égal à 0, aucune liste MRU n’est conservée.

##  <a name="m_bhelpmode"></a>  CWinApp::m_bHelpMode

TRUE si l’application est en mode de contexte d’aide (appelé de façon conventionnelle avec SHIFT + F1); Sinon, FALSe.

```
BOOL m_bHelpMode;
```

### <a name="remarks"></a>Notes

En mode de contexte d’aide, le curseur prend la forme d’un point d’interrogation et l’utilisateur peut le déplacer à propos de l’écran. Examinez cet indicateur si vous souhaitez implémenter une gestion spéciale dans le mode d’aide. `m_bHelpMode`variable publique de type BOOL.

##  <a name="m_dwrestartmanagersupportflags"></a>  CWinApp::m_dwRestartManagerSupportFlags

Indicateurs qui déterminent le comportement du gestionnaire de redémarrage.

```
DWORD m_dwRestartManagerSupportFlags;
```

### <a name="remarks"></a>Notes

Pour activer le gestionnaire de redémarrage `m_dwRestartManagerSupportFlags` , définissez sur le comportement de votre choix. Le tableau suivant répertorie les indicateurs qui sont disponibles.

|||
|-|-|
|Indicateur|Description|
|AFX_RESTART_MANAGER_SUPPORT_RESTART|L’application est inscrite à l’aide de [CWinApp :: RegisterWithRestartManager](#registerwithrestartmanager). Le gestionnaire de redémarrage est responsable du redémarrage de l’application si elle se termine de manière inattendue.|
|- AFX_RESTART_MANAGER_SUPPORT_RECOVERY|L’application est inscrite auprès du gestionnaire de redémarrage et le gestionnaire de redémarrage appelle la fonction de rappel de récupération lorsqu’il redémarre l’application. La fonction de rappel de récupération par défaut est [CWinApp :: ApplicationRecoveryCallback](#applicationrecoverycallback).|
|- AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART|L’enregistrement automatique est activé et le gestionnaire de redémarrage enregistre tous les documents ouverts lorsque l’application redémarre.|
|- AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL|L’enregistrement automatique est activé et le gestionnaire de redémarrage enregistre tous les documents ouverts à un intervalle régulier. L’intervalle est défini par [CWinApp :: m_nAutosaveInterval](#m_nautosaveinterval).|
|- AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES|Le gestionnaire de redémarrage ouvre les documents précédemment ouverts après le redémarrage de l’application à partir d’une sortie inattendue. La [classe CDataRecoveryHandler](../../mfc/reference/cdatarecoveryhandler-class.md) gère le stockage de la liste des documents ouverts et leur restauration.|
|- AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES|Le gestionnaire de redémarrage invite l’utilisateur à restaurer les fichiers enregistrés de façon automatique après le redémarrage de l’application. La `CDataRecoveryHandler` classe interroge l’utilisateur.|
|- AFX_RESTART_MANAGER_SUPPORT_NO_AUTOSAVE|Union de AFX_RESTART_MANAGER_SUPPORT_RESTART, AFX_RESTART_MANAGER_SUPPORT_RECOVER et AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES.|
|- AFX_RESTART_MANAGER_SUPPORT_ALL_ASPECTS|Union de AFX_RESTART_MANAGER_SUPPORT_NO_AUTOSAVE, AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART, AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL et AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES.|
|- AFX_RESTART_MANAGER_SUPPORT_RESTART_ASPECTS|Union de AFX_RESTART_MANAGER_SUPPORT_RESTART, AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART, AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES et AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES.|
|- AFX_RESTART_MANAGER_SUPPORT_RECOVERY_ASPECTS|Union ofAFX_RESTART_MANAGER_SUPPORT_RECOVERY, AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL, AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES et AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES.|

##  <a name="m_ehelptype"></a>  CWinApp::m_eHelpType

Le type de ce membre de données est le type énuméré AFX_HELP_TYPE, qui est défini dans la `CWinApp` classe.

```
AFX_HELP_TYPE m_eHelpType;
```

### <a name="remarks"></a>Notes

L’énumération AFX_HELP_TYPE est définie comme suit :

```
enum AFX_HELP_TYPE {
    afxWinHelp = 0,
    afxHTMLHelp = 1
    };
```

- Pour définir l’aide HTML de l’application, appelez [SetHelpMode](#sethelpmode) et spécifiez `afxHTMLHelp`.

- Pour définir l’aide de l’application sur WinHelp, `SetHelpMode` appelez et `afxWinHelp`spécifiez.

##  <a name="m_hinstance"></a>  CWinApp::m_hInstance

Correspond au paramètre *HINSTANCE* passé par Windows à `WinMain`.

```
HINSTANCE m_hInstance;
```

### <a name="remarks"></a>Notes

Le `m_hInstance` membre de données est un handle de l’instance actuelle de l’application s’exécutant sous Windows. Elle est retournée par la fonction globale [AfxGetInstanceHandle](application-information-and-management.md#afxgetinstancehandle). `m_hInstance`variable publique de type HINSTANCE.

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCWindowing#55](../../mfc/reference/codesnippet/cpp/cwinapp-class_15.cpp)]

##  <a name="m_lpcmdline"></a>  CWinApp::m_lpCmdLine

Correspond au paramètre *lpCmdLine* passé par Windows à `WinMain`.

```
LPTSTR m_lpCmdLine;
```

### <a name="remarks"></a>Notes

Pointe vers une chaîne se terminant par un caractère null qui spécifie la ligne de commande pour l’application. Utilisez `m_lpCmdLine` pour accéder à tous les arguments de ligne de commande entrés par l’utilisateur au démarrage de l’application. `m_lpCmdLine`est une variable publique de type LPTSTR.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#52](../../mfc/reference/codesnippet/cpp/cwinapp-class_16.cpp)]

##  <a name="m_nautosaveinterval"></a>  CWinApp::m_nAutosaveInterval

Durée, en millisecondes, entre les sauvegardes automatique.

```
int m_nAutosaveInterval;
```

### <a name="remarks"></a>Notes

Vous pouvez configurer le gestionnaire de redémarrage pour enregistrer automatiquement les documents ouverts à des intervalles définis. Si votre application n’enregistre pas les fichiers de façon automatique, ce paramètre n’a aucun effet.

##  <a name="m_ncmdshow"></a>  CWinApp::m_nCmdShow

Correspond au paramètre *nCmdShow* passé par Windows à `WinMain`.

```
int m_nCmdShow;
```

### <a name="remarks"></a>Notes

Vous devez passer `m_nCmdShow` en tant qu’argument quand vous appelez [CWnd :: ShowWindow](../../mfc/reference/cwnd-class.md#showwindow) pour la fenêtre principale de votre application. `m_nCmdShow`variable publique de type **int**.

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCWindowing#56](../../mfc/reference/codesnippet/cpp/cwinapp-class_17.cpp)]

##  <a name="m_pactivewnd"></a>  CWinApp::m_pActiveWnd

Utilisez ce membre de données pour stocker un pointeur vers la fenêtre principale de l’application conteneur OLE pour laquelle votre application serveur OLE est activée sur place.

### <a name="remarks"></a>Notes

Si ce membre de données est NULL, l’application n’est pas active sur place.

L’infrastructure définit cette variable membre lorsque la fenêtre frame est activée sur place par une application de conteneur OLE.

##  <a name="m_pdatarecoveryhandler"></a>  CWinApp::m_pDataRecoveryHandler

Pointeur vers le gestionnaire de récupération de données pour l’application.

```
CDataRecoveryHandler* m_pDataRecoveryHandler;
```

### <a name="remarks"></a>Notes

Le gestionnaire de récupération de données d’une application surveille les documents ouverts et les enregistre de manière automatique. L’infrastructure utilise le gestionnaire de récupération de données pour restaurer les fichiers enregistrés de façon automatique lorsqu’une application redémarre après avoir quitté de manière inattendue. Pour plus d’informations, consultez [CDataRecoveryHandler, classe](../../mfc/reference/cdatarecoveryhandler-class.md).

##  <a name="m_pszappname"></a>  CWinApp::m_pszAppName

Spécifie le nom de l’application.

```
LPCTSTR m_pszAppName;
```

### <a name="remarks"></a>Notes

Le nom de l’application peut provenir du paramètre passé au constructeur [CWinApp](#cwinapp) , ou, s’il n’est pas spécifié, à la chaîne de ressource avec l’ID de AFX_IDS_APP_TITLE. Si le nom de l’application est introuvable dans la ressource, il provient du programme. Nom de fichier EXE.

Retourné par la fonction globale [AfxGetAppName](application-information-and-management.md#afxgetappname). `m_pszAppName`variable publique de type **const char**<strong>\*</strong>.

> [!NOTE]
> Si vous assignez une `m_pszAppName`valeur à, elle doit être allouée dynamiquement sur le tas. Le `CWinApp` destructeur appelle **Free**() avec ce pointeur. Vous souhaitez utiliser la `_tcsdup`fonction de la bibliothèque Runtime () pour effectuer l’allocation. Libérez également la mémoire associée au pointeur actuel avant d’assigner une nouvelle valeur. Par exemple :

[!code-cpp[NVC_MFCWindowing#57](../../mfc/reference/codesnippet/cpp/cwinapp-class_18.cpp)]

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#65](../../mfc/reference/codesnippet/cpp/cwinapp-class_19.cpp)]

##  <a name="m_pszexename"></a>  CWinApp::m_pszExeName

Contient le nom du fichier exécutable de l’application sans extension.

```
LPCTSTR m_pszExeName;
```

### <a name="remarks"></a>Notes

Contrairement à [m_pszAppName](#m_pszappname), ce nom ne peut pas contenir de valeurs vides. `m_pszExeName`variable publique de type **const char**<strong>\*</strong>.

> [!NOTE]
> Si vous assignez une `m_pszExeName`valeur à, elle doit être allouée dynamiquement sur le tas. Le `CWinApp` destructeur appelle **Free**() avec ce pointeur. Vous souhaitez utiliser la `_tcsdup`fonction de la bibliothèque Runtime () pour effectuer l’allocation. Libérez également la mémoire associée au pointeur actuel avant d’assigner une nouvelle valeur. Par exemple :

[!code-cpp[NVC_MFCWindowing#58](../../mfc/reference/codesnippet/cpp/cwinapp-class_20.cpp)]

##  <a name="m_pszhelpfilepath"></a>  CWinApp::m_pszHelpFilePath

Contient le chemin d’accès au fichier d’aide de l’application.

```
LPCTSTR m_pszHelpFilePath;
```

### <a name="remarks"></a>Notes

Par défaut, le Framework initialise `m_pszHelpFilePath` le nom de l’application avec «. HLP» ajouté. Pour modifier le nom du fichier d’aide, définissez `m_pszHelpFilePath` pour pointer vers une chaîne qui contient le nom complet du fichier d’aide souhaité. Pour ce faire, il est pratique d’utiliser la fonction [InitInstance](#initinstance) de l’application. `m_pszHelpFilePath`variable publique de type **const char**<strong>\*</strong>.

> [!NOTE]
> Si vous assignez une `m_pszHelpFilePath`valeur à, elle doit être allouée dynamiquement sur le tas. Le `CWinApp` destructeur appelle **Free**() avec ce pointeur. Vous souhaitez utiliser la `_tcsdup`fonction de la bibliothèque Runtime () pour effectuer l’allocation. Libérez également la mémoire associée au pointeur actuel avant d’assigner une nouvelle valeur. Par exemple :

[!code-cpp[NVC_MFCWindowing#59](../../mfc/reference/codesnippet/cpp/cwinapp-class_21.cpp)]

##  <a name="m_pszprofilename"></a>  CWinApp::m_pszProfileName

Contient le nom de l’application. Fichier INI.

```
LPCTSTR m_pszProfileName;
```

### <a name="remarks"></a>Notes

`m_pszProfileName`variable publique de type **const char**<strong>\*</strong>.

> [!NOTE]
> Si vous assignez une `m_pszProfileName`valeur à, elle doit être allouée dynamiquement sur le tas. Le `CWinApp` destructeur appelle **Free**() avec ce pointeur. Vous souhaitez utiliser la `_tcsdup`fonction de la bibliothèque Runtime () pour effectuer l’allocation. Libérez également la mémoire associée au pointeur actuel avant d’assigner une nouvelle valeur. Par exemple :

[!code-cpp[NVC_MFCWindowing#60](../../mfc/reference/codesnippet/cpp/cwinapp-class_22.cpp)]

##  <a name="m_pszregistrykey"></a>  CWinApp::m_pszRegistryKey

Utilisé pour déterminer où, dans le registre ou le fichier INI, les paramètres du profil d’application sont stockés.

```
LPCTSTR m_pszRegistryKey;
```

### <a name="remarks"></a>Notes

Normalement, ce membre de données est traité en lecture seule.

- La valeur est stockée dans une clé de registre. Le nom du paramètre de profil d’application est ajouté à la clé de Registre suivante : HKEY_CURRENT_USER/Software/LocalAppWizard-generated/.

Si vous assignez une `m_pszRegistryKey`valeur à, elle doit être allouée dynamiquement sur le tas. Le `CWinApp` destructeur appelle **Free**() avec ce pointeur. Vous souhaitez utiliser la `_tcsdup`fonction de la bibliothèque Runtime () pour effectuer l’allocation. Libérez également la mémoire associée au pointeur actuel avant d’assigner une nouvelle valeur. Par exemple :

[!code-cpp[NVC_MFCWindowing#61](../../mfc/reference/codesnippet/cpp/cwinapp-class_23.cpp)]

##  <a name="m_pszappid"></a>  CWinApp::m_pszAppID

ID du modèle utilisateur de l’application.

```
LPCTSTR m_pszAppID;
```

### <a name="remarks"></a>Notes

##  <a name="oncontexthelp"></a>  CWinApp::OnContextHelp

Gère l’aide de MAJ + F1 au sein de l’application.

```
afx_msg void OnContextHelp();
```

### <a name="remarks"></a>Notes

Vous devez ajouter une `ON_COMMAND( ID_CONTEXT_HELP, OnContextHelp )` instruction à votre `CWinApp` table des messages de classe et également ajouter une entrée de table d’accélérateurs, en général MAJ + F1, pour activer cette fonction membre.

`OnContextHelp`met l’application en mode d’aide. Le curseur se transforme en flèche et en point d’interrogation, et l’utilisateur peut déplacer le pointeur de la souris et appuyer sur le bouton gauche de la souris pour sélectionner une boîte de dialogue, une fenêtre, un menu ou un bouton de commande. Cette fonction membre récupère le contexte d’aide de l’objet sous le curseur et appelle la fonction Windows WinHelp avec ce contexte d’aide.

##  <a name="onddecommand"></a>  CWinApp::OnDDECommand

Appelée par l’infrastructure lorsque la fenêtre frame principale reçoit un message d’exécution DDE.

```
virtual BOOL OnDDECommand(LPTSTR lpszCommand);
```

### <a name="parameters"></a>Paramètres

*lpszCommand*<br/>
Pointe vers une chaîne de commande DDE reçue par l’application.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la commande est gérée ; Sinon, 0.

### <a name="remarks"></a>Notes

L’implémentation par défaut vérifie si la commande est une demande d’ouverture d’un document et, le cas échéant, ouvre le document spécifié. Le gestionnaire de fichiers Windows envoie généralement ces chaînes de commande DDE lorsque l’utilisateur double-clique sur un fichier de données. Remplacez cette fonction pour gérer d’autres commandes d’exécution DDE, telles que la commande à imprimer.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#48](../../mfc/reference/codesnippet/cpp/cwinapp-class_24.cpp)]

##  <a name="onfilenew"></a>  CWinApp::OnFileNew

Implémente la commande ID_FILE_NEW.

```
afx_msg void OnFileNew();
```

### <a name="remarks"></a>Notes

Vous devez ajouter une `ON_COMMAND( ID_FILE_NEW, OnFileNew )` instruction à votre `CWinApp` table des messages de classe pour activer cette fonction membre. S’il est activé, cette fonction gère l’exécution de la commande fichier nouveau.

Consultez la [note technique 22](../../mfc/tn022-standard-commands-implementation.md) pour obtenir des informations sur le comportement par défaut et des conseils sur la façon de remplacer cette fonction membre.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

##  <a name="onfileopen"></a>  CWinApp::OnFileOpen

Implémente la commande ID_FILE_OPEN.

```
afx_msg void OnFileOpen();
```

### <a name="remarks"></a>Notes

Vous devez ajouter une `ON_COMMAND( ID_FILE_OPEN, OnFileOpen )` instruction à votre `CWinApp` table des messages de classe pour activer cette fonction membre. S’il est activé, cette fonction gère l’exécution de la commande fichier ouvrir.

Pour plus d’informations sur le comportement par défaut et des conseils sur la façon de remplacer cette fonction membre, consultez la [note technique 22](../../mfc/tn022-standard-commands-implementation.md).

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

##  <a name="onfileprintsetup"></a>  CWinApp::OnFilePrintSetup

Implémente la commande ID_FILE_PRINT_SETUP.

```
afx_msg void OnFilePrintSetup();
```

### <a name="remarks"></a>Notes

Vous devez ajouter une `ON_COMMAND( ID_FILE_PRINT_SETUP, OnFilePrintSetup )` instruction à votre `CWinApp` table des messages de classe pour activer cette fonction membre. S’il est activé, cette fonction gère l’exécution de la commande fichier print.

Pour plus d’informations sur le comportement par défaut et des conseils sur la façon de remplacer cette fonction membre, consultez la [note technique 22](../../mfc/tn022-standard-commands-implementation.md).

### <a name="example"></a>Exemples

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

##  <a name="onhelp"></a>  CWinApp::OnHelp

Gère l'aide F1 dans l'application (en utilisant le contexte actuel).

```
afx_msg void OnHelp();
```

### <a name="remarks"></a>Notes

En règle générale, vous ajoutez également une entrée d’accélérateur pour la touche F1. L’activation de la touche F1 n’est qu’une convention, et non une exigence.

Vous devez ajouter une `ON_COMMAND( ID_HELP, OnHelp )` instruction à votre `CWinApp` table des messages de classe pour activer cette fonction membre. S’il est activé, appelé par le Framework lorsque l’utilisateur appuie sur la touche F1.

L’implémentation par défaut de cette fonction de gestionnaire de messages détermine le contexte d’aide qui correspond à la fenêtre, à la boîte de dialogue ou à l’élément de menu en cours, puis appelle WINHELP. Exécutable. Si aucun contexte n’est actuellement disponible, la fonction utilise le contexte par défaut.

Substituez cette fonction membre pour définir le contexte d’aide à une valeur autre que la fenêtre, la boîte de dialogue, l’élément de menu ou le bouton de barre d’outils qui a actuellement le focus. Appelez `WinHelp` avec l’ID de contexte d’aide souhaité.

##  <a name="onhelpfinder"></a>  CWinApp::OnHelpFinder

Gère les commandes ID_HELP_FINDER et ID_DEFAULT_HELP.

```
afx_msg void OnHelpFinder();
```

### <a name="remarks"></a>Notes

Vous devez ajouter une `ON_COMMAND( ID_HELP_FINDER, OnHelpFinder )` instruction à votre `CWinApp` table des messages de classe pour activer cette fonction membre. Si cette option est activée, l’infrastructure appelle cette fonction du gestionnaire de messages lorsque l’utilisateur de votre application sélectionne la commande `WinHelp` de recherche de l’aide à appeler avec la rubrique standard **HELP_FINDER** .

##  <a name="onhelpindex"></a>  CWinApp::OnHelpIndex

Gère la commande ID_HELP_INDEX et fournit une rubrique d’aide par défaut.

```
afx_msg void OnHelpIndex();
```

### <a name="remarks"></a>Notes

Vous devez ajouter une `ON_COMMAND( ID_HELP_INDEX, OnHelpIndex )` instruction à votre `CWinApp` table des messages de classe pour activer cette fonction membre. Si cette option est activée, l’infrastructure appelle cette fonction de gestionnaire de messages lorsque l’utilisateur de votre application sélectionne la commande `WinHelp` d’index de l’aide à appeler avec la rubrique standard **HELP_INDEX** .

##  <a name="onhelpusing"></a>  CWinApp::OnHelpUsing

Gère la commande ID_HELP_USING.

```
afx_msg void OnHelpUsing();
```

### <a name="remarks"></a>Notes

Vous devez ajouter une `ON_COMMAND( ID_HELP_USING, OnHelpUsing )` instruction à votre `CWinApp` table des messages de classe pour activer cette fonction membre. L’infrastructure appelle cette fonction de gestionnaire de messages lorsque l’utilisateur de votre application sélectionne l’aide de la commande pour `WinHelp` appeler l’application avec la rubrique **HELP_HELPONHELP** standard.

##  <a name="onidle"></a>  CWinApp::OnIdle

Substituez cette fonction membre pour effectuer un traitement en temps inactif.

```
virtual BOOL OnIdle(LONG lCount);
```

### <a name="parameters"></a>Paramètres

*lCount*<br/>
Un compteur est incrémenté chaque `OnIdle` fois que la file d’attente de messages de l’application est vide. Ce nombre est réinitialisé à 0 chaque fois qu’un nouveau message est traité. Vous pouvez utiliser le paramètre *lCount* pour déterminer la durée relative pendant laquelle l’application a été inactive sans traiter un message.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro pour obtenir un temps de traitement plus inactif. 0 si aucune durée d’inactivité n’est nécessaire.

### <a name="remarks"></a>Notes

`OnIdle`est appelé dans la boucle de messages par défaut lorsque la file d’attente de messages de l’application est vide. Utilisez votre remplacement pour appeler vos propres tâches de gestionnaire d’inactivité en arrière-plan.

`OnIdle`doit retourner 0 pour indiquer qu’aucun temps de traitement inactif n’est requis. Le paramètre *lCount* est incrémenté chaque fois `OnIdle` que la file d’attente de messages est vide et rétablit la valeur 0 à chaque fois qu’un nouveau message est traité. Vous pouvez appeler vos différentes routines inactives en fonction de ce nombre.

Voici un résumé du traitement des boucles inactives :

1. Si la boucle de message dans le bibliothèque MFC (Microsoft Foundation Class) vérifie la file d’attente de messages et ne trouve aucun `OnIdle` message en attente, elle appelle pour l’objet d’application et fournit 0 comme argument *lCount* .

2. `OnIdle`effectue un traitement et retourne une valeur différente de zéro pour indiquer qu’il doit être rappelé pour effectuer un traitement supplémentaire.

3. La boucle de message vérifie à nouveau la file d’attente de messages. Si aucun message n’est en attente, `OnIdle` il appelle à nouveau, en incrémentant l’argument *lCount* .

4. Finit par `OnIdle` terminer le traitement de toutes les tâches inactives et retourne 0. Cela indique à la boucle de message d' `OnIdle` arrêter l’appel jusqu’à ce que le message suivant soit reçu de la file d’attente de messages, auquel moment le cycle d’inactivité redémarre avec l’argument défini sur 0.

N’effectuez pas de tâches de longue `OnIdle` durée pendant que votre application ne peut pas `OnIdle` traiter l’entrée d’utilisateur jusqu’à ce que retourne.

> [!NOTE]
> L’implémentation par défaut `OnIdle` des objets d’interface utilisateur de commande de mise à jour, tels que les éléments de menu et les boutons de barre d’outils, effectue le nettoyage de la structure de données interne. Par conséquent, si vous substituez `OnIdle`, vous devez appeler `CWinApp::OnIdle` avec `lCount` la dans votre version substituée. Tout d’abord, appelez tout le traitement inactif de la classe de base ( `OnIdle` c’est-à-dire, jusqu’à ce que la classe de base retourne 0). Si vous devez effectuer le travail avant la fin du traitement de la classe de base, examinez l’implémentation de la classe de base pour sélectionner le *lCount* approprié pour effectuer votre travail.

Si vous ne souhaitez `OnIdle` pas que soit appelé chaque fois qu’un message est récupéré à partir de la file d’attente de messages, vous pouvez remplacer [CWinThreadIsIdleMessage](../../mfc/reference/cwinthread-class.md#isidlemessage). Si une application a défini un minuteur très bref, ou si le système envoie le message WM_SYSTIMER, `OnIdle` est appelé à plusieurs reprises et dégrade les performances.

### <a name="example"></a>Exemples

Les deux exemples suivants montrent comment utiliser `OnIdle`. Le premier exemple traite deux tâches inactives à l’aide de l’argument *lCount* pour classer par ordre de priorité les tâches. La première tâche est haute priorité et vous devez le faire chaque fois que cela est possible. La deuxième tâche est moins importante et doit être effectuée uniquement lorsqu’il y a une longue pause dans l’entrée de l’utilisateur. Notez l’appel à la version de classe de base `OnIdle`de. Le deuxième exemple gère un groupe de tâches inactives avec des priorités différentes.

[!code-cpp[NVC_MFCWindowing#51](../../mfc/reference/codesnippet/cpp/cwinapp-class_27.cpp)]

##  <a name="opendocumentfile"></a>  CWinApp::OpenDocumentFile

L’infrastructure appelle cette méthode pour ouvrir le fichier [CDocument](../../mfc/reference/cdocument-class.md) nommé pour l’application.

```
virtual CDocument* OpenDocumentFile(
    LPCTSTR lpszFileName
    BOOL bAddToMRU = TRUE);
```

### <a name="parameters"></a>Paramètres

*lpszFileName*<br/>
dans Nom du fichier à ouvrir.

*bAddToMRU*<br/>
dans TRUE indique que le document est l’un des fichiers les plus récents ; FALSe indique que le document ne fait pas partie des fichiers les plus récents.

### <a name="return-value"></a>Valeur de retour

Pointeur vers un `CDocument` en cas de réussite ; sinon, null.

### <a name="remarks"></a>Notes

Si un document portant ce nom est déjà ouvert, la première fenêtre frame qui contient ce document obtient le focus. Si une application prend en charge plusieurs modèles de document, le Framework utilise l’extension de nom de fichier pour rechercher le modèle de document approprié afin d’essayer de charger le document. En cas de réussite, le modèle de document crée ensuite une fenêtre frame et une vue pour le document.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#52](../../mfc/reference/codesnippet/cpp/cwinapp-class_16.cpp)]

##  <a name="parsecommandline"></a>  CWinApp::ParseCommandLine

Appelez cette fonction membre pour analyser la ligne de commande et envoyer les paramètres, l’un après l’autre, à [CCommandLineInfo ::P arseparam](../../mfc/reference/ccommandlineinfo-class.md#parseparam).

```
void ParseCommandLine(CCommandLineInfo& rCmdInfo);
```

### <a name="parameters"></a>Paramètres

*rCmdInfo*<br/>
Référence à un objet [CCommandLineInfo](../../mfc/reference/ccommandlineinfo-class.md) .

### <a name="remarks"></a>Notes

Quand vous démarrez un nouveau projet MFC à l’aide de l’Assistant Application, l’Assistant application crée une instance `CCommandLineInfo`locale de, puis `ProcessShellCommand` appelle `ParseCommandLine` et dans la fonction membre [InitInstance](#initinstance) . Une ligne de commande suit l’itinéraire décrit ci-dessous :

1. Une fois créé dans `InitInstance`, l' `CCommandLineInfo` objet est passé à `ParseCommandLine`.

2. `ParseCommandLine`appelle `CCommandLineInfo::ParseParam` ensuite plusieurs fois, une fois pour chaque paramètre.

3. `ParseParam`remplit l' `CCommandLineInfo` objet, qui est ensuite passé à [ProcessShellCommand](#processshellcommand).

4. `ProcessShellCommand`gère les arguments de ligne de commande et les indicateurs.

Notez que vous pouvez appeler `ParseCommandLine` directement en fonction des besoins.

Pour obtenir une description des indicateurs de ligne de commande, consultez [CCommandLineInfo :: m_nShellCommand](../../mfc/reference/ccommandlineinfo-class.md#m_nshellcommand).

##  <a name="pretranslatemessage"></a>  CWinApp::PreTranslateMessage

Substituez cette fonction pour filtrer les messages de fenêtre avant qu’ils ne soient distribués aux fonctions Windows [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage) et [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) l’implémentation par défaut effectue une traduction d’accélérateurs, vous devez donc appeler `CWinApp::PreTranslateMessage`fonction membre dans votre version substituée.

```
virtual BOOL PreTranslateMessage(MSG* pMsg);
```

### <a name="parameters"></a>Paramètres

*pMsg*<br/>
Pointeur vers une structure [MSG](/windows/win32/api/winuser/ns-winuser-msg) qui contient le message à traiter.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro si le message a été `PreTranslateMessage` entièrement traité dans et ne doit pas être traité plus en détail. Zéro si le message doit être traité normalement.

##  <a name="processmessagefilter"></a>  CWinApp::ProcessMessageFilter

La fonction de raccordement de l’infrastructure appelle cette fonction membre pour filtrer et répondre à certains messages Windows.

```
virtual BOOL ProcessMessageFilter(
    int code,
    LPMSG lpMsg);
```

### <a name="parameters"></a>Paramètres

*code*<br/>
Spécifie un code de raccordement. Cette fonction membre utilise le code pour déterminer comment traiter *lpMsg.*

*lpMsg*<br/>
Pointeur vers un tructure de [message](/windows/win32/api/winuser/ns-winuser-msg)Windows.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le message est traité ; Sinon, 0.

### <a name="remarks"></a>Notes

Une fonction de raccordement traite les événements avant leur envoi au traitement de message normal de l’application.

Si vous remplacez cette fonctionnalité avancée, veillez à appeler la version de classe de base pour gérer le processus de raccordement du Framework.

##  <a name="processshellcommand"></a>  CWinApp::ProcessShellCommand

Cette fonction membre est appelée par [InitInstance](#initinstance) pour accepter les paramètres transmis à partir `CCommandLineInfo` de l’objet identifié par *rCmdInfo*et exécuter l’action indiquée.

```
BOOL ProcessShellCommand(CCommandLineInfo& rCmdInfo);
```

### <a name="parameters"></a>Paramètres

*rCmdInfo*<br/>
Référence à un objet [CCommandLineInfo](../../mfc/reference/ccommandlineinfo-class.md) .

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro si la commande de l’interpréteur de commandes est traitée avec succès. Si la valeur est 0, retourne FALSe de [InitInstance](#initinstance).

### <a name="remarks"></a>Notes

Quand vous démarrez un nouveau projet MFC à l’aide de l’Assistant Application, l’Assistant application crée une instance `CCommandLineInfo`locale de, puis `ProcessShellCommand` appelle et [ParseCommandLine](#parsecommandline) dans `InitInstance` la fonction membre. Une ligne de commande suit l’itinéraire décrit ci-dessous :

1. Une fois créé dans `InitInstance`, l' `CCommandLineInfo` objet est passé à `ParseCommandLine`.

2. `ParseCommandLine`appelle ensuite [CCommandLineInfo ::P arseparam](../../mfc/reference/ccommandlineinfo-class.md#parseparam) à plusieurs reprises, une fois pour chaque paramètre.

3. `ParseParam`remplit l' `CCommandLineInfo` objet, qui est ensuite passé à `ProcessShellCommand`.

4. `ProcessShellCommand`gère les arguments de ligne de commande et les indicateurs.

Les données membres de l' `CCommandLineInfo` objet, identifiées par [CCommandLineInfo :: m_nShellCommand](../../mfc/reference/ccommandlineinfo-class.md#m_nshellcommand), sont du type énuméré suivant, qui est défini dans la `CCommandLineInfo` classe.

```
enum {
    FileNew,
    FileOpen,
    FilePrint,
    FilePrintTo,
    FileDDE
    };
```

Pour obtenir une brève description de chacune de ces valeurs, `CCommandLineInfo::m_nShellCommand`consultez.

##  <a name="processwndprocexception"></a>  CWinApp::ProcessWndProcException

L’infrastructure appelle cette fonction membre chaque fois que le gestionnaire n’intercepte pas une exception levée dans l’un des gestionnaires de messages ou de commandes de votre application.

```
virtual LRESULT ProcessWndProcException(
    CException* e,
    const MSG* pMsg);
```

### <a name="parameters"></a>Paramètres

*e*<br/>
Pointeur vers une exception non interceptée.

*pMsg*<br/>
Tructure [MSG](/windows/win32/api/winuser/ns-winuser-msg)qui contient des informations sur le message Windows à l’origine de la levée d’une exception par l’infrastructure.

### <a name="return-value"></a>Valeur de retour

Valeur qui doit être retournée à Windows. En règle générale, il s’agit de 0L pour les messages Windows, 1L (TRUE) pour les messages de commande.

### <a name="remarks"></a>Notes

N’appelez pas cette fonction membre directement.

L’implémentation par défaut de cette fonction membre crée une boîte de message. Si l’exception non interceptée provient d’un menu, d’une barre d’outils ou d’un échec de commande d’accélérateur, la boîte de message affiche un message « échec de la commande ». dans le cas contraire, il affiche un message « erreur interne de l’application ».

Substituez cette fonction membre pour assurer le traitement global de vos exceptions. Appelez uniquement la fonctionnalité de base si vous souhaitez que la boîte de message s’affiche.

##  <a name="register"></a>  CWinApp::Register

Effectue toutes les tâches d’inscription non `RegisterShellFileTypes`gérées par.

```
virtual BOOL Register();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro en cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

L’implémentation par défaut retourne simplement TRUE. Substituez cette fonction pour fournir des étapes d’inscription personnalisées.

##  <a name="registershellfiletypes"></a>  CWinApp::RegisterShellFileTypes

Appelez cette fonction membre pour inscrire tous les types de documents de votre application avec le gestionnaire de fichiers Windows.

```
void RegisterShellFileTypes(BOOL bCompat = FALSE);
```

### <a name="parameters"></a>Paramètres

*bCompat*<br/>
dans TRUE ajoute des entrées d’inscription pour l’impression et l’impression des commandes de l’interpréteur de commandes, ce qui permet à un utilisateur d’imprimer des fichiers directement à partir de l’interpréteur de commandes ou en faisant glisser le fichier vers un objet Printer. Elle ajoute également une clé DefaultIcon. Par défaut, ce paramètre a la valeur FALSe pour des raisons de compatibilité descendante.

### <a name="remarks"></a>Notes

Cela permet à l’utilisateur d’ouvrir un fichier de données créé par votre application en double-cliquant dessus à partir du gestionnaire de fichiers. Appelez `RegisterShellFileTypes` après avoir appelé [AddDocTemplate](#adddoctemplate) pour chacun des modèles de document dans votre application. Appelez également la fonction membre [EnableShellOpen](#enableshellopen) quand vous appelez `RegisterShellFileTypes`.

`RegisterShellFileTypes`itère au sein de la liste des objets [CDocTemplate](../../mfc/reference/cdoctemplate-class.md) que l’application gère et, pour chaque modèle de document, ajoute des entrées à la base de données d’inscription gérée par Windows pour les associations de fichiers. Le gestionnaire de fichiers utilise ces entrées pour ouvrir un fichier de données lorsque l’utilisateur double-clique dessus. Cela élimine le besoin d’envoyer un. Fichier REG avec votre application.

> [!NOTE]
> `RegisterShellFileTypes`fonctionne uniquement si l’utilisateur exécute le programme avec des droits d’administrateur. Si le programme ne dispose pas de droits d’administrateur, il ne peut pas modifier les clés de registre.

Si la base de données d’inscription associe déjà une extension de nom de fichier donnée à un autre type de fichier, aucune nouvelle association n’est créée. Consultez la `CDocTemplate` classe pour connaître le format des chaînes nécessaires à l’enregistrement de ces informations.

##  <a name="registerwithrestartmanager"></a>  CWinApp::RegisterWithRestartManager

Inscrit l’application auprès du gestionnaire de redémarrage.

```
virtual HRESULT RegisterWithRestartManager(
    BOOL bRegisterRecoveryCallback,
    const CString& strRestartIdentifier);

virtual HRESULT RegisterWithRestartManager(
    LPCWSTR pwzCommandLineArgs,
    DWORD dwRestartFlags,
    APPLICATION_RECOVERY_CALLBACK pRecoveryCallback,
    LPVOID lpvParam,
    DWORD dwPingInterval,
    DWORD dwCallbackFlags);
```

### <a name="parameters"></a>Paramètres

|||
|-|-|
|Paramètre|Description|
|*bRegisterRecoveryCallback*|dans TRUE indique que cette instance de l’application utilise une fonction de rappel de récupération ; La valeur FALSe indique qu’elle ne l’est pas. L’infrastructure appelle la fonction de rappel de récupération lorsque l’application se ferme de manière inattendue. Pour plus d’informations, consultez [CWinApp :: ApplicationRecoveryCallback](#applicationrecoverycallback).|
|*strRestartIdentifier*|dans Chaîne unique qui identifie cette instance du gestionnaire de redémarrage. L’identificateur du gestionnaire de redémarrage est unique pour chaque instance d’une application.|
|*pwzCommandLineArgs*|dans Chaîne qui contient tous les arguments supplémentaires de la ligne de commande.|
|*dwRestartFlags*|dans Indicateurs facultatifs pour le gestionnaire de redémarrage. Pour plus d'informations, consultez la section Remarques.|
|*pRecoveryCallback*|dans Fonction de rappel de récupération. Cette fonction doit accepter un paramètre LPVOID comme entrée et retourner une valeur DWORD. La fonction de rappel de récupération `CWinApp::ApplicationRecoveryCallback`par défaut est.|
|*lpvParam*|dans Paramètre d’entrée pour la fonction de rappel de récupération. Pour plus d’informations, consultez [CWinApp :: ApplicationRecoveryCallback](#applicationrecoverycallback).|
|*dwPingInterval*|dans Durée pendant laquelle le gestionnaire de redémarrage attend que la fonction de rappel de récupération soit retournée. Ce paramètre est exprimé en millisecondes.|
|*dwCallbackFlags*|dans Indicateurs passés à la fonction de rappel de récupération. Réservé à un usage ultérieur.|

### <a name="return-value"></a>Valeur de retour

S_OK si la méthode réussit ; Sinon, code d’erreur.

### <a name="remarks"></a>Notes

Si votre application utilise l’implémentation MFC par défaut pour l’enregistrement automatique des fichiers, vous devez utiliser la `RegisterWithRestartManager`version simple de. Utilisez la version complexe de `RegisterWithRestartManager` si vous souhaitez personnaliser le comportement d’enregistrement automatique de votre application.

Si vous appelez cette méthode avec une chaîne vide pour *strRestartIdentifier*, `RegisterWithRestartManager` crée une chaîne d’identificateur unique pour cette instance du gestionnaire de redémarrage.

Quand une application se ferme de manière inattendue, le gestionnaire de redémarrage redémarre l’application à partir de la ligne de commande et fournit l’identificateur de redémarrage unique en tant qu’argument facultatif. Dans ce scénario, le Framework appelle `RegisterWithRestartManager` deux fois. Le premier appel provient de [CWinApp :: InitInstance](#initinstance) avec une chaîne vide pour l’identificateur de chaîne. Ensuite, la méthode [CWinApp ::P rocessshellcommand](#processshellcommand) appelle `RegisterWithRestartManager` avec l’identificateur de redémarrage unique.

Une fois que vous avez inscrit une application auprès du gestionnaire de redémarrage, le gestionnaire de redémarrage surveille l’application. Si l’application se ferme de manière inattendue, le gestionnaire de redémarrage appelle la fonction de rappel de récupération pendant le processus d’arrêt. Le gestionnaire de redémarrage attend l' *dwPingInterval* pour obtenir une réponse de la fonction de rappel de récupération. Si la fonction de rappel de récupération ne répond pas dans ce délai, l’application se ferme sans exécuter la fonction de rappel de récupération.

Par défaut, les dwRestartFlags ne sont pas pris en charge, mais sont fournis pour une utilisation ultérieure. Les valeurs possibles pour *dwRestartFlags* sont les suivantes :

- RESTART_NO_CRASH

- RESTART_NO_HANG

- RESTART_NO_PATCH

- RESTART_NO_REBOOT

##  <a name="reopenpreviousfilesatrestart"></a>  CWinApp::ReopenPreviousFilesAtRestart

Détermine si le gestionnaire de redémarrages ouvre à nouveau les fichiers qui étaient ouverts lorsque l’application s’est arrêtée de manière inattendue.

```
virtual BOOL ReopenPreviousFilesAtRestart() const;
```

### <a name="return-value"></a>Valeur de retour

TRUE indique que le gestionnaire de redémarrage ouvre à nouveau les fichiers précédemment ouverts ; FALSe indique que le gestionnaire de redémarrage ne le fait pas.

##  <a name="restartinstance"></a>  CWinApp::RestartInstance

Gère le redémarrage de l’application initié par le gestionnaire de redémarrage.

```
virtual BOOL CWinApp::RestartInstance();
```

### <a name="return-value"></a>Valeur de retour

TRUE si le gestionnaire de récupération de données ouvre les documents précédemment ouverts ; FALSe si le gestionnaire de récupération de données contient une erreur ou s’il n’y a pas de documents précédemment ouverts.

### <a name="remarks"></a>Notes

Quand le gestionnaire de redémarrage redémarre une application, le Framework appelle cette méthode. Cette méthode récupère le gestionnaire de récupération de données et restaure les fichiers enregistrés de façon automatique. Cette méthode appelle [CDataRecoveryHandler :: RestoreAutosavedDocuments](../../mfc/reference/cdatarecoveryhandler-class.md#restoreautosaveddocuments) pour déterminer si l’utilisateur souhaite restaurer les fichiers enregistrés de façon automatique.

Cette méthode retourne FALSe si le [CDataRecoveryHandler](../../mfc/reference/cdatarecoveryhandler-class.md) détermine qu’il n’existait aucun document ouvert. Si aucun document n’est ouvert, l’application démarre normalement.

##  <a name="restoreautosavedfilesatrestart"></a>  CWinApp::RestoreAutosavedFilesAtRestart

Détermine si le gestionnaire de redémarrage restaure les fichiers enregistrés de façon automatique lorsqu’il redémarre l’application.

```
virtual BOOL RestoreAutosavedFilesAtRestart() const;
```

### <a name="return-value"></a>Valeur de retour

La valeur TRUE indique que le gestionnaire de redémarrage restaure les fichiers enregistrés de façon automatique. FALSe indique que le gestionnaire de redémarrage ne le fait pas.

##  <a name="run"></a>  CWinApp::Run

Fournit une boucle de messages par défaut.

```
virtual int Run();
```

### <a name="return-value"></a>Valeur de retour

Valeur **int** retournée par `WinMain`.

### <a name="remarks"></a>Notes

`Run`acquiert et distribue des messages Windows jusqu’à ce que l’application reçoive un message WM_QUIT. Si la file d’attente de messages de l’application ne `Run` contient actuellement aucun message, appelle [OnIdle](#onidle) pour effectuer le traitement du temps d’inactivité. Les messages entrants sont envoyés à la fonction membre [PreTranslateMessage](#pretranslatemessage) pour un traitement spécial, puis `TranslateMessage` à la fonction Windows pour la traduction du `DispatchMessage` clavier standard. Enfin, la fonction Windows est appelée.

`Run`est rarement substitué, mais vous pouvez le remplacer pour fournir un comportement spécial.

##  <a name="runautomated"></a>  CWinApp::RunAutomated

Appelez cette fonction pour déterminer si l’option « **/Automation**» ou « **-Automation**» est présente, ce qui indique si l’application serveur a été lancée par une application cliente.

```
BOOL RunAutomated();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si l’option a été trouvée ; Sinon, 0.

### <a name="remarks"></a>Notes

S’il est présent, l’option est supprimée de la ligne de commande. Pour plus d’informations sur OLE Automation, consultez l’article [Serveurs Automation](../../mfc/automation-servers.md).

##  <a name="runembedded"></a>  CWinApp::RunEmbedded

Appelez cette fonction pour déterminer si l’option « **/Embedding**» ou « **-Embedding**» est présente, ce qui indique si l’application serveur a été lancée par une application cliente.

```
BOOL RunEmbedded();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si l’option a été trouvée ; Sinon, 0.

### <a name="remarks"></a>Notes

S’il est présent, l’option est supprimée de la ligne de commande. Pour plus d’informations sur l’incorporation, consultez l' [article serveurs : Implémentation d’un](../../mfc/servers-implementing-a-server.md)serveur.

##  <a name="saveallmodified"></a>  CWinApp::SaveAllModified

Appelé par le Framework pour enregistrer tous les documents lorsque la fenêtre frame principale de l’application doit être fermée ou via un message WM_QUERYENDSESSION.

```
virtual BOOL SaveAllModified();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si l’application est arrêtée en toute sécurité ; 0 s’il n’est pas sûr de mettre fin à l’application.

### <a name="remarks"></a>Notes

L’implémentation par défaut de cette fonction membre appelle la fonction membre [CDocument :: SaveModified](../../mfc/reference/cdocument-class.md#savemodified) à son tour pour tous les documents modifiés dans l’application.

##  <a name="selectprinter"></a>  CWinApp::SelectPrinter

Appelez cette fonction membre pour sélectionner une imprimante spécifique et libérer l’imprimante précédemment sélectionnée dans la boîte de dialogue Imprimer.

```
void SelectPrinter(
    HANDLE hDevNames,
    HANDLE hDevMode,
    BOOL bFreeOld = TRUE);
```

### <a name="parameters"></a>Paramètres

*hDevNames*<br/>
Descripteur d’un tructure [DEVNAMES](/windows/win32/api/commdlg/ns-commdlg-devnames)identifiant les noms de pilote, de périphérique et de port de sortie d’une imprimante spécifique.

*hDevMode*<br/>
Handle d’une structure [DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea) qui spécifie des informations sur l’initialisation de l’appareil et l’environnement d’une imprimante.

*bFreeOld*<br/>
Libère l’imprimante sélectionnée précédemment.

### <a name="remarks"></a>Notes

Si *hDevMode* et *hDevNames* ont tous les deux `SelectPrinter` la valeur null, utilise l’imprimante par défaut actuelle.

##  <a name="sethelpmode"></a>  CWinApp::SetHelpMode

Définit le type d’aide de l’application.

```
void SetHelpMode(AFX_HELP_TYPE eHelpType);
```

### <a name="parameters"></a>Paramètres

*eHelpType*<br/>
Spécifie le type d’aide à utiliser. Pour plus d’informations, consultez [CWinApp :: m_eHelpType](#m_ehelptype) .

### <a name="remarks"></a>Notes

Définit le type d’aide de l’application.

Pour définir le type d’aide de votre application sur HTMLHelp, vous pouvez appeler [EnableHTMLHelp](#enablehtmlhelp). Une fois que `EnableHTMLHelp`vous appelez, votre application doit utiliser HTMLHelp comme application d’aide. Si vous souhaitez modifier pour utiliser WinHelp, vous pouvez appeler `SetHelpMode` et définir *eHelpType* sur. `afxWinHelp`

##  <a name="setregistrykey"></a>  CWinApp::SetRegistryKey

Entraîne le stockage des paramètres de l’application dans le registre au lieu des fichiers INI.

```
void SetRegistryKey(LPCTSTR lpszRegistryKey);
void SetRegistryKey(UINT nIDRegistryKey);
```

### <a name="parameters"></a>Paramètres

*lpszRegistryKey*<br/>
Pointeur vers une chaîne contenant le nom de la clé.

*nIDRegistryKey*<br/>
ID d’une ressource de type chaîne contenant le nom de la clé de registre.

### <a name="remarks"></a>Notes

Cette fonction définit *m_pszRegistryKey*, qui est ensuite utilisé par les `GetProfileInt` `GetProfileString` `WriteProfileInt`fonctions membres,, `WriteProfileString` et de. `CWinApp` Si cette fonction a été appelée, la liste des derniers fichiers utilisés (MRU) est également stockée dans le registre. La clé de Registre est généralement le nom d’une société. Il est stocké dans une clé de la forme suivante : HKEY_CURRENT_USER\Software\\< nom\>\>\\\>de la société < nom de l’application < nom de la section\\< nom de la valeur.\>\\

##  <a name="supportsapplicationrecovery"></a>  CWinApp::SupportsApplicationRecovery

Détermine si le gestionnaire de redémarrage récupère une application qui s’est arrêtée de manière inattendue.

```
virtual BOOL SupportsApplicationRecovery() const;
```

### <a name="return-value"></a>Valeur de retour

TRUE indique que le gestionnaire de redémarrage récupère l’application ; FALSe indique que le gestionnaire de redémarrage ne le fait pas.

##  <a name="supportsautosaveatinterval"></a>  CWinApp::SupportsAutosaveAtInterval

Détermine si le gestionnaire de redémarrage enregistre les documents ouverts de façon automatique à intervalles réguliers.

```
virtual BOOL SupportsAutosaveAtInterval() const;
```

### <a name="return-value"></a>Valeur de retour

La valeur TRUE indique que le gestionnaire de redémarrage enregistre les documents ouverts. FALSe indique que le gestionnaire de redémarrage ne le fait pas.

##  <a name="supportsautosaveatrestart"></a>  CWinApp::SupportsAutosaveAtRestart

Détermine si le gestionnaire de redémarrage enregistre tous les documents ouverts lorsque l’application redémarre.

```
virtual BOOL SupportsAutosaveAtRestart() const;
```

### <a name="return-value"></a>Valeur de retour

La valeur TRUE indique que le gestionnaire de redémarrage enregistre les documents ouverts lorsque l’application redémarre ; FALSe indique que le gestionnaire de redémarrage ne le fait pas.

##  <a name="supportsrestartmanager"></a>  CWinApp::SupportsRestartManager

Détermine si l’application prend en charge le gestionnaire de redémarrage.

```
virtual BOOL SupportsRestartManager() const;
```

### <a name="return-value"></a>Valeur de retour

TRUE indique que l’application prend en charge le gestionnaire de redémarrage ; FALSe indique que l’application ne le fait pas.

##  <a name="unregister"></a>  CWinApp::Unregister

Annule l’inscription de tous les fichiers enregistrés par l’objet application.

```
virtual BOOL Unregister();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro en cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

La `Unregister` fonction [annule](#register) l’inscription effectuée par l’objet application et la fonction Register. Normalement, les deux fonctions sont appelées implicitement par MFC et, par conséquent, n’apparaissent pas dans votre code.

Substituez cette fonction pour exécuter des étapes d’annulation d’inscription personnalisées.

##  <a name="unregistershellfiletypes"></a>  CWinApp::UnregisterShellFileTypes

Appelez cette fonction membre pour annuler l’inscription de tous les types de documents de votre application avec le gestionnaire de fichiers Windows.

```
void UnregisterShellFileTypes();
```

##  <a name="winhelp"></a>  CWinApp::WinHelp

Appelez cette fonction membre pour appeler l’application WinHelp.

```
virtual void WinHelp(
    DWORD_PTR dwData,
    UINT nCmd = HELP_CONTEXT);
```

### <a name="parameters"></a>Paramètres

*dwData*<br/>
Spécifie des données supplémentaires. La valeur utilisée dépend de la valeur du paramètre *nCmd* .

*nCmd*<br/>
Spécifie le type d’aide demandée. Pour obtenir une liste des valeurs possibles et savoir comment elles affectent le paramètre *dwData* , consultez la fonction Windows [WinHelp](/windows/win32/api/winuser/nf-winuser-winhelpw) .

### <a name="remarks"></a>Notes

L’infrastructure appelle également cette fonction pour appeler l’application WinHelp.

L’infrastructure ferme automatiquement l’application WinHelp lorsque votre application s’arrête.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#53](../../mfc/reference/codesnippet/cpp/cwinapp-class_28.cpp)]

##  <a name="writeprofilebinary"></a>  CWinApp::WriteProfileBinary

Appelez cette fonction membre pour écrire des données binaires dans la section spécifiée du registre de l’application ou. Fichier INI.

```
BOOL WriteProfileBinary(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Pointe vers une chaîne se terminant par un caractère null qui spécifie la section contenant l’entrée. Si la section n’existe pas, elle est créée. Le nom de la section est indépendant de la casse ; la chaîne peut être n’importe quelle combinaison de lettres majuscules et minuscules.

*lpszEntry*<br/>
Pointe vers une chaîne se terminant par un caractère null qui contient l’entrée dans laquelle la valeur doit être écrite. Si l’entrée n’existe pas dans la section spécifiée, elle est créée.

*pData*<br/>
Pointe vers les données à écrire.

*nBytes*<br/>
Contient le nombre d’octets à écrire.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="example"></a>Exemples

Cet exemple utilise `CWinApp* pApp = AfxGetApp();` pour obtenir la classe CWinApp illustrant une façon dont `WriteProfileBinary` et `GetProfileBinary` peuvent être utilisés à partir de n’importe quelle fonction dans une application MFC.

[!code-cpp[NVC_MFCWindowing#54](../../mfc/reference/codesnippet/cpp/cwinapp-class_29.cpp)]

Pour obtenir un autre exemple, consultez l’exemple pour [CWinApp :: GetProfileBinary](#getprofilebinary).

##  <a name="writeprofileint"></a>  CWinApp::WriteProfileInt

Appelez cette fonction membre pour écrire la valeur spécifiée dans la section spécifiée du registre de l’application ou. Fichier INI.

```
BOOL WriteProfileInt(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Pointe vers une chaîne se terminant par un caractère null qui spécifie la section contenant l’entrée. Si la section n’existe pas, elle est créée. Le nom de la section est indépendant de la casse ; la chaîne peut être n’importe quelle combinaison de lettres majuscules et minuscules.

*lpszEntry*<br/>
Pointe vers une chaîne se terminant par un caractère null qui contient l’entrée dans laquelle la valeur doit être écrite. Si l’entrée n’existe pas dans la section spécifiée, elle est créée.

*nValue*<br/>
Contient la valeur à écrire.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="example"></a>Exemple

Cet exemple utilise `CWinApp* pApp = AfxGetApp();` pour obtenir la classe CWinApp illustrant une façon dont `WriteProfileString`, `WriteProfileInt`, `GetProfileString`et `GetProfileInt` peuvent être utilisés à partir de n’importe quelle fonction dans une application MFC.

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

Pour obtenir un autre exemple, consultez l’exemple pour [CWinApp :: GetProfileInt](#getprofileint).

##  <a name="writeprofilestring"></a>  CWinApp::WriteProfileString

Appelez cette fonction membre pour écrire la chaîne spécifiée dans la section spécifiée du registre de l’application ou. Fichier INI.

```
BOOL WriteProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>Paramètres

*lpszSection*<br/>
Pointe vers une chaîne se terminant par un caractère null qui spécifie la section contenant l’entrée. Si la section n’existe pas, elle est créée. Le nom de la section est indépendant de la casse ; la chaîne peut être n’importe quelle combinaison de lettres majuscules et minuscules.

*lpszEntry*<br/>
Pointe vers une chaîne se terminant par un caractère null qui contient l’entrée dans laquelle la valeur doit être écrite. Si l’entrée n’existe pas dans la section spécifiée, elle est créée. Si ce paramètre a la valeur NULL, la section spécifiée par *lpszSection* est supprimée.

*lpszValue*<br/>
Pointe vers la chaîne à écrire. Si ce paramètre a la valeur NULL, l’entrée spécifiée par le paramètre *lpszEntry* est supprimée.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="example"></a>Exemple

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

Pour obtenir un autre exemple, consultez l’exemple pour [CWinApp :: GetProfileInt](#getprofileint).

##  <a name="setappid"></a>  CWinApp::SetAppID

Définit explicitement l’ID du modèle utilisateur de l’application pour l’application. Cette méthode doit être appelée avant que toute interface utilisateur ne soit présentée à l’utilisateur (le meilleur emplacement est le constructeur d’application).

```
void SetAppID(LPCTSTR lpcszAppID);
```

### <a name="parameters"></a>Paramètres

*lpcszAppID*<br/>
Spécifie l’ID du modèle utilisateur de l’application.

### <a name="remarks"></a>Notes

## <a name="see-also"></a>Voir aussi

[CWinThread, classe](../../mfc/reference/cwinthread-class.md)<br/>
[Graphique hiérarchique](../../mfc/hierarchy-chart.md)<br/>
[Guide pratique : Ajouter la prise en charge du Gestionnaire de redémarrage](../../mfc/how-to-add-restart-manager-support.md)
