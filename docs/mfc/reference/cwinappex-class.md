---
title: CWinAppEx, classe
ms.date: 11/04/2016
f1_keywords:
- CWinAppEx
- AFXWINAPPEX/CWinAppEx
- AFXWINAPPEX/CWinAppEx::CWinAppEx
- AFXWINAPPEX/CWinAppEx::CleanState
- AFXWINAPPEX/CWinAppEx::EnableLoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::EnableTearOffMenus
- AFXWINAPPEX/CWinAppEx::EnableUserTools
- AFXWINAPPEX/CWinAppEx::ExitInstance
- AFXWINAPPEX/CWinAppEx::GetBinary
- AFXWINAPPEX/CWinAppEx::GetContextMenuManager
- AFXWINAPPEX/CWinAppEx::GetDataVersion
- AFXWINAPPEX/CWinAppEx::GetDataVersionMajor
- AFXWINAPPEX/CWinAppEx::GetDataVersionMinor
- AFXWINAPPEX/CWinAppEx::GetInt
- AFXWINAPPEX/CWinAppEx::GetKeyboardManager
- AFXWINAPPEX/CWinAppEx::GetMouseManager
- AFXWINAPPEX/CWinAppEx::GetObject
- AFXWINAPPEX/CWinAppEx::GetRegSectionPath
- AFXWINAPPEX/CWinAppEx::GetRegistryBase
- AFXWINAPPEX/CWinAppEx::GetSectionBinary
- AFXWINAPPEX/CWinAppEx::GetSectionInt
- AFXWINAPPEX/CWinAppEx::GetSectionObject
- AFXWINAPPEX/CWinAppEx::GetSectionString
- AFXWINAPPEX/CWinAppEx::GetShellManager
- AFXWINAPPEX/CWinAppEx::GetString
- AFXWINAPPEX/CWinAppEx::GetTooltipManager
- AFXWINAPPEX/CWinAppEx::GetUserToolsManager
- AFXWINAPPEX/CWinAppEx::InitContextMenuManager
- AFXWINAPPEX/CWinAppEx::InitKeyboardManager
- AFXWINAPPEX/CWinAppEx::InitMouseManager
- AFXWINAPPEX/CWinAppEx::InitShellManager
- AFXWINAPPEX/CWinAppEx::InitTooltipManager
- AFXWINAPPEX/CWinAppEx::IsResourceSmartUpdate
- AFXWINAPPEX/CWinAppEx::IsStateExists
- AFXWINAPPEX/CWinAppEx::LoadState
- AFXWINAPPEX/CWinAppEx::OnAppContextHelp
- AFXWINAPPEX/CWinAppEx::OnViewDoubleClick
- AFXWINAPPEX/CWinAppEx::OnWorkspaceIdle
- AFXWINAPPEX/CWinAppEx::SaveState
- AFXWINAPPEX/CWinAppEx::SetRegistryBase
- AFXWINAPPEX/CWinAppEx::ShowPopupMenu
- AFXWINAPPEX/CWinAppEx::WriteBinary
- AFXWINAPPEX/CWinAppEx::WriteInt
- AFXWINAPPEX/CWinAppEx::WriteObject
- AFXWINAPPEX/CWinAppEx::WriteSectionBinary
- AFXWINAPPEX/CWinAppEx::WriteSectionInt
- AFXWINAPPEX/CWinAppEx::WriteSectionObject
- AFXWINAPPEX/CWinAppEx::WriteSectionString
- AFXWINAPPEX/CWinAppEx::WriteString
- AFXWINAPPEX/CWinAppEx::LoadCustomState
- AFXWINAPPEX/CWinAppEx::LoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::OnClosingMainFrame
- AFXWINAPPEX/CWinAppEx::PreLoadState
- AFXWINAPPEX/CWinAppEx::PreSaveState
- AFXWINAPPEX/CWinAppEx::ReloadWindowPlacement
- AFXWINAPPEX/CWinAppEx::SaveCustomState
- AFXWINAPPEX/CWinAppEx::StoreWindowPlacement
- AFXWINAPPEX/CWinAppEx::m_bForceImageReset
helpviewer_keywords:
- CWinAppEx [MFC], CWinAppEx
- CWinAppEx [MFC], CleanState
- CWinAppEx [MFC], EnableLoadWindowPlacement
- CWinAppEx [MFC], EnableTearOffMenus
- CWinAppEx [MFC], EnableUserTools
- CWinAppEx [MFC], ExitInstance
- CWinAppEx [MFC], GetBinary
- CWinAppEx [MFC], GetContextMenuManager
- CWinAppEx [MFC], GetDataVersion
- CWinAppEx [MFC], GetDataVersionMajor
- CWinAppEx [MFC], GetDataVersionMinor
- CWinAppEx [MFC], GetInt
- CWinAppEx [MFC], GetKeyboardManager
- CWinAppEx [MFC], GetMouseManager
- CWinAppEx [MFC], GetObject
- CWinAppEx [MFC], GetRegSectionPath
- CWinAppEx [MFC], GetRegistryBase
- CWinAppEx [MFC], GetSectionBinary
- CWinAppEx [MFC], GetSectionInt
- CWinAppEx [MFC], GetSectionObject
- CWinAppEx [MFC], GetSectionString
- CWinAppEx [MFC], GetShellManager
- CWinAppEx [MFC], GetString
- CWinAppEx [MFC], GetTooltipManager
- CWinAppEx [MFC], GetUserToolsManager
- CWinAppEx [MFC], InitContextMenuManager
- CWinAppEx [MFC], InitKeyboardManager
- CWinAppEx [MFC], InitMouseManager
- CWinAppEx [MFC], InitShellManager
- CWinAppEx [MFC], InitTooltipManager
- CWinAppEx [MFC], IsResourceSmartUpdate
- CWinAppEx [MFC], IsStateExists
- CWinAppEx [MFC], LoadState
- CWinAppEx [MFC], OnAppContextHelp
- CWinAppEx [MFC], OnViewDoubleClick
- CWinAppEx [MFC], OnWorkspaceIdle
- CWinAppEx [MFC], SaveState
- CWinAppEx [MFC], SetRegistryBase
- CWinAppEx [MFC], ShowPopupMenu
- CWinAppEx [MFC], WriteBinary
- CWinAppEx [MFC], WriteInt
- CWinAppEx [MFC], WriteObject
- CWinAppEx [MFC], WriteSectionBinary
- CWinAppEx [MFC], WriteSectionInt
- CWinAppEx [MFC], WriteSectionObject
- CWinAppEx [MFC], WriteSectionString
- CWinAppEx [MFC], WriteString
- CWinAppEx [MFC], LoadCustomState
- CWinAppEx [MFC], LoadWindowPlacement
- CWinAppEx [MFC], OnClosingMainFrame
- CWinAppEx [MFC], PreLoadState
- CWinAppEx [MFC], PreSaveState
- CWinAppEx [MFC], ReloadWindowPlacement
- CWinAppEx [MFC], SaveCustomState
- CWinAppEx [MFC], StoreWindowPlacement
- CWinAppEx [MFC], m_bForceImageReset
ms.assetid: a3d3e053-3e22-463f-9444-c73abb1bb9d7
ms.openlocfilehash: b630a588d6c7ec81a22a9665deb0fa7517f90dc8
ms.sourcegitcommit: 7a6116e48c3c11b97371b8ae4ecc23adce1f092d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/22/2020
ms.locfileid: "81750650"
---
# <a name="cwinappex-class"></a>CWinAppEx, classe

`CWinAppEx`gère l’état de demande, sauve l’état au registre, charge l’état du registre, initialise les gestionnaires de demande, et fournit des liens vers ces mêmes gestionnaires d’application.

Pour plus de détails, consultez le code source situé dans le dossier **VC\\\\atlmfc src\\mfc** de votre installation Visual Studio.

## <a name="syntax"></a>Syntaxe

```
class CWinAppEx : public CWinApp
```

## <a name="members"></a>Membres

### <a name="public-constructors"></a>Constructeurs publics

|Nom|Description|
|----------|-----------------|
|[CWinAppEx::CWinAppEx](#cwinappex)|Construit un objet `CWinAppEx`.|

### <a name="public-methods"></a>M&#233;thodes publiques

|Nom|Description|
|----------|-----------------|
|[CWinAppEx::CleanState](#cleanstate)|Supprime les informations sur l’application du registre Windows.|
|[CWinAppEx::EnableLoadWindowPlacement](#enableloadwindowplacement)|Précise si l’application chargera la taille initiale et l’emplacement de la fenêtre principale du cadre à partir du registre.|
|[CWinAppEx::EnableTearOffMenus](#enabletearoffmenus)|Permet des menus déchirants pour l’application.|
|[CWinAppEx::EnableUserTools](#enableusertools)|Permet à l’utilisateur de créer des commandes de menu personnalisées dans l’application.|
|[CWinAppEx::ExitInstance](#exitinstance)|Appelé par le cadre `Run` de l’intérieur de la fonction membre de quitter cette instance de l’application. (Overrides [CWinApp::ExitInstance](../../mfc/reference/cwinapp-class.md#exitinstance).)|
|[CWinAppEx::GetBinary](#getbinary)|Lit les données binaires associées à la valeur spécifiée du registre.|
|[CWinAppEx::GetContextMenuManager](#getcontextmenumanager)|Retourne un pointeur à l’objet mondial [CContextMenuManager.](../../mfc/reference/ccontextmenumanager-class.md)|
|[CWinAppEx::GetDataVersion](#getdataversion)||
|[CWinAppEx::GetDataVersionMajor](#getdataversionmajor)|Retourne la version principale de l’application enregistrée dans le registre Windows.|
|[CWinAppEx::GetDataVersionMinor](#getdataversionminor)|Retourne la version mineure de l’application enregistrée dans le registre Windows.|
|[CWinAppEx::GetInt](#getint)|Lit les données numériques associées à la valeur spécifiée du registre.|
|[CWinAppEx::GetKeyboardManager](#getkeyboardmanager)|Retourne un pointeur à l’objet [mondial CKeyboardManager.](../../mfc/reference/ckeyboardmanager-class.md)|
|[CWinAppEx::GetMouseManager](#getmousemanager)|Retourne un pointeur à l’objet [mondial CMouseManager.](../../mfc/reference/cmousemanager-class.md)|
|[CWinAppEx::GetObject](#getobject)|Lit `CObject`-données dérivées qui sont associées à la valeur spécifiée du registre.|
|[CWinAppEx::GetRegSectionPath](#getregsectionpath)|Retourne une chaîne qui est le chemin d’une clé de registre. Ce chemin concatenates le chemin relatif fourni avec le chemin d’application.|
|[CWinAppEx::GetRegistryBase](#getregistrybase)|Retourne la voie du registre pour la demande.|
|[CWinAppEx::GetSectionBinary](#getsectionbinary)|Lit les données binaires qui sont associées à la clé spécifiée et la valeur du registre.|
|[CWinAppEx::GetSectionInt](#getsectionint)|Lit les données numériques du registre associées à la clé et à la valeur spécifiées.|
|[CWinAppEx::GetSectionObject](#getsectionobject)|Lit `CObject` les données associées à la clé spécifiée et la valeur du registre.|
|[CWinAppEx::GetSectionString](#getsectionstring)|Lit les données de chaîne qui sont associées à la clé spécifiée et la valeur du registre.|
|[CWinAppEx::GetShellManager](#getshellmanager)|Retourne un pointeur à l’objet [mondial CShellManager.](../../mfc/reference/cshellmanager-class.md)|
|[CWinAppEx::GetString](#getstring)|Lit les données de chaîne qui sont associées à la valeur spécifiée du registre.|
|[CWinAppEx::GetTooltipManager](#gettooltipmanager)|Retourne un pointeur à l’objet mondial [CTooltipManager.](../../mfc/reference/ctooltipmanager-class.md)|
|[CWinAppEx::GetUserToolsManager](#getusertoolsmanager)|Retourne un pointeur à l’objet mondial [CUserToolsManager.](../../mfc/reference/cusertoolsmanager-class.md)|
|[CWinAppEx::InitContextMenuManager](#initcontextmenumanager)|Initialise l'objet `CContextMenuManager`.|
|[CWinAppEx::InitKeyboardManager](#initkeyboardmanager)|Initialise l'objet `CKeyboardManager`.|
|[CWinAppEx::InitMouseManager](#initmousemanager)|Initialise l'objet `CMouseManager`.|
|[CWinAppEx::InitShellManager](#initshellmanager)|Initialise la `CShellManager` classe|
|[CWinAppEx::InitTooltipManager](#inittooltipmanager)|Initialise la classe `CTooltipManager`.|
|[CWinAppEx::IsResourceSmartUpdate](#isresourcesmartupdate)||
|[CWinAppEx:IsStateExists](#isstateexists)|Indique si la clé spécifiée est dans le registre.|
|[CWinAppEx::LoadState](#loadstate)|Charge l’état de demande du registre.|
|[CWinAppEx::OnAppContextHelp](#onappcontexthelp)|Appelé par le cadre lorsque l’utilisateur demande l’aide contextuelle pour la boîte de dialogue **Customization.**|
|[CWinAppEx::OnViewDoubleClick](#onviewdoubleclick)|Appelle la commande définie par l’utilisateur lorsque l’utilisateur double-clics n’importe où dans l’application.|
|[CWinAppEx::OnWorkspaceIdle](#onworkspaceidle)||
|[CWinAppEx::SaveState](#savestate)|Écrit l’état du cadre d’application au registre Windows.|
|[CWinAppEx::SetRegistryBase](#setregistrybase)|Définit le chemin de la clé de registre par défaut. Cette clé servira de racine à tous les appels de registre ultérieurs.|
|[CWinAppEx::ShowPopupMenu](#showpopupmenu)|Affiche un menu popup.|
|[CWinAppEx::WriteBinary](#writebinary)|Écrit les données binaires à la valeur spécifiée du registre.|
|[CWinAppEx::WriteInt](#writeint)|Écrit les données numériques à la valeur spécifiée du registre.|
|[CWinAppEx::EcrireObject](#writeobject)|Rédige des données dérivées de la [classe CObject](../../mfc/reference/cobject-class.md) à la valeur spécifiée du registre.|
|[CWinAppEx::WriteSectionBinary](#writesectionbinary)|Écrit les données binaires à une valeur de la clé de registre spécifiée.|
|[CWinAppEx::WriteSectionInt](#writesectionint)|Écrit les données numériques à une valeur de la clé de registre spécifiée.|
|[CWinAppEx::WriteSectionObject](#writesectionobject)|Écrit des données `CObject` dérivées de la classe à une valeur de la clé de registre spécifiée.|
|[CWinAppEx::WriteSectionString](#writesectionstring)|Écrit les données de chaîne à une valeur de la clé de registre spécifiée.|
|[CWinAppEx::WriteString](#writestring)|Écrit les données de chaîne à la valeur spécifiée du registre.|

### <a name="protected-methods"></a>Méthodes protégées

|Nom|Description|
|----------|-----------------|
|[CWinAppEx::LoadCustomState](#loadcustomstate)|Appelé par le cadre lorsque l’état d’application a été chargé.|
|[CWinAppEx::LoadWindowPlacement](#loadwindowplacement)|Appelé par le cadre quand il charge la taille et l’emplacement de votre demande à partir du registre. Les données chargées comprennent la taille et l’emplacement de l’image principale au moment de la fermeture de votre application.|
|[CWinAppEx::OnClosingMainFrame](#onclosingmainframe)|Appelé par le cadre quand une fenêtre de cadre principale est le traitement WM_CLOSE.|
|[CWinAppEx::PreLoadState](#preloadstate)|Appelé par le cadre immédiatement avant que l’état d’application est chargé.|
|[CWinAppEx::PreSaveState](#presavestate)|Appelé par le cadre immédiatement avant que l’état d’application est enregistré.|
|[CWinAppEx::ReloadWindowPlacement](#reloadwindowplacement)|Recharge la taille et l’emplacement de la fenêtre fournie à partir du registre|
|[CWinAppEx::SaveCustomState](#savecustomstate)|Appelé par le cadre après qu’il écrit l’état de demande au registre.|
|[CWinAppEx::StoreWindowPlacement](#storewindowplacement)|Appelé par le cadre pour écrire la taille et l’emplacement du cadre principal au registre.|

### <a name="data-members"></a>Données membres

|Nom|Description|
|----------|-----------------|
|[CWinAppEx:m_bForceImageReset](#m_bforceimagereset)|Précise si le cadre réinitialisera toutes les images de la barre d’outils lorsque la fenêtre de cadre qui contient la barre d’outils est chargée.|

## <a name="remarks"></a>Notes

Une grande partie de la fonctionnalité fournie `CWinAppEx` par le cadre MFC dépend de la classe. Vous pouvez `CWinAppEx` intégrer la classe dans votre application de deux façons :

- Construire `CWinAppEx` une classe dans le fil principal.

- Dérivez la classe `CWinAppEx`principale d’application de .

Une fois `CWinAppEx` que vous vous êtes intégré à votre application, vous pouvez initialiser l’un des gestionnaires de candidatures. Avant d’utiliser un gestionnaire d’application, vous devez l’initialiser en appelant la méthode de initialisation appropriée. Pour obtenir un pointeur à un gestionnaire spécifique, appelez la méthode d’obtention associée. La `CWinAppEx` classe gère les gestionnaires d’applications suivants: [CMouseManager Class](../../mfc/reference/cmousemanager-class.md), [CContextMenuManager Class](../../mfc/reference/ccontextmenumanager-class.md), [CKeyboardManager Class](../../mfc/reference/ckeyboardmanager-class.md), [CUserToolsManager Class](../../mfc/reference/cusertoolsmanager-class.md), et [CMenuTearOffManager Class](../../mfc/reference/cmenutearoffmanager-class.md).

## <a name="inheritance-hierarchy"></a>Hiérarchie d'héritage

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWinThread](../../mfc/reference/cwinthread-class.md)

[CWinApp (en)](../../mfc/reference/cwinapp-class.md)

[CWinAppEx](../../mfc/reference/cwinappex-class.md)

## <a name="requirements"></a>Spécifications

**En-tête:** afxwinappex.h

## <a name="cwinappexcleanstate"></a><a name="cleanstate"></a>CWinAppEx::CleanState

Supprime toutes les informations sur l’application du registre Windows.

```
virtual BOOL CleanState(LPCTSTR lpszSectionName=NULL);
```

### <a name="parameters"></a>Paramètres

*lpszSectionName*<br/>
[dans] Une chaîne qui contient un chemin d’une clé de registre.

### <a name="return-value"></a>Valeur de retour

Nonzero si la méthode a été couronnée de succès; sinon 0.

### <a name="remarks"></a>Notes

Cette méthode efface les données d’application d’une section spécifique du registre. Vous pouvez spécifier la section à effacer en utilisant le paramètre *lpszSectionName*. Si *lpszSectionName* est NULL, cette méthode utilisera `CWinAppEx` la trajectoire de registre par défaut stockée dans l’objet. Pour obtenir le chemin du registre par défaut, utilisez [CWinAppEx::GetRegistryBase](#getregistrybase).

## <a name="cwinappexcwinappex"></a><a name="cwinappex"></a>CWinAppEx::CWinAppEx

Construit un objet `CWinAppEx`.

```
CWinAppEx(BOOL bResourceSmartUpdate = FALSE);
```

### <a name="parameters"></a>Paramètres

*bResourceSmartUpdate (en)*<br/>
[dans] Un paramètre Boolean qui précise si l’objet de l’espace de travail doit détecter et gérer les mises à jour des ressources.

### <a name="remarks"></a>Notes

La `CWinAppEx` classe dispose de méthodes d’initialisation, fournit des fonctionnalités pour enregistrer et charger des informations d’application au registre, et contrôle les paramètres d’application globale. Il vous permet également d’utiliser des gestionnaires mondiaux tels que la [classe CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md) et la [classe CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md). Chaque application ne peut avoir `CWinAppEx` qu’une seule instance de la classe.

## <a name="cwinappexenableloadwindowplacement"></a><a name="enableloadwindowplacement"></a>CWinAppEx::EnableLoadWindowPlacement

Précise si l’application chargera la taille initiale et l’emplacement de la fenêtre principale du cadre à partir du registre.

```cpp
void EnableLoadWindowPlacement(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>Paramètres

*bEnable*<br/>
[dans] Précise si l’application charge la taille initiale et l’emplacement de la fenêtre du cadre principal du registre.

### <a name="remarks"></a>Notes

Par défaut, la taille et l’emplacement de l’image principale sont chargés à partir du registre ainsi que d’autres paramètres d’application. Cela se produit pendant [CWinAppEx:LoadState](#loadstate). Si vous ne voulez pas charger le placement de fenêtre initiale du registre, appelez cette méthode avec *bEnable* réglé à FALSE.

## <a name="cwinappexenabletearoffmenus"></a><a name="enabletearoffmenus"></a>CWinAppEx::EnableTearOffMenus

Crée et initialise un objet [CMenuTearOffManager.](../../mfc/reference/cmenutearoffmanager-class.md)

```
BOOL EnableTearOffMenus(
    LPCTSTR lpszRegEntry,
    const UINT uiCmdFirst,
    const UINT uiCmdLast);
```

### <a name="parameters"></a>Paramètres

*lpszRegEntry (en)*<br/>
[dans] Une chaîne qui contient le chemin d’une clé de registre. L’application utilise cette clé de registre pour stocker des informations pour les menus déchirants.

*uiCmdFirst*<br/>
[dans] La première déchirure de l’ID du menu.

*uiCmdLast*<br/>
[dans] La dernière déchirure de l’ID du menu.

### <a name="return-value"></a>Valeur de retour

VRAI si `CMenuTearOffManager` le est créé et para initialisé avec succès; FALSE si une erreur `CMenuTearOffManager` se produit ou si elle existe déjà.

### <a name="remarks"></a>Notes

Utilisez cette fonction pour activer les menus déchirants de votre application. Vous devriez appeler `InitInstance`cette fonction de .

## <a name="cwinappexenableusertools"></a><a name="enableusertools"></a>CWinAppEx::EnableUserTools

Permet à l’utilisateur de créer des commandes de menu personnalisées qui réduisent les frappes de votre application. Cette méthode crée un objet [CUserToolsManager.](../../mfc/reference/cusertoolsmanager-class.md)

```
BOOL EnableUserTools(
    const UINT uiCmdToolsDummy,
    const UINT uiCmdFirst,
    const UINT uiCmdLast,
    CRuntimeClass* pToolRTC = RUNTIME_CLASS(CUserTool),
    UINT uArgMenuID = 0,
    UINT uInitDirMenuID = 0);
```

### <a name="parameters"></a>Paramètres

*uiCmdToolsDummy*<br/>
[dans] Un insignable que le cadre utilise comme un espace réservé pour l’ID de commande du menu des outils utilisateur.

*uiCmdFirst*<br/>
[dans] L’ID de commande pour la première commande d’outil utilisateur.

*uiCmdLast*<br/>
[dans] L’ID de commande pour la dernière commande d’outil utilisateur.

*pToolRTC (en)*<br/>
[dans] Une classe `CUserToolsManager` que l’objet utilise pour créer de nouveaux outils d’utilisateur.

*uArgMenuID*<br/>
[dans] L’ID du menu d’argumentation.

*uInitDirMenuID*<br/>
[dans] L’ID du menu pour le répertoire initial de l’outil.

### <a name="return-value"></a>Valeur de retour

VRAI si la méthode crée `CUserToolsManager` et initialise un objet; FALSE si la méthode `CUserToolsManager` échoue ou si un objet existe déjà.

### <a name="remarks"></a>Notes

Lorsque vous activez des outils définis par l’utilisateur, le cadre prend automatiquement en charge un menu dynamique qui peut être étendu lors de la personnalisation. Le cadre associe chaque nouvel élément à une commande externe. Le cadre invoque ces commandes lorsque l’utilisateur sélectionne l’élément approprié à partir du menu **Tools.**

Chaque fois que l’utilisateur ajoute un nouvel élément, le cadre crée un nouvel objet. Le type de classe pour le nouvel objet est défini par *pToolRTC*. Le type de classe *pToolRTC* doit être dérivé de la [classe CUserTool](../../mfc/reference/cusertool-class.md).

Pour plus d’informations sur les outils utilisateur et comment les intégrer dans votre application, voir [Outils définis par l’utilisateur](../../mfc/user-defined-tools.md).

## <a name="cwinappexexitinstance"></a><a name="exitinstance"></a>CWinAppEx::ExitInstance

```
virtual int ExitInstance();
```

### <a name="return-value"></a>Valeur de retour

### <a name="remarks"></a>Notes

## <a name="cwinappexgetbinary"></a><a name="getbinary"></a>CWinAppEx::GetBinary

Lit les données binaires à partir d’une clé de registre spécifiée.

```
BOOL GetBinary(
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>Paramètres

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient le nom d’une clé de registre.

*ppData (en)*<br/>
[out] Un pointeur vers le tampon que la méthode remplit avec les données binaires.

*pBytes (en)*<br/>
[out] Un pointeur à un integer non signé que la méthode utilise pour écrire le nombre d’octets lus.

### <a name="return-value"></a>Valeur de retour

VRAI en cas de succès; FALSE autrement.

### <a name="remarks"></a>Notes

Cette méthode lit des données binaires écrites au registre. Pour écrire des données au registre, utilisez les méthodes [CWinAppEx::WriteBinary](#writebinary) et [CWinAppEx::WriteSectionBinary](#writesectionbinary).

Le paramètre *lpszEntry* est le nom d’une entrée de registre située sous la clé du registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

## <a name="cwinappexgetcontextmenumanager"></a><a name="getcontextmenumanager"></a>CWinAppEx::GetContextMenuManager

Retourne un pointeur à l’objet mondial [CContextMenuManager.](../../mfc/reference/ccontextmenumanager-class.md)

```
CContextMenuManager* GetContextMenuManager();
```

### <a name="return-value"></a>Valeur de retour

Un pointeur `CContextMenuManager` de l’objet global.

### <a name="remarks"></a>Notes

Si l’objet CContextMenuManager n’est pas initialisé, cette fonction appelle [CWinAppEx::InitContextMenuManager](#initcontextmenumanager) avant qu’il ne retourne un pointeur.

## <a name="cwinappexgetdataversion"></a><a name="getdataversion"></a>CWinAppEx::GetDataVersion

```
int GetDataVersion() const;
```

### <a name="return-value"></a>Valeur de retour

### <a name="remarks"></a>Notes

## <a name="cwinappexgetdataversionmajor"></a><a name="getdataversionmajor"></a>CWinAppEx::GetDataVersionMajor

Retourne la version principale de l’application qui est enregistrée dans le registre Windows lorsque vous appelez [CWinAppEx:SaveState](#savestate).

```
int GetDataVersionMajor() const;
```

### <a name="return-value"></a>Valeur de retour

Une valeur integer qui contient le numéro de version principal.

## <a name="cwinappexgetdataversionminor"></a><a name="getdataversionminor"></a>CWinAppEx::GetDataVersionMinor

Retourne la version mineure de l’application qui est enregistrée dans le registre Windows lorsque vous appelez [CWinAppEx:SaveState](#savestate).

```
int GetDataVersionMinor() const;
```

### <a name="return-value"></a>Valeur de retour

Une valeur integer qui contient le numéro de version mineur.

## <a name="cwinappexgetint"></a><a name="getint"></a>CWinAppEx::GetInt

Lit les données de l’élément à partir d’une clé de registre spécifiée.

```
int GetInt(
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>Paramètres

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient le nom d’une inscription au registre.

*nDefault (en)*<br/>
[dans] La valeur par défaut que la méthode renvoie si l’entrée spécifiée du registre n’existe pas.

### <a name="return-value"></a>Valeur de retour

Les données du registre si la méthode a été couronnée de succès; autrement *nDefault*.

### <a name="remarks"></a>Notes

Cette méthode lit les données integer du registre. S’il n’y a pas de données integer associées à la clé de registre indiquée par *lpszEntry*, cette méthode renvoie *nDefault*. Pour écrire des données au registre, utilisez les méthodes [CWinAppEx::WriteSectionInt](#writesectionint) et [CWinAppEx::WriteInt](#writeint).

Le paramètre *lpszEntry* est le nom d’une entrée de registre située sous la clé du registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

## <a name="cwinappexgetkeyboardmanager"></a><a name="getkeyboardmanager"></a>CWinAppEx::GetKeyboardManager

Retourne un pointeur à l’objet [mondial CKeyboardManager.](../../mfc/reference/ckeyboardmanager-class.md)

```
CKeyboardManager* GetKeyboardManager();
```

### <a name="return-value"></a>Valeur de retour

Un pointeur `CKeyboardManager` de l’objet global.

### <a name="remarks"></a>Notes

Si le gestionnaire du clavier n’est pas initialisé, cette fonction appelle [CWinAppEx::InitKeyboardManager](#initkeyboardmanager) avant qu’il ne retourne un pointeur.

## <a name="cwinappexgetmousemanager"></a><a name="getmousemanager"></a>CWinAppEx::GetMouseManager

Retourne un pointeur à l’objet [mondial CMouseManager.](../../mfc/reference/cmousemanager-class.md)

```
CMouseManager* GetMouseManager();
```

### <a name="return-value"></a>Valeur de retour

Un pointeur `CMouseManager` de l’objet global.

### <a name="remarks"></a>Notes

Si le gestionnaire de souris n’est pas initialisé, cette fonction appelle [CWinAppEx::InitMouseManager](#initmousemanager) avant qu’il ne retourne un pointeur.

## <a name="cwinappexgetobject"></a><a name="getobject"></a>CWinAppEx::GetObject

Lit les données [CObject](../../mfc/reference/cobject-class.md)-dervied du registre.

```
BOOL GetObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>Paramètres

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient le chemin relatif d’une entrée de registre.

*obj*<br/>
[out] Une référence `CObject`à un . La méthode utilise cette référence pour stocker les données du registre.

### <a name="return-value"></a>Valeur de retour

Nonzero si la méthode a été couronnée de succès; sinon 0.

### <a name="remarks"></a>Notes

Cette méthode lit les données du `CObject`registre qui est dérivée de . Pour `CObject` écrire des données au registre, utilisez [CWinAppEx::WriteObject](#writeobject) ou [CWinAppEx::WriteSectionObject](#writesectionobject).

Le paramètre *lpszEntry* est le nom d’une inscription au registre qui se trouve sous la clé du registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

## <a name="cwinappexgetregistrybase"></a><a name="getregistrybase"></a>CWinAppEx::GetRegistryBase

Récupère la trajectoire du registre par défaut pour l’application.

```
LPCTSTR GetRegistryBase();
```

### <a name="return-value"></a>Valeur de retour

Une chaîne qui contient le chemin de l’emplacement du registre par défaut.

### <a name="remarks"></a>Notes

Toutes les méthodes de la [classe CWinAppEx](../../mfc/reference/cwinappex-class.md) qui accèdent au registre commencent dans un emplacement par défaut. Utilisez cette méthode pour récupérer un chemin de l’emplacement du registre par défaut. Utilisez [CWinAppEx::SetRegistryBase](#setregistrybase) pour modifier l’emplacement du registre par défaut.

## <a name="cwinappexgetregsectionpath"></a><a name="getregsectionpath"></a>CWinAppEx::GetRegSectionPath

Crée et retourne le chemin absolu d’une clé de registre.

```
CString GetRegSectionPath(LPCTSTR szSectionAdd = _T(""));
```

### <a name="parameters"></a>Paramètres

*szSectionAdd*<br/>
[dans] Une chaîne qui contient le chemin relatif d’une clé de registre.

### <a name="return-value"></a>Valeur de retour

A `CString` qui contient le chemin absolu d’une clé de registre.

### <a name="remarks"></a>Notes

Cette méthode définit le chemin absolu de la clé de registre en apboursant le chemin relatif dans *szSectionAdd* à l’emplacement du registre par défaut pour votre demande. Pour obtenir la clé de registre par défaut, utilisez la méthode [CWinAppEx::GetRegistryBase](#getregistrybase).

## <a name="cwinappexgetsectionbinary"></a><a name="getsectionbinary"></a>CWinAppEx::GetSectionBinary

Lit les données binaires du registre.

```
BOOL GetSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
[dans] Une chaîne qui contient le chemin relatif d’une clé de registre.

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient la valeur de lire.

*ppData (en)*<br/>
[out] Un pointeur vers le tampon où la méthode stocke les données.

*pBytes (en)*<br/>
[out] Un pointeur à un integer non signé. La méthode écrit la taille de *ppData* à ce paramètre.

### <a name="return-value"></a>Valeur de retour

TRUE en cas de réussite, sinon FALSE.

### <a name="remarks"></a>Notes

Cette méthode lit les données binaires qui est écrit au registre en utilisant les méthodes [CWinAppEx::WriteBinary](#writebinary) et [CWinAppEx::WriteSectionBinary](#writesectionbinary).

Le *paramètre lpszSubSection* n’est pas un chemin absolu pour une entrée de registre. Il s’agit d’un chemin relatif qui est annexé à la fin de la clé de registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

## <a name="cwinappexgetsectionint"></a><a name="getsectionint"></a>CWinAppEx::GetSectionInt

Lit les données de l’intégrant du registre.

```
int GetSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
[dans] Une chaîne qui contient le chemin relatif d’une clé de registre.

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient la valeur de lire.

*nDefault (en)*<br/>
[dans] La valeur par défaut à retourner si la valeur spécifiée n’existe pas.

### <a name="return-value"></a>Valeur de retour

Les données integer qui sont stockées dans la valeur spécifiée du registre; *nDefault* si les données n’existent pas.

### <a name="remarks"></a>Notes

Utilisez les méthodes [CWinAppEx::WriteInt](#writeint) et [CWinAppEx::WriteSectionInt](#writesectionint) pour écrire des données d’intégrage au registre.

Le *paramètre lpszSubSection* n’est pas un chemin absolu d’une inscription au registre. Il s’agit d’un chemin relatif qui est ajouté à la fin de la clé de registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

## <a name="cwinappexgetsectionobject"></a><a name="getsectionobject"></a>CWinAppEx::GetSectionObject

Lit les données du registre [CObject](../../mfc/reference/cobject-class.md) du registre.

```
BOOL GetSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
[dans] Une chaîne qui contient le chemin relatif d’une clé de registre.

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient la valeur de lire.

*obj*<br/>
[out] Une référence `CObject`à un . La méthode `CObject` s’en sert pour stocker les données du registre.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Cette méthode lit les données du registre. Les données `CObject` lues sont des données, `CObject`ou des données pour une classe dérivée de . Pour `CObject` écrire des données au registre, utilisez [CWinAppEx::WriteObject](#writeobject) ou [CWinAppEx::WriteSectionObject](#writesectionobject).

Le *paramètre lpszSubSection* n’est pas un chemin absolu pour une entrée de registre. Il s’agit d’un chemin relatif qui est annexé à la fin de la clé de registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

## <a name="cwinappexgetsectionstring"></a><a name="getsectionstring"></a>CWinAppEx::GetSectionString

Lit les données des chaînes du registre.

```
CString GetSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault = _T(""));
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
[dans] Une chaîne qui contient le chemin relatif d’une clé de registre.

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient la valeur de lire.

*lpszDefault*<br/>
[dans] La valeur par défaut à retourner si la valeur spécifiée n’existe pas.

### <a name="return-value"></a>Valeur de retour

Les données de chaîne stockées dans la valeur spécifiée du registre si les données existent; autrement *lpszDefault*.

### <a name="remarks"></a>Notes

Cette méthode lit les données de chaîne écrites au registre. Utilisez [CWinAppEx:WriteString](#writestring) et [CWinAppEx::WriteSectionString](#writesectionstring) pour écrire des données de chaîne au registre.

Le *paramètre lpszSubSection* n’est pas un chemin absolu pour une entrée de registre. Il s’agit d’un chemin relatif qui est annexé à la fin de la clé de registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

## <a name="cwinappexgetshellmanager"></a><a name="getshellmanager"></a>CWinAppEx::GetShellManager

Retourne un pointeur à l’objet [mondial CShellManager.](../../mfc/reference/cshellmanager-class.md)

```
CShellManager* GetShellManager();
```

### <a name="return-value"></a>Valeur de retour

Un pointeur `CShellManager` de l’objet global.

### <a name="remarks"></a>Notes

Si `CShellManager` l’objet n’est pas initialisé, cette fonction appelle [CWinAppEx::InitShellManager](#initshellmanager) avant qu’il ne retourne un pointeur.

## <a name="cwinappexgetstring"></a><a name="getstring"></a>CWinAppEx::GetString

Lit les données de chaîne à partir d’une clé de registre spécifiée.

```
CString GetString(
    LPCTSTR lpszEntry,
    LPCTSTR lpzDefault= _T(""));
```

### <a name="parameters"></a>Paramètres

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient le nom d’une clé de registre

*lpzDefault*<br/>
[dans] La valeur par défaut que la méthode renvoie si l’entrée spécifiée du registre n’existe pas.

### <a name="return-value"></a>Valeur de retour

Les données de chaîne stockées dans le registre en cas de succès; *lpszDefault* autrement.

### <a name="remarks"></a>Notes

Cette méthode lit les données de chaîne écrites au registre. Pour écrire des données au registre, utilisez les méthodes [CWinAppEx::WriteString](#writestring) ou [CWinAppEx::WriteSectionString](#writesectionstring).

Le paramètre *lpszEntry* est le nom d’une entrée de registre située sous la clé du registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

## <a name="cwinappexgettooltipmanager"></a><a name="gettooltipmanager"></a>CWinAppEx::GetTooltipManager

Retourne un pointeur à l’objet mondial [CTooltipManager.](../../mfc/reference/ctooltipmanager-class.md)

```
CTooltipManager* GetTooltipManager();
```

### <a name="return-value"></a>Valeur de retour

Un pointeur `CTooltipManager` de l’objet global.

### <a name="remarks"></a>Notes

Si `CTooltipManager` l’objet n’est pas initialisé, cette fonction appelle [CWinAppEx::InitTooltipManager](#inittooltipmanager) avant qu’il ne retourne un pointeur.

## <a name="cwinappexgetusertoolsmanager"></a><a name="getusertoolsmanager"></a>CWinAppEx::GetUserToolsManager

Retourne un pointeur à l’objet mondial [CUserToolsManager.](../../mfc/reference/cusertoolsmanager-class.md)

```
CUserToolsManager* GetUserToolsManager();
```

### <a name="return-value"></a>Valeur de retour

Un pointeur `CUserToolsManager` de l’objet global; NULL si la gestion des outils utilisateur n’est pas activée pour l’application.

### <a name="remarks"></a>Notes

Avant de récupérer un `CUserToolsManager` pointeur sur l’objet, vous devez initialiser le gestionnaire en appelant [CWinAppEx::EnableUserTools](#enableusertools).

## <a name="cwinappexinitcontextmenumanager"></a><a name="initcontextmenumanager"></a>CWinAppEx::InitContextMenuManager

Initialise l’objet [CContextMenuManager.](../../mfc/reference/ccontextmenumanager-class.md)

```
BOOL InitContextMenuManager();
```

### <a name="return-value"></a>Valeur de retour

Nonzero si la méthode crée l’objet CContextMenuManager; 0 si `CContextMenuManager` l’objet existe déjà.

### <a name="remarks"></a>Notes

Si vous appelez [CWinAppEx::GetContextMenuManager](#getcontextmenumanager), la `InitContextMenuManager`mise en œuvre par défaut de cette méthode appelle .

Si votre application dispose déjà d’un gestionnaire de menu contextuelle et que vous appelez, `InitContextMenuManager`votre application aura un échec [ASSERT.](diagnostic-services.md#assert) Par conséquent, vous `InitContextMenuManager` ne devriez `CContextMenuManager` pas appeler si vous créez un objet directement. Si vous n’utilisez `CContextMenuManager`pas une `GetContextMenuManager` coutume, `CContextMenuManager` vous devez utiliser pour créer un objet.

## <a name="cwinappexinitkeyboardmanager"></a><a name="initkeyboardmanager"></a>CWinAppEx::InitKeyboardManager

Initialise l’objet [CKeyboardManager.](../../mfc/reference/ckeyboardmanager-class.md)

```
BOOL InitKeyboardManager();
```

### <a name="return-value"></a>Valeur de retour

Nonzero si la `CKeyboardManager` méthode crée l’objet; 0 si `CKeyboardManager` l’objet existe déjà.

### <a name="remarks"></a>Notes

Si vous appelez [CWinAppEx::GetKeyboardManager](#getkeyboardmanager), la `InitKeyboardManager`mise en œuvre par défaut de cette méthode appelle .

Si votre application a déjà un `InitKeyboardManager`gestionnaire de clavier et que vous appelez, votre application aura un échec [ASSERT.](diagnostic-services.md#assert) Par conséquent, vous `InitKeyboardManager` ne devriez `CKeyboardManager` pas appeler si vous créez un objet directement. Si vous n’utilisez `CKeyboardManager`pas une `GetKeyboardManager` coutume, `CKeyboardManager` vous devez utiliser pour créer un objet.

## <a name="cwinappexinitmousemanager"></a><a name="initmousemanager"></a>CWinAppEx::InitMouseManager

Initialise l’objet [CMouseManager.](../../mfc/reference/cmousemanager-class.md)

```
BOOL InitMouseManager();
```

### <a name="return-value"></a>Valeur de retour

Nonzero si la `CMouseManager` méthode crée l’objet; 0 si `CMouseManager` l’objet existe déjà.

### <a name="remarks"></a>Notes

Si vous appelez [CWinAppEx::GetMouseManager](#getmousemanager), la `InitMouseManager`mise en œuvre par défaut de cette méthode appelle .

Si votre application a déjà un `InitMouseManager`gestionnaire de souris et que vous appelez, votre application aura un échec [ASSERT.](diagnostic-services.md#assert) Par conséquent, `InitMouseManager` vous ne `CMouseManager` devriez pas appeler si vous créez un objet directement. Si vous n’utilisez `CMouseManager`pas une `GetMouseManager` coutume, `CMouseManager` vous devez utiliser pour créer un objet.

## <a name="cwinappexinitshellmanager"></a><a name="initshellmanager"></a>CWinAppEx::InitShellManager

Initialise l’objet [CShellManager.](../../mfc/reference/cshellmanager-class.md)

```
BOOL InitShellManager();
```

### <a name="return-value"></a>Valeur de retour

Nonzero si la `CShellManager` méthode crée l’objet; 0 si `CShellManager` l’objet existe déjà.

### <a name="remarks"></a>Notes

Si vous appelez [CWinAppEx::GetShellManager](#getshellmanager), la `InitShellManager`mise en œuvre par défaut de cette méthode appelle .

Si votre application a déjà un `InitShellManager`gestionnaire de shell et que vous appelez, votre application soulève une défaillance [d’ASSERT.](diagnostic-services.md#assert) Par conséquent, `InitShellManager` n’appelez `CShellManager` pas si vous créez un objet directement. Si vous n’utilisez `CShellManager`pas `GetShellManager` une `CShellManager` coutume, utilisez-le pour créer un objet.

## <a name="cwinappexinittooltipmanager"></a><a name="inittooltipmanager"></a>CWinAppEx::InitTooltipManager

Initialise l’objet [CTooltipManager.](../../mfc/reference/ctooltipmanager-class.md)

```
BOOL InitTooltipManager();
```

### <a name="return-value"></a>Valeur de retour

Nonzero si la `CTooltipManager` méthode crée l’objet; 0 si `CTooltipManager` l’objet existe déjà.

### <a name="remarks"></a>Notes

Si vous appelez [CWinAppEx::GetTooltipManager](#gettooltipmanager), la `InitTooltipManager`mise en œuvre par défaut de cette méthode appelle .

Si votre application a déjà un gestionnaire `InitTooltipManager`tooltip et que vous appelez, votre application aura un échec [ASSERT.](diagnostic-services.md#assert) Par conséquent, vous `InitTooltipManager` ne devriez `CTooltipManager` pas appeler si vous créez un objet directement. Si vous n’utilisez `CTooltipManager`pas une `GetTooltipManager` coutume, `CTooltipManager` vous devez utiliser pour créer un objet.

## <a name="cwinappexisresourcesmartupdate"></a><a name="isresourcesmartupdate"></a>CWinAppEx::IsResourceSmartUpdate

```
BOOL IsResourceSmartUpdate() const;
```

### <a name="return-value"></a>Valeur de retour

### <a name="remarks"></a>Notes

## <a name="cwinappexisstateexists"></a><a name="isstateexists"></a>CWinAppEx:IsStateExists

Indique si la clé spécifiée est dans le registre.

```
BOOL IsStateExists(LPCTSTR lpszSectionName);
```

### <a name="parameters"></a>Paramètres

*lpszSectionName*<br/>
[dans] Une chaîne qui contient un chemin d’une clé de registre.

### <a name="return-value"></a>Valeur de retour

Nonzero si la clé est dans le registre; sinon 0.

## <a name="cwinappexloadcustomstate"></a><a name="loadcustomstate"></a>CWinAppEx::LoadCustomState

Le cadre appelle cette méthode après qu’elle charge l’état de l’application à partir du registre.

```
virtual void LoadCustomState();
```

### <a name="remarks"></a>Notes

Remplacer cette méthode si vous voulez faire un traitement après que la demande charge l’état du registre. Par défaut, cette méthode ne fait rien.

Afin de charger des informations d’état personnalisées à partir du registre, les informations doivent d’abord être enregistrées en utilisant [CWinAppEx::SaveCustomState](#savecustomstate).

## <a name="cwinappexloadstate"></a><a name="loadstate"></a>CWinAppEx::LoadState

Lit l’état de l’application à partir du registre Windows.

```
BOOL LoadState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

virtual BOOL LoadState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);
```

### <a name="parameters"></a>Paramètres

*pFrame (en)*<br/>
[dans] Un pointeur à un objet de fenêtre de cadre. La méthode applique les informations d’état dans le registre à cette fenêtre de cadre.

*lpszSectionName*<br/>
[dans] Une chaîne qui contient le chemin relatif d’une clé de registre.

*pFrameImpl*<br/>
[dans] Un pointeur `CFrameImpl` à un objet. La méthode applique les informations d’état dans le registre à cette fenêtre de cadre.

### <a name="return-value"></a>Valeur de retour

Nonzero en cas de succès; 0 autrement.

### <a name="remarks"></a>Notes

Cette méthode charge l’état de l’application et toute information d’état pour une fenêtre de cadre. Les informations chargées pour la fenêtre de cadre sont appliquées à la fenêtre de cadre fournie. Si vous ne fournissez pas une fenêtre de cadre, seules les informations d’état d’application sont chargées. Les informations d’application incluent l’état de la [classe CMouseManager](../../mfc/reference/cmousemanager-class.md), [CContextMenuManager Class](../../mfc/reference/ccontextmenumanager-class.md), [CKeyboardManager Class](../../mfc/reference/ckeyboardmanager-class.md), et la classe [CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md).

La mise `CFrameImpl::OnLoadFrame` en `LoadState`œuvre par défaut des appels .

Le paramètre *lpszSectionName* n’est pas le chemin absolu pour une entrée de registre. Il s’agit d’un chemin relatif qui est ajouté à la fin de la clé de registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

## <a name="cwinappexloadwindowplacement"></a><a name="loadwindowplacement"></a>CWinAppEx::LoadWindowPlacement

Appelé par le cadre quand il charge la taille et l’emplacement de la fenêtre de cadre principale du registre.

```
virtual BOOL LoadWindowPlacement(
    CRect& rectNormalPosition,
    int& nFlags,
    int& nShowCmd);
```

### <a name="parameters"></a>Paramètres

*rectNormalPosition (en)*<br/>
[out] Un rectangle qui contient les coordonnées de la fenêtre du cadre principal lorsqu’il est en position restaurée.

*nFlags*<br/>
[out] Drapeaux qui contrôlent la position de la fenêtre réduite au minimum et comment le système d’exploitation passe d’une fenêtre réduite au minimum à une fenêtre restaurée.

*nShowCmd (en)*<br/>
[out] Un integer qui spécifie l’état de spectacle de la fenêtre. Pour plus d’informations sur les valeurs possibles, voir [CWnd::ShowWindow](../../mfc/reference/cwnd-class.md#showwindow).

### <a name="return-value"></a>Valeur de retour

Nonzero en cas de succès; 0 autrement.

### <a name="remarks"></a>Notes

Par défaut, MFC charge automatiquement la position et l’état précédents de la fenêtre de cadre principale lorsque l’application démarre. Pour plus d’informations sur la façon dont ces informations sont stockées dans le registre, voir [CWinAppEx::StoreWindowPlacement](#storewindowplacement).

Remplacez cette méthode si vous souhaitez charger des informations supplémentaires sur la fenêtre du cadre principal.

## <a name="cwinappexm_bforceimagereset"></a><a name="m_bforceimagereset"></a>CWinAppEx:m_bForceImageReset

Précise si le cadre réinitialise toutes les images de la barre d’outils lorsqu’il recharge la fenêtre de cadre qui contient la barre d’outils.

```
BOOL m_bForceImageReset;
```

### <a name="remarks"></a>Notes

Le `m_bForceImageReset` membre des données est une variable protégée.

## <a name="cwinappexonappcontexthelp"></a><a name="onappcontexthelp"></a>CWinAppEx::OnAppContextHelp

Le cadre appelle cette méthode lorsque l’utilisateur demande une aide contextuelle pour la boîte de dialogue **De Personnalisation.**

```
virtual void OnAppContextHelp(
    CWnd* pWndControl,
    const DWORD dwHelpIDArray[]);
```

### <a name="parameters"></a>Paramètres

*pWndControl (en)*<br/>
[dans] Un pointeur vers un objet de fenêtre pour lequel l’utilisateur a invoqué l’aide de contexte.

*dwHelpIDArray[]*<br/>
[dans] Une valeur réservée.

### <a name="remarks"></a>Notes

Cette méthode est actuellement réservée à une utilisation future. La mise en œuvre par défaut ne fait rien et elle n’est actuellement pas appelée par le cadre.

## <a name="cwinappexonclosingmainframe"></a><a name="onclosingmainframe"></a>CWinAppEx::OnClosingMainFrame

Le cadre appelle cette méthode lorsqu’une fenêtre de cadre traite WM_CLOSE.

```
virtual void OnClosingMainFrame(CFrameImpl* pFrameImpl);
```

### <a name="parameters"></a>Paramètres

*pFrameImpl*<br/>
[dans] Un pointeur `CFrameImpl` à un objet.

### <a name="remarks"></a>Notes

La mise en œuvre par défaut de cette méthode sauve l’état de *pFrameImpl*.

## <a name="cwinappexonviewdoubleclick"></a><a name="onviewdoubleclick"></a>CWinAppEx::OnViewDoubleClick

Appelle la commande définie par l’utilisateur qui est associée à une vue lorsque l’utilisateur double-clics n’importe où dans cette vue.

```
virtual BOOL OnViewDoubleClick(
    CWnd* pWnd,
    int iViewId);
```

### <a name="parameters"></a>Paramètres

*Pwnd*<br/>
[dans] Un pointeur à un objet dérivé de la [classe CView](../../mfc/reference/cview-class.md).

*iViewId (en)*<br/>
[dans] L’ID de vue.

### <a name="return-value"></a>Valeur de retour

VRAI si le cadre trouve une commande; autrement FALSE.

### <a name="remarks"></a>Notes

Afin de prendre en charge le comportement personnalisé de la souris, vous devez appeler cette fonction lorsque vous traitez le message WM_LBUTTONDBLCLK. Cette méthode exécutera la commande associée à l’ID de vue fourni par *iViewId*. Pour plus d’informations sur le comportement personnalisé de la souris, voir [Keyboard et Mouse Customization](../../mfc/keyboard-and-mouse-customization.md).

## <a name="cwinappexonworkspaceidle"></a><a name="onworkspaceidle"></a>CWinAppEx::OnWorkspaceIdle

```
virtual BOOL OnWorkspaceIdle(CWnd*);
```

### <a name="parameters"></a>Paramètres

[dans] *&#38;CWnd*<br/>

### <a name="return-value"></a>Valeur de retour

### <a name="remarks"></a>Notes

## <a name="cwinappexpreloadstate"></a><a name="preloadstate"></a>CWinAppEx::PreLoadState

Le cadre appelle cette méthode immédiatement avant qu’elle charge l’état de la demande à partir du registre.

```
virtual void PreLoadState();
```

### <a name="remarks"></a>Notes

Remplacer cette méthode si vous souhaitez effectuer un traitement immédiatement avant que le cadre charge l’état d’application.

## <a name="cwinappexpresavestate"></a><a name="presavestate"></a>CWinAppEx::PreSaveState

Le cadre appelle cette méthode immédiatement avant qu’elle n’enregistre l’état d’application.

```
virtual void PreSaveState();
```

### <a name="remarks"></a>Notes

Remplacer cette méthode si vous souhaitez effectuer un traitement immédiatement avant que le cadre enregistre l’état d’application.

## <a name="cwinappexreloadwindowplacement"></a><a name="reloadwindowplacement"></a>CWinAppEx::ReloadWindowPlacement

Recharge la taille et l’emplacement d’une fenêtre du registre.

```
virtual BOOL ReloadWindowPlacement(CFrameWnd* pFrame);
```

### <a name="parameters"></a>Paramètres

*pFrame (en)*<br/>
[dans] Un pointeur à une fenêtre de cadre.

### <a name="return-value"></a>Valeur de retour

Nonzero si la méthode a été couronnée de succès; 0 si la charge a échoué ou qu’il n’y a pas de données à charger.

### <a name="remarks"></a>Notes

Utilisez la fonction [CWinAppEx::StoreWindowPlacement](#storewindowplacement) pour écrire la taille et l’emplacement d’une fenêtre au registre.

## <a name="cwinappexsavecustomstate"></a><a name="savecustomstate"></a>CWinAppEx::SaveCustomState

Le cadre appelle cette méthode après qu’elle enregistre l’état de l’application au registre.

```
virtual void SaveCustomState();
```

### <a name="remarks"></a>Notes

Remplacer cette méthode si vous souhaitez effectuer un traitement après que la demande enregistre l’état au registre. Par défaut, cette méthode ne fait rien.

## <a name="cwinappexsavestate"></a><a name="savestate"></a>CWinAppEx::SaveState

Écrit l’état de l’application au registre Windows.

```
virtual BOOL SaveState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);

BOOL SaveState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>Paramètres

*lpszSectionName*<br/>
[dans] Une chaîne qui contient le chemin relatif d’une clé de registre.

*pFrameImpl*<br/>
[dans] Un pointeur `CFrameImpl` à un objet. Ce cadre est enregistré au registre Windows.

*pFrame (en)*<br/>
[dans] Un pointeur à un objet de fenêtre de cadre. Ce cadre est enregistré au registre Windows.

### <a name="return-value"></a>Valeur de retour

VRAI en cas de succès; FALSE autrement.

### <a name="remarks"></a>Notes

Cette méthode enregistre l’état de l’application et toute information d’état pour la fenêtre de cadre fournie. Si vous ne fournissez pas de fenêtre de cadre, la méthode n’enregistre que l’état d’application. Les informations d’application incluent l’état de la [classe CMouseManager](../../mfc/reference/cmousemanager-class.md), [CContextMenuManager Class](../../mfc/reference/ccontextmenumanager-class.md), [CKeyboardManager Class](../../mfc/reference/ckeyboardmanager-class.md), et la classe [CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md).

Le paramètre *lpszSectionName* n’est pas le chemin absolu pour une entrée de registre. Il s’agit d’un chemin relatif qui est annexé à la fin de la clé de registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

## <a name="cwinappexsetregistrybase"></a><a name="setregistrybase"></a>CWinAppEx::SetRegistryBase

Définit la trajectoire du registre par défaut pour l’application.

```
LPCTSTR SetRegistryBase(LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>Paramètres

*lpszSectionName*<br/>
[dans] Une chaîne qui contient le chemin d’une clé de registre.

### <a name="return-value"></a>Valeur de retour

Une chaîne qui contient le chemin de l’emplacement du registre par défaut.

### <a name="remarks"></a>Notes

Toutes les méthodes de la [classe CWinAppEx](../../mfc/reference/cwinappex-class.md) qui accèdent au registre commencent dans un emplacement par défaut. Utilisez cette méthode pour modifier l’emplacement du registre par défaut. Utilisez [CWinAppEx:GetRegistryBase](#getregistrybase) pour récupérer l’emplacement du registre par défaut.

## <a name="cwinappexshowpopupmenu"></a><a name="showpopupmenu"></a>CWinAppEx::ShowPopupMenu

Affiche un menu popup.

```
virtual BOOL ShowPopupMenu(
    UINT uiMenuResId,
    const CPoint& point,
    CWnd* pWnd);
```

### <a name="parameters"></a>Paramètres

*uiMenuResId*<br/>
[dans] Une pièce d’identité de ressource de menu.

*Point*<br/>
[dans] Un [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) qui spécifie la position du menu dans les coordonnées de l’écran.

*Pwnd*<br/>
[dans] Un pointeur à la fenêtre qui possède le menu popup.

### <a name="return-value"></a>Valeur de retour

Nonzero si le menu popup est affiché avec succès; 0 autrement.

### <a name="remarks"></a>Notes

Cette méthode affiche le menu associé à *uiMenuResId*.

Pour prendre en charge les menus popup, vous devez avoir un objet [CContextMenuManager.](../../mfc/reference/ccontextmenumanager-class.md) Si vous n’avez `CContextMenuManager` pas `ShowPopupMenu` para initialisé l’objet, échouera.

## <a name="cwinappexstorewindowplacement"></a><a name="storewindowplacement"></a>CWinAppEx::StoreWindowPlacement

Appelé par le cadre pour écrire la taille et l’emplacement de la fenêtre de cadre principale au registre.

```
virtual BOOL StoreWindowPlacement(
    const CRect& rectNormalPosition,
    int nFlags,
    int nShowCmd);
```

### <a name="parameters"></a>Paramètres

*nFlags*<br/>
[dans] Drapeaux qui contrôlent la position de la fenêtre réduite au minimum et comment le système d’exploitation passe d’une fenêtre réduite au minimum à une fenêtre restaurée.

*nShowCmd (en)*<br/>
[dans] Un integer qui spécifie l’état de spectacle de la fenêtre. Pour plus d’informations sur les valeurs possibles, voir [CWnd::ShowWindow](../../mfc/reference/cwnd-class.md#showwindow).

*rectNormalPosition (en)*<br/>
[dans] Un rectangle qui contient les coordonnées de la fenêtre du cadre principal lorsqu’il est dans l’état restauré.

### <a name="return-value"></a>Valeur de retour

Nonzero en cas de succès; 0 autrement.

### <a name="remarks"></a>Notes

Par défaut, MFC enregistre automatiquement la position et l’état de la fenêtre de cadre principale avant la sortie de l’application. Ces informations sont stockées dans le registre Windows sous la clé WindowPlacement dans l’emplacement du registre par défaut pour votre application. Pour plus d’informations sur l’emplacement du registre par défaut de votre demande, voir [CWinAppEx:GetRegistryBase](#getregistrybase).

Remplacez cette méthode si vous souhaitez stocker des informations supplémentaires sur la fenêtre du cadre principal.

## <a name="cwinappexwritebinary"></a><a name="writebinary"></a>CWinAppEx::WriteBinary

Écrit des données binaires au registre.

```
BOOL WriteBinary(
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>Paramètres

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient le nom d’une clé de registre.

*Pdata*<br/>
[dans] Les données à stocker.

*nBytes (en)*<br/>
[dans] La taille de *pData* dans les octets.

### <a name="return-value"></a>Valeur de retour

VRAI si cette méthode est réussie; autrement FALSE.

### <a name="remarks"></a>Notes

Le paramètre *lpszEntry* est le nom d’une inscription au registre qui se trouve sous la clé du registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

Si la clé spécifiée par *lpszEntry* n’existe pas, cette méthode la créera.

## <a name="cwinappexwriteint"></a><a name="writeint"></a>CWinAppEx::WriteInt

Rédige des données numériques au registre.

```
BOOL WriteInt(
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>Paramètres

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient le nom d’une clé de registre.

*nValue (en)*<br/>
[dans] Les données à stocker.

### <a name="return-value"></a>Valeur de retour

VRAI si cette méthode est réussie; autrement FALSE.

### <a name="remarks"></a>Notes

Le paramètre *lpszEntry* est le nom d’une entrée de registre située sous la clé du registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

Si la clé spécifiée par *lpszEntry* n’existe pas, cette méthode la créera.

## <a name="cwinappexwriteobject"></a><a name="writeobject"></a>CWinAppEx::EcrireObject

Écrit des données dérivées de la [classe CObject](../../mfc/reference/cobject-class.md) au registre.

```
BOOL WriteObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>Paramètres

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient la valeur à définir.

*obj*<br/>
[dans] Une référence `CObject` aux données que la méthode stockera.

### <a name="return-value"></a>Valeur de retour

VRAI si cette méthode est réussie; autrement FALSE.

### <a name="remarks"></a>Notes

Cette méthode écrit les données *obj* à la valeur spécifiée sous la clé du registre par défaut. Utilisez [CWinAppEx:GetRegistryBase](#getregistrybase) pour déterminer la clé de registre actuelle.

## <a name="cwinappexwritesectionbinary"></a><a name="writesectionbinary"></a>CWinAppEx::WriteSectionBinary

Écrit des données binaires à une valeur dans le registre.

```
BOOL WriteSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
[dans] Une chaîne qui contient le nom d’une clé de registre

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient la valeur à définir.

*Pdata*<br/>
[dans] Les données à écrire au registre.

*nBytes (en)*<br/>
[dans] La taille de *pData* dans les octets.

### <a name="return-value"></a>Valeur de retour

VRAI si cette méthode est réussie; autrement FALSE.

### <a name="remarks"></a>Notes

Le paramètre *lpszSubSection* n’est pas le chemin absolu pour une entrée de registre. Il s’agit d’un chemin relatif qui est annexé à la fin de la clé de registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

Si la clé spécifiée par *lpszEntry* n’existe pas, cette méthode la créera.

## <a name="cwinappexwritesectionint"></a><a name="writesectionint"></a>CWinAppEx::WriteSectionInt

Rédige des données numériques au registre.

```
BOOL WriteSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
[dans] Une chaîne qui contient le chemin relatif d’une clé de registre.

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient la valeur à définir.

*nValue (en)*<br/>
[dans] Les données à écrire au registre.

### <a name="return-value"></a>Valeur de retour

VRAI si cette méthode est réussie; autrement FALSE.

### <a name="remarks"></a>Notes

Le *paramètre lpszSubSection* n’est pas un chemin absolu pour une entrée de registre. Il s’agit d’un chemin relatif qui est annexé à la clé de registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

Si la clé spécifiée par *lpszEntry* n’existe pas, cette méthode la créera.

## <a name="cwinappexwritesectionobject"></a><a name="writesectionobject"></a>CWinAppEx::WriteSectionObject

Écrit des données dérivées de la [classe CObject](../../mfc/reference/cobject-class.md) à une valeur de registre spécifique.

```
BOOL WriteSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
[dans] Une chaîne qui contient le nom d’une clé de registre.

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient le nom de la valeur à définir.

*obj*<br/>
[dans] Les données à stocker.

### <a name="return-value"></a>Valeur de retour

VRAI si cette méthode est réussie; autrement FALSE.

### <a name="remarks"></a>Notes

Le *paramètre lpszSubSection* n’est pas un chemin absolu pour une entrée de registre. Il s’agit d’un chemin relatif qui est annexé à la fin de la clé de registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase), respectivement.

Si la valeur spécifiée par *lpszEntry* n’existe pas en vertu de la clé de registre spécifiée par *lpszSubSection*, cette méthode créera cette valeur.

## <a name="cwinappexwritesectionstring"></a><a name="writesectionstring"></a>CWinAppEx::WriteSectionString

Écrit des données de chaîne à une valeur dans le registre.

```
BOOL WriteSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
[dans] Une chaîne qui contient le nom d’une clé de registre.

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient la valeur à définir.

*lpszValue*<br/>
[dans] Les données de chaîne à écrire au registre.

### <a name="return-value"></a>Valeur de retour

VRAI si cette méthode est réussie; autrement FALSE.

### <a name="remarks"></a>Notes

Le *paramètre lpszSubSection* n’est pas un chemin absolu pour une entrée de registre. Il s’agit d’un chemin relatif qui est annexé à la fin de la clé de registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase), respectivement.

Si la valeur spécifiée par *lpszEntry* n’existe pas sous *lpszSubSection*, cette méthode va la créer.

## <a name="cwinappexwritestring"></a><a name="writestring"></a>CWinAppEx::WriteString

Rédige des données de chaîne au registre.

```
BOOL WriteString(
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>Paramètres

*lpszEntry (en)*<br/>
[dans] Une chaîne qui contient le nom d’une clé de registre.

*lpszValue*<br/>
[dans] Les données à stocker.

### <a name="return-value"></a>Valeur de retour

VRAI si cette méthode est réussie; autrement FALSE.

### <a name="remarks"></a>Notes

Le paramètre *lpszEntry* est le nom d’une entrée de registre située sous la clé du registre par défaut pour votre demande. Pour obtenir ou définir la clé de registre par défaut, utilisez les méthodes [CWinAppEx::GetRegistryBase](#getregistrybase) et [CWinAppEx::SetRegistryBase](#setregistrybase) respectivement.

Si la clé spécifiée par *lspzEntry* n’existe pas, cette méthode la créera.

## <a name="see-also"></a>Voir aussi

[Graphique hiérarchique](../../mfc/hierarchy-chart.md)<br/>
[Classes](../../mfc/reference/mfc-classes.md)<br/>
[CWinApp, classe](../../mfc/reference/cwinapp-class.md)<br/>
[Classe CMouseManager](../../mfc/reference/cmousemanager-class.md)<br/>
[CContextMenuManager, classe](../../mfc/reference/ccontextmenumanager-class.md)<br/>
[Classe CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md)<br/>
[Classe CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md)
