---
title: CWinAppEx, classe
ms.date: 11/04/2016
f1_keywords:
- CWinAppEx
- AFXWINAPPEX/CWinAppEx
- AFXWINAPPEX/CWinAppEx::CWinAppEx
- AFXWINAPPEX/CWinAppEx::CleanState
- AFXWINAPPEX/CWinAppEx::EnableLoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::EnableTearOffMenus
- AFXWINAPPEX/CWinAppEx::EnableUserTools
- AFXWINAPPEX/CWinAppEx::ExitInstance
- AFXWINAPPEX/CWinAppEx::GetBinary
- AFXWINAPPEX/CWinAppEx::GetContextMenuManager
- AFXWINAPPEX/CWinAppEx::GetDataVersion
- AFXWINAPPEX/CWinAppEx::GetDataVersionMajor
- AFXWINAPPEX/CWinAppEx::GetDataVersionMinor
- AFXWINAPPEX/CWinAppEx::GetInt
- AFXWINAPPEX/CWinAppEx::GetKeyboardManager
- AFXWINAPPEX/CWinAppEx::GetMouseManager
- AFXWINAPPEX/CWinAppEx::GetObject
- AFXWINAPPEX/CWinAppEx::GetRegSectionPath
- AFXWINAPPEX/CWinAppEx::GetRegistryBase
- AFXWINAPPEX/CWinAppEx::GetSectionBinary
- AFXWINAPPEX/CWinAppEx::GetSectionInt
- AFXWINAPPEX/CWinAppEx::GetSectionObject
- AFXWINAPPEX/CWinAppEx::GetSectionString
- AFXWINAPPEX/CWinAppEx::GetShellManager
- AFXWINAPPEX/CWinAppEx::GetString
- AFXWINAPPEX/CWinAppEx::GetTooltipManager
- AFXWINAPPEX/CWinAppEx::GetUserToolsManager
- AFXWINAPPEX/CWinAppEx::InitContextMenuManager
- AFXWINAPPEX/CWinAppEx::InitKeyboardManager
- AFXWINAPPEX/CWinAppEx::InitMouseManager
- AFXWINAPPEX/CWinAppEx::InitShellManager
- AFXWINAPPEX/CWinAppEx::InitTooltipManager
- AFXWINAPPEX/CWinAppEx::IsResourceSmartUpdate
- AFXWINAPPEX/CWinAppEx::IsStateExists
- AFXWINAPPEX/CWinAppEx::LoadState
- AFXWINAPPEX/CWinAppEx::OnAppContextHelp
- AFXWINAPPEX/CWinAppEx::OnViewDoubleClick
- AFXWINAPPEX/CWinAppEx::OnWorkspaceIdle
- AFXWINAPPEX/CWinAppEx::SaveState
- AFXWINAPPEX/CWinAppEx::SetRegistryBase
- AFXWINAPPEX/CWinAppEx::ShowPopupMenu
- AFXWINAPPEX/CWinAppEx::WriteBinary
- AFXWINAPPEX/CWinAppEx::WriteInt
- AFXWINAPPEX/CWinAppEx::WriteObject
- AFXWINAPPEX/CWinAppEx::WriteSectionBinary
- AFXWINAPPEX/CWinAppEx::WriteSectionInt
- AFXWINAPPEX/CWinAppEx::WriteSectionObject
- AFXWINAPPEX/CWinAppEx::WriteSectionString
- AFXWINAPPEX/CWinAppEx::WriteString
- AFXWINAPPEX/CWinAppEx::LoadCustomState
- AFXWINAPPEX/CWinAppEx::LoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::OnClosingMainFrame
- AFXWINAPPEX/CWinAppEx::PreLoadState
- AFXWINAPPEX/CWinAppEx::PreSaveState
- AFXWINAPPEX/CWinAppEx::ReloadWindowPlacement
- AFXWINAPPEX/CWinAppEx::SaveCustomState
- AFXWINAPPEX/CWinAppEx::StoreWindowPlacement
- AFXWINAPPEX/CWinAppEx::m_bForceImageReset
helpviewer_keywords:
- CWinAppEx [MFC], CWinAppEx
- CWinAppEx [MFC], CleanState
- CWinAppEx [MFC], EnableLoadWindowPlacement
- CWinAppEx [MFC], EnableTearOffMenus
- CWinAppEx [MFC], EnableUserTools
- CWinAppEx [MFC], ExitInstance
- CWinAppEx [MFC], GetBinary
- CWinAppEx [MFC], GetContextMenuManager
- CWinAppEx [MFC], GetDataVersion
- CWinAppEx [MFC], GetDataVersionMajor
- CWinAppEx [MFC], GetDataVersionMinor
- CWinAppEx [MFC], GetInt
- CWinAppEx [MFC], GetKeyboardManager
- CWinAppEx [MFC], GetMouseManager
- CWinAppEx [MFC], GetObject
- CWinAppEx [MFC], GetRegSectionPath
- CWinAppEx [MFC], GetRegistryBase
- CWinAppEx [MFC], GetSectionBinary
- CWinAppEx [MFC], GetSectionInt
- CWinAppEx [MFC], GetSectionObject
- CWinAppEx [MFC], GetSectionString
- CWinAppEx [MFC], GetShellManager
- CWinAppEx [MFC], GetString
- CWinAppEx [MFC], GetTooltipManager
- CWinAppEx [MFC], GetUserToolsManager
- CWinAppEx [MFC], InitContextMenuManager
- CWinAppEx [MFC], InitKeyboardManager
- CWinAppEx [MFC], InitMouseManager
- CWinAppEx [MFC], InitShellManager
- CWinAppEx [MFC], InitTooltipManager
- CWinAppEx [MFC], IsResourceSmartUpdate
- CWinAppEx [MFC], IsStateExists
- CWinAppEx [MFC], LoadState
- CWinAppEx [MFC], OnAppContextHelp
- CWinAppEx [MFC], OnViewDoubleClick
- CWinAppEx [MFC], OnWorkspaceIdle
- CWinAppEx [MFC], SaveState
- CWinAppEx [MFC], SetRegistryBase
- CWinAppEx [MFC], ShowPopupMenu
- CWinAppEx [MFC], WriteBinary
- CWinAppEx [MFC], WriteInt
- CWinAppEx [MFC], WriteObject
- CWinAppEx [MFC], WriteSectionBinary
- CWinAppEx [MFC], WriteSectionInt
- CWinAppEx [MFC], WriteSectionObject
- CWinAppEx [MFC], WriteSectionString
- CWinAppEx [MFC], WriteString
- CWinAppEx [MFC], LoadCustomState
- CWinAppEx [MFC], LoadWindowPlacement
- CWinAppEx [MFC], OnClosingMainFrame
- CWinAppEx [MFC], PreLoadState
- CWinAppEx [MFC], PreSaveState
- CWinAppEx [MFC], ReloadWindowPlacement
- CWinAppEx [MFC], SaveCustomState
- CWinAppEx [MFC], StoreWindowPlacement
- CWinAppEx [MFC], m_bForceImageReset
ms.assetid: a3d3e053-3e22-463f-9444-c73abb1bb9d7
ms.openlocfilehash: c222567703d0e57480c00f6f2bf9e78f16979150
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/16/2020
ms.locfileid: "79420882"
---
# <a name="cwinappex-class"></a>CWinAppEx, classe

`CWinAppEx` gère l’état de l’application, enregistre l’État dans le registre, charge l’État à partir du Registre, initialise les gestionnaires d’applications et fournit des liens vers ces mêmes gestionnaires d’applications.

   Pour plus d’informations, consultez le code source situé dans le dossier **VC\\atlmfc\\src\\MFC** de votre installation Visual Studio.
## <a name="syntax"></a>Syntaxe

```
class CWinAppEx : public CWinApp
```

## <a name="members"></a>Membres

### <a name="public-constructors"></a>Constructeurs publics

|Name|Description|
|----------|-----------------|
|[CWinAppEx :: CWinAppEx](#cwinappex)|Construit un objet `CWinAppEx`.|

### <a name="public-methods"></a>M&#233;thodes publiques

|Name|Description|
|----------|-----------------|
|[CWinAppEx :: CleanState](#cleanstate)|Supprime les informations relatives à l’application du Registre Windows.|
|[CWinAppEx :: EnableLoadWindowPlacement](#enableloadwindowplacement)|Spécifie si l’application chargera la taille initiale et l’emplacement de la fenêtre frame principale à partir du Registre.|
|[CWinAppEx :: EnableTearOffMenus](#enabletearoffmenus)|Active les menus détachables pour l’application.|
|[CWinAppEx :: EnableUserTools](#enableusertools)|Permet à l’utilisateur de créer des commandes de menu personnalisées dans l’application.|
|[CWinAppEx :: ExitInstance](#exitinstance)|Appelée par l’infrastructure à partir de la fonction membre `Run` pour quitter cette instance de l’application. (Substitue [CWinApp :: ExitInstance](../../mfc/reference/cwinapp-class.md#exitinstance).)|
|[CWinAppEx :: GetBinary](#getbinary)|Lit les données binaires associées à la valeur de Registre spécifiée.|
|[CWinAppEx :: GetContextMenuManager](#getcontextmenumanager)|Retourne un pointeur vers l’objet global [CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md) .|
|[CWinAppEx :: GetDataVersion](#getdataversion)||
|[CWinAppEx :: GetDataVersionMajor](#getdataversionmajor)|Retourne la version principale de l’application enregistrée dans le Registre Windows.|
|[CWinAppEx :: GetDataVersionMinor](#getdataversionminor)|Retourne la version mineure de l’application enregistrée dans le Registre Windows.|
|[CWinAppEx :: GetInt](#getint)|Lit les données numériques associées à la valeur spécifiée dans le registre.|
|[CWinAppEx :: GetKeyboardManager](#getkeyboardmanager)|Retourne un pointeur vers l’objet global [CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md) .|
|[CWinAppEx :: GetMouseManager](#getmousemanager)|Retourne un pointeur vers l’objet global [CMouseManager](../../mfc/reference/cmousemanager-class.md) .|
|[CWinAppEx :: GetObject](#getobject)|Lit les données dérivées de `CObject`associées à la valeur spécifiée à partir du Registre.|
|[CWinAppEx :: GetRegSectionPath](#getregsectionpath)|Retourne une chaîne qui correspond au chemin d’accès d’une clé de registre. Ce chemin d’accès concatène le chemin d’accès relatif fourni avec le chemin d’accès de l’application.|
|[CWinAppEx :: GetRegistryBase](#getregistrybase)|Retourne le chemin d’accès au registre de l’application.|
|[CWinAppEx :: GetSectionBinary](#getsectionbinary)|Lit les données binaires associées à la clé et à la valeur spécifiées dans le registre.|
|[CWinAppEx :: GetSectionInt](#getsectionint)|Lit les données numériques du Registre associées à la clé et à la valeur spécifiées.|
|[CWinAppEx :: GetSectionObject](#getsectionobject)|Lit `CObject` données associées à la clé et à la valeur spécifiées dans le registre.|
|[CWinAppEx :: GetSectionString](#getsectionstring)|Lit les données de chaîne associées à la clé et à la valeur spécifiées dans le registre.|
|[CWinAppEx :: GetShellManager](#getshellmanager)|Retourne un pointeur vers l’objet global [CShellManager](../../mfc/reference/cshellmanager-class.md) .|
|[CWinAppEx :: GetString](#getstring)|Lit les données de chaîne associées à la valeur spécifiée dans le registre.|
|[CWinAppEx :: GetTooltipManager](#gettooltipmanager)|Retourne un pointeur vers l’objet global [CTooltipManager](../../mfc/reference/ctooltipmanager-class.md) .|
|[CWinAppEx :: GetUserToolsManager](#getusertoolsmanager)|Retourne un pointeur vers l’objet global [CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md) .|
|[CWinAppEx :: InitContextMenuManager](#initcontextmenumanager)|Initialise l'objet `CContextMenuManager`.|
|[CWinAppEx :: InitKeyboardManager](#initkeyboardmanager)|Initialise l'objet `CKeyboardManager`.|
|[CWinAppEx :: InitMouseManager](#initmousemanager)|Initialise l'objet `CMouseManager`.|
|[CWinAppEx :: InitShellManager](#initshellmanager)|Initialise la classe `CShellManager`|
|[CWinAppEx :: InitTooltipManager](#inittooltipmanager)|Initialise la classe `CTooltipManager`.|
|[CWinAppEx :: IsResourceSmartUpdate](#isresourcesmartupdate)||
|[CWinAppEx :: IsStateExists](#isstateexists)|Indique si la clé spécifiée se trouve dans le registre.|
|[CWinAppEx :: LoadState](#loadstate)|Charge l’état de l’application à partir du Registre.|
|[CWinAppEx :: OnAppContextHelp](#onappcontexthelp)|Appelée par l’infrastructure quand l’utilisateur demande de l’aide contextuelle pour la boîte de dialogue de **personnalisation** .|
|[CWinAppEx :: OnViewDoubleClick](#onviewdoubleclick)|Appelle la commande définie par l’utilisateur lorsque l’utilisateur double-clique n’importe où dans l’application.|
|[CWinAppEx :: OnWorkspaceIdle](#onworkspaceidle)||
|[CWinAppEx :: saveste](#savestate)|Écrit l’état de l’infrastructure de l’application dans le Registre Windows.|
|[CWinAppEx :: SetRegistryBase](#setregistrybase)|Définit le chemin d’accès de la clé de Registre par défaut. Cette clé servira de racine pour tous les appels de registre suivants.|
|[CWinAppEx :: ShowPopupMenu](#showpopupmenu)|Affiche un menu contextuel.|
|[CWinAppEx :: WriteBinary](#writebinary)|Écrit les données binaires dans la valeur de Registre spécifiée.|
|[CWinAppEx :: WriteInt](#writeint)|Écrit les données numériques dans la valeur de Registre spécifiée.|
|[CWinAppEx :: WriteObject](#writeobject)|Écrit des données dérivées de la [classe CObject](../../mfc/reference/cobject-class.md) dans la valeur de Registre spécifiée.|
|[CWinAppEx :: WriteSectionBinary](#writesectionbinary)|Écrit les données binaires dans une valeur de la clé de Registre spécifiée.|
|[CWinAppEx :: WriteSectionInt](#writesectionint)|Écrit les données numériques dans une valeur de la clé de Registre spécifiée.|
|[CWinAppEx :: WriteSectionObject](#writesectionobject)|Écrit des données dérivées de la classe `CObject` dans une valeur de la clé de Registre spécifiée.|
|[CWinAppEx :: WriteSectionString](#writesectionstring)|Écrit les données de chaîne dans une valeur de la clé de Registre spécifiée.|
|[CWinAppEx :: WriteString](#writestring)|Écrit les données de chaîne dans la valeur de Registre spécifiée.|

### <a name="protected-methods"></a>Méthodes protégées

|Name|Description|
|----------|-----------------|
|[CWinAppEx :: LoadCustomState](#loadcustomstate)|Appelé par le Framework lorsque l’état de l’application a été chargé.|
|[CWinAppEx :: LoadWindowPlacement](#loadwindowplacement)|Appelée par le Framework lorsqu’il charge la taille et l’emplacement de votre application à partir du Registre. Les données chargées incluent la taille et l’emplacement du frame principal au moment de la dernière fermeture de votre application.|
|[CWinAppEx :: OnClosingMainFrame](#onclosingmainframe)|Appelé par le Framework lorsqu’une fenêtre frame principale est en cours de traitement WM_CLOSE.|
|[CWinAppEx ::P reLoadState](#preloadstate)|Appelée par l’infrastructure juste avant le chargement de l’état de l’application.|
|[CWinAppEx ::P reSaveState](#presavestate)|Appelée par l’infrastructure juste avant l’enregistrement de l’état de l’application.|
|[CWinAppEx :: ReloadWindowPlacement](#reloadwindowplacement)|Recharge la taille et l’emplacement de la fenêtre fournie à partir du Registre.|
|[CWinAppEx :: SaveCustomState](#savecustomstate)|Appelée par l’infrastructure après avoir écrit l’état de l’application dans le registre.|
|[CWinAppEx :: StoreWindowPlacement](#storewindowplacement)|Appelé par l’infrastructure pour écrire la taille et l’emplacement du frame principal dans le registre.|

### <a name="data-members"></a>Données membres

|Name|Description|
|----------|-----------------|
|[CWinAppEx :: m_bForceImageReset](#m_bforceimagereset)|Spécifie si l’infrastructure doit réinitialiser toutes les images de la barre d’outils lorsque la fenêtre frame qui contient la barre d’outils est chargée.|

## <a name="remarks"></a>Notes

La plupart des fonctionnalités fournies par l’infrastructure MFC dépendent de la classe `CWinAppEx`. Vous pouvez incorporer la classe `CWinAppEx` dans votre application de l’une des deux manières suivantes :

- Construisez une classe `CWinAppEx` dans le thread principal.

- Dérivez la classe d’application principale de `CWinAppEx`.

Une fois que vous avez incorporé `CWinAppEx` dans votre application, vous pouvez initialiser l’un des gestionnaires d’applications. Avant d’utiliser un gestionnaire d’applications, vous devez l’initialiser en appelant la méthode Initialize appropriée. Pour obtenir un pointeur vers un gestionnaire spécifique, appelez la méthode d’obtention associée. La classe `CWinAppEx` gère les gestionnaires d’applications suivants : [classe CMouseManager](../../mfc/reference/cmousemanager-class.md), classe [CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md), classe [CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md), [classe CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md)et [classe CMenuTearOffManager](../../mfc/reference/cmenutearoffmanager-class.md).

## <a name="inheritance-hierarchy"></a>Hiérarchie d’héritage

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWinThread](../../mfc/reference/cwinthread-class.md)

[CWinApp](../../mfc/reference/cwinapp-class.md)

[CWinAppEx](../../mfc/reference/cwinappex-class.md)

## <a name="requirements"></a>Spécifications

**En-tête :** afxwinappex. h

##  <a name="cleanstate"></a>CWinAppEx :: CleanState

Supprime toutes les informations relatives à l’application du Registre Windows.

```
virtual BOOL CleanState(LPCTSTR lpszSectionName=NULL);
```

### <a name="parameters"></a>Paramètres

*lpszSectionName*<br/>
dans Chaîne qui contient un chemin d’accès à une clé de registre.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la méthode a réussi ; Sinon, 0.

### <a name="remarks"></a>Notes

Cette méthode efface les données d’application d’une section spécifique du Registre. Vous pouvez spécifier la section à effacer à l’aide du paramètre *lpszSectionName*. Si *lpszSectionName* a la valeur null, cette méthode utilise le chemin d’accès au registre par défaut stocké dans l’objet `CWinAppEx`. Pour récupérer le chemin d’accès au registre par défaut, utilisez [CWinAppEx :: GetRegistryBase](#getregistrybase).

##  <a name="cwinappex"></a>CWinAppEx :: CWinAppEx

Construit un objet `CWinAppEx`.

```
CWinAppEx(BOOL bResourceSmartUpdate = FALSE);
```

### <a name="parameters"></a>Paramètres

*bResourceSmartUpdate*<br/>
dans Paramètre booléen qui spécifie si l’objet de l’espace de travail doit détecter et gérer les mises à jour des ressources.

### <a name="remarks"></a>Notes

La classe `CWinAppEx` a des méthodes d’initialisation, fournit des fonctionnalités permettant d’enregistrer et de charger des informations sur l’application dans le registre, et contrôle les paramètres d’application globaux. Elle vous permet également d’utiliser des gestionnaires globaux, tels que la [classe CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md) et la [classe CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md). Chaque application ne peut avoir qu’une seule instance de la classe `CWinAppEx`.

##  <a name="enableloadwindowplacement"></a>CWinAppEx :: EnableLoadWindowPlacement

Spécifie si l’application chargera la taille initiale et l’emplacement de la fenêtre frame principale à partir du Registre.

```
void EnableLoadWindowPlacement(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>Paramètres

*bEnable*<br/>
dans Spécifie si l’application charge la taille initiale et l’emplacement de la fenêtre frame principale à partir du Registre.

### <a name="remarks"></a>Notes

Par défaut, la taille et l’emplacement du frame principal sont chargés à partir du Registre avec d’autres paramètres d’application. Cela se produit pendant [CWinAppEx :: LoadState](#loadstate). Si vous ne souhaitez pas charger le positionnement initial de la fenêtre à partir du Registre, appelez cette méthode avec *bEnable* défini sur false.

##  <a name="enabletearoffmenus"></a>CWinAppEx :: EnableTearOffMenus

Crée et initialise un objet [CMenuTearOffManager](../../mfc/reference/cmenutearoffmanager-class.md) .

```
BOOL EnableTearOffMenus(
    LPCTSTR lpszRegEntry,
    const UINT uiCmdFirst,
    const UINT uiCmdLast);
```

### <a name="parameters"></a>Paramètres

*lpszRegEntry*<br/>
dans Chaîne qui contient le chemin d’accès à une clé de registre. L’application utilise cette clé de Registre pour stocker des informations pour les menus détachables.

*uiCmdFirst*<br/>
dans ID de menu de la première déchirure.

*uiCmdLast*<br/>
dans ID de menu de la dernière déchirure.

### <a name="return-value"></a>Valeur de retour

TRUE si la `CMenuTearOffManager` est créée et initialisée avec succès ; FALSe si une erreur se produit ou si le `CMenuTearOffManager` existe déjà.

### <a name="remarks"></a>Notes

Utilisez cette fonction pour activer les menus détachables dans votre application. Vous devez appeler cette fonction à partir de `InitInstance`.

##  <a name="enableusertools"></a>CWinAppEx :: EnableUserTools

Permet à l’utilisateur de créer des commandes de menu personnalisées qui réduisent les séquences de touches dans votre application. Cette méthode crée un objet [CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md) .

```
BOOL EnableUserTools(
    const UINT uiCmdToolsDummy,
    const UINT uiCmdFirst,
    const UINT uiCmdLast,
    CRuntimeClass* pToolRTC = RUNTIME_CLASS(CUserTool),
    UINT uArgMenuID = 0,
    UINT uInitDirMenuID = 0);
```

### <a name="parameters"></a>Paramètres

*uiCmdToolsDummy*<br/>
dans Entier non signé que le Framework utilise comme espace réservé pour l’ID de commande du menu outils de l’utilisateur.

*uiCmdFirst*<br/>
dans ID de commande de la première commande de l’outil utilisateur.

*uiCmdLast*<br/>
dans ID de commande de la dernière commande de l’outil utilisateur.

*pToolRTC*<br/>
dans Classe que l’objet `CUserToolsManager` utilise pour créer de nouveaux outils utilisateur.

*uArgMenuID*<br/>
dans ID de menu de l’argument.

*uInitDirMenuID*<br/>
dans ID de menu du répertoire d’outils initial.

### <a name="return-value"></a>Valeur de retour

TRUE si la méthode crée et initialise un objet `CUserToolsManager` ; FALSe si la méthode échoue ou si un objet `CUserToolsManager` existe déjà.

### <a name="remarks"></a>Notes

Lorsque vous activez les outils définis par l’utilisateur, le Framework prend automatiquement en charge un menu dynamique qui peut être étendu pendant la personnalisation. L’infrastructure associe chaque nouvel élément à une commande externe. L’infrastructure appelle ces commandes lorsque l’utilisateur sélectionne l’élément approprié dans le menu **Outils** .

Chaque fois que l’utilisateur ajoute un nouvel élément, l’infrastructure crée un nouvel objet. Le type de classe pour le nouvel objet est défini par *pToolRTC*. Le type de classe *pToolRTC* doit être dérivé de la [classe CUserTool](../../mfc/reference/cusertool-class.md).

Pour plus d’informations sur les outils utilisateur et sur la façon de les incorporer dans votre application, consultez [Outils définis par l’utilisateur](../../mfc/user-defined-tools.md).

##  <a name="exitinstance"></a>CWinAppEx :: ExitInstance

```
virtual int ExitInstance();
```

### <a name="return-value"></a>Valeur de retour

### <a name="remarks"></a>Notes

##  <a name="getbinary"></a>CWinAppEx :: GetBinary

Lit les données binaires d’une clé de Registre spécifiée.

```
BOOL GetBinary(
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>Paramètres

*lpszEntry*<br/>
dans Chaîne qui contient le nom d’une clé de registre.

*ppData*<br/>
à Pointeur vers la mémoire tampon que la méthode remplit avec les données binaires.

*pBytes*<br/>
à Pointeur vers un entier non signé que la méthode utilise pour écrire le nombre d’octets lus.

### <a name="return-value"></a>Valeur de retour

TRUE en cas de réussite ; FALSe dans le cas contraire.

### <a name="remarks"></a>Notes

Cette méthode lit les données binaires écrites dans le registre. Pour écrire des données dans le registre, utilisez les méthodes [CWinAppEx :: writeBinary](#writebinary) et [CWinAppEx :: WriteSectionBinary](#writesectionbinary).

Le paramètre *lpszEntry* est le nom d’une entrée de Registre située sous la clé de Registre par défaut de votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

##  <a name="getcontextmenumanager"></a>CWinAppEx :: GetContextMenuManager

Retourne un pointeur vers l’objet global [CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md) .

```
CContextMenuManager* GetContextMenuManager();
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers l’objet de `CContextMenuManager` global.

### <a name="remarks"></a>Notes

Si l’objet CContextMenuManager n’est pas initialisé, cette fonction appelle [CWinAppEx :: InitContextMenuManager](#initcontextmenumanager) avant de retourner un pointeur.

##  <a name="getdataversion"></a>CWinAppEx :: GetDataVersion

```
int GetDataVersion() const;
```

### <a name="return-value"></a>Valeur de retour

### <a name="remarks"></a>Notes

##  <a name="getdataversionmajor"></a>CWinAppEx :: GetDataVersionMajor

Retourne la version principale de l’application enregistrée dans le Registre Windows lorsque vous appelez [CWinAppEx :: saveste](#savestate).

```
int GetDataVersionMajor() const;
```

### <a name="return-value"></a>Valeur de retour

Valeur entière qui contient le numéro de version principale.

##  <a name="getdataversionminor"></a>CWinAppEx :: GetDataVersionMinor

Retourne la version mineure de l’application enregistrée dans le Registre Windows lorsque vous appelez [CWinAppEx :: saveste](#savestate).

```
int GetDataVersionMinor() const;
```

### <a name="return-value"></a>Valeur de retour

Valeur entière qui contient le numéro de version secondaire.

##  <a name="getint"></a>CWinAppEx :: GetInt

Lit des données de type entier à partir d’une clé de Registre spécifiée.

```
int GetInt(
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>Paramètres

*lpszEntry*<br/>
dans Chaîne qui contient le nom d’une entrée de registre.

*nDefault*<br/>
dans Valeur par défaut retournée par la méthode si l’entrée de Registre spécifiée n’existe pas.

### <a name="return-value"></a>Valeur de retour

Les données du Registre si la méthode a réussi ; sinon *nDefault*.

### <a name="remarks"></a>Notes

Cette méthode lit les données de type entier à partir du Registre. Si aucune donnée entière n’est associée à la clé de Registre indiquée par *lpszEntry*, cette méthode retourne *nDefault*. Pour écrire des données dans le registre, utilisez les méthodes [CWinAppEx :: WriteSectionInt](#writesectionint) et [CWinAppEx :: writeInt](#writeint).

Le paramètre *lpszEntry* est le nom d’une entrée de Registre située sous la clé de Registre par défaut de votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

##  <a name="getkeyboardmanager"></a>CWinAppEx :: GetKeyboardManager

Retourne un pointeur vers l’objet global [CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md) .

```
CKeyboardManager* GetKeyboardManager();
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers l’objet de `CKeyboardManager` global.

### <a name="remarks"></a>Notes

Si le gestionnaire de clavier n’est pas initialisé, cette fonction appelle [CWinAppEx :: InitKeyboardManager](#initkeyboardmanager) avant de retourner un pointeur.

##  <a name="getmousemanager"></a>CWinAppEx :: GetMouseManager

Retourne un pointeur vers l’objet global [CMouseManager](../../mfc/reference/cmousemanager-class.md) .

```
CMouseManager* GetMouseManager();
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers l’objet de `CMouseManager` global.

### <a name="remarks"></a>Notes

Si le gestionnaire de souris n’est pas initialisé, cette fonction appelle [CWinAppEx :: InitMouseManager](#initmousemanager) avant de retourner un pointeur.

##  <a name="getobject"></a>CWinAppEx :: GetObject

Lit les données [CObject](../../mfc/reference/cobject-class.md)-dérivé à partir du Registre.

```
BOOL GetObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>Paramètres

*lpszEntry*<br/>
dans Chaîne qui contient le chemin d’accès relatif d’une entrée de registre.

*obj*<br/>
à Référence à un `CObject`. La méthode utilise cette référence pour stocker les données de registre.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la méthode a réussi ; Sinon, 0.

### <a name="remarks"></a>Notes

Cette méthode lit les données du Registre dérivées de `CObject`. Pour écrire des données `CObject` dans le registre, utilisez [CWinAppEx :: WriteObject](#writeobject) ou [CWinAppEx :: WriteSectionObject](#writesectionobject).

Le paramètre *lpszEntry* est le nom d’une entrée de Registre qui se trouve sous la clé de Registre par défaut de votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

##  <a name="getregistrybase"></a>CWinAppEx :: GetRegistryBase

Récupère le chemin d’accès au registre par défaut pour l’application.

```
LPCTSTR GetRegistryBase();
```

### <a name="return-value"></a>Valeur de retour

Chaîne qui contient le chemin d’accès de l’emplacement du Registre par défaut.

### <a name="remarks"></a>Notes

Toutes les méthodes de la [classe CWinAppEx](../../mfc/reference/cwinappex-class.md) qui accèdent au registre démarrent à un emplacement par défaut. Utilisez cette méthode pour récupérer un chemin d’accès à l’emplacement du Registre par défaut. Utilisez [CWinAppEx :: SetRegistryBase](#setregistrybase) pour modifier l’emplacement du Registre par défaut.

##  <a name="getregsectionpath"></a>CWinAppEx :: GetRegSectionPath

Crée et retourne le chemin d’accès absolu d’une clé de registre.

```
CString GetRegSectionPath(LPCTSTR szSectionAdd = _T(""));
```

### <a name="parameters"></a>Paramètres

*szSectionAdd*<br/>
dans Chaîne qui contient le chemin d’accès relatif d’une clé de registre.

### <a name="return-value"></a>Valeur de retour

`CString` qui contient le chemin d’accès absolu d’une clé de registre.

### <a name="remarks"></a>Notes

Cette méthode définit le chemin d’accès absolu de la clé de registre en ajoutant le chemin d’accès relatif dans *szSectionAdd* à l’emplacement de Registre par défaut de votre application. Pour récupérer la clé de Registre par défaut, utilisez la méthode [CWinAppEx :: GetRegistryBase](#getregistrybase).

##  <a name="getsectionbinary"></a>CWinAppEx :: GetSectionBinary

Lit les données binaires à partir du Registre.

```
BOOL GetSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
dans Chaîne qui contient le chemin d’accès relatif d’une clé de registre.

*lpszEntry*<br/>
dans Chaîne qui contient la valeur à lire.

*ppData*<br/>
à Pointeur vers la mémoire tampon où la méthode stocke les données.

*pBytes*<br/>
à Pointeur vers un entier non signé. La méthode écrit la taille de *ppData* dans ce paramètre.

### <a name="return-value"></a>Valeur de retour

TRUE en cas de réussite, sinon FALSE.

### <a name="remarks"></a>Notes

Cette méthode lit les données binaires écrites dans le registre à l’aide des méthodes [CWinAppEx :: writeBinary](#writebinary) et [CWinAppEx :: WriteSectionBinary](#writesectionbinary).

Le paramètre *lpszSubSection* n’est pas un chemin d’accès absolu pour une entrée de registre. Il s’agit d’un chemin d’accès relatif qui est ajouté à la fin de la clé de Registre par défaut pour votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

##  <a name="getsectionint"></a>CWinAppEx :: GetSectionInt

Lit des données de type entier à partir du Registre.

```
int GetSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
dans Chaîne qui contient le chemin d’accès relatif d’une clé de registre.

*lpszEntry*<br/>
dans Chaîne qui contient la valeur à lire.

*nDefault*<br/>
dans Valeur par défaut à retourner si la valeur spécifiée n’existe pas.

### <a name="return-value"></a>Valeur de retour

Données entières stockées dans la valeur de Registre spécifiée ; *nDefault* si les données n’existent pas.

### <a name="remarks"></a>Notes

Utilisez les méthodes [CWinAppEx :: writeInt](#writeint) et [CWinAppEx :: WriteSectionInt](#writesectionint) pour écrire des données de type entier dans le registre.

Le paramètre *lpszSubSection* n’est pas un chemin d’accès absolu d’une entrée de registre. Il s’agit d’un chemin d’accès relatif qui est ajouté à la fin de la clé de Registre par défaut pour votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

##  <a name="getsectionobject"></a>CWinAppEx :: GetSectionObject

Lit les données de Registre [CObject](../../mfc/reference/cobject-class.md) à partir du Registre.

```
BOOL GetSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
dans Chaîne qui contient le chemin d’accès relatif d’une clé de registre.

*lpszEntry*<br/>
dans Chaîne qui contient la valeur à lire.

*obj*<br/>
à Référence à un `CObject`. La méthode utilise cette `CObject` pour stocker les données du Registre.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro cas de réussite ; sinon, 0.

### <a name="remarks"></a>Notes

Cette méthode lit les données à partir du Registre. Les données lues sont `CObject` données ou des données pour une classe dérivée de `CObject`. Pour écrire des données `CObject` dans le registre, utilisez [CWinAppEx :: WriteObject](#writeobject) ou [CWinAppEx :: WriteSectionObject](#writesectionobject).

Le paramètre *lpszSubSection* n’est pas un chemin d’accès absolu pour une entrée de registre. Il s’agit d’un chemin d’accès relatif qui est ajouté à la fin de la clé de Registre par défaut pour votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

##  <a name="getsectionstring"></a>CWinAppEx :: GetSectionString

Lit les données de chaîne à partir du Registre.

```
CString GetSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault = _T(""));
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
dans Chaîne qui contient le chemin d’accès relatif d’une clé de registre.

*lpszEntry*<br/>
dans Chaîne qui contient la valeur à lire.

*lpszDefault*<br/>
dans Valeur par défaut à retourner si la valeur spécifiée n’existe pas.

### <a name="return-value"></a>Valeur de retour

Données de chaîne stockées dans la valeur de Registre spécifiée si les données existent ; sinon *lpszDefault*.

### <a name="remarks"></a>Notes

Cette méthode lit les données de chaîne écrites dans le registre. Utilisez [CWinAppEx :: WriteString](#writestring) et [CWinAppEx :: WriteSectionString](#writesectionstring) pour écrire des données de chaîne dans le registre.

Le paramètre *lpszSubSection* n’est pas un chemin d’accès absolu pour une entrée de registre. Il s’agit d’un chemin d’accès relatif qui est ajouté à la fin de la clé de Registre par défaut pour votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

##  <a name="getshellmanager"></a>CWinAppEx :: GetShellManager

Retourne un pointeur vers l’objet global [CShellManager](../../mfc/reference/cshellmanager-class.md) .

```
CShellManager* GetShellManager();
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers l’objet de `CShellManager` global.

### <a name="remarks"></a>Notes

Si l’objet `CShellManager` n’est pas initialisé, cette fonction appelle [CWinAppEx :: InitShellManager](#initshellmanager) avant de retourner un pointeur.

##  <a name="getstring"></a>CWinAppEx :: GetString

Lit les données de type chaîne à partir d’une clé de Registre spécifiée.

```
CString GetString(
    LPCTSTR lpszEntry,
    LPCTSTR lpzDefault= _T(""));
```

### <a name="parameters"></a>Paramètres

*lpszEntry*<br/>
dans Chaîne qui contient le nom d’une clé de registre.

*lpzDefault*<br/>
dans Valeur par défaut retournée par la méthode si l’entrée de Registre spécifiée n’existe pas.

### <a name="return-value"></a>Valeur de retour

Données de chaîne stockées dans le registre en cas de réussite ; *lpszDefault* dans le cas contraire.

### <a name="remarks"></a>Notes

Cette méthode lit les données de chaîne écrites dans le registre. Pour écrire des données dans le registre, utilisez les méthodes [CWinAppEx :: WriteString](#writestring) ou [CWinAppEx :: WriteSectionString](#writesectionstring).

Le paramètre *lpszEntry* est le nom d’une entrée de Registre située sous la clé de Registre par défaut de votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

##  <a name="gettooltipmanager"></a>CWinAppEx :: GetTooltipManager

Retourne un pointeur vers l’objet global [CTooltipManager](../../mfc/reference/ctooltipmanager-class.md) .

```
CTooltipManager* GetTooltipManager();
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers l’objet de `CTooltipManager` global.

### <a name="remarks"></a>Notes

Si l’objet `CTooltipManager` n’est pas initialisé, cette fonction appelle [CWinAppEx :: InitTooltipManager](#inittooltipmanager) avant de retourner un pointeur.

##  <a name="getusertoolsmanager"></a>CWinAppEx :: GetUserToolsManager

Retourne un pointeur vers l’objet global [CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md) .

```
CUserToolsManager* GetUserToolsManager();
```

### <a name="return-value"></a>Valeur de retour

Pointeur vers l’objet `CUserToolsManager` global ; NULL si la gestion des outils utilisateur n’est pas activée pour l’application.

### <a name="remarks"></a>Notes

Avant de récupérer un pointeur vers l’objet `CUserToolsManager`, vous devez initialiser le gestionnaire en appelant [CWinAppEx :: EnableUserTools](#enableusertools).

##  <a name="initcontextmenumanager"></a>CWinAppEx :: InitContextMenuManager

Initialise l’objet [CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md) .

```
BOOL InitContextMenuManager();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la méthode crée l’objet CContextMenuManager ; 0 si l’objet `CContextMenuManager` existe déjà.

### <a name="remarks"></a>Notes

Si vous appelez [CWinAppEx :: GetContextMenuManager](#getcontextmenumanager), l’implémentation par défaut de cette méthode appelle `InitContextMenuManager`.

Si votre application possède déjà un gestionnaire de menu contextuel et que vous appelez `InitContextMenuManager`, votre application aura un échec d' [assertion](diagnostic-services.md#assert) . Par conséquent, vous ne devez pas appeler `InitContextMenuManager` si vous créez un objet `CContextMenuManager` directement. Si vous n’utilisez pas une `CContextMenuManager`personnalisée, vous devez utiliser `GetContextMenuManager` pour créer un objet `CContextMenuManager`.

##  <a name="initkeyboardmanager"></a>CWinAppEx :: InitKeyboardManager

Initialise l’objet [CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md) .

```
BOOL InitKeyboardManager();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la méthode crée l’objet `CKeyboardManager` ; 0 si l’objet `CKeyboardManager` existe déjà.

### <a name="remarks"></a>Notes

Si vous appelez [CWinAppEx :: GetKeyboardManager](#getkeyboardmanager), l’implémentation par défaut de cette méthode appelle `InitKeyboardManager`.

Si votre application possède déjà un gestionnaire de clavier et que vous appelez `InitKeyboardManager`, votre application aura un échec d' [assertion](diagnostic-services.md#assert) . Par conséquent, vous ne devez pas appeler `InitKeyboardManager` si vous créez un objet `CKeyboardManager` directement. Si vous n’utilisez pas une `CKeyboardManager`personnalisée, vous devez utiliser `GetKeyboardManager` pour créer un objet `CKeyboardManager`.

##  <a name="initmousemanager"></a>CWinAppEx :: InitMouseManager

Initialise l’objet [CMouseManager](../../mfc/reference/cmousemanager-class.md) .

```
BOOL InitMouseManager();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la méthode crée l’objet `CMouseManager` ; 0 si l’objet `CMouseManager` existe déjà.

### <a name="remarks"></a>Notes

Si vous appelez [CWinAppEx :: GetMouseManager](#getmousemanager), l’implémentation par défaut de cette méthode appelle `InitMouseManager`.

Si votre application possède déjà un gestionnaire de souris et que vous appelez `InitMouseManager`, votre application aura un échec d' [assertion](diagnostic-services.md#assert) . Par conséquent, vous ne devez pas appeler `InitMouseManager` si vous créez un objet `CMouseManager` directement. Si vous n’utilisez pas une `CMouseManager`personnalisée, vous devez utiliser `GetMouseManager` pour créer un objet `CMouseManager`.

##  <a name="initshellmanager"></a>CWinAppEx :: InitShellManager

Initialise l’objet [CShellManager](../../mfc/reference/cshellmanager-class.md) .

```
BOOL InitShellManager();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la méthode crée l’objet `CShellManager` ; 0 si l’objet `CShellManager` existe déjà.

### <a name="remarks"></a>Notes

Si vous appelez [CWinAppEx :: GetShellManager](#getshellmanager), l’implémentation par défaut de cette méthode appelle `InitShellManager`.

Si votre application possède déjà un gestionnaire de Shell et que vous appelez `InitShellManager`, votre application déclenche un échec d' [assertion](diagnostic-services.md#assert) . Par conséquent, n’appelez pas `InitShellManager` si vous créez un objet `CShellManager` directement. Si vous n’utilisez pas un `CShellManager`personnalisé, utilisez `GetShellManager` pour créer un objet `CShellManager`.

##  <a name="inittooltipmanager"></a>CWinAppEx :: InitTooltipManager

Initialise l’objet [CTooltipManager](../../mfc/reference/ctooltipmanager-class.md) .

```
BOOL InitTooltipManager();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la méthode crée l’objet `CTooltipManager` ; 0 si l’objet `CTooltipManager` existe déjà.

### <a name="remarks"></a>Notes

Si vous appelez [CWinAppEx :: GetTooltipManager](#gettooltipmanager), l’implémentation par défaut de cette méthode appelle `InitTooltipManager`.

Si votre application possède déjà un gestionnaire d’info-bulles et que vous appelez `InitTooltipManager`, votre application aura un échec d' [assertion](diagnostic-services.md#assert) . Par conséquent, vous ne devez pas appeler `InitTooltipManager` si vous créez un objet `CTooltipManager` directement. Si vous n’utilisez pas une `CTooltipManager`personnalisée, vous devez utiliser `GetTooltipManager` pour créer un objet `CTooltipManager`.

##  <a name="isresourcesmartupdate"></a>CWinAppEx :: IsResourceSmartUpdate

```
BOOL IsResourceSmartUpdate() const;
```

### <a name="return-value"></a>Valeur de retour

### <a name="remarks"></a>Notes

##  <a name="isstateexists"></a>CWinAppEx :: IsStateExists

Indique si la clé spécifiée se trouve dans le registre.

```
BOOL IsStateExists(LPCTSTR lpszSectionName);
```

### <a name="parameters"></a>Paramètres

*lpszSectionName*<br/>
dans Chaîne qui contient un chemin d’accès à une clé de registre.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la clé est dans le registre ; Sinon, 0.

##  <a name="loadcustomstate"></a>CWinAppEx :: LoadCustomState

L’infrastructure appelle cette méthode après avoir chargé l’état de l’application à partir du Registre.

```
virtual void LoadCustomState();
```

### <a name="remarks"></a>Notes

Substituez cette méthode si vous souhaitez effectuer un traitement après que l’application a chargé l’État à partir du Registre. Par défaut, cette méthode ne fait rien.

Pour pouvoir charger des informations d’état personnalisées à partir du Registre, vous devez d’abord enregistrer les informations à l’aide de [CWinAppEx :: SaveCustomState](#savecustomstate).

##  <a name="loadstate"></a>CWinAppEx :: LoadState

Lit l’état de l’application à partir du Registre Windows.

```
BOOL LoadState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

virtual BOOL LoadState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);
```

### <a name="parameters"></a>Paramètres

*pFrame*<br/>
dans Pointeur vers un objet de fenêtre frame. La méthode applique les informations d’État dans le registre à cette fenêtre frame.

*lpszSectionName*<br/>
dans Chaîne qui contient le chemin d’accès relatif d’une clé de registre.

*pFrameImpl*<br/>
dans Pointeur vers un objet `CFrameImpl`. La méthode applique les informations d’État dans le registre à cette fenêtre frame.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro en cas de réussite ; Sinon, 0.

### <a name="remarks"></a>Notes

Cette méthode charge l’état de l’application et toutes les informations d’état d’une fenêtre frame. Les informations chargées pour la fenêtre frame sont appliquées à la fenêtre frame fournie. Si vous ne fournissez pas de fenêtre frame, seules les informations d’état de l’application sont chargées. Les informations de l’application incluent l’état de la [classe CMouseManager](../../mfc/reference/cmousemanager-class.md), de la classe [CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md), de la classe [CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md)et de la [classe CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md).

L’implémentation par défaut de `CFrameImpl::OnLoadFrame` appelle `LoadState`.

Le paramètre *lpszSectionName* n’est pas le chemin d’accès absolu d’une entrée de registre. Il s’agit d’un chemin d’accès relatif qui est ajouté à la fin de la clé de Registre par défaut pour votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

##  <a name="loadwindowplacement"></a>CWinAppEx :: LoadWindowPlacement

Appelée par le Framework lorsqu’il charge la taille et l’emplacement de la fenêtre frame principale à partir du Registre.

```
virtual BOOL LoadWindowPlacement(
    CRect& rectNormalPosition,
    int& nFlags,
    int& nShowCmd);
```

### <a name="parameters"></a>Paramètres

*rectNormalPosition*<br/>
à Rectangle qui contient les coordonnées de la fenêtre frame principale lorsqu’elle est dans la position restaurée.

*nFlags*<br/>
à Indicateurs qui contrôlent la position de la fenêtre réduite et la manière dont le système d’exploitation bascule entre une fenêtre réduite et une fenêtre restaurée.

*nShowCmd*<br/>
à Entier qui spécifie l’état d’affichage de la fenêtre. Pour plus d’informations sur les valeurs possibles, consultez [CWnd :: ShowWindow](../../mfc/reference/cwnd-class.md#showwindow).

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro en cas de réussite ; Sinon, 0.

### <a name="remarks"></a>Notes

Par défaut, MFC charge automatiquement la position et l’État précédents de la fenêtre frame principale au démarrage de l’application. Pour plus d’informations sur la façon dont ces informations sont stockées dans le registre, consultez [CWinAppEx :: StoreWindowPlacement](#storewindowplacement).

Substituez cette méthode si vous souhaitez charger des informations supplémentaires sur la fenêtre frame principale.

##  <a name="m_bforceimagereset"></a>CWinAppEx :: m_bForceImageReset

Spécifie si le Framework réinitialise toutes les images de barre d’outils lors du rechargement de la fenêtre frame qui contient la barre d’outils.

```
BOOL m_bForceImageReset;
```

### <a name="remarks"></a>Notes

Le membre de données `m_bForceImageReset` est une variable protégée.

##  <a name="onappcontexthelp"></a>CWinAppEx :: OnAppContextHelp

L’infrastructure appelle cette méthode lorsque l’utilisateur demande de l’aide contextuelle pour la boîte de dialogue de **personnalisation** .

```
virtual void OnAppContextHelp(
    CWnd* pWndControl,
    const DWORD dwHelpIDArray[]);
```

### <a name="parameters"></a>Paramètres

*pWndControl*<br/>
dans Pointeur vers un objet de fenêtre pour lequel l’utilisateur a appelé l’aide contextuelle.

*dwHelpIDArray[]*<br/>
dans Valeur réservée.

### <a name="remarks"></a>Notes

Cette méthode est actuellement réservée pour une utilisation ultérieure. L’implémentation par défaut ne fait rien et n’est actuellement pas appelée par le Framework.

##  <a name="onclosingmainframe"></a>CWinAppEx :: OnClosingMainFrame

L’infrastructure appelle cette méthode lorsqu’une fenêtre frame est en cours de traitement WM_CLOSE.

```
virtual void OnClosingMainFrame(CFrameImpl* pFrameImpl);
```

### <a name="parameters"></a>Paramètres

*pFrameImpl*<br/>
dans Pointeur vers un objet `CFrameImpl`.

### <a name="remarks"></a>Notes

L’implémentation par défaut de cette méthode enregistre l’état de *pFrameImpl*.

##  <a name="onviewdoubleclick"></a>CWinAppEx :: OnViewDoubleClick

Appelle la commande définie par l’utilisateur qui est associée à une vue lorsque l’utilisateur double-clique n’importe où dans cette vue.

```
virtual BOOL OnViewDoubleClick(
    CWnd* pWnd,
    int iViewId);
```

### <a name="parameters"></a>Paramètres

*pWnd*<br/>
dans Pointeur vers un objet dérivé de la [classe CView](../../mfc/reference/cview-class.md).

*iViewId*<br/>
dans ID de la vue.

### <a name="return-value"></a>Valeur de retour

TRUE si le Framework trouve une commande ; Sinon, FALSe.

### <a name="remarks"></a>Notes

Pour prendre en charge le comportement de souris personnalisé, vous devez appeler cette fonction lorsque vous traitez le message de WM_LBUTTONDBLCLK. Cette méthode exécutera la commande associée à l’ID de vue fourni par *iViewId*. Pour plus d’informations sur le comportement personnalisé de la souris, consultez [Personnalisation du clavier et de la souris](../../mfc/keyboard-and-mouse-customization.md).

##  <a name="onworkspaceidle"></a>CWinAppEx :: OnWorkspaceIdle

```
virtual BOOL OnWorkspaceIdle(CWnd*);
```

### <a name="parameters"></a>Paramètres

dans *CWnd&#38;*<br/>

### <a name="return-value"></a>Valeur de retour

### <a name="remarks"></a>Notes

##  <a name="preloadstate"></a>CWinAppEx ::P reLoadState

L’infrastructure appelle cette méthode immédiatement avant de charger l’état de l’application à partir du Registre.

```
virtual void PreLoadState();
```

### <a name="remarks"></a>Notes

Substituez cette méthode si vous souhaitez effectuer un traitement immédiatement avant que le Framework ne charge l’état de l’application.

##  <a name="presavestate"></a>CWinAppEx ::P reSaveState

L’infrastructure appelle cette méthode immédiatement avant d’enregistrer l’état de l’application.

```
virtual void PreSaveState();
```

### <a name="remarks"></a>Notes

Substituez cette méthode si vous souhaitez effectuer un traitement immédiatement avant que le Framework n’enregistre l’état de l’application.

##  <a name="reloadwindowplacement"></a>CWinAppEx :: ReloadWindowPlacement

Recharge la taille et l’emplacement d’une fenêtre à partir du Registre.

```
virtual BOOL ReloadWindowPlacement(CFrameWnd* pFrame);
```

### <a name="parameters"></a>Paramètres

*pFrame*<br/>
dans Pointeur vers une fenêtre frame.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la méthode a réussi ; 0 si le chargement a échoué ou s’il n’y a pas de données à charger.

### <a name="remarks"></a>Notes

Utilisez la fonction [CWinAppEx :: StoreWindowPlacement](#storewindowplacement) pour écrire la taille et l’emplacement d’une fenêtre dans le registre.

##  <a name="savecustomstate"></a>CWinAppEx :: SaveCustomState

L’infrastructure appelle cette méthode après avoir enregistré l’état de l’application dans le registre.

```
virtual void SaveCustomState();
```

### <a name="remarks"></a>Notes

Substituez cette méthode si vous souhaitez effectuer un traitement après que l’application a enregistré l’État dans le registre. Par défaut, cette méthode ne fait rien.

##  <a name="savestate"></a>CWinAppEx :: saveste

Écrit l’état de l’application dans le Registre Windows.

```
virtual BOOL SaveState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);

BOOL SaveState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>Paramètres

*lpszSectionName*<br/>
dans Chaîne qui contient le chemin d’accès relatif d’une clé de registre.

*pFrameImpl*<br/>
dans Pointeur vers un objet `CFrameImpl`. Ce frame est enregistré dans le Registre Windows.

*pFrame*<br/>
dans Pointeur vers un objet de fenêtre frame. Ce frame est enregistré dans le Registre Windows.

### <a name="return-value"></a>Valeur de retour

TRUE en cas de réussite ; FALSe dans le cas contraire.

### <a name="remarks"></a>Notes

Cette méthode enregistre l’état de l’application et toutes les informations d’État pour la fenêtre frame fournie. Si vous ne fournissez pas de fenêtre frame, la méthode enregistre uniquement l’état de l’application. Les informations de l’application incluent l’état de la [classe CMouseManager](../../mfc/reference/cmousemanager-class.md), de la classe [CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md), de la classe [CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md)et de la [classe CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md).

Le paramètre *lpszSectionName* n’est pas le chemin d’accès absolu d’une entrée de registre. Il s’agit d’un chemin d’accès relatif qui est ajouté à la fin de la clé de Registre par défaut pour votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

##  <a name="setregistrybase"></a>CWinAppEx :: SetRegistryBase

Définit le chemin d’accès au registre par défaut pour l’application.

```
LPCTSTR SetRegistryBase(LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>Paramètres

*lpszSectionName*<br/>
dans Chaîne qui contient le chemin d’accès à une clé de registre.

### <a name="return-value"></a>Valeur de retour

Chaîne qui contient le chemin d’accès de l’emplacement du Registre par défaut.

### <a name="remarks"></a>Notes

Toutes les méthodes de la [classe CWinAppEx](../../mfc/reference/cwinappex-class.md) qui accèdent au registre démarrent à un emplacement par défaut. Utilisez cette méthode pour modifier cet emplacement du Registre par défaut. Utilisez [CWinAppEx :: GetRegistryBase](#getregistrybase) pour récupérer l’emplacement du Registre par défaut.

##  <a name="showpopupmenu"></a>CWinAppEx :: ShowPopupMenu

Affiche un menu contextuel.

```
virtual BOOL ShowPopupMenu(
    UINT uiMenuResId,
    const CPoint& point,
    CWnd* pWnd);
```

### <a name="parameters"></a>Paramètres

*uiMenuResId*<br/>
dans ID de ressource de menu.

*point*<br/>
dans [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) qui spécifie la position du menu en coordonnées d’écran.

*pWnd*<br/>
dans Pointeur vers la fenêtre qui possède le menu contextuel.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le menu contextuel s’affiche avec succès ; Sinon, 0.

### <a name="remarks"></a>Notes

Cette méthode affiche le menu associé à *uiMenuResId*.

Pour prendre en charge les menus contextuels, vous devez disposer d’un objet [CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md) . Si vous n’avez pas initialisé l’objet `CContextMenuManager`, `ShowPopupMenu` échoue.

##  <a name="storewindowplacement"></a>CWinAppEx :: StoreWindowPlacement

Appelé par l’infrastructure pour écrire la taille et l’emplacement de la fenêtre frame principale dans le registre.

```
virtual BOOL StoreWindowPlacement(
    const CRect& rectNormalPosition,
    int nFlags,
    int nShowCmd);
```

### <a name="parameters"></a>Paramètres

*nFlags*<br/>
dans Indicateurs qui contrôlent la position de la fenêtre réduite et la manière dont le système d’exploitation bascule entre une fenêtre réduite et une fenêtre restaurée.

*nShowCmd*<br/>
dans Entier qui spécifie l’état d’affichage de la fenêtre. Pour plus d’informations sur les valeurs possibles, consultez [CWnd :: ShowWindow](../../mfc/reference/cwnd-class.md#showwindow).

*rectNormalPosition*<br/>
dans Rectangle qui contient les coordonnées de la fenêtre frame principale lorsqu’elle est dans l’état restauré.

### <a name="return-value"></a>Valeur de retour

Valeur différente de zéro en cas de réussite ; Sinon, 0.

### <a name="remarks"></a>Notes

Par défaut, MFC enregistre automatiquement la position et l’état de la fenêtre frame principale avant la fermeture de l’application. Ces informations sont stockées dans le Registre Windows sous la clé WindowPlacement dans l’emplacement du Registre par défaut de votre application. Pour plus d’informations sur l’emplacement par défaut de votre application dans le registre, consultez [CWinAppEx :: GetRegistryBase](#getregistrybase).

Substituez cette méthode si vous souhaitez stocker des informations supplémentaires sur la fenêtre frame principale.

##  <a name="writebinary"></a>CWinAppEx :: WriteBinary

Écrit des données binaires dans le registre.

```
BOOL WriteBinary(
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>Paramètres

*lpszEntry*<br/>
dans Chaîne qui contient le nom d’une clé de registre.

*pData*<br/>
dans Données à stocker.

*nBytes*<br/>
dans Taille de *pData* en octets.

### <a name="return-value"></a>Valeur de retour

TRUE si cette méthode réussit ; Sinon, FALSe.

### <a name="remarks"></a>Notes

Le paramètre *lpszEntry* est le nom d’une entrée de Registre qui se trouve sous la clé de Registre par défaut de votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

Si la clé spécifiée par *lpszEntry* n’existe pas, cette méthode la crée.

##  <a name="writeint"></a>CWinAppEx :: WriteInt

Écrit des données numériques dans le registre.

```
BOOL WriteInt(
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>Paramètres

*lpszEntry*<br/>
dans Chaîne qui contient le nom d’une clé de registre.

*nValeur*<br/>
dans Données à stocker.

### <a name="return-value"></a>Valeur de retour

TRUE si cette méthode réussit ; Sinon, FALSe.

### <a name="remarks"></a>Notes

Le paramètre *lpszEntry* est le nom d’une entrée de Registre située sous la clé de Registre par défaut de votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

Si la clé spécifiée par *lpszEntry* n’existe pas, cette méthode la crée.

##  <a name="writeobject"></a>CWinAppEx :: WriteObject

Écrit des données dérivées de la [classe CObject](../../mfc/reference/cobject-class.md) dans le registre.

```
BOOL WriteObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>Paramètres

*lpszEntry*<br/>
dans Chaîne qui contient la valeur à définir.

*obj*<br/>
dans Référence à `CObject` données que la méthode stockera.

### <a name="return-value"></a>Valeur de retour

TRUE si cette méthode réussit ; Sinon, FALSe.

### <a name="remarks"></a>Notes

Cette méthode écrit les données *obj* dans la valeur spécifiée sous la clé de Registre par défaut. Utilisez [CWinAppEx :: GetRegistryBase](#getregistrybase) pour déterminer la clé de Registre actuelle.

##  <a name="writesectionbinary"></a>CWinAppEx :: WriteSectionBinary

Écrit des données binaires dans une valeur du Registre.

```
BOOL WriteSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
dans Chaîne qui contient le nom d’une clé de registre.

*lpszEntry*<br/>
dans Chaîne qui contient la valeur à définir.

*pData*<br/>
dans Données à écrire dans le registre.

*nBytes*<br/>
dans Taille de *pData* en octets.

### <a name="return-value"></a>Valeur de retour

TRUE si cette méthode réussit ; Sinon, FALSe.

### <a name="remarks"></a>Notes

Le paramètre *lpszSubSection* n’est pas le chemin d’accès absolu d’une entrée de registre. Il s’agit d’un chemin d’accès relatif qui est ajouté à la fin de la clé de Registre par défaut pour votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

Si la clé spécifiée par *lpszEntry* n’existe pas, cette méthode la crée.

##  <a name="writesectionint"></a>CWinAppEx :: WriteSectionInt

Écrit des données numériques dans le registre.

```
BOOL WriteSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
dans Chaîne qui contient le chemin d’accès relatif d’une clé de registre.

*lpszEntry*<br/>
dans Chaîne qui contient la valeur à définir.

*nValeur*<br/>
dans Données à écrire dans le registre.

### <a name="return-value"></a>Valeur de retour

TRUE si cette méthode réussit ; Sinon, FALSe.

### <a name="remarks"></a>Notes

Le paramètre *lpszSubSection* n’est pas un chemin d’accès absolu pour une entrée de registre. Il s’agit d’un chemin d’accès relatif qui est ajouté à la clé de Registre par défaut de votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

Si la clé spécifiée par *lpszEntry* n’existe pas, cette méthode la crée.

##  <a name="writesectionobject"></a>CWinAppEx :: WriteSectionObject

Écrit des données dérivées de la [classe CObject](../../mfc/reference/cobject-class.md) dans une valeur de Registre spécifique.

```
BOOL WriteSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
dans Chaîne qui contient le nom d’une clé de registre.

*lpszEntry*<br/>
dans Chaîne qui contient le nom de la valeur à définir.

*obj*<br/>
dans Données à stocker.

### <a name="return-value"></a>Valeur de retour

TRUE si cette méthode réussit ; Sinon, FALSe.

### <a name="remarks"></a>Notes

Le paramètre *lpszSubSection* n’est pas un chemin d’accès absolu pour une entrée de registre. Il s’agit d’un chemin d’accès relatif qui est ajouté à la fin de la clé de Registre par défaut pour votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase).

Si la valeur spécifiée par *lpszEntry* n’existe pas sous la clé de Registre spécifiée par *lpszSubSection*, cette méthode crée cette valeur.

##  <a name="writesectionstring"></a>CWinAppEx :: WriteSectionString

Écrit des données de chaîne dans une valeur du Registre.

```
BOOL WriteSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>Paramètres

*lpszSubSection*<br/>
dans Chaîne qui contient le nom d’une clé de registre.

*lpszEntry*<br/>
dans Chaîne qui contient la valeur à définir.

*lpszValue*<br/>
dans Données de chaîne à écrire dans le registre.

### <a name="return-value"></a>Valeur de retour

TRUE si cette méthode réussit ; Sinon, FALSe.

### <a name="remarks"></a>Notes

Le paramètre *lpszSubSection* n’est pas un chemin d’accès absolu pour une entrée de registre. Il s’agit d’un chemin d’accès relatif qui est ajouté à la fin de la clé de Registre par défaut pour votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase).

Si la valeur spécifiée par *lpszEntry* n’existe pas sous *lpszSubSection*, cette méthode la crée.

##  <a name="writestring"></a>CWinAppEx :: WriteString

Écrit des données de chaîne dans le registre.

```
BOOL WriteString(
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>Paramètres

*lpszEntry*<br/>
dans Chaîne qui contient le nom d’une clé de registre.

*lpszValue*<br/>
dans Données à stocker.

### <a name="return-value"></a>Valeur de retour

TRUE si cette méthode réussit ; Sinon, FALSe.

### <a name="remarks"></a>Notes

Le paramètre *lpszEntry* est le nom d’une entrée de Registre située sous la clé de Registre par défaut de votre application. Pour récupérer ou définir la clé de Registre par défaut, utilisez respectivement les méthodes [CWinAppEx :: GetRegistryBase](#getregistrybase) et [CWinAppEx :: SetRegistryBase](#setregistrybase) .

Si la clé spécifiée par *lspzEntry* n’existe pas, cette méthode la crée.

## <a name="see-also"></a>Voir aussi

[Graphique hiérarchique](../../mfc/hierarchy-chart.md)<br/>
[Classes](../../mfc/reference/mfc-classes.md)<br/>
[CWinApp, classe](../../mfc/reference/cwinapp-class.md)<br/>
[CMouseManager, classe](../../mfc/reference/cmousemanager-class.md)<br/>
[CContextMenuManager, classe](../../mfc/reference/ccontextmenumanager-class.md)<br/>
[CKeyboardManager, classe](../../mfc/reference/ckeyboardmanager-class.md)<br/>
[CUserToolsManager, classe](../../mfc/reference/cusertoolsmanager-class.md)
