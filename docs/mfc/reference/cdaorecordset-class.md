---
description: 'En savoir plus sur : classe CDaoRecordset'
title: CDaoRecordset (classe)
ms.date: 08/27/2018
f1_keywords:
- CDaoRecordset
- AFXDAO/CDaoRecordset
- AFXDAO/CDaoRecordset::CDaoRecordset
- AFXDAO/CDaoRecordset::AddNew
- AFXDAO/CDaoRecordset::CanAppend
- AFXDAO/CDaoRecordset::CanBookmark
- AFXDAO/CDaoRecordset::CancelUpdate
- AFXDAO/CDaoRecordset::CanRestart
- AFXDAO/CDaoRecordset::CanScroll
- AFXDAO/CDaoRecordset::CanTransact
- AFXDAO/CDaoRecordset::CanUpdate
- AFXDAO/CDaoRecordset::Close
- AFXDAO/CDaoRecordset::Delete
- AFXDAO/CDaoRecordset::DoFieldExchange
- AFXDAO/CDaoRecordset::Edit
- AFXDAO/CDaoRecordset::FillCache
- AFXDAO/CDaoRecordset::Find
- AFXDAO/CDaoRecordset::FindFirst
- AFXDAO/CDaoRecordset::FindLast
- AFXDAO/CDaoRecordset::FindNext
- AFXDAO/CDaoRecordset::FindPrev
- AFXDAO/CDaoRecordset::GetAbsolutePosition
- AFXDAO/CDaoRecordset::GetBookmark
- AFXDAO/CDaoRecordset::GetCacheSize
- AFXDAO/CDaoRecordset::GetCacheStart
- AFXDAO/CDaoRecordset::GetCurrentIndex
- AFXDAO/CDaoRecordset::GetDateCreated
- AFXDAO/CDaoRecordset::GetDateLastUpdated
- AFXDAO/CDaoRecordset::GetDefaultDBName
- AFXDAO/CDaoRecordset::GetDefaultSQL
- AFXDAO/CDaoRecordset::GetEditMode
- AFXDAO/CDaoRecordset::GetFieldCount
- AFXDAO/CDaoRecordset::GetFieldInfo
- AFXDAO/CDaoRecordset::GetFieldValue
- AFXDAO/CDaoRecordset::GetIndexCount
- AFXDAO/CDaoRecordset::GetIndexInfo
- AFXDAO/CDaoRecordset::GetLastModifiedBookmark
- AFXDAO/CDaoRecordset::GetLockingMode
- AFXDAO/CDaoRecordset::GetName
- AFXDAO/CDaoRecordset::GetParamValue
- AFXDAO/CDaoRecordset::GetPercentPosition
- AFXDAO/CDaoRecordset::GetRecordCount
- AFXDAO/CDaoRecordset::GetSQL
- AFXDAO/CDaoRecordset::GetType
- AFXDAO/CDaoRecordset::GetValidationRule
- AFXDAO/CDaoRecordset::GetValidationText
- AFXDAO/CDaoRecordset::IsBOF
- AFXDAO/CDaoRecordset::IsDeleted
- AFXDAO/CDaoRecordset::IsEOF
- AFXDAO/CDaoRecordset::IsFieldDirty
- AFXDAO/CDaoRecordset::IsFieldNull
- AFXDAO/CDaoRecordset::IsFieldNullable
- AFXDAO/CDaoRecordset::IsOpen
- AFXDAO/CDaoRecordset::Move
- AFXDAO/CDaoRecordset::MoveFirst
- AFXDAO/CDaoRecordset::MoveLast
- AFXDAO/CDaoRecordset::MoveNext
- AFXDAO/CDaoRecordset::MovePrev
- AFXDAO/CDaoRecordset::Open
- AFXDAO/CDaoRecordset::Requery
- AFXDAO/CDaoRecordset::Seek
- AFXDAO/CDaoRecordset::SetAbsolutePosition
- AFXDAO/CDaoRecordset::SetBookmark
- AFXDAO/CDaoRecordset::SetCacheSize
- AFXDAO/CDaoRecordset::SetCacheStart
- AFXDAO/CDaoRecordset::SetCurrentIndex
- AFXDAO/CDaoRecordset::SetFieldDirty
- AFXDAO/CDaoRecordset::SetFieldNull
- AFXDAO/CDaoRecordset::SetFieldValue
- AFXDAO/CDaoRecordset::SetFieldValueNull
- AFXDAO/CDaoRecordset::SetLockingMode
- AFXDAO/CDaoRecordset::SetParamValue
- AFXDAO/CDaoRecordset::SetParamValueNull
- AFXDAO/CDaoRecordset::SetPercentPosition
- AFXDAO/CDaoRecordset::Update
- AFXDAO/CDaoRecordset::m_bCheckCacheForDirtyFields
- AFXDAO/CDaoRecordset::m_nFields
- AFXDAO/CDaoRecordset::m_nParams
- AFXDAO/CDaoRecordset::m_pDAORecordset
- AFXDAO/CDaoRecordset::m_pDatabase
- AFXDAO/CDaoRecordset::m_strFilter
- AFXDAO/CDaoRecordset::m_strSort
helpviewer_keywords:
- CDaoRecordset [MFC], CDaoRecordset
- CDaoRecordset [MFC], AddNew
- CDaoRecordset [MFC], CanAppend
- CDaoRecordset [MFC], CanBookmark
- CDaoRecordset [MFC], CancelUpdate
- CDaoRecordset [MFC], CanRestart
- CDaoRecordset [MFC], CanScroll
- CDaoRecordset [MFC], CanTransact
- CDaoRecordset [MFC], CanUpdate
- CDaoRecordset [MFC], Close
- CDaoRecordset [MFC], Delete
- CDaoRecordset [MFC], DoFieldExchange
- CDaoRecordset [MFC], Edit
- CDaoRecordset [MFC], FillCache
- CDaoRecordset [MFC], Find
- CDaoRecordset [MFC], FindFirst
- CDaoRecordset [MFC], FindLast
- CDaoRecordset [MFC], FindNext
- CDaoRecordset [MFC], FindPrev
- CDaoRecordset [MFC], GetAbsolutePosition
- CDaoRecordset [MFC], GetBookmark
- CDaoRecordset [MFC], GetCacheSize
- CDaoRecordset [MFC], GetCacheStart
- CDaoRecordset [MFC], GetCurrentIndex
- CDaoRecordset [MFC], GetDateCreated
- CDaoRecordset [MFC], GetDateLastUpdated
- CDaoRecordset [MFC], GetDefaultDBName
- CDaoRecordset [MFC], GetDefaultSQL
- CDaoRecordset [MFC], GetEditMode
- CDaoRecordset [MFC], GetFieldCount
- CDaoRecordset [MFC], GetFieldInfo
- CDaoRecordset [MFC], GetFieldValue
- CDaoRecordset [MFC], GetIndexCount
- CDaoRecordset [MFC], GetIndexInfo
- CDaoRecordset [MFC], GetLastModifiedBookmark
- CDaoRecordset [MFC], GetLockingMode
- CDaoRecordset [MFC], GetName
- CDaoRecordset [MFC], GetParamValue
- CDaoRecordset [MFC], GetPercentPosition
- CDaoRecordset [MFC], GetRecordCount
- CDaoRecordset [MFC], GetSQL
- CDaoRecordset [MFC], GetType
- CDaoRecordset [MFC], GetValidationRule
- CDaoRecordset [MFC], GetValidationText
- CDaoRecordset [MFC], IsBOF
- CDaoRecordset [MFC], IsDeleted
- CDaoRecordset [MFC], IsEOF
- CDaoRecordset [MFC], IsFieldDirty
- CDaoRecordset [MFC], IsFieldNull
- CDaoRecordset [MFC], IsFieldNullable
- CDaoRecordset [MFC], IsOpen
- CDaoRecordset [MFC], Move
- CDaoRecordset [MFC], MoveFirst
- CDaoRecordset [MFC], MoveLast
- CDaoRecordset [MFC], MoveNext
- CDaoRecordset [MFC], MovePrev
- CDaoRecordset [MFC], Open
- CDaoRecordset [MFC], Requery
- CDaoRecordset [MFC], Seek
- CDaoRecordset [MFC], SetAbsolutePosition
- CDaoRecordset [MFC], SetBookmark
- CDaoRecordset [MFC], SetCacheSize
- CDaoRecordset [MFC], SetCacheStart
- CDaoRecordset [MFC], SetCurrentIndex
- CDaoRecordset [MFC], SetFieldDirty
- CDaoRecordset [MFC], SetFieldNull
- CDaoRecordset [MFC], SetFieldValue
- CDaoRecordset [MFC], SetFieldValueNull
- CDaoRecordset [MFC], SetLockingMode
- CDaoRecordset [MFC], SetParamValue
- CDaoRecordset [MFC], SetParamValueNull
- CDaoRecordset [MFC], SetPercentPosition
- CDaoRecordset [MFC], Update
- CDaoRecordset [MFC], m_bCheckCacheForDirtyFields
- CDaoRecordset [MFC], m_nFields
- CDaoRecordset [MFC], m_nParams
- CDaoRecordset [MFC], m_pDAORecordset
- CDaoRecordset [MFC], m_pDatabase
- CDaoRecordset [MFC], m_strFilter
- CDaoRecordset [MFC], m_strSort
ms.assetid: 2322067f-1027-4662-a5d7-aa2fc7488630
ms.openlocfilehash: cc24894c0efc61ae37d57ff3c01ca43e71beddf3
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/11/2020
ms.locfileid: "97248207"
---
# <a name="cdaorecordset-class"></a>CDaoRecordset (classe)

Représente un ensemble d'enregistrements sélectionnés à partir d'une source de données.

## <a name="syntax"></a>Syntaxe

```cpp
class CDaoRecordset : public CObject
```

## <a name="members"></a>Membres

### <a name="public-constructors"></a>Constructeurs publics

|Nom|Description|
|----------|-----------------|
|[CDaoRecordset :: CDaoRecordset](#cdaorecordset)|Construit un objet `CDaoRecordset`.|

### <a name="public-methods"></a>M&#233;thodes publiques

|Nom|Description|
|----------|-----------------|
|[CDaoRecordset :: AddNew](#addnew)|Prépare l’ajout d’un nouvel enregistrement. Appelez [Update](#update) pour terminer l’addition.|
|[CDaoRecordset :: CanAppend](#canappend)|Retourne une valeur différente de zéro si de nouveaux enregistrements peuvent être ajoutés au recordset via la fonction membre [AddNew](#addnew) .|
|[CDaoRecordset :: CanBookmark](#canbookmark)|Retourne une valeur différente de zéro si le Recordset prend en charge les signets.|
|[CDaoRecordset :: CancelUpdate](#cancelupdate)|Annule toutes les mises à jour en attente en raison d’une opération de [modification](#edit) ou de [AddNew](#addnew) .|
|[CDaoRecordset :: CanRestart](#canrestart)|Retourne une valeur différente de zéro si [Requery](#requery) peut être appelé pour exécuter à nouveau la requête du Recordset.|
|[CDaoRecordset :: CanScroll](#canscroll)|Retourne une valeur différente de zéro si vous pouvez faire défiler les enregistrements.|
|[CDaoRecordset :: CanTransact](#cantransact)|Retourne une valeur différente de zéro si la source de données prend en charge les transactions.|
|[CDaoRecordset :: CanUpdate](#canupdate)|Retourne une valeur différente de zéro si le jeu d’enregistrements peut être mis à jour (vous pouvez ajouter, mettre à jour ou supprimer des enregistrements).|
|[CDaoRecordset :: Close](#close)|Ferme le Recordset.|
|[CDaoRecordset ::D supprim](#delete)|Supprime l’enregistrement actif du Recordset. Vous devez faire défiler explicitement jusqu’à un autre enregistrement après la suppression.|
|[CDaoRecordset ::D oFieldExchange](#dofieldexchange)|Appelé pour échanger des données (dans les deux sens) entre les données membres de champ du Recordset et l’enregistrement correspondant sur la source de données. Implémente l’échange de champs d’enregistrements DAO (DFX).|
|[CDaoRecordset :: Edit](#edit)|Prépare les modifications apportées à l’enregistrement en cours. Appelez `Update` pour terminer la modification.|
|[CDaoRecordset :: FillCache](#fillcache)|Remplit tout ou partie d’un cache local pour un objet Recordset qui contient des données d’une source de données ODBC.|
|[CDaoRecordset :: find](#find)|Localise le premier, le prochain, le précédent ou le dernier emplacement d’une chaîne particulière dans un jeu d’enregistrements de type Dynaset qui répond aux critères spécifiés et convertit cet enregistrement en enregistrement actif.|
|[CDaoRecordset :: FindFirst](#findfirst)|Localise le premier enregistrement dans un jeu d’enregistrements de type feuille de réponse dynamique ou instantané qui répond aux critères spécifiés et convertit cet enregistrement en enregistrement actif.|
|[CDaoRecordset :: FindLast](#findlast)|Localise le dernier enregistrement dans un jeu d’enregistrements de type feuille de réponse dynamique ou instantané qui répond aux critères spécifiés et convertit cet enregistrement en enregistrement actif.|
|[CDaoRecordset :: FindNext](#findnext)|Localise l’enregistrement suivant dans un jeu d’enregistrements de type feuille de réponse dynamique ou instantané qui répond aux critères spécifiés et convertit cet enregistrement en enregistrement actif.|
|[CDaoRecordset :: FindPrev](#findprev)|Localise l’enregistrement précédent dans un jeu d’enregistrements de type feuille de réponse dynamique ou instantané qui répond aux critères spécifiés et convertit cet enregistrement en enregistrement actif.|
|[CDaoRecordset :: GetAbsolutePosition](#getabsoluteposition)|Retourne le numéro d’enregistrement d’un enregistrement actif d’un objet Recordset.|
|[CDaoRecordset :: GetBookmark](#getbookmark)|Retourne une valeur qui représente le signet sur un enregistrement.|
|[CDaoRecordset :: GetCacheSize](#getcachesize)|Retourne une valeur qui spécifie le nombre d’enregistrements dans un jeu d’enregistrements de type feuille de réponse dynamique contenant les données à mettre en cache localement à partir d’une source de données ODBC.|
|[CDaoRecordset :: GetCacheStart](#getcachestart)|Retourne une valeur qui spécifie le signet du premier enregistrement dans le recordset à mettre en cache.|
|[CDaoRecordset :: GetCurrentIndex](#getcurrentindex)|Retourne un `CString` contenant le nom de l’index le plus récemment utilisé sur un index, de type table `CDaoRecordset` .|
|[CDaoRecordset :: GetDateCreated](#getdatecreated)|Retourne la date et l’heure de création de la table de base sous-jacente à un `CDaoRecordset` objet|
|[CDaoRecordset :: GetDateLastUpdated](#getdatelastupdated)|Retourne la date et l’heure de la dernière modification apportée à la conception d’une table de base sous-jacente à un `CDaoRecordset` objet.|
|[CDaoRecordset :: GetDefaultDBName](#getdefaultdbname)|Retourne le nom de la source de données par défaut.|
|[CDaoRecordset :: GetDefaultSQL](#getdefaultsql)|Appelé pour récupérer la chaîne SQL par défaut à exécuter.|
|[CDaoRecordset :: GetEditMode](#geteditmode)|Retourne une valeur qui indique l’état de modification de l’enregistrement en cours.|
|[CDaoRecordset :: GetFieldCount](#getfieldcount)|Retourne une valeur qui représente le nombre de champs dans un Recordset.|
|[CDaoRecordset :: GetFieldInfo](#getfieldinfo)|Retourne des types spécifiques d’informations sur les champs du Recordset.|
|[CDaoRecordset :: GetFieldValue](#getfieldvalue)|Retourne la valeur d’un champ dans un Recordset.|
|[CDaoRecordset :: GetIndexCount](#getindexcount)|Récupère le nombre d’index d’une table sous-jacente à un Recordset.|
|[CDaoRecordset :: GetIndexInfo](#getindexinfo)|Retourne différents types d’informations sur un index.|
|[CDaoRecordset :: GetLastModifiedBookmark](#getlastmodifiedbookmark)|Utilisé pour déterminer l’enregistrement le plus récemment ajouté ou mis à jour.|
|[CDaoRecordset :: GetLockingMode](#getlockingmode)|Retourne une valeur qui indique le type de verrouillage en vigueur pendant la modification.|
|[CDaoRecordset :: GetName](#getname)|Retourne un `CString` contenant le nom du Recordset.|
|[CDaoRecordset :: GetParamValue](#getparamvalue)|Récupère la valeur actuelle du paramètre spécifié stocké dans l’objet DAOParameter sous-jacent.|
|[CDaoRecordset :: GetPercentPosition](#getpercentposition)|Retourne la position de l’enregistrement actuel sous la forme d’un pourcentage du nombre total d’enregistrements.|
|[CDaoRecordset :: GetRecordCount](#getrecordcount)|Retourne le nombre d’enregistrements accédés dans un objet Recordset.|
|[CDaoRecordset :: GetSQL](#getsql)|Obtient la chaîne SQL utilisée pour sélectionner des enregistrements pour le Recordset.|
|[CDaoRecordset :: GetType](#gettype)|Appelé pour déterminer le type d’un jeu d’enregistrements : table-type, Dynaset-type ou Snapshot-type.|
|[CDaoRecordset :: GetValidationRule](#getvalidationrule)|Retourne un `CString` contenant la valeur qui valide les données au fur et à mesure de leur entrée dans un champ.|
|[CDaoRecordset :: GetValidationText](#getvalidationtext)|Récupère le texte qui s’affiche lorsqu’une règle de validation n’est pas satisfaite.|
|[CDaoRecordset :: IsBOF](#isbof)|Retourne une valeur différente de zéro si le jeu d’enregistrements a été placé avant le premier enregistrement. Aucun enregistrement actif.|
|[CDaoRecordset :: IsDeleted](#isdeleted)|Retourne une valeur différente de zéro si le jeu d’enregistrements est positionné sur un enregistrement supprimé.|
|[CDaoRecordset :: IsEOF](#iseof)|Retourne une valeur différente de zéro si le jeu d’enregistrements a été placé après le dernier enregistrement. Aucun enregistrement actif.|
|[CDaoRecordset :: IsFieldDirty](#isfielddirty)|Retourne une valeur différente de zéro si le champ spécifié dans l’enregistrement actif a été modifié.|
|[CDaoRecordset :: IsFieldNull](#isfieldnull)|Retourne une valeur différente de zéro si le champ spécifié dans l’enregistrement actif est null (sans valeur).|
|[CDaoRecordset :: IsFieldNullable](#isfieldnullable)|Retourne une valeur différente de zéro si le champ spécifié dans l’enregistrement actif peut être défini sur null (sans valeur).|
|[CDaoRecordset :: IsOpen](#isopen)|Retourne une valeur différente de zéro si [Open](#open) a été appelé précédemment.|
|[CDaoRecordset :: Move](#move)|Positionne le Recordset sur un nombre spécifié d’enregistrements à partir de l’enregistrement actif dans l’une ou l’autre direction.|
|[CDaoRecordset :: MoveFirst](#movefirst)|Positionne l’enregistrement actif sur le premier enregistrement du Recordset.|
|[CDaoRecordset :: MoveLast](#movelast)|Positionne l’enregistrement actif sur le dernier enregistrement du Recordset.|
|[CDaoRecordset :: MoveNext](#movenext)|Positionne l’enregistrement actif sur l’enregistrement suivant dans le Recordset.|
|[CDaoRecordset :: MovePrev](#moveprev)|Positionne l’enregistrement actif sur l’enregistrement précédent dans le Recordset.|
|[CDaoRecordset :: Open](#open)|Crée un nouvel ensemble d’enregistrements à partir d’une table, d’une feuille de réponse dynamique ou d’un instantané.|
|[CDaoRecordset :: Requery](#requery)|Réexécute la requête du Recordset pour actualiser les enregistrements sélectionnés.|
|[CDaoRecordset :: Seek](#seek)|Localise l’enregistrement dans un objet Recordset de type table indexé qui satisfait aux critères spécifiés pour l’index actuel et convertit cet enregistrement en enregistrement actif.|
|[CDaoRecordset :: SetAbsolutePosition](#setabsoluteposition)|Définit le numéro d’enregistrement de l’enregistrement actif d’un objet Recordset.|
|[CDaoRecordset :: SetBookmark](#setbookmark)|Positionne le Recordset sur un enregistrement contenant le signet spécifié.|
|[CDaoRecordset :: SetCacheSize](#setcachesize)|Définit une valeur qui spécifie le nombre d’enregistrements dans un jeu d’enregistrements de type feuille de réponse dynamique contenant les données à mettre en cache localement à partir d’une source de données ODBC.|
|[CDaoRecordset :: SetCacheStart](#setcachestart)|Définit une valeur qui spécifie le signet du premier enregistrement dans le recordset à mettre en cache.|
|[CDaoRecordset :: SetCurrentIndex](#setcurrentindex)|Appelé pour définir un index sur un jeu d’enregistrements de type table.|
|[CDaoRecordset :: SetFieldDirty](#setfielddirty)|Marque le champ spécifié dans l’enregistrement actuel comme modifié.|
|[CDaoRecordset :: SetFieldNull](#setfieldnull)|Définit la valeur du champ spécifié dans l’enregistrement actuel sur null (sans valeur).|
|[CDaoRecordset :: SetFieldValue](#setfieldvalue)|Définit la valeur d’un champ dans un Recordset.|
|[CDaoRecordset :: SetFieldValueNull](#setfieldvaluenull)|Affecte la valeur null à un champ d’un jeu d’enregistrements. (sans valeur).|
|[CDaoRecordset :: SetLockingMode](#setlockingmode)|Définit une valeur qui indique le type de verrouillage à appliquer pendant la modification.|
|[CDaoRecordset :: SetParamValue](#setparamvalue)|Définit la valeur actuelle du paramètre spécifié stocké dans l’objet DAOParameter sous-jacent.|
|[CDaoRecordset :: SetParamValueNull](#setparamvaluenull)|Définit la valeur actuelle du paramètre spécifié sur null (sans valeur).|
|[CDaoRecordset :: SetPercentPosition](#setpercentposition)|Définit la position de l’enregistrement en cours à un emplacement correspondant à un pourcentage du nombre total d’enregistrements dans un Recordset.|
|[CDaoRecordset :: Update](#update)|Termine une `AddNew` `Edit` opération ou en enregistrant les données nouvelles ou modifiées sur la source de données.|

### <a name="public-data-members"></a>Membres de données publics

|Nom|Description|
|----------|-----------------|
|[CDaoRecordset :: m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields)|Contient un indicateur qui spécifie si les champs sont automatiquement marqués comme modifiés.|
|[CDaoRecordset :: m_nFields](#m_nfields)|Contient le nombre de membres de données de champ dans la classe de Recordset et le nombre de colonnes sélectionnées par le Recordset de la source de données.|
|[CDaoRecordset :: m_nParams](#m_nparams)|Contient le nombre de membres de données de paramètre dans la classe Recordset (le nombre de paramètres transmis avec la requête du Recordset)|
|[CDaoRecordset :: m_pDAORecordset](#m_pdaorecordset)|Pointeur vers l’interface DAO sous-jacente de l’objet Recordset.|
|[CDaoRecordset :: m_pDatabase](#m_pdatabase)|Base de données source pour ce jeu de résultats. Contient un pointeur vers un objet [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md) .|
|[CDaoRecordset :: m_strFilter](#m_strfilter)|Contient une chaîne utilisée pour construire une instruction SQL **Where** .|
|[CDaoRecordset :: m_strSort](#m_strsort)|Contient une chaîne utilisée pour construire une instruction SQL **order by** .|

## <a name="remarks"></a>Notes

Appelés « recordsets », `CDaoRecordset` les objets sont disponibles dans les trois formes suivantes :

- Les jeux d’enregistrements de type table représentent une table de base que vous pouvez utiliser pour examiner, ajouter, modifier ou supprimer des enregistrements d’une table de base de données unique.

- Les jeux d’enregistrements de type feuille de réponse dynamique sont le résultat d’une requête pouvant contenir des enregistrements pouvant être mis à jour. Ces jeux d’enregistrements sont un ensemble d’enregistrements que vous pouvez utiliser pour examiner, ajouter, modifier ou supprimer des enregistrements dans une table ou des tables de base de données sous-jacentes. Les jeux d’enregistrements de type feuille de réponse dynamique peuvent contenir des champs d’une ou plusieurs tables d’une base de données.

- Les jeux d’enregistrements de type instantané sont une copie statique d’un ensemble d’enregistrements que vous pouvez utiliser pour rechercher des données ou générer des rapports. Ces jeux d’enregistrements peuvent contenir des champs d’une ou plusieurs tables d’une base de données, mais ils ne peuvent pas être mis à jour.

Chaque forme de Recordset représente un ensemble d’enregistrements fixés au moment de l’ouverture du Recordset. Lorsque vous faites défiler vers un enregistrement dans un jeu d’enregistrements de type table ou un jeu d’enregistrements de type feuille de réponse dynamique, il reflète les modifications apportées à l’enregistrement après l’ouverture du Recordset, soit par d’autres utilisateurs, soit par d’autres jeux d’enregistrements de votre application. (Un jeu d’enregistrements de type instantané ne peut pas être mis à jour.) Vous pouvez utiliser `CDaoRecordset` directement ou dériver une classe de Recordset spécifique à l’application à partir de `CDaoRecordset` . Vous pouvez ensuite :

- Faites défiler les enregistrements.

- Définissez un index et recherchez rapidement les enregistrements à l’aide de [Seek](#seek) (jeux d’enregistrements de type table uniquement).

- Rechercher des enregistrements en fonction d’une comparaison de chaînes : « < », « \<=", "=", "> = » ou « > » (jeux d’enregistrements de type Dynaset et instantané).

- Mettez à jour les enregistrements et spécifiez un mode de verrouillage (à l’exception des jeux d’enregistrements de type instantané).

- Filtrez le Recordset pour limiter les enregistrements qu’il sélectionne parmi ceux qui sont disponibles dans la source de données.

- Triez le Recordset.

- Paramétrez le Recordset pour personnaliser sa sélection avec des informations inconnues jusqu’au moment de l’exécution.

`CDaoRecordset`La classe fournit une interface semblable à celle de la classe `CRecordset` . La principale différence est que la classe `CDaoRecordset` accède aux données via un objet d’accès aux données (DAO) basé sur OLE. `CRecordset`La classe accède au SGBD via Open Database Connectivity (ODBC) et un pilote ODBC pour ce SGBD.

> [!NOTE]
> Les classes de base de données DAO sont distinctes des classes de base de données MFC basées sur Open Database Connectivity (ODBC). Tous les noms de classe de base de données DAO ont le préfixe « CDao ». Vous pouvez toujours accéder aux sources de données ODBC avec les classes DAO. les classes DAO offrent généralement des fonctionnalités supérieures, car elles sont spécifiques au moteur de base de données Microsoft Jet.

Vous pouvez utiliser `CDaoRecordset` directement ou dériver une classe de `CDaoRecordset` . Pour utiliser une classe Recordset dans les deux cas, ouvrez une base de données et construisez un objet Recordset, en passant au constructeur un pointeur vers votre `CDaoDatabase` objet. Vous pouvez également construire un `CDaoRecordset` objet et laisser MFC créer un `CDaoDatabase` objet temporaire pour vous. Appelez ensuite la fonction membre [Open](#open) du Recordset, en spécifiant si l’objet est un jeu d’enregistrements de type table, un jeu d’enregistrements de type feuille de réponse dynamique ou un jeu d’enregistrements de type instantané. `Open`L’appel de sélectionne des données de la base de données et récupère le premier enregistrement.

Utilisez les fonctions membres et les membres de données de l’objet pour faire défiler les enregistrements et les utiliser. Les opérations disponibles varient selon que l’objet est un jeu d’enregistrements de type table, un jeu d’enregistrements de type feuille de réponse dynamique ou un jeu d’enregistrements de type instantané, et qu’il est modifiable ou en lecture seule ; cela dépend de la capacité de la source de données de la base de données ou de la Open Database Connectivity (ODBC). Pour actualiser les enregistrements qui ont peut-être été modifiés ou ajoutés depuis l' `Open` appel, appelez la fonction membre [Requery](#requery) de l’objet. Appelez la fonction membre de l’objet `Close` et détruisez l’objet une fois que vous l’avez terminé.

`CDaoRecordset` utilise l’échange de champs d’enregistrements DAO (DFX) pour prendre en charge la lecture et la mise à jour des champs d’enregistrement via des membres C++ de type sécurisé de votre `CDaoRecordset` `CDaoRecordset` classe dérivée de ou. Vous pouvez également implémenter la liaison dynamique de colonnes dans une base de données sans utiliser le mécanisme DFX à l’aide de [GetFieldValue](#getfieldvalue) et [SetFieldValue](#setfieldvalue).

Pour obtenir des informations connexes, consultez la rubrique « objet Recordset » dans l’aide de DAO.

## <a name="inheritance-hierarchy"></a>Hiérarchie d'héritage

[CObject](../../mfc/reference/cobject-class.md)

`CDaoRecordset`

## <a name="requirements"></a>Spécifications

**En-tête :** afxdao. h

## <a name="cdaorecordsetaddnew"></a><a name="addnew"></a> CDaoRecordset :: AddNew

Appelez cette fonction membre pour ajouter un nouvel enregistrement à un type de table ou à un jeu d’enregistrements de type feuille de réponse dynamique.

```cpp
virtual void AddNew();
```

### <a name="remarks"></a>Notes

Les champs de l’enregistrement ont initialement la valeur null. (Dans la terminologie de base de données, null signifie « aucune valeur » et n’est pas identique à NULL en C++.) Pour terminer l’opération, vous devez appeler la fonction membre [Update](#update) . `Update` enregistre les modifications apportées à la source de données.

> [!CAUTION]
> Si vous modifiez un enregistrement et que vous faites défiler vers un autre enregistrement sans appeler `Update` , vos modifications sont perdues sans avertissement.

Si vous ajoutez un enregistrement à un jeu d’enregistrements de type Dynaset en appelant [AddNew](#addnew), l’enregistrement est visible dans le Recordset et inclus dans la table sous-jacente où il devient visible pour les nouveaux `CDaoRecordset` objets.

La position du nouvel enregistrement dépend du type d’objet Recordset :

- Dans un jeu d’enregistrements de type Dynaset, où le nouvel enregistrement est inséré n’est pas garanti. Ce comportement a changé avec Microsoft Jet 3,0 pour des raisons de performances et d’accès concurrentiel. Si votre objectif est de faire de l’enregistrement qui vient d’être ajouté l’enregistrement en cours, récupérez le signet du dernier enregistrement modifié et accédez à ce signet :

[!code-cpp[NVC_MFCDatabase#1](../../mfc/codesnippet/cpp/cdaorecordset-class_1.cpp)]

- Dans un jeu d’enregistrements de type table pour lequel un index a été spécifié, les enregistrements sont retournés à leur emplacement approprié dans l’ordre de tri. Si aucun index n’a été spécifié, les nouveaux enregistrements sont retournés à la fin de l’ensemble d’enregistrements.

L’enregistrement qui était en cours avant l’utilisation `AddNew` reste en cours. Si vous souhaitez rendre le nouvel enregistrement actif et que le Recordset prend en charge les signets, appelez [SetBookmark](#setbookmark) au signet identifié par le paramètre de propriété LastModified de l’objet recordset DAO sous-jacent. Cela est utile pour déterminer la valeur des champs Counter (auto-incrément) dans un enregistrement ajouté. Pour plus d’informations, consultez [GetLastModifiedBookmark](#getlastmodifiedbookmark).

Si la base de données prend en charge les transactions, vous pouvez faire en sorte que votre `AddNew` appel fasse partie d’une transaction. Pour plus d’informations sur les transactions, consultez la classe [CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md). Notez que vous devez appeler [CDaoWorkspace :: BeginTrans](../../mfc/reference/cdaoworkspace-class.md#begintrans) avant d’appeler `AddNew` .

Il est interdit d’appeler `AddNew` pour un jeu d’enregistrements dont la fonction membre [Open](#open) n’a pas été appelée. Une `CDaoException` exception est levée si vous appelez `AddNew` pour un Recordset qui ne peut pas être ajouté. Vous pouvez déterminer si le jeu d’enregistrements peut être mis à jour en appelant [CanAppend](#canappend).

Le Framework marque les membres de données de champ modifiés pour s’assurer qu’ils seront écrits dans l’enregistrement sur la source de données par le mécanisme d’échange de champs d’enregistrements DAO (DFX). La modification de la valeur d’un champ définit généralement le champ modifié automatiquement. par conséquent, vous devrez rarement appeler [SetFieldDirty](#setfielddirty) vous-même, mais vous souhaiterez peut-être également vous assurer que les colonnes seront mises à jour ou insérées de manière explicite, quelle que soit la valeur du membre de données de champ. Le mécanisme DFX utilise également l’utilisation de **Pseudo-null**. Pour plus d’informations, consultez [CDaoFieldExchange :: m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

Si le mécanisme de double mise en mémoire tampon n’est pas utilisé, la modification de la valeur du champ ne définit pas automatiquement le champ comme étant modifié. Dans ce cas, il est nécessaire de définir explicitement le champ modifié. L’indicateur contenu dans [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) contrôle cette vérification de champ automatique.

> [!NOTE]
> Si les enregistrements sont mis deux fois en mémoire tampon (autrement dit, si la vérification automatique des champs est activée), `CancelUpdate` l’appel de restaure les variables membres aux valeurs qu’elles avaient avant `AddNew` ou `Edit` a été appelée.

Pour obtenir des informations connexes, consultez les rubriques « méthode AddNew », « méthode CancelUpdate », « propriété LastModified » et « propriété EditMode » dans l’aide de DAO.

## <a name="cdaorecordsetcanappend"></a><a name="canappend"></a> CDaoRecordset :: CanAppend

Appelez cette fonction membre pour déterminer si le Recordset précédemment ouvert vous permet d’ajouter de nouveaux enregistrements en appelant la fonction membre [AddNew](#addnew) .

```cpp
BOOL CanAppend() const;
```

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si le Recordset autorise l’ajout de nouveaux enregistrements ; Sinon, 0. `CanAppend` retourne 0 si vous avez ouvert le Recordset en lecture seule.

### <a name="remarks"></a>Notes

Pour obtenir des informations connexes, consultez la rubrique « méthode Append » dans l’aide de DAO.

## <a name="cdaorecordsetcanbookmark"></a><a name="canbookmark"></a> CDaoRecordset :: CanBookmark

Appelez cette fonction membre pour déterminer si le Recordset précédemment ouvert vous permet de marquer des enregistrements individuellement à l’aide de signets.

```cpp
BOOL CanBookmark();
```

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si le Recordset prend en charge les signets, sinon 0.

### <a name="remarks"></a>Notes

Si vous utilisez des jeux d’enregistrements basés entièrement sur des tables du moteur de base de données Microsoft Jet, les signets peuvent être utilisés, sauf sur les jeux d’enregistrements de type instantané marqués comme des recordsets de défilement avant uniquement. Les autres produits de base de données (sources de données ODBC externes) peuvent ne pas prendre en charge les signets.

Pour obtenir des informations connexes, consultez la rubrique « propriété signet » dans l’aide de DAO.

## <a name="cdaorecordsetcancelupdate"></a><a name="cancelupdate"></a> CDaoRecordset :: CancelUpdate

La `CancelUpdate` fonction membre annule toutes les mises à jour en attente en raison d’une opération de [modification](#edit) ou de [AddNew](#addnew) .

```cpp
virtual void CancelUpdate();
```

### <a name="remarks"></a>Notes

Par exemple, si une application appelle la `Edit` `AddNew` fonction membre ou et n’a pas appelé [Update](#update), `CancelUpdate` annule toutes les modifications apportées après l' `Edit` appel de ou de `AddNew` .

> [!NOTE]
> Si les enregistrements sont mis deux fois en mémoire tampon (autrement dit, si la vérification automatique des champs est activée), `CancelUpdate` l’appel de restaure les variables membres aux valeurs qu’elles avaient avant `AddNew` ou `Edit` a été appelée.

S’il n’y a aucune `Edit` `AddNew` opération ou en attente, `CancelUpdate` MFC lève une exception. Appelez la fonction membre [GetEditMode](#geteditmode) pour déterminer s’il existe une opération en attente qui peut être annulée.

Pour obtenir des informations connexes, consultez la rubrique « méthode CancelUpdate » dans l’aide de DAO.

## <a name="cdaorecordsetcanrestart"></a><a name="canrestart"></a> CDaoRecordset :: CanRestart

Appelez cette fonction membre pour déterminer si le Recordset autorise le redémarrage de sa requête (pour actualiser ses enregistrements) en appelant la `Requery` fonction membre.

```cpp
BOOL CanRestart();
```

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si `Requery` peut être appelé pour exécuter à nouveau la requête du Recordset, sinon 0.

### <a name="remarks"></a>Notes

Les jeux d’enregistrements de type table ne prennent pas en charge `Requery` .

Si `Requery` n’est pas pris en charge, appelez [Close](#close) , puis [ouvrez](#open) pour actualiser les données. Vous pouvez appeler `Requery` pour mettre à jour la requête de paramètre sous-jacente d’un objet Recordset une fois que les valeurs des paramètres ont été modifiées.

Pour obtenir des informations connexes, consultez la rubrique « propriété redémarrable » dans l’aide de DAO.

## <a name="cdaorecordsetcanscroll"></a><a name="canscroll"></a> CDaoRecordset :: CanScroll

Appelez cette fonction membre pour déterminer si le jeu d’enregistrements permet le défilement.

```cpp
BOOL CanScroll() const;
```

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si vous pouvez faire défiler les enregistrements, sinon 0.

### <a name="remarks"></a>Notes

Si vous appelez [Open](#open) avec `dbForwardOnly` , le jeu d’enregistrements peut uniquement faire défiler vers l’avant.

Pour obtenir des informations connexes, consultez la rubrique « positionnement du pointeur d’enregistrement actuel avec DAO » dans l’aide de DAO.

## <a name="cdaorecordsetcantransact"></a><a name="cantransact"></a> CDaoRecordset :: CanTransact

Appelez cette fonction membre pour déterminer si le Recordset autorise les transactions.

```cpp
BOOL CanTransact();
```

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si la source de données sous-jacente prend en charge les transactions ; sinon, 0.

### <a name="remarks"></a>Notes

Pour obtenir des informations connexes, consultez la rubrique « propriété transactions » dans l’aide de DAO.

## <a name="cdaorecordsetcanupdate"></a><a name="canupdate"></a> CDaoRecordset :: CanUpdate

Appelez cette fonction membre pour déterminer si le jeu d’enregistrements peut être mis à jour.

```cpp
BOOL CanUpdate() const;
```

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si le jeu d’enregistrements peut être mis à jour (ajout, mise à jour et suppression d’enregistrements); sinon, 0.

### <a name="remarks"></a>Notes

Un jeu d’enregistrements peut être en lecture seule si la source de données sous-jacente est en lecture seule ou si vous avez spécifié `dbReadOnly` pour *nOptions* lorsque vous avez appelé [Open](#open) pour le Recordset.

Pour obtenir des informations connexes, consultez les rubriques « AddNew Method », « Edit Method », « Delete Method », « Update Method » et « Updatable Property » dans l’aide de DAO.

## <a name="cdaorecordsetcdaorecordset"></a><a name="cdaorecordset"></a> CDaoRecordset :: CDaoRecordset

Construit un objet `CDaoRecordset`.

```cpp
CDaoRecordset(CDaoDatabase* pDatabase = NULL);
```

### <a name="parameters"></a>Paramètres

*pDatabase*<br/>
Contient un pointeur vers un objet [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md) ou la valeur null. Si la valeur n’est pas NULL et que la `CDaoDatabase` fonction membre de l’objet n' `Open` a pas été appelée pour la connecter à la source de données, l’ensemble d’enregistrements tente de l’ouvrir pour vous lors de son propre appel [ouvert](#open) . Si vous transmettez la valeur NULL, un `CDaoDatabase` objet est construit et connecté pour vous à l’aide des informations de source de données que vous avez spécifiées si vous avez dérivé la classe de Recordset de `CDaoRecordset` .

### <a name="remarks"></a>Notes

Vous pouvez utiliser `CDaoRecordset` directement ou dériver une classe spécifique à l’application à partir de `CDaoRecordset` . Vous pouvez utiliser ClassWizard pour dériver vos classes de Recordset.

> [!NOTE]
> Si vous dérivez une `CDaoRecordset` classe, votre classe dérivée doit fournir son propre constructeur. Dans le constructeur de votre classe dérivée, appelez le constructeur `CDaoRecordset::CDaoRecordset` , en lui passant les paramètres appropriés.

Transmettez la valeur NULL au constructeur de votre jeu d’enregistrements pour qu’un `CDaoDatabase` objet soit construit et connecté automatiquement pour vous. Il s’agit d’un raccourci utile qui ne nécessite pas la construction et la connexion d’un `CDaoDatabase` objet avant la construction de votre Recordset. Si l' `CDaoDatabase` objet n’est pas ouvert, un objet [CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md) est également créé pour vous qui utilise l’espace de travail par défaut. Pour plus d’informations, consultez [CDaoDatabase :: CDaoDatabase](../../mfc/reference/cdaodatabase-class.md#cdaodatabase).

## <a name="cdaorecordsetclose"></a><a name="close"></a> CDaoRecordset :: Close

La fermeture d’un `CDaoRecordset` objet le supprime de la collection des jeux d’enregistrements ouverts dans la base de données associée.

```cpp
virtual void Close();
```

### <a name="remarks"></a>Notes

Étant donné que `Close` ne détruit pas l' `CDaoRecordset` objet, vous pouvez réutiliser l’objet en appelant `Open` sur la même source de données ou une autre source de données.

Toutes les instructions [AddNew](#addnew) ou [Edit](#edit) en attente sont annulées, et toutes les transactions en attente sont annulées. Si vous souhaitez conserver les ajouts ou les modifications en attente, appelez [Update](#update) avant `Close` d’appeler pour chaque Recordset.

Vous pouvez appeler `Open` à nouveau après avoir appelé `Close` . Cela vous permet de réutiliser l’objet Recordset. Une meilleure solution consiste à appeler [Requery](#requery), si possible.

Pour obtenir des informations connexes, consultez la rubrique « méthode Close » dans l’aide de DAO.

## <a name="cdaorecordsetdelete"></a><a name="delete"></a> CDaoRecordset ::D supprim

Appelez cette fonction membre pour supprimer l’enregistrement en cours dans un objet Recordset de type feuille de réponse ou de type table ouvert.

```cpp
virtual void Delete();
```

### <a name="remarks"></a>Notes

Après une suppression réussie, les membres de données de champ du Recordset sont définis sur une valeur null, et vous devez appeler explicitement l’une des fonctions membres de navigation dans le jeu d’enregistrements ( [Move](#move), [Seek](#seek), [SetBookmark](#setbookmark), etc.) afin de déplacer l’enregistrement supprimé. Lorsque vous supprimez des enregistrements d’un jeu d’enregistrements, il doit y avoir un enregistrement actif dans le Recordset avant d’appeler `Delete` ; sinon, MFC lève une exception.

`Delete` supprime l’enregistrement en cours et le rend inaccessible. Bien que vous ne pouvez pas modifier ou utiliser l’enregistrement supprimé, il reste en cours. Toutefois, une fois que vous avez déplacé vers un autre enregistrement, vous ne pouvez plus faire en sorte que l’enregistrement supprimé soit à nouveau actif.

> [!CAUTION]
> L’ensemble d’enregistrements doit pouvoir être mis à jour et un enregistrement valide doit être présent dans le recordset lorsque vous appelez `Delete` . Par exemple, si vous supprimez un enregistrement mais que vous ne faites pas défiler jusqu’à un nouvel enregistrement avant de rappeler `Delete` , `Delete` lève une [CDaoException](../../mfc/reference/cdaoexception-class.md).

Vous pouvez annuler la suppression d’un enregistrement si vous utilisez des transactions et que vous appelez la fonction membre [CDaoWorkspace :: Rollback](../../mfc/reference/cdaoworkspace-class.md#rollback) . Si la table de base est la table primaire d’une relation de suppression en cascade, la suppression de l’enregistrement en cours peut également supprimer un ou plusieurs enregistrements d’une table étrangère. Pour plus d’informations, consultez la définition « cascade Delete » dans l’aide de DAO.

Contrairement à `AddNew` et `Edit` , un appel à `Delete` n’est pas suivi d’un appel à `Update` .

Pour obtenir des informations connexes, consultez les rubriques « AddNew Method », « Edit Method », « Delete Method », « Update Method » et « Updatable Property » dans l’aide de DAO.

## <a name="cdaorecordsetdofieldexchange"></a><a name="dofieldexchange"></a> CDaoRecordset ::D oFieldExchange

L’infrastructure appelle cette fonction membre pour échanger automatiquement des données entre les membres de données de champ de votre objet Recordset et les colonnes correspondantes de l’enregistrement actif sur la source de données.

```cpp
virtual void DoFieldExchange(CDaoFieldExchange* pFX);
```

### <a name="parameters"></a>Paramètres

*pFX*<br/>
Contient un pointeur vers un `CDaoFieldExchange` objet. L’infrastructure aura déjà configuré cet objet pour spécifier un contexte pour l’opération d’échange de champs.

### <a name="remarks"></a>Notes

Il lie également vos membres de données de paramètre, le cas échéant, aux espaces réservés de paramètre dans la chaîne de l’instruction SQL pour la sélection du Recordset. L’échange de données de champ, appelé DAO Record Field Exchange (DFX), fonctionne dans les deux sens : à partir des données membres de champ de l’objet Recordset vers les champs de l’enregistrement sur la source de données, et de l’enregistrement sur la source de données vers l’objet Recordset. Si vous liez des colonnes dynamiquement, vous n’êtes pas obligé d’implémenter `DoFieldExchange` .

La seule action que vous devez normalement prendre pour implémenter `DoFieldExchange` pour votre classe de Recordset dérivée consiste à créer la classe avec ClassWizard et à spécifier les noms et les types de données des membres de données de champ. Vous pouvez également ajouter du code à ce que l’Assistant ClassWizard écrit pour spécifier des membres de données de paramètre. Si tous les champs doivent être liés dynamiquement, cette fonction est inactive, sauf si vous spécifiez des membres de données de paramètre.

Quand vous déclarez votre classe de Recordset dérivée avec ClassWizard, l’Assistant écrit une substitution de `DoFieldExchange` pour vous, qui ressemble à l’exemple suivant :

[!code-cpp[NVC_MFCDatabase#2](../../mfc/codesnippet/cpp/cdaorecordset-class_2.cpp)]

## <a name="cdaorecordsetedit"></a><a name="edit"></a> CDaoRecordset :: Edit

Appelez cette fonction membre pour autoriser les modifications de l’enregistrement en cours.

```cpp
virtual void Edit();
```

### <a name="remarks"></a>Notes

Une fois que vous avez appelé la `Edit` fonction membre, les modifications apportées aux champs de l’enregistrement actif sont copiées dans la mémoire tampon de copie. Après avoir apporté les modifications souhaitées à l’enregistrement, appelez `Update` pour enregistrer vos modifications. `Edit` enregistre les valeurs des membres de données du Recordset. Si vous appelez `Edit` , apportez des modifications, puis rappelez `Edit` , les valeurs de l’enregistrement sont restaurées sur ce qu’elles étaient avant le premier `Edit` appel.

> [!CAUTION]
> Si vous modifiez un enregistrement, puis effectuez une opération qui se déplace vers un autre enregistrement sans appeler au préalable `Update` , vos modifications sont perdues sans avertissement. En outre, si vous fermez l’ensemble d’enregistrements ou la base de données parente, votre enregistrement modifié est ignoré sans avertissement.

Dans certains cas, vous souhaiterez peut-être mettre à jour une colonne en la rendant null (ne contenant aucune donnée). Pour ce faire, appelez `SetFieldNull` avec un paramètre de true pour marquer le champ null. cela entraîne également la mise à jour de la colonne. Si vous souhaitez qu’un champ soit écrit dans la source de données même si sa valeur n’a pas changé, appelez `SetFieldDirty` avec un paramètre ayant la valeur true. Cela fonctionne même si le champ avait la valeur null.

Le Framework marque les membres de données de champ modifiés pour s’assurer qu’ils seront écrits dans l’enregistrement sur la source de données par le mécanisme d’échange de champs d’enregistrements DAO (DFX). La modification de la valeur d’un champ définit généralement le champ modifié automatiquement. par conséquent, vous devrez rarement appeler [SetFieldDirty](#setfielddirty) vous-même, mais vous souhaiterez peut-être également vous assurer que les colonnes seront mises à jour ou insérées de manière explicite, quelle que soit la valeur du membre de données de champ. Le mécanisme DFX utilise également l’utilisation de **Pseudo-null**. Pour plus d’informations, consultez [CDaoFieldExchange :: m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

Si le mécanisme de double mise en mémoire tampon n’est pas utilisé, la modification de la valeur du champ ne définit pas automatiquement le champ comme étant modifié. Dans ce cas, il est nécessaire de définir explicitement le champ modifié. L’indicateur contenu dans [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) contrôle cette vérification de champ automatique.

Lorsque l’objet Recordset est pessimistically verrouillé dans un environnement multi-utilisateur, l’enregistrement reste verrouillé à partir du moment où `Edit` la mise à jour est terminée. Si le Recordset est verrouillé de manière optimiste, l’enregistrement est verrouillé et comparé à l’enregistrement antérieur à la modification juste avant d’être mis à jour dans la base de données. Si l’enregistrement a changé depuis que vous avez appelé `Edit` , l' `Update` opération échoue et MFC lève une exception. Vous pouvez modifier le mode de verrouillage avec `SetLockingMode` .

> [!NOTE]
> Le verrouillage optimiste est toujours utilisé sur les formats de base de données externes, tels que ODBC et ISAM installables.

L’enregistrement actif reste actif après l’appel de `Edit` . Pour appeler `Edit` , il doit y avoir un enregistrement en cours. S’il n’y a pas d’enregistrement actif ou si le jeu d’enregistrements ne fait pas référence à un objet Recordset de type table ou feuille de réponse dynamique ouvert, une exception se produit. `Edit` `CDaoException` L’appel de entraîne la levée d’une exception dans les conditions suivantes :

- Aucun enregistrement actif.

- La base de données ou le Recordset est en lecture seule.

- Aucun champ de l’enregistrement ne peut être mis à jour.

- La base de données ou le jeu d’enregistrements a été ouvert pour une utilisation exclusive par un autre utilisateur.

- Un autre utilisateur a verrouillé la page contenant votre enregistrement.

Si la source de données prend en charge les transactions, vous pouvez faire en sorte que l' `Edit` appel fasse partie d’une transaction. Notez que vous devez appeler `CDaoWorkspace::BeginTrans` avant `Edit` d’appeler et après l’ouverture du Recordset. Notez également que l’appel de `CDaoWorkspace::CommitTrans` n’est pas un substitut d’appeler `Update` pour terminer l' `Edit` opération. Pour plus d’informations sur les transactions, consultez la classe `CDaoWorkspace` .

Pour obtenir des informations connexes, consultez les rubriques « AddNew Method », « Edit Method », « Delete Method », « Update Method » et « Updatable Property » dans l’aide de DAO.

## <a name="cdaorecordsetfillcache"></a><a name="fillcache"></a> CDaoRecordset :: FillCache

Appelez cette fonction membre pour mettre en cache un nombre spécifié d’enregistrements à partir du Recordset.

```cpp
void FillCache(
    long* pSize = NULL,
    COleVariant* pBookmark = NULL);
```

### <a name="parameters"></a>Paramètres

*pSize*<br/>
Spécifie le nombre de lignes à remplir dans le cache. Si vous omettez ce paramètre, la valeur est déterminée par le paramètre de propriété CacheSize de l’objet DAO sous-jacent.

*pBookmark*<br/>
[COleVariant](../../mfc/reference/colevariant-class.md) spécifiant un signet. Le cache est rempli à partir de l’enregistrement indiqué par ce signet. Si vous omettez ce paramètre, le cache est rempli à partir de l’enregistrement indiqué par la propriété CacheStart de l’objet DAO sous-jacent.

### <a name="remarks"></a>Notes

La mise en cache améliore les performances d’une application qui récupère ou extrait des données d’un serveur distant. Un cache est un espace dans la mémoire locale qui contient les données récemment extraites du serveur en partant du principe que les données seront probablement demandées à nouveau pendant l’exécution de l’application. Lorsque des données sont demandées, le moteur de base de données Microsoft Jet vérifie d’abord la mise en cache des données plutôt que de les récupérer à partir du serveur, ce qui prend plus de temps. L’utilisation de la mise en cache des données sur des sources de données non-ODBC n’a aucun effet, car les données ne sont pas enregistrées dans le cache.

Au lieu d’attendre que le cache soit rempli d’enregistrements au fur et à mesure de leur extraction, vous pouvez à tout moment remplir explicitement le cache en appelant la `FillCache` fonction membre. Il s’agit d’un moyen plus rapide de remplir le cache, car il `FillCache` Récupère plusieurs enregistrements à la fois au lieu d’un seul à la fois. Par exemple, alors que chaque écran d’enregistrements est affiché, vous pouvez demander à votre application `FillCache` d’extraire les enregistrements d’écran suivants.

Toute base de données ODBC accessible avec des objets Recordset peut avoir un cache local. Pour créer le cache, ouvrez un objet Recordset à partir de la source de données distante, puis appelez les `SetCacheSize` `SetCacheStart` fonctions membres et du Recordset. Si *lSize* et *lBookmark* créent une plage qui est partiellement ou entièrement en dehors de la plage spécifiée par `SetCacheSize` et `SetCacheStart` , la partie de l’ensemble d’enregistrements en dehors de cette plage est ignorée et n’est pas chargée dans le cache. Si `FillCache` demande plus d’enregistrements que le reste dans la source de données distante, seuls les enregistrements restants sont récupérés et aucune exception n’est levée.

Les enregistrements récupérés à partir du cache ne reflètent pas les modifications apportées simultanément aux données sources par d’autres utilisateurs.

`FillCache` récupère uniquement les enregistrements qui n’ont pas encore été mis en cache. Pour forcer une mise à jour de toutes les données mises en cache, appelez la `SetCacheSize` fonction membre avec un paramètre *lSize* égal à 0, appelez `SetCacheSize` à nouveau avec le paramètre *lSize* égal à la taille du cache que vous avez demandé à l’origine, puis appelez `FillCache` .

Pour obtenir des informations connexes, consultez la rubrique « méthode FillCache » dans l’aide de DAO.

## <a name="cdaorecordsetfind"></a><a name="find"></a> CDaoRecordset :: find

Appelez cette fonction membre pour localiser une chaîne particulière dans un jeu d’enregistrements de type feuille de réponse dynamique ou instantané à l’aide d’un opérateur de comparaison.

```cpp
virtual BOOL Find(
    long lFindType,
    LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Paramètres

*lFindType*<br/>
Valeur indiquant le type de l’opération de recherche souhaitée. Les valeurs possibles sont les suivantes :

- AFX_DAO_NEXT Rechercher l’emplacement suivant d’une chaîne correspondante.

- AFX_DAO_PREV Rechercher l’emplacement précédent d’une chaîne correspondante.

- AFX_DAO_FIRST Rechercher le premier emplacement d’une chaîne correspondante.

- AFX_DAO_LAST Rechercher le dernier emplacement d’une chaîne correspondante.

*lpszFilter*<br/>
Expression de chaîne (comme la clause **Where** dans une instruction SQL sans le mot **Where**) utilisée pour localiser l’enregistrement. Par exemple :

[!code-cpp[NVC_MFCDatabase#3](../../mfc/codesnippet/cpp/cdaorecordset-class_3.cpp)]

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si des enregistrements correspondants sont trouvés ; sinon, 0.

### <a name="remarks"></a>Notes

Vous pouvez rechercher la première instance, la prochaine, la précédente ou la dernière instance de la chaîne. `Find` est une fonction virtuelle. vous pouvez donc la remplacer et ajouter votre propre implémentation. Les `FindFirst` `FindLast` `FindNext` fonctions membres,, et `FindPrev` appellent la `Find` fonction membre, de sorte que vous pouvez utiliser `Find` pour contrôler le comportement de toutes les opérations de recherche.

Pour localiser un enregistrement dans un jeu d’enregistrements de type table, appelez la fonction membre [Seek](#seek) .

> [!TIP]
> Plus le jeu d’enregistrements dont vous disposez est petit, plus l’efficacité `Find` sera élevée. En général, et surtout avec les données ODBC, il est préférable de créer une nouvelle requête qui récupère uniquement les enregistrements de votre choix.

Pour obtenir des informations connexes, consultez la rubrique « FindFirst, FindLast, FindNext, méthodes FindPrevious » dans l’aide de DAO.

## <a name="cdaorecordsetfindfirst"></a><a name="findfirst"></a> CDaoRecordset :: FindFirst

Appelez cette fonction membre pour rechercher le premier enregistrement qui correspond à une condition spécifiée.

```cpp
BOOL FindFirst(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Paramètres

*lpszFilter*<br/>
Expression de chaîne (comme la clause **Where** dans une instruction SQL sans le mot **Where**) utilisée pour localiser l’enregistrement.

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si des enregistrements correspondants sont trouvés ; sinon, 0.

### <a name="remarks"></a>Notes

La `FindFirst` fonction membre commence sa recherche à partir du début de l’ensemble d’enregistrements et effectue la recherche jusqu’à la fin de l’ensemble d’enregistrements.

Si vous souhaitez inclure tous les enregistrements dans votre recherche (pas seulement ceux qui répondent à une condition spécifique), utilisez l’une des opérations de déplacement pour passer d’un enregistrement à un autre. Pour localiser un enregistrement dans un jeu d’enregistrements de type table, appelez la `Seek` fonction membre.

Si aucun enregistrement correspondant aux critères n’est trouvé, le pointeur d’enregistrement actif est indéterminé et `FindFirst` retourne zéro. Si le jeu d’enregistrements contient plus d’un enregistrement conforme aux critères, `FindFirst` localise la première occurrence, `FindNext` localise l’occurrence suivante, et ainsi de suite.

> [!CAUTION]
> Si vous modifiez l’enregistrement actif, veillez à enregistrer les modifications en appelant la `Update` fonction membre avant de passer à un autre enregistrement. Si vous passez à un autre enregistrement sans mise à jour, vos modifications sont perdues sans avertissement.

Les `Find` fonctions membres recherchent à partir de l’emplacement et de la direction spécifiées dans le tableau suivant :

|Opérations de recherche|Début|Sens de la recherche|
|---------------------|-----------|----------------------|
|`FindFirst`|Début de l’ensemble d’enregistrements|Fin du Recordset|
|`FindLast`|Fin du Recordset|Début de l’ensemble d’enregistrements|
|`FindNext`|Enregistrement actif|Fin du Recordset|
|`FindPrevious`|Enregistrement actif|Début de l’ensemble d’enregistrements|

> [!NOTE]
> Lorsque vous appelez `FindLast` , le moteur de base de données Microsoft Jet remplit entièrement votre jeu d’enregistrements avant de commencer la recherche, si ce n’est déjà fait. La première recherche peut prendre plus de temps que les recherches suivantes.

L’utilisation de l’une des opérations de recherche n’est pas la même que l’appel de `MoveFirst` ou `MoveNext` , ce qui rend simplement le premier enregistrement ou le prochain enregistrement sans spécification de condition. Vous pouvez suivre une opération de recherche avec une opération de déplacement.

Lorsque vous utilisez les opérations de recherche, gardez à l’esprit les points suivants :

- Si `Find` retourne une valeur différente de zéro, l’enregistrement actuel n’est pas défini. Dans ce cas, vous devez placer le pointeur d’enregistrement actif à nouveau sur un enregistrement valide.

- Vous ne pouvez pas utiliser une opération de recherche avec un jeu d’enregistrements de type instantané avant uniquement.

- Vous devez utiliser le format de date U.S. (mois-jour-année) lorsque vous recherchez des champs contenant des dates, même si vous n’utilisez pas la version américaine du moteur de base de données Microsoft Jet. Sinon, les enregistrements correspondants peuvent être introuvables.

- Lorsque vous utilisez des bases de données ODBC et des feuilles de réponse dynamiques volumineuses, vous pouvez constater que l’utilisation des opérations de recherche est lente, en particulier lorsque vous travaillez avec des jeux d’enregistrements volumineux. Vous pouvez améliorer les performances à l’aide de requêtes SQL avec des clauses **orderby** ou **Where** personnalisées, des requêtes de paramètres ou des `CDaoQuerydef` objets qui extraient des enregistrements indexés spécifiques.

Pour obtenir des informations connexes, consultez la rubrique « FindFirst, FindLast, FindNext, méthodes FindPrevious » dans l’aide de DAO.

## <a name="cdaorecordsetfindlast"></a><a name="findlast"></a> CDaoRecordset :: FindLast

Appelez cette fonction membre pour rechercher le dernier enregistrement qui correspond à une condition spécifiée.

```cpp
BOOL FindLast(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Paramètres

*lpszFilter*<br/>
Expression de chaîne (comme la clause **Where** dans une instruction SQL sans le mot **Where**) utilisée pour localiser l’enregistrement.

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si des enregistrements correspondants sont trouvés ; sinon, 0.

### <a name="remarks"></a>Notes

La `FindLast` fonction membre commence sa recherche à la fin du Recordset et effectue la recherche vers l’arrière vers le début du Recordset.

Si vous souhaitez inclure tous les enregistrements dans votre recherche (pas seulement ceux qui répondent à une condition spécifique), utilisez l’une des opérations de déplacement pour passer d’un enregistrement à un autre. Pour localiser un enregistrement dans un jeu d’enregistrements de type table, appelez la `Seek` fonction membre.

Si aucun enregistrement correspondant aux critères n’est trouvé, le pointeur d’enregistrement actif est indéterminé et `FindLast` retourne zéro. Si le jeu d’enregistrements contient plus d’un enregistrement conforme aux critères, `FindFirst` localise la première occurrence, `FindNext` localise l’occurrence suivante après la première occurrence, et ainsi de suite.

> [!CAUTION]
> Si vous modifiez l’enregistrement actif, veillez à enregistrer les modifications en appelant la `Update` fonction membre avant de passer à un autre enregistrement. Si vous passez à un autre enregistrement sans mise à jour, vos modifications sont perdues sans avertissement.

L’utilisation de l’une des opérations de recherche n’est pas la même que l’appel de `MoveFirst` ou `MoveNext` , ce qui rend simplement le premier enregistrement ou le prochain enregistrement sans spécification de condition. Vous pouvez suivre une opération de recherche avec une opération de déplacement.

Lorsque vous utilisez les opérations de recherche, gardez à l’esprit les points suivants :

- Si `Find` retourne une valeur différente de zéro, l’enregistrement actuel n’est pas défini. Dans ce cas, vous devez placer le pointeur d’enregistrement actif à nouveau sur un enregistrement valide.

- Vous ne pouvez pas utiliser une opération de recherche avec un jeu d’enregistrements de type instantané avant uniquement.

- Vous devez utiliser le format de date U.S. (mois-jour-année) lorsque vous recherchez des champs contenant des dates, même si vous n’utilisez pas la version américaine du moteur de base de données Microsoft Jet. Sinon, les enregistrements correspondants peuvent être introuvables.

- Lorsque vous utilisez des bases de données ODBC et des feuilles de réponse dynamiques volumineuses, vous pouvez constater que l’utilisation des opérations de recherche est lente, en particulier lorsque vous travaillez avec des jeux d’enregistrements volumineux. Vous pouvez améliorer les performances à l’aide de requêtes SQL avec des clauses **orderby** ou **Where** personnalisées, des requêtes de paramètres ou des `CDaoQuerydef` objets qui extraient des enregistrements indexés spécifiques.

Pour obtenir des informations connexes, consultez la rubrique « FindFirst, FindLast, FindNext, méthodes FindPrevious » dans l’aide de DAO.

## <a name="cdaorecordsetfindnext"></a><a name="findnext"></a> CDaoRecordset :: FindNext

Appelez cette fonction membre pour Rechercher l’enregistrement suivant qui correspond à une condition spécifiée.

```cpp
BOOL FindNext(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Paramètres

*lpszFilter*<br/>
Expression de chaîne (comme la clause **Where** dans une instruction SQL sans le mot **Where**) utilisée pour localiser l’enregistrement.

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si des enregistrements correspondants sont trouvés ; sinon, 0.

### <a name="remarks"></a>Notes

La `FindNext` fonction membre commence sa recherche au niveau de l’enregistrement actuel et effectue la recherche jusqu’à la fin de l’ensemble d’enregistrements.

Si vous souhaitez inclure tous les enregistrements dans votre recherche (pas seulement ceux qui répondent à une condition spécifique), utilisez l’une des opérations de déplacement pour passer d’un enregistrement à un autre. Pour localiser un enregistrement dans un jeu d’enregistrements de type table, appelez la `Seek` fonction membre.

Si aucun enregistrement correspondant aux critères n’est trouvé, le pointeur d’enregistrement actif est indéterminé et `FindNext` retourne zéro. Si le jeu d’enregistrements contient plus d’un enregistrement conforme aux critères, `FindFirst` localise la première occurrence, `FindNext` localise l’occurrence suivante, et ainsi de suite.

> [!CAUTION]
> Si vous modifiez l’enregistrement actif, veillez à enregistrer les modifications en appelant la `Update` fonction membre avant de passer à un autre enregistrement. Si vous passez à un autre enregistrement sans mise à jour, vos modifications sont perdues sans avertissement.

L’utilisation de l’une des opérations de recherche n’est pas la même que l’appel de `MoveFirst` ou `MoveNext` , ce qui rend simplement le premier enregistrement ou le prochain enregistrement sans spécification de condition. Vous pouvez suivre une opération de recherche avec une opération de déplacement.

Lorsque vous utilisez les opérations de recherche, gardez à l’esprit les points suivants :

- Si `Find` retourne une valeur différente de zéro, l’enregistrement actuel n’est pas défini. Dans ce cas, vous devez placer le pointeur d’enregistrement actif à nouveau sur un enregistrement valide.

- Vous ne pouvez pas utiliser une opération de recherche avec un jeu d’enregistrements de type instantané avant uniquement.

- Vous devez utiliser le format de date U.S. (mois-jour-année) lorsque vous recherchez des champs contenant des dates, même si vous n’utilisez pas la version américaine du moteur de base de données Microsoft Jet. Sinon, les enregistrements correspondants peuvent être introuvables.

- Lorsque vous utilisez des bases de données ODBC et des feuilles de réponse dynamiques volumineuses, vous pouvez constater que l’utilisation des opérations de recherche est lente, en particulier lorsque vous travaillez avec des jeux d’enregistrements volumineux. Vous pouvez améliorer les performances à l’aide de requêtes SQL avec des clauses **orderby** ou **Where** personnalisées, des requêtes de paramètres ou des `CDaoQuerydef` objets qui extraient des enregistrements indexés spécifiques.

Pour obtenir des informations connexes, consultez la rubrique « FindFirst, FindLast, FindNext, méthodes FindPrevious » dans l’aide de DAO.

## <a name="cdaorecordsetfindprev"></a><a name="findprev"></a> CDaoRecordset :: FindPrev

Appelez cette fonction membre pour Rechercher l’enregistrement précédent qui correspond à une condition spécifiée.

```cpp
BOOL FindPrev(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Paramètres

*lpszFilter*<br/>
Expression de chaîne (comme la clause **Where** dans une instruction SQL sans le mot **Where**) utilisée pour localiser l’enregistrement.

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si des enregistrements correspondants sont trouvés ; sinon, 0.

### <a name="remarks"></a>Notes

La `FindPrev` fonction membre commence sa recherche au niveau de l’enregistrement actuel et effectue une recherche vers l’arrière vers le début du Recordset.

Si vous souhaitez inclure tous les enregistrements dans votre recherche (pas seulement ceux qui répondent à une condition spécifique), utilisez l’une des opérations de déplacement pour passer d’un enregistrement à un autre. Pour localiser un enregistrement dans un jeu d’enregistrements de type table, appelez la `Seek` fonction membre.

Si aucun enregistrement correspondant aux critères n’est trouvé, le pointeur d’enregistrement actif est indéterminé et `FindPrev` retourne zéro. Si le jeu d’enregistrements contient plus d’un enregistrement conforme aux critères, `FindFirst` localise la première occurrence, `FindNext` localise l’occurrence suivante, et ainsi de suite.

> [!CAUTION]
> Si vous modifiez l’enregistrement actif, veillez à enregistrer les modifications en appelant la `Update` fonction membre avant de passer à un autre enregistrement. Si vous passez à un autre enregistrement sans mise à jour, vos modifications sont perdues sans avertissement.

L’utilisation de l’une des opérations de recherche n’est pas la même que l’appel de `MoveFirst` ou `MoveNext` , ce qui rend simplement le premier enregistrement ou le prochain enregistrement sans spécification de condition. Vous pouvez suivre une opération de recherche avec une opération de déplacement.

Lorsque vous utilisez les opérations de recherche, gardez à l’esprit les points suivants :

- Si `Find` retourne une valeur différente de zéro, l’enregistrement actuel n’est pas défini. Dans ce cas, vous devez placer le pointeur d’enregistrement actif à nouveau sur un enregistrement valide.

- Vous ne pouvez pas utiliser une opération de recherche avec un jeu d’enregistrements de type instantané avant uniquement.

- Vous devez utiliser le format de date U.S. (mois-jour-année) lorsque vous recherchez des champs contenant des dates, même si vous n’utilisez pas la version américaine du moteur de base de données Microsoft Jet. Sinon, les enregistrements correspondants peuvent être introuvables.

- Lorsque vous utilisez des bases de données ODBC et des feuilles de réponse dynamiques volumineuses, vous pouvez constater que l’utilisation des opérations de recherche est lente, en particulier lorsque vous travaillez avec des jeux d’enregistrements volumineux. Vous pouvez améliorer les performances à l’aide de requêtes SQL avec des clauses **orderby** ou **Where** personnalisées, des requêtes de paramètres ou des `CDaoQuerydef` objets qui extraient des enregistrements indexés spécifiques.

Pour obtenir des informations connexes, consultez la rubrique « FindFirst, FindLast, FindNext, méthodes FindPrevious » dans l’aide de DAO.

## <a name="cdaorecordsetgetabsoluteposition"></a><a name="getabsoluteposition"></a> CDaoRecordset :: GetAbsolutePosition

Retourne le numéro d’enregistrement d’un enregistrement actif d’un objet Recordset.

```cpp
long GetAbsolutePosition();
```

### <a name="return-value"></a>Valeur renvoyée

Entier compris entre 0 et le nombre d’enregistrements dans l’ensemble d’enregistrements. Correspond à la position ordinale de l’enregistrement en cours dans le Recordset.

### <a name="remarks"></a>Notes

La valeur de la propriété AbsolutePosition de l’objet DAO sous-jacent est de base zéro ; la valeur 0 fait référence au premier enregistrement du jeu d’enregistrements. Vous pouvez déterminer le nombre d’enregistrements remplis dans le Recordset en appelant [GetRecordCount](#getrecordcount). `GetRecordCount`L’appel de peut prendre un certain temps, car il doit accéder à tous les enregistrements pour déterminer le nombre.

S’il n’y a aucun enregistrement en cours, comme lorsqu’il n’y a aucun enregistrement dans le jeu d’enregistrements,-1 est retourné. Si l’enregistrement en cours est supprimé, la valeur de la propriété AbsolutePosition n’est pas définie et MFC lève une exception si elle est référencée. Pour les jeux d’enregistrements de type Dynaset, les nouveaux enregistrements sont ajoutés à la fin de la séquence.

> [!NOTE]
> Cette propriété n’est pas destinée à être utilisée comme numéro d’enregistrement de substitution. Les signets sont toujours la méthode recommandée pour la conservation et le retour à une position donnée et sont la seule façon de positionner l’enregistrement actuel sur tous les types d’objets Recordset. En particulier, la position d’un enregistrement donné change lorsque le ou les enregistrements qui le précèdent sont supprimés. En outre, il n’est pas garanti qu’un enregistrement donné aura la même position absolue si le jeu d’enregistrements est recréé parce que l’ordre des enregistrements individuels au sein d’un jeu d’enregistrements n’est pas garanti, sauf s’il est créé avec une instruction SQL à l’aide d’une clause **orderby** .

> [!NOTE]
> Cette fonction membre est valide uniquement pour les jeux d’enregistrements de type Dynaset et Snapshot.

Pour obtenir des informations connexes, consultez la rubrique « propriété AbsolutePosition » dans l’aide de DAO.

## <a name="cdaorecordsetgetbookmark"></a><a name="getbookmark"></a> CDaoRecordset :: GetBookmark

Appelez cette fonction membre pour obtenir la valeur de signet dans un enregistrement particulier.

```cpp
COleVariant GetBookmark();
```

### <a name="return-value"></a>Valeur renvoyée

Retourne une valeur représentant le signet de l’enregistrement en cours.

### <a name="remarks"></a>Notes

Lors de la création ou de l’ouverture d’un objet Recordset, chacun de ses enregistrements a déjà un signet unique s’il les prend en charge. Appelez `CanBookmark` pour déterminer si un Recordset prend en charge les signets.

Vous pouvez enregistrer le signet de l’enregistrement en cours en affectant la valeur du signet à un `COleVariant` objet. Pour revenir rapidement à cet enregistrement à tout moment après l’avoir déplacé vers un autre enregistrement, appelez `SetBookmark` avec un paramètre correspondant à la valeur de cet `COleVariant` objet.

> [!NOTE]
> L’appel de [Requery](#requery) modifie les signets DAO.

Pour obtenir des informations connexes, consultez la rubrique « propriété Bookmark » dans l’aide de DAO.

## <a name="cdaorecordsetgetcachesize"></a><a name="getcachesize"></a> CDaoRecordset :: GetCacheSize

Appelez cette fonction membre pour obtenir le nombre d’enregistrements mis en cache.

```cpp
long GetCacheSize();
```

### <a name="return-value"></a>Valeur renvoyée

Valeur qui spécifie le nombre d’enregistrements dans un jeu d’enregistrements de type feuille de réponse dynamique contenant les données à mettre en cache localement à partir d’une source de données ODBC.

### <a name="remarks"></a>Notes

La mise en cache des données améliore les performances d’une application qui récupère des données à partir d’un serveur distant par le biais d’objets Recordset de type feuille de réponse dynamique. Un cache est un espace dans la mémoire locale qui contient les données les plus récemment récupérées à partir du serveur dans le cas où les données seront de nouveau demandées pendant l’exécution de l’application. Lorsque des données sont demandées, le moteur de base de données Microsoft Jet vérifie d’abord le cache pour les données demandées plutôt que de les récupérer à partir du serveur, ce qui prend plus de temps. Les données qui ne proviennent pas d’une source de données ODBC ne sont pas enregistrées dans le cache.

Toute source de données ODBC, telle qu’une table attachée, peut avoir un cache local.

Pour obtenir des informations connexes, consultez la rubrique « CacheSize, propriétés CacheStart » dans l’aide de DAO.

## <a name="cdaorecordsetgetcachestart"></a><a name="getcachestart"></a> CDaoRecordset :: GetCacheStart

Appelez cette fonction membre pour obtenir la valeur de signet du premier enregistrement dans le jeu d’enregistrements à mettre en cache.

```cpp
COleVariant GetCacheStart();
```

### <a name="return-value"></a>Valeur renvoyée

`COleVariant`Qui spécifie le signet du premier enregistrement dans le recordset à mettre en cache.

### <a name="remarks"></a>Notes

Le moteur de base de données Microsoft Jet demande des enregistrements à l’intérieur de la plage du cache et demande des enregistrements en dehors de la plage du cache du serveur.

> [!NOTE]
> Les enregistrements récupérés à partir du cache ne reflètent pas les modifications apportées simultanément aux données sources par d’autres utilisateurs.

Pour obtenir des informations connexes, consultez la rubrique « CacheSize, propriétés CacheStart » dans l’aide de DAO.

## <a name="cdaorecordsetgetcurrentindex"></a><a name="getcurrentindex"></a> CDaoRecordset :: GetCurrentIndex

Appelez cette fonction membre pour déterminer l’index en cours d’utilisation dans un objet de type table indexé `CDaoRecordset` .

```cpp
CString GetCurrentIndex();
```

### <a name="return-value"></a>Valeur renvoyée

`CString`Contenant le nom de l’index en cours d’utilisation avec un jeu d’enregistrements de type table. Retourne une chaîne vide si aucun index n’a été défini.

### <a name="remarks"></a>Notes

Cet index est la base du classement des enregistrements dans un jeu d’enregistrements de type table et est utilisé par la fonction membre [Seek](#seek) pour localiser les enregistrements.

Un `CDaoRecordset` objet peut avoir plusieurs index, mais ne peut utiliser qu’un seul index à la fois (même si un objet [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) peut avoir plusieurs index définis dessus).

Pour obtenir des informations connexes, consultez la rubrique « index Object » et la définition « current index » dans l’aide de DAO.

## <a name="cdaorecordsetgetdatecreated"></a><a name="getdatecreated"></a> CDaoRecordset :: GetDateCreated

Appelez cette fonction membre pour récupérer la date et l’heure de création d’une table de base.

```cpp
COleDateTime GetDateCreated();
```

### <a name="return-value"></a>Valeur renvoyée

Objet [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) contenant la date et l’heure de création de la table de base.

### <a name="remarks"></a>Notes

Les paramètres de date et d’heure sont dérivés de l’ordinateur sur lequel la table de base a été créée.

Pour obtenir des informations connexes, consultez la rubrique « Propriétés DateCreated, LastUpdated » dans l’aide de DAO.

## <a name="cdaorecordsetgetdatelastupdated"></a><a name="getdatelastupdated"></a> CDaoRecordset :: GetDateLastUpdated

Appelez cette fonction membre pour récupérer la date et l’heure de la dernière mise à jour du schéma.

```cpp
COleDateTime GetDateLastUpdated();
```

### <a name="return-value"></a>Valeur renvoyée

Objet [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) contenant la date et l’heure de la dernière mise à jour de la structure de la table de base (schéma).

### <a name="remarks"></a>Notes

Les paramètres de date et d’heure sont dérivés de l’ordinateur sur lequel la structure de la table de base (schéma) a été mise à jour pour la dernière fois.

Pour obtenir des informations connexes, consultez la rubrique « Propriétés DateCreated, LastUpdated » dans l’aide de DAO.

## <a name="cdaorecordsetgetdefaultdbname"></a><a name="getdefaultdbname"></a> CDaoRecordset :: GetDefaultDBName

Appelez cette fonction membre pour déterminer le nom de la base de données pour ce Recordset.

```cpp
virtual CString GetDefaultDBName();
```

### <a name="return-value"></a>Valeur renvoyée

`CString`Qui contient le chemin d’accès et le nom de la base de données à partir de laquelle ce recordset est dérivé.

### <a name="remarks"></a>Notes

Si un jeu d’enregistrements est créé sans pointeur vers un objet [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md), ce chemin d’accès est utilisé par le Recordset pour ouvrir la base de données par défaut. Par défaut, cette fonction retourne une chaîne vide. Lorsque ClassWizard dérive un nouvel ensemble d’enregistrements de `CDaoRecordset` , il crée cette fonction pour vous.

L’exemple suivant illustre l’utilisation de la double barre oblique inverse ( \\ \\ ) dans la chaîne, comme cela est nécessaire pour que la chaîne soit interprétée correctement.

[!code-cpp[NVC_MFCDatabase#4](../../mfc/codesnippet/cpp/cdaorecordset-class_4.cpp)]

## <a name="cdaorecordsetgetdefaultsql"></a><a name="getdefaultsql"></a> CDaoRecordset :: GetDefaultSQL

L’infrastructure appelle cette fonction membre pour recevoir l’instruction SQL par défaut sur laquelle est basé le Recordset.

```cpp
virtual CString GetDefaultSQL();
```

### <a name="return-value"></a>Valeur renvoyée

`CString`Qui contient l’instruction SQL par défaut.

### <a name="remarks"></a>Notes

Il peut s’agir d’un nom de table ou d’une instruction SQL **Select** .

Vous définissez indirectement l’instruction SQL par défaut en déclarant votre classe Recordset avec ClassWizard, et ClassWizard effectue cette tâche pour vous.

Si vous transmettez une chaîne SQL null à [Open](#open), cette fonction est appelée pour déterminer le nom de la table ou SQL pour votre Recordset.

## <a name="cdaorecordsetgeteditmode"></a><a name="geteditmode"></a> CDaoRecordset :: GetEditMode

Appelez cette fonction membre pour déterminer l’état de modification, qui est l’une des valeurs suivantes :

```cpp
short GetEditMode();
```

### <a name="return-value"></a>Valeur renvoyée

Retourne une valeur qui indique l’état de modification de l’enregistrement en cours.

### <a name="remarks"></a>Notes

|Valeur|Description|
|-----------|-----------------|
|`dbEditNone`|Aucune opération de modification n’est en cours.|
|`dbEditInProgress`|`Edit` a été appelé.|
|`dbEditAdd`|`AddNew` a été appelé.|

Pour obtenir des informations connexes, consultez la rubrique « propriété EditMode » dans l’aide de DAO.

## <a name="cdaorecordsetgetfieldcount"></a><a name="getfieldcount"></a> CDaoRecordset :: GetFieldCount

Appelez cette fonction membre pour récupérer le nombre de champs (colonnes) définis dans le Recordset.

```cpp
short GetFieldCount();
```

### <a name="return-value"></a>Valeur renvoyée

Nombre de champs dans le Recordset.

### <a name="remarks"></a>Notes

Pour obtenir des informations connexes, consultez la rubrique « propriété Count » dans l’aide de DAO.

## <a name="cdaorecordsetgetfieldinfo"></a><a name="getfieldinfo"></a> CDaoRecordset :: GetFieldInfo

Appelez cette fonction membre pour obtenir des informations sur les champs d’un Recordset.

```cpp
void GetFieldInfo(
    int nIndex,
    CDaoFieldInfo& fieldinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

void GetFieldInfo(
    LPCTSTR lpszName,
    CDaoFieldInfo& fieldinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
Index de base zéro du champ prédéfini dans la collection de champs du Recordset, pour la recherche par index.

*FieldInfo*<br/>
Référence à une structure [cdaofieldinfo,](../../mfc/reference/cdaofieldinfo-structure.md) .

*dwInfoOptions*<br/>
Options qui spécifient les informations relatives au jeu d’enregistrements à récupérer. Les options disponibles sont répertoriées ici, ainsi que ce qu’elles provoquent le retour de la fonction. Pour des performances optimales, récupérez uniquement le niveau d’informations dont vous avez besoin :

- `AFX_DAO_PRIMARY_INFO` Valeurs Nom, type, taille, attributs

- `AFX_DAO_SECONDARY_INFO` Informations principales, plus : position ordinale, obligatoire, autoriser la longueur nulle, ordre de classement, nom étranger, champ source, table source

- `AFX_DAO_ALL_INFO` Informations primaires et secondaires, plus : valeur par défaut, règle de validation, texte de validation

*lpszName*<br/>
Nom du champ.

### <a name="remarks"></a>Notes

Une version de la fonction vous permet de rechercher un champ par index. L’autre version vous permet de rechercher un champ par nom.

Pour obtenir une description des informations retournées, consultez la structure [cdaofieldinfo,](../../mfc/reference/cdaofieldinfo-structure.md) . Cette structure a des membres qui correspondent aux éléments d’informations énumérés ci-dessus dans la description de *dwInfoOptions*. Lorsque vous demandez des informations à un niveau, vous recevez également des informations sur les niveaux précédents.

Pour obtenir des informations connexes, consultez la rubrique « propriété Attributes » dans l’aide de DAO.

## <a name="cdaorecordsetgetfieldvalue"></a><a name="getfieldvalue"></a> CDaoRecordset :: GetFieldValue

Appelez cette fonction membre pour récupérer des données dans un Recordset.

```cpp
virtual void GetFieldValue(
    LPCTSTR lpszName,
    COleVariant& varValue);

virtual void GetFieldValue(
    int nIndex,
    COleVariant& varValue);

virtual COleVariant GetFieldValue(LPCTSTR lpszName);
virtual COleVariant GetFieldValue(int nIndex);
```

### <a name="parameters"></a>Paramètres

*lpszName*<br/>
Pointeur vers une chaîne qui contient le nom d’un champ.

*varValue*<br/>
Référence à un `COleVariant` objet qui stocke la valeur d’un champ.

*nIndex*<br/>
Index de base zéro du champ dans la collection de champs du Recordset, pour la recherche par index.

### <a name="return-value"></a>Valeur renvoyée

Les deux versions de `GetFieldValue` qui retournent une valeur retournent un objet [COleVariant](../../mfc/reference/colevariant-class.md) qui contient la valeur d’un champ.

### <a name="remarks"></a>Notes

Vous pouvez rechercher un champ par son nom ou par sa position ordinale.

> [!NOTE]
> Il est plus efficace d’appeler l’une des versions de cette fonction membre qui accepte une `COleVariant` référence d’objet en tant que paramètre, plutôt que d’appeler une version qui retourne un `COleVariant` objet. Les dernières versions de cette fonction sont conservées à des fins de compatibilité descendante.

Utilisez `GetFieldValue` et [SetFieldValue](#setfieldvalue) pour lier dynamiquement des champs au moment de l’exécution plutôt que de lier des colonnes de manière statique à l’aide du mécanisme [DoFieldExchange](#dofieldexchange) .

`GetFieldValue` et le `DoFieldExchange` mécanisme peut être combiné pour améliorer les performances. Par exemple, utilisez `GetFieldValue` pour récupérer une valeur dont vous avez besoin uniquement à la demande, et assignez cet appel à un bouton « plus d’informations » dans l’interface.

Pour obtenir des informations connexes, consultez les rubriques « objet champ » et « propriété valeur » dans l’aide de DAO.

## <a name="cdaorecordsetgetindexcount"></a><a name="getindexcount"></a> CDaoRecordset :: GetIndexCount

Appelez cette fonction membre pour déterminer le nombre d’index disponibles sur le jeu d’enregistrements de type table.

```cpp
short GetIndexCount();
```

### <a name="return-value"></a>Valeur renvoyée

Nombre d’index dans le jeu d’enregistrements de type table.

### <a name="remarks"></a>Notes

`GetIndexCount` est utile pour boucler dans tous les index du Recordset. À cet effet, utilisez `GetIndexCount` conjointement avec [getIndexInfo](#getindexinfo). Si vous appelez cette fonction membre sur des jeux d’enregistrements de type feuille de réponse dynamique ou instantané, MFC lève une exception.

Pour obtenir des informations connexes, consultez la rubrique « propriété Attributes » dans l’aide de DAO.

## <a name="cdaorecordsetgetindexinfo"></a><a name="getindexinfo"></a> CDaoRecordset :: GetIndexInfo

Appelez cette fonction membre pour obtenir différents genres d’informations sur un index défini dans la table de base sous-jacente à un Recordset.

```cpp
void GetIndexInfo(
    int nIndex,
    CDaoIndexInfo& indexinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

void GetIndexInfo(
    LPCTSTR lpszName,
    CDaoIndexInfo& indexinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
Index de base zéro dans la collection d’index de la table, pour la recherche par position numérique.

*indexinfo*<br/>
Référence à une structure [cdaoindexinfo,](../../mfc/reference/cdaoindexinfo-structure.md) .

*dwInfoOptions*<br/>
Options qui spécifient les informations relatives à l’index à récupérer. Les options disponibles sont répertoriées ici, ainsi que ce qu’elles provoquent le retour de la fonction. Pour des performances optimales, récupérez uniquement le niveau d’informations dont vous avez besoin :

- `AFX_DAO_PRIMARY_INFO` Valeurs Nom, informations de champ, champs

- `AFX_DAO_SECONDARY_INFO` Informations principales, plus : principal, unique, Clustered, IgnoreNulls, required, Foreign

- `AFX_DAO_ALL_INFO` Informations primaires et secondaires, plus : nombre distinct

*lpszName*<br/>
Pointeur vers le nom de l’objet d’index, pour la recherche par nom.

### <a name="remarks"></a>Notes

Une version de la fonction vous permet de rechercher un index en fonction de sa position dans la collection. L’autre version vous permet de rechercher un index par nom.

Pour obtenir une description des informations retournées, consultez la structure [cdaoindexinfo,](../../mfc/reference/cdaoindexinfo-structure.md) . Cette structure a des membres qui correspondent aux éléments d’informations énumérés ci-dessus dans la description de *dwInfoOptions*. Lorsque vous demandez des informations à un niveau, vous recevez également des informations sur les niveaux précédents.

Pour obtenir des informations connexes, consultez la rubrique « propriété Attributes » dans l’aide de DAO.

## <a name="cdaorecordsetgetlastmodifiedbookmark"></a><a name="getlastmodifiedbookmark"></a> CDaoRecordset :: GetLastModifiedBookmark

Appelez cette fonction membre pour récupérer le signet de l’enregistrement le plus récemment ajouté ou mis à jour.

```cpp
COleVariant GetLastModifiedBookmark();
```

### <a name="return-value"></a>Valeur renvoyée

`COleVariant`Contenant un signet qui indique l’enregistrement le plus récemment ajouté ou modifié.

### <a name="remarks"></a>Notes

Lors de la création ou de l’ouverture d’un objet Recordset, chacun de ses enregistrements a déjà un signet unique s’il les prend en charge. Appelez [GetBookmark](#getbookmark) pour déterminer si le Recordset prend en charge les signets. Si le recordset ne prend pas en charge les signets, une `CDaoException` exception est levée.

Lorsque vous ajoutez un enregistrement, il apparaît à la fin de l’ensemble d’enregistrements et n’est pas l’enregistrement en cours. Pour rendre le nouvel enregistrement actif, appelez, puis `GetLastModifiedBookmark` appelez `SetBookmark` pour revenir à l’enregistrement qui vient d’être ajouté.

Pour obtenir des informations connexes, consultez la rubrique « propriété LastModified » dans l’aide de DAO.

## <a name="cdaorecordsetgetlockingmode"></a><a name="getlockingmode"></a> CDaoRecordset :: GetLockingMode

Appelez cette fonction membre pour déterminer le type de verrouillage en vigueur pour le Recordset.

```cpp
BOOL GetLockingMode();
```

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si le type de verrouillage est pessimiste, sinon 0 pour le verrouillage optimiste des enregistrements.

### <a name="remarks"></a>Notes

Lorsque le verrouillage pessimiste est activé, la page de données contenant l’enregistrement que vous modifiez est verrouillée dès que vous appelez la fonction membre [Edit](#edit) . La page est déverrouillée lorsque vous appelez la fonction membre [Update](#update) ou [Close](#close) , ou l’une des opérations Move ou Find.

Lorsque le verrouillage optimiste est activé, la page de données contenant l’enregistrement est verrouillée uniquement lorsque l’enregistrement est mis à jour avec la `Update` fonction membre.

Lorsque vous utilisez des sources de données ODBC, le mode de verrouillage est toujours optimiste.

Pour obtenir des informations connexes, consultez les rubriques « propriété LockEdits » et « comportement de verrouillage dans les applications multi-utilisateur » dans l’aide de DAO.

## <a name="cdaorecordsetgetname"></a><a name="getname"></a> CDaoRecordset :: GetName

Appelez cette fonction membre pour récupérer le nom du Recordset.

```cpp
CString GetName();
```

### <a name="return-value"></a>Valeur renvoyée

`CString`Contenant le nom du Recordset.

### <a name="remarks"></a>Notes

Le nom de l’ensemble d’enregistrements doit commencer par une lettre et peut contenir jusqu’à 40 caractères. Elle peut inclure des nombres et des traits de soulignement, mais ne peut pas inclure de caractères de ponctuation ou d’espace.

Pour obtenir des informations connexes, consultez la rubrique « propriété Name » dans l’aide de DAO.

## <a name="cdaorecordsetgetparamvalue"></a><a name="getparamvalue"></a> CDaoRecordset :: GetParamValue

Appelez cette fonction membre pour récupérer la valeur actuelle du paramètre spécifié stocké dans l’objet DAOParameter sous-jacent.

```cpp
virtual COleVariant GetParamValue(int nIndex);
virtual COleVariant GetParamValue(LPCTSTR lpszName);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
Position numérique du paramètre dans l’objet DAOParameter sous-jacent.

*lpszName*<br/>
Nom du paramètre dont vous souhaitez obtenir la valeur.

### <a name="return-value"></a>Valeur renvoyée

Objet de la classe [COleVariant](../../mfc/reference/colevariant-class.md) qui contient la valeur du paramètre.

### <a name="remarks"></a>Notes

Vous pouvez accéder au paramètre par son nom ou par sa position numérique dans la collection.

Pour obtenir des informations connexes, consultez la rubrique « objet Parameter » dans l’aide de DAO.

## <a name="cdaorecordsetgetpercentposition"></a><a name="getpercentposition"></a> CDaoRecordset :: GetPercentPosition

Lors de l’utilisation d’un jeu d’enregistrements de type feuille de réponse dynamique ou instantané, si vous appelez `GetPercentPosition` avant de remplir entièrement le Recordset, la quantité de mouvement est relative au nombre d’enregistrements accédés comme indiqué par l’appel de [GetRecordCount](#getrecordcount).

```cpp
float GetPercentPosition();
```

### <a name="return-value"></a>Valeur renvoyée

Nombre compris entre 0 et 100 qui indique l’emplacement approximatif de l’enregistrement actif dans l’objet Recordset en fonction d’un pourcentage des enregistrements du Recordset.

### <a name="remarks"></a>Notes

Vous pouvez accéder au dernier enregistrement en appelant [MoveLast](#movelast) pour terminer le remplissage de tous les jeux d’enregistrements, mais cela peut prendre beaucoup de temps.

Vous pouvez appeler `GetPercentPosition` sur les trois types d’objets Recordset, y compris les tables sans index. Toutefois, vous ne pouvez pas appeler `GetPercentPosition` sur des instantanés de défilement avant uniquement ou sur un jeu d’enregistrements ouvert à partir d’une requête directe sur une base de données externe. S’il n’existe aucun enregistrement en cours ou si l’enregistrement actuel a été supprimé, une `CDaoException` exception est levée.

Pour obtenir des informations connexes, consultez la rubrique « propriété PercentPosition » dans l’aide de DAO.

## <a name="cdaorecordsetgetrecordcount"></a><a name="getrecordcount"></a> CDaoRecordset :: GetRecordCount

Appelez cette fonction membre pour connaître le nombre d’enregistrements ayant fait l’objet d’un accès à un jeu d’enregistrements.

```cpp
long GetRecordCount();
```

### <a name="return-value"></a>Valeur renvoyée

Retourne le nombre d’enregistrements accédés dans un objet Recordset.

### <a name="remarks"></a>Notes

`GetRecordCount` n’indique pas le nombre d’enregistrements contenus dans un jeu d’enregistrements de type feuille de réponse dynamique ou instantané, jusqu’à ce que tous les enregistrements aient fait l’objet d’un accès. Cet appel de fonction membre peut prendre beaucoup de temps.

Une fois que le dernier enregistrement a fait l’objet d’un accès, la valeur de retour indique le nombre total d’enregistrements qui n’ont pas été supprimés dans le Recordset. Pour forcer l’accès au dernier enregistrement, appelez la `MoveLast` `FindLast` fonction membre ou pour le Recordset. Vous pouvez également utiliser un nombre SQL pour déterminer le nombre approximatif d’enregistrements renvoyés par votre requête.

À mesure que votre application supprime des enregistrements dans un jeu d’enregistrements de type Dynaset, la valeur de retour de `GetRecordCount` diminue. Toutefois, les enregistrements supprimés par d’autres utilisateurs ne sont pas reflétés par `GetRecordCount` jusqu’à ce que l’enregistrement actif soit positionné sur un enregistrement supprimé. Si vous exécutez une transaction qui affecte le nombre d’enregistrements et que vous restaurez ensuite la transaction, ne `GetRecordCount` reflète pas le nombre réel d’enregistrements restants.

La valeur de `GetRecordCount` à partir d’un jeu d’enregistrements de type instantané n’est pas affectée par les modifications apportées aux tables sous-jacentes.

La valeur de `GetRecordCount` à partir d’un jeu d’enregistrements de type table reflète le nombre approximatif d’enregistrements dans la table et est immédiatement affectée en cas d’ajout et de suppression d’enregistrements de table.

Un Recordset sans enregistrement retourne la valeur 0. Lorsque vous utilisez des tables attachées ou des bases de données ODBC, `GetRecordCount` retourne toujours-1. L’appel `Requery` de la fonction membre sur un Recordset réinitialise la valeur de `GetRecordCount` comme si la requête était réexécutée.

Pour obtenir des informations connexes, consultez la rubrique « propriété RecordCount » dans l’aide de DAO.

## <a name="cdaorecordsetgetsql"></a><a name="getsql"></a> CDaoRecordset :: GetSQL

Appelez cette fonction membre pour récupérer l’instruction SQL utilisée pour sélectionner les enregistrements du Recordset lorsqu’elle a été ouverte.

```cpp
CString GetSQL() const;
```

### <a name="return-value"></a>Valeur renvoyée

`CString`Qui contient l’instruction SQL.

### <a name="remarks"></a>Notes

Il s’agit généralement d’une instruction SQL **Select** .

La chaîne retournée par `GetSQL` est généralement différente de toute chaîne que vous avez peut-être passée au recordset dans le paramètre *lpszSQL* de la fonction membre [Open](#open) . Cela est dû au fait que le recordset construit une instruction SQL complète basée sur ce que vous avez passé à `Open` , ce que vous avez spécifié avec ClassWizard et ce que vous avez spécifié dans les membres de données [m_strFilter](#m_strfilter) et [m_strSort](#m_strsort) .

> [!NOTE]
> Appelez cette fonction membre uniquement après avoir appelé `Open` .

Pour obtenir des informations connexes, consultez la rubrique « propriété SQL » dans l’aide de DAO.

## <a name="cdaorecordsetgettype"></a><a name="gettype"></a> CDaoRecordset :: GetType

Appelez cette fonction membre après avoir ouvert le Recordset pour déterminer le type de l’objet Recordset.

```cpp
short GetType();
```

### <a name="return-value"></a>Valeur renvoyée

L’une des valeurs suivantes qui indique le type d’un jeu d’enregistrements :

- `dbOpenTable` Recordset de type table

- `dbOpenDynaset` Jeu d’enregistrements de type feuille de réponse dynamique

- `dbOpenSnapshot` Recordset de type instantané

### <a name="remarks"></a>Notes

Pour obtenir des informations connexes, consultez la rubrique « type Property » dans l’aide de DAO.

## <a name="cdaorecordsetgetvalidationrule"></a><a name="getvalidationrule"></a> CDaoRecordset :: GetValidationRule

Appelez cette fonction membre pour déterminer la règle utilisée pour valider les données.

```cpp
CString GetValidationRule();
```

### <a name="return-value"></a>Valeur renvoyée

`CString`Objet contenant une valeur qui valide les données d’un enregistrement au fur et à mesure qu’elles sont modifiées ou ajoutées à une table.

### <a name="remarks"></a>Notes

Cette règle est basée sur du texte et est appliquée chaque fois que la table sous-jacente est modifiée. Si les données ne sont pas autorisées, MFC lève une exception. Le message d’erreur retourné est le texte de la propriété ValidationText de l’objet de champ sous-jacent, s’il est spécifié, ou le texte de l’expression spécifiée par la propriété ValidationRule de l’objet de champ sous-jacent. Vous pouvez appeler [GetValidationText](#getvalidationtext) pour obtenir le texte du message d’erreur.

Par exemple, un champ dans un enregistrement qui requiert le jour du mois peut avoir une règle de validation telle que « DAY BETWEEN 1 AND 31 ».

Pour obtenir des informations connexes, consultez la rubrique « propriété ValidationRule » dans l’aide de DAO.

## <a name="cdaorecordsetgetvalidationtext"></a><a name="getvalidationtext"></a> CDaoRecordset :: GetValidationText

Appelez cette fonction membre pour récupérer le texte de la propriété ValidationText de l’objet de champ sous-jacent.

```cpp
CString GetValidationText();
```

### <a name="return-value"></a>Valeur renvoyée

`CString`Objet contenant le texte du message qui est affiché si la valeur d’un champ ne satisfait pas la règle de validation de l’objet de champ sous-jacent.

### <a name="remarks"></a>Notes

Pour obtenir des informations connexes, consultez la rubrique « propriété MessageSiErreur » dans l’aide de DAO.

## <a name="cdaorecordsetisbof"></a><a name="isbof"></a> CDaoRecordset :: IsBOF

Appelez cette fonction membre avant de faire défiler d’un enregistrement à un autre pour savoir si vous êtes allé avant le premier enregistrement du jeu d’enregistrements.

```cpp
BOOL IsBOF() const;
```

### <a name="return-value"></a>Valeur renvoyée

Valeur différente de zéro si le jeu d’enregistrements ne contient aucun enregistrement ou si vous avez fait défiler vers le haut le premier enregistrement ; Sinon, 0.

### <a name="remarks"></a>Notes

Vous pouvez également appeler `IsBOF` avec `IsEOF` pour déterminer si le Recordset contient des enregistrements ou s’il est vide. Immédiatement après l’appel `Open` de, si le jeu d’enregistrements ne contient aucun enregistrement, retourne une valeur `IsBOF` différente de zéro. Lorsque vous ouvrez un jeu d’enregistrements qui a au moins un enregistrement, le premier enregistrement est l’enregistrement actif et `IsBOF` retourne 0.

Si le premier enregistrement est l’enregistrement en cours et que vous appelez `MovePrev` , retourne par la `IsBOF` suite une valeur différente de zéro. Si `IsBOF` retourne une valeur différente de zéro et que vous appelez `MovePrev` , une exception est levée. Si `IsBOF` retourne une valeur différente de zéro, l’enregistrement actif n’est pas défini et toute action qui requiert un enregistrement en cours entraîne une exception.

Effet de méthodes spécifiques sur `IsBOF` les `IsEOF` paramètres et :

- L’appel de en `Open*` interne rend le premier enregistrement dans le jeu d’enregistrements de l’enregistrement actuel en appelant `MoveFirst` . Par conséquent, `Open` l’appel de sur un jeu d’enregistrements vide provoque `IsBOF` et retourne une valeur `IsEOF` différente de zéro. (Consultez le tableau suivant pour connaître le comportement d’un `MoveFirst` appel ou d’un échec `MoveLast` .)

- Toutes les opérations de déplacement qui localisent correctement un enregistrement entraînent à la fois `IsBOF` et `IsEOF` à retourner 0.

- Un `AddNew` appel suivi d’un `Update` appel qui insère correctement un nouvel enregistrement entraîne le `IsBOF` retour de 0, mais uniquement si `IsEOF` est déjà différent de zéro. L’état de `IsEOF` restera toujours inchangé. Comme défini par le moteur de base de données Microsoft Jet, le pointeur d’enregistrement actif d’un jeu d’enregistrements vide se trouve à la fin d’un fichier, de sorte que tout nouvel enregistrement est inséré après l’enregistrement actif.

- Tout `Delete` appel, même s’il supprime le seul enregistrement restant d’un jeu d’enregistrements, ne modifie pas la valeur de `IsBOF` ou `IsEOF` .

Ce tableau indique les opérations de déplacement autorisées avec différentes combinaisons de `IsBOF` /  `IsEOF` .

|State|MoveFirst, MoveLast|MovePrev<br /><br /> Déplacer < 0|Déplacer 0|MoveNext<br /><br /> Déplacer > 0|
|------|-------------------------|-----------------------------|------------|-----------------------------|
|`IsBOF`= différent de zéro,<br /><br /> `IsEOF`=0|Autorisé|Exception|Exception|Autorisé|
|`IsBOF`=0,<br /><br /> `IsEOF`= différent de zéro|Autorisé|Autorisé|Exception|Exception|
|Non nul|Exception|Exception|Exception|Exception|
|Les deux|Autorisé|Autorisé|Autorisé|Autorisé|

L’autorisation d’une opération de déplacement ne signifie pas que l’opération parviendra à localiser un enregistrement. Il indique simplement qu’une tentative d’exécution de l’opération de déplacement spécifiée est autorisée et ne génère pas d’exception. La valeur des `IsBOF` `IsEOF` fonctions membres et peut changer à la suite de la tentative de déplacement.

L’effet des opérations de déplacement qui ne localisent pas un enregistrement sur la valeur de `IsBOF` et les `IsEOF` paramètres est indiqué dans le tableau suivant.

|Operations|IsBOF|IsEOF|
|------|-----------|-----------|
|`MoveFirst`, `MoveLast`|Différente|Différente|
|`Move` 0|Aucun changement|Aucun changement|
|`MovePrev`, `Move` < 0|Différente|Aucun changement|
|`MoveNext`, `Move` > 0|Aucun changement|Différente|

Pour obtenir des informations connexes, consultez la rubrique « propriétés BOF, EOF » dans l’aide de DAO.

## <a name="cdaorecordsetisdeleted"></a><a name="isdeleted"></a> CDaoRecordset :: IsDeleted

Appelez cette fonction membre pour déterminer si l’enregistrement en cours a été supprimé.

```cpp
BOOL IsDeleted() const;
```

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si le jeu d’enregistrements est positionné sur un enregistrement supprimé ; Sinon, 0.

### <a name="remarks"></a>Notes

Si vous faites défiler vers un enregistrement et que `IsDeleted` retourne true (différent de zéro), vous devez faire défiler vers un autre enregistrement avant de pouvoir effectuer d’autres opérations sur les jeux d’enregistrements.

> [!NOTE]
> Vous n’avez pas besoin de vérifier l’état supprimé pour les enregistrements d’un instantané ou d’un jeu d’enregistrements de type table. Étant donné que les enregistrements ne peuvent pas être supprimés d’un instantané, il n’est pas nécessaire d’appeler `IsDeleted` . Pour les jeux d’enregistrements de type table, les enregistrements supprimés sont en fait supprimés du Recordset. Une fois qu’un enregistrement a été supprimé, par vous-même, par un autre utilisateur ou un autre jeu d’enregistrements, vous ne pouvez pas faire défiler vers cet enregistrement. Par conséquent, il n’est pas nécessaire d’appeler `IsDeleted` .

Lorsque vous supprimez un enregistrement d’une feuille de réponse dynamique, il est supprimé du Recordset et vous ne pouvez pas le faire défiler vers cet enregistrement. Toutefois, si un enregistrement dans une feuille de réponse dynamique est supprimé par un autre utilisateur ou dans un autre jeu d’enregistrements basé sur la même table, `IsDeleted` retourne la valeur true lorsque vous faites défiler ultérieurement vers cet enregistrement.

Pour obtenir des informations connexes, consultez les rubriques « Delete Method », « LastModified Property » et « EditMode Property » dans l’aide de DAO.

## <a name="cdaorecordsetiseof"></a><a name="iseof"></a> CDaoRecordset :: IsEOF

Appelez cette fonction membre lorsque vous faites défiler d’un enregistrement à l’autre pour savoir si vous avez dépassé le dernier enregistrement du jeu d’enregistrements.

```cpp
BOOL IsEOF() const;
```

### <a name="return-value"></a>Valeur renvoyée

Valeur différente de zéro si le jeu d’enregistrements ne contient aucun enregistrement ou si vous avez défilé au-delà du dernier enregistrement. Sinon, 0.

### <a name="remarks"></a>Notes

Vous pouvez également appeler `IsEOF` pour déterminer si le Recordset contient des enregistrements ou s’il est vide. Immédiatement après l’appel `Open` de, si le jeu d’enregistrements ne contient aucun enregistrement, retourne une valeur `IsEOF` différente de zéro. Lorsque vous ouvrez un jeu d’enregistrements qui a au moins un enregistrement, le premier enregistrement est l’enregistrement actif et `IsEOF` retourne 0.

Si le dernier enregistrement est l’enregistrement en cours lorsque vous appelez `MoveNext` , retourne par la `IsEOF` suite une valeur différente de zéro. Si `IsEOF` retourne une valeur différente de zéro et que vous appelez `MoveNext` , une exception est levée. Si `IsEOF` retourne une valeur différente de zéro, l’enregistrement actif n’est pas défini et toute action qui requiert un enregistrement en cours entraîne une exception.

Effet de méthodes spécifiques sur `IsBOF` les `IsEOF` paramètres et :

- L’appel de en `Open` interne rend le premier enregistrement dans le jeu d’enregistrements de l’enregistrement actuel en appelant `MoveFirst` . Par conséquent, `Open` l’appel de sur un jeu d’enregistrements vide provoque `IsBOF` et retourne une valeur `IsEOF` différente de zéro. (Consultez le tableau suivant pour connaître le comportement d’un `MoveFirst` appel ayant échoué.)

- Toutes les opérations de déplacement qui localisent correctement un enregistrement entraînent à la fois `IsBOF` et `IsEOF` à retourner 0.

- Un `AddNew` appel suivi d’un `Update` appel qui insère correctement un nouvel enregistrement entraîne le `IsBOF` retour de 0, mais uniquement si `IsEOF` est déjà différent de zéro. L’état de `IsEOF` restera toujours inchangé. Comme défini par le moteur de base de données Microsoft Jet, le pointeur d’enregistrement actif d’un jeu d’enregistrements vide se trouve à la fin d’un fichier, de sorte que tout nouvel enregistrement est inséré après l’enregistrement actif.

- Tout `Delete` appel, même s’il supprime le seul enregistrement restant d’un jeu d’enregistrements, ne modifie pas la valeur de `IsBOF` ou `IsEOF` .

Ce tableau indique les opérations de déplacement autorisées avec différentes combinaisons de `IsBOF` /  `IsEOF` .

|State|MoveFirst, MoveLast|MovePrev<br /><br /> Déplacer < 0|Déplacer 0|MoveNext<br /><br /> Déplacer > 0|
|------|-------------------------|-----------------------------|------------|-----------------------------|
|`IsBOF`= différent de zéro,<br /><br /> `IsEOF`=0|Autorisé|Exception|Exception|Autorisé|
|`IsBOF`=0,<br /><br /> `IsEOF`= différent de zéro|Autorisé|Autorisé|Exception|Exception|
|Non nul|Exception|Exception|Exception|Exception|
|Les deux|Autorisé|Autorisé|Autorisé|Autorisé|

L’autorisation d’une opération de déplacement ne signifie pas que l’opération parviendra à localiser un enregistrement. Il indique simplement qu’une tentative d’exécution de l’opération de déplacement spécifiée est autorisée et ne génère pas d’exception. La valeur des `IsBOF` `IsEOF` fonctions membres et peut changer à la suite de la tentative de déplacement.

L’effet des opérations de déplacement qui ne localisent pas un enregistrement sur la valeur de `IsBOF` et les `IsEOF` paramètres est indiqué dans le tableau suivant.

|Operations|IsBOF|IsEOF|
|------|-----------|-----------|
|`MoveFirst`, `MoveLast`|Différente|Différente|
|`Move` 0|Aucun changement|Aucun changement|
|`MovePrev`, `Move` < 0|Différente|Aucun changement|
|`MoveNext`, `Move` > 0|Aucun changement|Différente|

Pour obtenir des informations connexes, consultez la rubrique « propriétés BOF, EOF » dans l’aide de DAO.

## <a name="cdaorecordsetisfielddirty"></a><a name="isfielddirty"></a> CDaoRecordset :: IsFieldDirty

Appelez cette fonction membre pour déterminer si le membre de données de champ spécifié d’une feuille de réponse dynamique a été marqué comme « modifié » (modifié).

```cpp
BOOL IsFieldDirty(void* pv);
```

### <a name="parameters"></a>Paramètres

*va*<br/>
Pointeur vers le membre de données de champ dont vous souhaitez vérifier l’État, ou NULL pour déterminer si l’un des champs est impropre.

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si le membre de données de champ spécifié est marqué comme modifié ; Sinon, 0.

### <a name="remarks"></a>Notes

Les données de tous les membres de données de champ non modifiés seront transférées vers l’enregistrement sur la source de données lorsque l’enregistrement actif est mis à jour par un appel à la `Update` fonction membre de `CDaoRecordset` (suite à un appel à `Edit` ou `AddNew` ). Grâce à ces informations, vous pouvez prendre des mesures supplémentaires, comme annuler l’indicateur du membre de données de champ pour marquer la colonne afin qu’elle ne soit pas écrite dans la source de données.

`IsFieldDirty` est implémenté par le biais de `DoFieldExchange` .

## <a name="cdaorecordsetisfieldnull"></a><a name="isfieldnull"></a> CDaoRecordset :: IsFieldNull

Appelez cette fonction membre pour déterminer si le membre de données de champ spécifié d’un jeu d’enregistrements a été marqué comme null.

```cpp
BOOL IsFieldNull(void* pv);
```

### <a name="parameters"></a>Paramètres

*va*<br/>
Pointeur vers le membre de données de champ dont vous souhaitez vérifier l’État, ou NULL pour déterminer si l’un des champs a la valeur null.

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si le membre de données de champ spécifié est marqué comme null ; Sinon, 0.

### <a name="remarks"></a>Notes

(Dans la terminologie de base de données, null signifie « aucune valeur » et n’est pas identique à NULL en C++.) Si un membre de données de champ est marqué comme null, il est interprété comme une colonne de l’enregistrement actif pour lequel il n’y a aucune valeur.

> [!NOTE]
> Dans certaines situations, l’utilisation de `IsFieldNull` peut être inefficace, comme l’illustre l’exemple de code suivant :

[!code-cpp[NVC_MFCDatabase#5](../../mfc/codesnippet/cpp/cdaorecordset-class_5.cpp)]

> [!NOTE]
> Si vous utilisez la liaison d’enregistrement dynamique, sans dériver de `CDaoRecordset` , veillez à utiliser VT_NULL comme indiqué dans l’exemple.

## <a name="cdaorecordsetisfieldnullable"></a><a name="isfieldnullable"></a> CDaoRecordset :: IsFieldNullable

Appelez cette fonction membre pour déterminer si le membre de données de champ spécifié est « Nullable » (peut être défini sur une valeur null ; C++ NULL n’est pas identique à null, ce qui, dans la terminologie de base de données, signifie « aucune valeur »).

```cpp
BOOL IsFieldNullable(void* pv);
```

### <a name="parameters"></a>Paramètres

*va*<br/>
Pointeur vers le membre de données de champ dont vous souhaitez vérifier l’État, ou NULL pour déterminer si l’un des champs a la valeur null.

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si le membre de données de champ spécifié peut avoir la valeur null ; Sinon, 0.

### <a name="remarks"></a>Notes

Un champ qui ne peut pas être null doit avoir une valeur. Si vous tentez de définir un tel champ avec la valeur null lors de l’ajout ou de la mise à jour d’un enregistrement, la source de données rejette l’ajout ou la mise à jour et `Update` lèvera une exception. L’exception se produit lorsque vous appelez `Update` , et non lorsque vous appelez `SetFieldNull` .

## <a name="cdaorecordsetisopen"></a><a name="isopen"></a> CDaoRecordset :: IsOpen

Appelez cette fonction membre pour déterminer si le jeu d’enregistrements est ouvert.

```cpp
BOOL IsOpen() const;
```

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si la fonction membre ou de l’objet Recordset `Open` `Requery` a été précédemment appelée et que le Recordset n’a pas été fermé ; sinon, 0.

### <a name="remarks"></a>Notes

## <a name="cdaorecordsetm_bcheckcachefordirtyfields"></a><a name="m_bcheckcachefordirtyfields"></a> CDaoRecordset :: m_bCheckCacheForDirtyFields

Contient un indicateur qui spécifie si les champs mis en cache sont automatiquement marqués comme modifiés (modifiés) et null.

### <a name="remarks"></a>Notes

La valeur par défaut de l’indicateur est TRUE. Le paramètre dans ce membre de données contrôle l’ensemble du mécanisme de double mise en mémoire tampon. Si vous affectez la valeur TRUE à l’indicateur, vous pouvez désactiver la mise en cache sur une base champ par champ à l’aide du mécanisme DFX. Si vous affectez à l’indicateur la valeur FALSe, vous devez appeler `SetFieldDirty` et vous `SetFieldNull` -même.

Définissez ce membre de données avant d’appeler `Open` . Ce mécanisme est principalement destiné à faciliter l’utilisation. Les performances peuvent être plus lentes en raison de la double mise en mémoire tampon des champs au fur et à mesure que des modifications sont apportées.

## <a name="cdaorecordsetm_nfields"></a><a name="m_nfields"></a> CDaoRecordset :: m_nFields

Contient le nombre de membres de données de champ dans la classe de Recordset et le nombre de colonnes sélectionnées par le Recordset de la source de données.

### <a name="remarks"></a>Notes

Le constructeur pour la classe Recordset doit s’initialiser `m_nFields` avec le nombre correct de champs liés statiquement. ClassWizard écrit cette initialisation pour vous quand vous l’utilisez pour déclarer votre classe de Recordset. Vous pouvez également l’écrire manuellement.

L’infrastructure utilise ce nombre pour gérer l’interaction entre les membres de données de champ et les colonnes correspondantes de l’enregistrement actuel sur la source de données.

> [!NOTE]
> Ce nombre doit correspondre au nombre de colonnes de sortie inscrites dans `DoFieldExchange` après un appel à `SetFieldType` avec le paramètre `CDaoFieldExchange::outputColumn` .

Vous pouvez lier des colonnes de manière dynamique à l’aide de `CDaoRecordset::GetFieldValue` et de `CDaoRecordset::SetFieldValue` . Dans ce cas, vous n’avez pas besoin d’incrémenter le nombre dans `m_nFields` pour refléter le nombre d’appels de fonction DFX dans votre `DoFieldExchange` fonction membre.

## <a name="cdaorecordsetm_nparams"></a><a name="m_nparams"></a> CDaoRecordset :: m_nParams

Contient le nombre de membres de données de paramètre dans la classe Recordset (le nombre de paramètres transmis avec la requête du Recordset).

### <a name="remarks"></a>Notes

Si votre classe de Recordset contient des membres de données de paramètre, le constructeur de la classe doit initialiser *m_nParams* avec le nombre correct. La valeur de *m_nParams* par défaut est 0. Si vous ajoutez des membres de données de paramètre (que vous devez effectuer manuellement), vous devez également ajouter manuellement une initialisation dans le constructeur de classe pour refléter le nombre de paramètres (qui doit être au moins aussi grand que le nombre d’espaces réservés «» dans votre *m_strFilter* ou *m_strSort* chaîne).

L’infrastructure utilise ce nombre lorsqu’il paramètre la requête du Recordset.

> [!NOTE]
> Ce nombre doit correspondre au nombre de « params » inscrits dans `DoFieldExchange` après un appel à `SetFieldType` avec le paramètre `CFieldExchange::param` .

Pour obtenir des informations connexes, consultez la rubrique « objet Parameter » dans l’aide de DAO.

## <a name="cdaorecordsetm_pdaorecordset"></a><a name="m_pdaorecordset"></a> CDaoRecordset :: m_pDAORecordset

Contient un pointeur vers l’interface OLE pour l’objet recordset DAO sous-jacent à l' `CDaoRecordset` objet.

### <a name="remarks"></a>Notes

Utilisez ce pointeur si vous devez accéder directement à l’interface DAO.

Pour obtenir des informations connexes, consultez la rubrique « objet Recordset » dans l’aide de DAO.

## <a name="cdaorecordsetm_pdatabase"></a><a name="m_pdatabase"></a> CDaoRecordset :: m_pDatabase

Contient un pointeur vers l' `CDaoDatabase` objet par le biais duquel le Recordset est connecté à une source de données.

### <a name="remarks"></a>Notes

Cette variable est définie de deux manières. En général, vous transmettez un pointeur vers un `CDaoDatabase` objet déjà ouvert quand vous construisez l’objet Recordset. Si vous transmettez une valeur NULL `CDaoRecordset` à la place, crée un `CDaoDatabase` objet pour vous et l’ouvre. Dans les deux cas, `CDaoRecordset` stocke le pointeur dans cette variable.

Normalement, il n’est pas nécessaire d’utiliser directement le pointeur stocké dans `m_pDatabase` . Toutefois, si vous écrivez vos propres extensions dans `CDaoRecordset` , vous devrez peut-être utiliser le pointeur. Par exemple, vous pouvez avoir besoin du pointeur si vous levez votre `CDaoException` ou vos propres.

Pour obtenir des informations connexes, consultez la rubrique « objet de base de données » dans l’aide de DAO.

## <a name="cdaorecordsetm_strfilter"></a><a name="m_strfilter"></a> CDaoRecordset :: m_strFilter

Contient une chaîne utilisée pour construire la clause **Where** d’une instruction SQL.

### <a name="remarks"></a>Notes

Elle n’inclut pas le mot réservé **dans lequel** filtrer l’ensemble d’enregistrements. L’utilisation de ce membre de données ne s’applique pas aux recordsets de type table. L’utilisation de `m_strFilter` n’a aucun effet lors de l’ouverture d’un recordset à l’aide d’un `CDaoQueryDef` pointeur.

Utilisez le format de date U.S. (mois-jour-année) lorsque vous filtrez des champs contenant des dates, même si vous n’utilisez pas la version américaine du moteur de base de données Microsoft Jet. dans le cas contraire, les données risquent de ne pas être filtrées comme prévu.

Pour obtenir des informations connexes, consultez la rubrique « propriété de filtre » dans l’aide de DAO.

## <a name="cdaorecordsetm_strsort"></a><a name="m_strsort"></a> CDaoRecordset :: m_strSort

Contient une chaîne contenant la clause **orderby** d’une instruction SQL sans les mots réservés **orderby**.

### <a name="remarks"></a>Notes

Vous pouvez effectuer un tri sur les objets Recordset de type feuille de réponse dynamique et instantané.

Vous ne pouvez pas trier les objets Recordset de type table. Pour déterminer l’ordre de tri d’un jeu d’enregistrements de type table, appelez [SetCurrentIndex](#setcurrentindex).

L’utilisation de *m_strSort* n’a aucun effet lors de l’ouverture d’un recordset à l’aide d’un `CDaoQueryDef` pointeur.

Pour obtenir des informations connexes, consultez la rubrique « sort Property » dans l’aide de DAO.

## <a name="cdaorecordsetmove"></a><a name="move"></a> CDaoRecordset :: Move

Appelez cette fonction membre pour positionner les enregistrements *lRows* de l’ensemble d’enregistrements à partir de l’enregistrement en cours.

```cpp
virtual void Move(long lRows);
```

### <a name="parameters"></a>Paramètres

*lRows*<br/>
Nombre d’enregistrements à déplacer vers l’avant ou vers l’arrière. Les valeurs positives se déplacent vers la fin de l’ensemble d’enregistrements. Les valeurs négatives se déplacent vers l’arrière, vers le début.

### <a name="remarks"></a>Notes

Vous pouvez vous déplacer vers l’avant ou vers l’arrière. `Move( 1 )` équivaut à `MoveNext` , et `Move( -1 )` équivaut à `MovePrev` .

> [!CAUTION]
> L’appel de l’une des `Move` fonctions lève une exception si le Recordset n’a pas d’enregistrement. En général, appelez `IsBOF` `IsEOF` à la fois et avant une opération de déplacement pour déterminer si le Recordset contient des enregistrements. Après avoir appelé `Open` ou `Requery` , appelez `IsBOF` ou `IsEOF` .

> [!NOTE]
> Si vous avez défilé au-delà du début ou de la fin du recordset ( `IsBOF` ou que `IsEOF` retourne une valeur différente de zéro), un appel à `Move` lève une exception `CDaoException` .

> [!NOTE]
> Si vous appelez l’une des `Move` fonctions lors de la mise à jour ou de l’ajout de l’enregistrement actif, les mises à jour sont perdues sans avertissement.

Lorsque vous appelez `Move` sur un instantané de défilement avant uniquement, le paramètre *lRows* doit être un entier positif et les signets ne sont pas autorisés. vous pouvez donc avancer uniquement.

Pour créer l’enregistrement First, Last, Next ou Previous dans un Recordset de l’enregistrement actuel, appelez la `MoveFirst` `MoveLast` fonction membre,, `MoveNext` ou `MovePrev` .

Pour obtenir des informations connexes, consultez les rubriques « méthode Move » et « MoveFirst, MoveLast, MoveNext, MovePrevious Methods » dans l’aide de DAO.

## <a name="cdaorecordsetmovefirst"></a><a name="movefirst"></a> CDaoRecordset :: MoveFirst

Appelez cette fonction membre pour créer le premier enregistrement dans le jeu d’enregistrements (le cas échéant) de l’enregistrement en cours.

```cpp
void MoveFirst();
```

### <a name="remarks"></a>Notes

Vous n’avez pas à appeler `MoveFirst` immédiatement après l’ouverture de l’ensemble d’enregistrements. À ce moment-là, le premier enregistrement (le cas échéant) est automatiquement l’enregistrement en cours.

> [!CAUTION]
> L’appel de l’une des `Move` fonctions lève une exception si le Recordset n’a pas d’enregistrement. En général, appelez `IsBOF` `IsEOF` à la fois et avant une opération de déplacement pour déterminer si le Recordset contient des enregistrements. Après avoir appelé `Open` ou `Requery` , appelez `IsBOF` ou `IsEOF` .

> [!NOTE]
> Si vous appelez l’une des `Move` fonctions lors de la mise à jour ou de l’ajout de l’enregistrement actif, les mises à jour sont perdues sans avertissement.

Utilisez les `Move` fonctions pour vous déplacer d’un enregistrement à un autre sans appliquer une condition. Utilisez les opérations de recherche pour localiser des enregistrements dans un objet Recordset de type feuille de réponse dynamique ou instantané qui remplissent une certaine condition. Pour localiser un enregistrement dans un objet Recordset de type table, appelez `Seek` .

Si le Recordset fait référence à un jeu d’enregistrements de type table, le déplacement suit l’index actuel de la table. Vous pouvez définir l’index actuel à l’aide de la propriété index de l’objet DAO sous-jacent. Si vous ne définissez pas l’index actuel, l’ordre des enregistrements retournés n’est pas défini.

Si vous appelez `MoveLast` sur un objet Recordset basé sur une requête SQL ou une querydef, la requête est forcée à se terminer et l’objet Recordset est entièrement rempli.

Vous ne pouvez pas appeler la `MoveFirst` `MovePrev` fonction membre ou avec un instantané de défilement avant uniquement.

Pour déplacer la position de l’enregistrement actif dans un objet Recordset un nombre spécifique d’enregistrements vers l’avant ou vers l’arrière, appelez `Move` .

Pour obtenir des informations connexes, consultez les rubriques « méthode Move » et « MoveFirst, MoveLast, MoveNext, MovePrevious Methods » dans l’aide de DAO.

## <a name="cdaorecordsetmovelast"></a><a name="movelast"></a> CDaoRecordset :: MoveLast

Appelez cette fonction membre pour créer le dernier enregistrement (le cas échéant) dans le Recordset de l’enregistrement actuel.

```cpp
void MoveLast();
```

### <a name="remarks"></a>Notes

> [!CAUTION]
> L’appel de l’une des `Move` fonctions lève une exception si le Recordset n’a pas d’enregistrement. En général, appelez `IsBOF` `IsEOF` à la fois et avant une opération de déplacement pour déterminer si le Recordset contient des enregistrements. Après avoir appelé `Open` ou `Requery` , appelez `IsBOF` ou `IsEOF` .

> [!NOTE]
> Si vous appelez l’une des `Move` fonctions lors de la mise à jour ou de l’ajout de l’enregistrement actif, les mises à jour sont perdues sans avertissement.

Utilisez les `Move` fonctions pour vous déplacer d’un enregistrement à un autre sans appliquer une condition. Utilisez les opérations de recherche pour localiser des enregistrements dans un objet Recordset de type feuille de réponse dynamique ou instantané qui remplissent une certaine condition. Pour localiser un enregistrement dans un objet Recordset de type table, appelez `Seek` .

Si le Recordset fait référence à un jeu d’enregistrements de type table, le déplacement suit l’index actuel de la table. Vous pouvez définir l’index actuel à l’aide de la propriété index de l’objet DAO sous-jacent. Si vous ne définissez pas l’index actuel, l’ordre des enregistrements retournés n’est pas défini.

Si vous appelez `MoveLast` sur un objet Recordset basé sur une requête SQL ou une querydef, la requête est forcée à se terminer et l’objet Recordset est entièrement rempli.

Pour déplacer la position de l’enregistrement actif dans un objet Recordset un nombre spécifique d’enregistrements vers l’avant ou vers l’arrière, appelez `Move` .

Pour obtenir des informations connexes, consultez les rubriques « méthode Move » et « MoveFirst, MoveLast, MoveNext, MovePrevious Methods » dans l’aide de DAO.

## <a name="cdaorecordsetmovenext"></a><a name="movenext"></a> CDaoRecordset :: MoveNext

Appelez cette fonction membre pour créer l’enregistrement suivant dans le jeu d’enregistrements actuel.

```cpp
void MoveNext();
```

### <a name="remarks"></a>Notes

Il est recommandé d’appeler `IsBOF` avant d’essayer de passer à l’enregistrement précédent. Un appel à `MovePrev` lève une exception `CDaoException` si `IsBOF` retourne une valeur différente de zéro, ce qui indique que vous avez déjà défilé avant le premier enregistrement ou qu’aucun enregistrement n’a été sélectionné par le Recordset.

> [!CAUTION]
> L’appel de l’une des `Move` fonctions lève une exception si le Recordset n’a pas d’enregistrement. En général, appelez `IsBOF` `IsEOF` à la fois et avant une opération de déplacement pour déterminer si le Recordset contient des enregistrements. Après avoir appelé `Open` ou `Requery` , appelez `IsBOF` ou `IsEOF` .

> [!NOTE]
> Si vous appelez l’une des `Move` fonctions lors de la mise à jour ou de l’ajout de l’enregistrement actif, les mises à jour sont perdues sans avertissement.

Utilisez les `Move` fonctions pour vous déplacer d’un enregistrement à un autre sans appliquer une condition. Utilisez les opérations de recherche pour localiser des enregistrements dans un objet Recordset de type feuille de réponse dynamique ou instantané qui remplissent une certaine condition. Pour localiser un enregistrement dans un objet Recordset de type table, appelez `Seek` .

Si le Recordset fait référence à un jeu d’enregistrements de type table, le déplacement suit l’index actuel de la table. Vous pouvez définir l’index actuel à l’aide de la propriété index de l’objet DAO sous-jacent. Si vous ne définissez pas l’index actuel, l’ordre des enregistrements retournés n’est pas défini.

Pour déplacer la position de l’enregistrement actif dans un objet Recordset un nombre spécifique d’enregistrements vers l’avant ou vers l’arrière, appelez `Move` .

Pour obtenir des informations connexes, consultez les rubriques « méthode Move » et « MoveFirst, MoveLast, MoveNext, MovePrevious Methods » dans l’aide de DAO.

## <a name="cdaorecordsetmoveprev"></a><a name="moveprev"></a> CDaoRecordset :: MovePrev

Appelez cette fonction membre pour créer l’enregistrement précédent dans le jeu d’enregistrements actuel.

```cpp
void MovePrev();
```

### <a name="remarks"></a>Notes

Il est recommandé d’appeler `IsBOF` avant d’essayer de passer à l’enregistrement précédent. Un appel à `MovePrev` lève une exception `CDaoException` si `IsBOF` retourne une valeur différente de zéro, ce qui indique que vous avez déjà défilé avant le premier enregistrement ou qu’aucun enregistrement n’a été sélectionné par le Recordset.

> [!CAUTION]
> L’appel de l’une des `Move` fonctions lève une exception si le Recordset n’a pas d’enregistrement. En général, appelez `IsBOF` `IsEOF` à la fois et avant une opération de déplacement pour déterminer si le Recordset contient des enregistrements. Après avoir appelé `Open` ou `Requery` , appelez `IsBOF` ou `IsEOF` .

> [!NOTE]
> Si vous appelez l’une des `Move` fonctions lors de la mise à jour ou de l’ajout de l’enregistrement actif, les mises à jour sont perdues sans avertissement.

Utilisez les `Move` fonctions pour vous déplacer d’un enregistrement à un autre sans appliquer une condition. Utilisez les opérations de recherche pour localiser des enregistrements dans un objet Recordset de type feuille de réponse dynamique ou instantané qui remplissent une certaine condition. Pour localiser un enregistrement dans un objet Recordset de type table, appelez `Seek` .

Si le Recordset fait référence à un jeu d’enregistrements de type table, le déplacement suit l’index actuel de la table. Vous pouvez définir l’index actuel à l’aide de la propriété index de l’objet DAO sous-jacent. Si vous ne définissez pas l’index actuel, l’ordre des enregistrements retournés n’est pas défini.

Vous ne pouvez pas appeler la `MoveFirst` `MovePrev` fonction membre ou avec un instantané de défilement avant uniquement.

Pour déplacer la position de l’enregistrement actif dans un objet Recordset un nombre spécifique d’enregistrements vers l’avant ou vers l’arrière, appelez `Move` .

Pour obtenir des informations connexes, consultez les rubriques « méthode Move » et « MoveFirst, MoveLast, MoveNext, MovePrevious Methods » dans l’aide de DAO.

## <a name="cdaorecordsetopen"></a><a name="open"></a> CDaoRecordset :: Open

Vous devez appeler cette fonction membre pour récupérer les enregistrements du Recordset.

```cpp
virtual void Open(
    int nOpenType = AFX_DAO_USE_DEFAULT_TYPE,
    LPCTSTR lpszSQL = NULL,
    int nOptions = 0);

virtual void Open(
    CDaoTableDef* pTableDef,
    int nOpenType = dbOpenTable,
    int nOptions = 0);

virtual void Open(
    CDaoQueryDef* pQueryDef,
    int nOpenType = dbOpenDynaset,
    int nOptions = 0);
```

### <a name="parameters"></a>Paramètres

*nOpenType*<br/>
Une des valeurs suivantes :

- `dbOpenDynaset` Jeu d’enregistrements de type Dynaset avec défilement bidirectionnel. Il s’agit de la valeur par défaut.

- `dbOpenTable` Un jeu d’enregistrements de type table avec défilement bidirectionnel.

- `dbOpenSnapshot` Jeu d’enregistrements de type instantané avec défilement bidirectionnel.

*lpszSQL*<br/>
Pointeur de chaîne contenant l’un des éléments suivants :

- Pointeur NULL.

- Nom d’un ou plusieurs objets TableDef et/ou querydefs (séparés par des virgules).

- Une instruction SQL **Select** (éventuellement avec une clause SQL **Where** ou **orderby** ).

- Requête directe.

*nOptions*<br/>
Une ou plusieurs des options ci-dessous. La valeur par défaut est 0. Les valeurs possibles sont les suivantes :

- `dbAppendOnly` Vous pouvez uniquement ajouter de nouveaux enregistrements (jeu d’enregistrements de type feuille de réponse dynamique uniquement). Cette option signifie littéralement que les enregistrements peuvent être ajoutés uniquement. Les classes de base de données ODBC MFC ont une option d’ajout uniquement qui permet d’extraire et d’ajouter des enregistrements.

- `dbForwardOnly` Le jeu d’enregistrements est un instantané de défilement avant uniquement.

- `dbSeeChanges` Générez une exception si un autre utilisateur modifie les données que vous modifiez.

- `dbDenyWrite` Les autres utilisateurs ne peuvent pas modifier ou ajouter des enregistrements.

- `dbDenyRead` Les autres utilisateurs ne peuvent pas afficher les enregistrements (jeu d’enregistrements de type table uniquement).

- `dbReadOnly` Vous ne pouvez afficher que les enregistrements ; les autres utilisateurs peuvent les modifier.

- `dbInconsistent` Les mises à jour incohérentes sont autorisées (jeu d’enregistrements de type feuille de réponse dynamique uniquement).

- `dbConsistent` Seules les mises à jour cohérentes sont autorisées (jeu d’enregistrements de type feuille de réponse dynamique uniquement).

> [!NOTE]
> Les constantes `dbConsistent` et `dbInconsistent` s’excluent mutuellement. Vous pouvez utiliser l’un ou l’autre, mais pas les deux dans une instance donnée de `Open` .

*pTableDef*<br/>
Pointeur vers un objet [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) . Cette version est valide uniquement pour les jeux d’enregistrements de type table. Quand vous utilisez cette option, le `CDaoDatabase` pointeur utilisé pour construire le `CDaoRecordset` n’est pas utilisé ; au lieu de cela, la base de données dans laquelle réside l’objet TableDef est utilisée.

*pQueryDef*<br/>
Pointeur vers un objet [CDaoQueryDef](../../mfc/reference/cdaoquerydef-class.md) . Cette version est valide uniquement pour les jeux d’enregistrements de type Dynaset et Snapshot. Quand vous utilisez cette option, le `CDaoDatabase` pointeur utilisé pour construire le `CDaoRecordset` n’est pas utilisé ; au lieu de cela, la base de données dans laquelle réside la querydef est utilisée.

### <a name="remarks"></a>Notes

Avant `Open` d’appeler, vous devez construire l’objet Recordset. Pour ce faire, plusieurs méthodes sont possibles :

- Lorsque vous construisez l’objet Recordset, transmettez un pointeur vers un `CDaoDatabase` objet qui est déjà ouvert.

- Lorsque vous construisez l’objet Recordset, transmettez un pointeur vers un `CDaoDatabase` objet qui n’est pas ouvert. Le Recordset ouvre un `CDaoDatabase` objet, mais ne le ferme pas au moment de la fermeture de l’objet Recordset.

- Lorsque vous construisez l’objet Recordset, transmettez un pointeur NULL. L’objet Recordset appelle `GetDefaultDBName` pour récupérer le nom de Microsoft Access. Fichier MDB à ouvrir. Le Recordset ouvre ensuite un `CDaoDatabase` objet et le maintient ouvert tant que le jeu d’enregistrements est ouvert. Lorsque vous appelez `Close` sur le Recordset, l' `CDaoDatabase` objet est également fermé.

    > [!NOTE]
    >  Lorsque l’objet Recordset ouvre l' `CDaoDatabase` objet, il ouvre la source de données avec un accès non exclusif.

Pour la version de `Open` qui utilise le paramètre *lpszSQL* , une fois que le jeu d’enregistrements est ouvert, vous pouvez récupérer les enregistrements de plusieurs façons. La première option consiste à avoir des fonctions DFX dans votre `DoFieldExchange` . La deuxième option consiste à utiliser la liaison dynamique en appelant la `GetFieldValue` fonction membre. Ces options peuvent être implémentées séparément ou en combinaison. S’ils sont combinés, vous devrez passer l’instruction SQL vous-même sur l’appel à `Open` .

Lorsque vous utilisez la deuxième version de `Open` où vous transmettez un `CDaoTableDef` objet, les colonnes résultantes sont disponibles pour la liaison via `DoFieldExchange` et le mécanisme DFX, et/ou la liaison dynamique via `GetFieldValue` .

> [!NOTE]
> Vous pouvez appeler uniquement `Open` à l’aide `CDaoTableDef` d’un objet pour les jeux d’enregistrements de type table.

Lorsque vous utilisez la troisième version de `Open` où vous transmettez un `CDaoQueryDef` objet, cette requête est exécutée, et les colonnes résultantes sont disponibles pour la liaison via `DoFieldExchange` et le mécanisme DFX, et/ou la liaison dynamique via `GetFieldValue` .

> [!NOTE]
> Vous pouvez appeler uniquement `Open` à l’aide `CDaoQueryDef` d’un objet pour les jeux d’enregistrements de type Dynaset et Snapshot.

Pour la première version de `Open` qui utilise le `lpszSQL` paramètre, les enregistrements sont sélectionnés en fonction des critères indiqués dans le tableau suivant.

|Valeur du paramètre `lpszSQL`.|Les enregistrements sélectionnés sont déterminés par|Exemple|
|--------------------------------------|----------------------------------------|-------------|
|NULL|Chaîne retournée par `GetDefaultSQL` .||
|Liste séparée par des virgules d’un ou plusieurs noms d’objets TableDef et/ou querydef.|Toutes les colonnes représentées dans le `DoFieldExchange` .|`"Customer"`|
|**Sélectionner** une colonne dans la liste **des** tables|Colonnes spécifiées dans le ou les TableDef (s) et/ou les querydef spécifiés.|`"SELECT CustId, CustName`<br /><br /> `FROM Customer"`|

La procédure habituelle consiste à passer NULL à `Open` ; dans ce cas, `Open` appelle `GetDefaultSQL` , une fonction membre substituable que ClassWizard génère lors de la création d’une `CDaoRecordset` classe dérivée de. Cette valeur indique le ou les noms de tabledef et/ou de querydef que vous avez spécifiés dans ClassWizard. À la place, vous pouvez spécifier d’autres informations dans le paramètre *lpszSQL* .

Tout ce que vous transmettez, `Open` construit une chaîne SQL finale pour la requête (la chaîne peut avoir des clauses SQL **Where** et **orderby** ajoutées à la chaîne *lpszSQL* que vous avez transmise), puis exécute la requête. Vous pouvez examiner la chaîne construite en appelant `GetSQL` après l’appel de `Open` .

Les données membres de champ de votre classe Recordset sont liées aux colonnes des données sélectionnées. Si des enregistrements sont renvoyés, le premier enregistrement devient l’enregistrement en cours.

Si vous souhaitez définir des options pour le Recordset, telles qu’un filtre ou un tri, un jeu `m_strSort` ou `m_strFilter` une fois que vous avez construit l’objet Recordset, mais avant d’appeler `Open` . Si vous souhaitez actualiser les enregistrements dans le jeu d’enregistrements une fois que le Recordset est déjà ouvert, appelez `Requery` .

Si vous appelez `Open` sur un jeu d’enregistrements de type feuille de réponse dynamique ou instantané, ou si la source de données fait référence à une instruction SQL ou à une TableDef qui représente une table attachée, vous ne pouvez pas utiliser `dbOpenTable` pour l’argument de type ; si vous le faites, MFC lève une exception. Pour déterminer si un objet TableDef représente une table attachée, créez un objet [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) et appelez sa fonction membre [GetConnect](../../mfc/reference/cdaotabledef-class.md#getconnect) .

Utilisez l' `dbSeeChanges` indicateur si vous souhaitez intercepter les modifications apportées par un autre utilisateur ou un autre programme sur votre ordinateur lors de la modification ou de la suppression du même enregistrement. Par exemple, si deux utilisateurs commencent à modifier le même enregistrement, le premier utilisateur à appeler la `Update` fonction membre est correctement exécuté. Lorsque `Update` est appelé par le deuxième utilisateur, une `CDaoException` exception est levée. De même, si le deuxième utilisateur tente d’appeler `Delete` pour supprimer l’enregistrement et qu’il a déjà été modifié par le premier utilisateur, un `CDaoException` événement se produit.

En règle générale, si l’utilisateur obtient cela `CDaoException` pendant la mise à jour, votre code doit actualiser le contenu des champs et récupérer les valeurs nouvellement modifiées. Si l’exception se produit au cours du processus de suppression, votre code peut afficher les nouvelles données de l’enregistrement à l’utilisateur et un message indiquant que les données ont été modifiées récemment. À ce stade, votre code peut demander une confirmation que l’utilisateur souhaite toujours supprimer l’enregistrement.

> [!TIP]
> Utilisez l’option de défilement avant uniquement ( `dbForwardOnly` ) pour améliorer les performances lorsque votre application effectue une seule passe via un jeu d’enregistrements ouvert à partir d’une source de données ODBC.

Pour obtenir des informations connexes, consultez la rubrique « méthode OpenRecordset » dans l’aide de DAO.

## <a name="cdaorecordsetrequery"></a><a name="requery"></a> CDaoRecordset :: Requery

Appelez cette fonction membre pour régénérer (Actualiser) un Recordset.

```cpp
virtual void Requery();
```

### <a name="remarks"></a>Notes

Si des enregistrements sont renvoyés, le premier enregistrement devient l’enregistrement en cours.

Pour que le recordset reflète les ajouts et les suppressions que vous ou d’autres utilisateurs apportez à la source de données, vous devez reconstruire le Recordset en appelant `Requery` . Si le Recordset est une feuille de réponse dynamique, il reflète automatiquement les mises à jour que vous ou d’autres utilisateurs apportez à ses enregistrements existants (mais pas les ajouts). Si le jeu d’enregistrements est un instantané, vous devez appeler `Requery` pour refléter les modifications apportées par d’autres utilisateurs, ainsi que les ajouts et les suppressions.

Pour une feuille de réponse dynamique ou un instantané, appelez `Requery` chaque fois que vous souhaitez reconstruire le recordset à l’aide des valeurs de paramètre. Définissez le nouveau filtre ou triez en définissant [m_strFilter](#m_strfilter) et [m_strSort](#m_strsort) avant d’appeler `Requery` . Définissez de nouveaux paramètres en assignant de nouvelles valeurs aux membres de données de paramètre avant d’appeler `Requery` .

Si la tentative de régénération du Recordset échoue, le jeu d’enregistrements est fermé. Avant d’appeler `Requery` , vous pouvez déterminer si le jeu d’enregistrements peut être interrogé en appelant la fonction membre [CanRestart](#canrestart) . `CanRestart` ne garantit pas que `Requery` fonctionnera correctement.

> [!CAUTION]
> Appelez `Requery` uniquement après avoir appelé `Open` .

> [!NOTE]
> L’appel de [Requery](#requery) modifie les signets DAO.

Vous ne pouvez pas appeler `Requery` sur un jeu d’enregistrements de type feuille de réponse dynamique ou instantané si l’appel `CanRestart` retourne 0, et vous ne pouvez pas l’utiliser sur un jeu d’enregistrements de type table.

Si `IsBOF` et `IsEOF` retournent tous deux une valeur différente de zéro après `Requery` l’appel de, la requête n’a retourné aucun enregistrement et l’ensemble d’enregistrements ne contient pas de données.

Pour obtenir des informations connexes, consultez la rubrique « méthode de rerequête » dans l’aide de DAO.

## <a name="cdaorecordsetseek"></a><a name="seek"></a> CDaoRecordset :: Seek

Appelez cette fonction membre pour localiser l’enregistrement dans un objet Recordset de type table indexé qui satisfait aux critères spécifiés pour l’index actuel et faire de cet enregistrement l’enregistrement actif.

```cpp
BOOL Seek(
    LPCTSTR lpszComparison,
    COleVariant* pKey1,
    COleVariant* pKey2 = NULL,
    COleVariant* pKey3 = NULL);

BOOL Seek(
    LPCTSTR lpszComparison,
    COleVariant* pKeyArray,
    WORD nKeys);
```

### <a name="parameters"></a>Paramètres

*lpszComparison*<br/>
Une des expressions de chaîne suivantes : « < », « \<=", "=", "> = » ou « > ».

*pKey1*<br/>
Pointeur vers un [COleVariant](../../mfc/reference/colevariant-class.md) dont la valeur correspond au premier champ de l’index. Obligatoire.

*pKey2*<br/>
Pointeur vers un `COleVariant` dont la valeur correspond au deuxième champ de l’index, le cas échéant. La valeur par défaut est NULL.

*pKey3*<br/>
Pointeur vers un `COleVariant` dont la valeur correspond au troisième champ de l’index, le cas échéant. La valeur par défaut est NULL.

*pKeyArray*<br/>
Pointeur vers un tableau de variants. La taille du tableau correspond au nombre de champs dans l’index.

*nKeys*<br/>
Entier correspondant à la taille du tableau, qui est le nombre de champs dans l’index.

> [!NOTE]
> Ne spécifiez pas de caractères génériques dans les clés. Les caractères génériques ne `Seek` renverront aucun enregistrement correspondant.

### <a name="return-value"></a>Valeur renvoyée

Différent de zéro si des enregistrements correspondants sont trouvés ; sinon, 0.

### <a name="remarks"></a>Notes

Utilisez la deuxième version (tableau) de `Seek` pour gérer les index de quatre champs ou plus.

`Seek` active la recherche d’index haute performance sur les jeux d’enregistrements de type table. Vous devez définir l’index actuel en appelant `SetCurrentIndex` avant d’appeler `Seek` . Si l’index identifie un ou des champs de clé non uniques, `Seek` localise le premier enregistrement qui répond aux critères. Si vous ne définissez pas d’index, une exception est levée.

Notez que si vous n’êtes pas en train de créer un jeu d’enregistrements UNICODE, les `COleVariant` objets doivent être explicitement déclarés ANSI. Pour ce faire, vous pouvez utiliser la forme [COleVariant :: COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)** du constructeur *avec vtSrc* défini sur `VT_BSTRT` (ANSI) ou à l’aide de la `COleVariant` fonction [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** avec *vtSrc* défini sur `VT_BSTRT` .

Lorsque vous appelez `Seek` , vous transmettez une ou plusieurs valeurs de clé et un opérateur de comparaison ("<", " \<=", "=", "> =" ou ">"). `Seek` effectue une recherche dans les champs clés spécifiés et recherche le premier enregistrement conforme aux critères spécifiés par *lpszComparison* et *pKey1*. Une fois trouvé, retourne une valeur `Seek` différente de zéro et rend cet enregistrement actif. Si `Seek` ne parvient pas à localiser une correspondance, `Seek` retourne la valeur zéro et l’enregistrement actif n’est pas défini. Lorsque vous utilisez DAO directement, vous devez vérifier explicitement la propriété NoMatch.

Si `lpszComparison` est "=", ">=" ou ">", `Seek` commence au début de l’index. Si *lpszComparison* est « < » ou « <= », `Seek` démarre à la fin de l’index et effectue une recherche vers l’arrière, à moins qu’il y ait des entrées d’index en double à la fin. Dans ce cas, `Seek` commence à une entrée arbitraire parmi les entrées d’index dupliquées à la fin de l’index.

Il n’est pas nécessaire qu’un enregistrement soit actif lorsque vous utilisez `Seek` .

Pour localiser un enregistrement dans un jeu d’enregistrements de type feuille de réponse dynamique ou instantané qui satisfait à une condition spécifique, utilisez les opérations de recherche. Pour inclure tous les enregistrements, pas seulement ceux qui satisfont à une condition spécifique, utilisez les opérations de déplacement pour passer d’un enregistrement à un autre.

Vous ne pouvez pas appeler `Seek` sur une table attachée de n’importe quel type, car les tables attachées doivent être ouvertes en tant que types feuille de réponse dynamique ou Recordset de type instantané. Toutefois, si vous appelez `CDaoDatabase::Open` pour ouvrir directement une base de données ISAM installable, vous pouvez appeler `Seek` sur les tables de cette base de données, même si les performances peuvent être lentes.

Pour obtenir des informations connexes, consultez la rubrique « méthode Seek » dans l’aide de DAO.

## <a name="cdaorecordsetsetabsoluteposition"></a><a name="setabsoluteposition"></a> CDaoRecordset :: SetAbsolutePosition

Définit le numéro d’enregistrement relatif de l’enregistrement actif d’un objet Recordset.

```cpp
void SetAbsolutePosition(long lPosition);
```

### <a name="parameters"></a>Paramètres

*lPosition*<br/>
Correspond à la position ordinale de l’enregistrement en cours dans le Recordset.

### <a name="remarks"></a>Notes

L’appel de `SetAbsolutePosition` vous permet de positionner le pointeur d’enregistrement actif sur un enregistrement spécifique en fonction de sa position ordinale dans un jeu d’enregistrements de type feuille de réponse dynamique ou instantané. Vous pouvez également déterminer le numéro d’enregistrement en cours en appelant [GetAbsolutePosition](#getabsoluteposition).

> [!NOTE]
> Cette fonction membre est valide uniquement pour les jeux d’enregistrements de type Dynaset et Snapshot.

La valeur de la propriété AbsolutePosition de l’objet DAO sous-jacent est de base zéro ; la valeur 0 fait référence au premier enregistrement du jeu d’enregistrements. La définition d’une valeur supérieure au nombre d’enregistrements remplis entraîne la levée d’une exception par MFC. Vous pouvez déterminer le nombre d’enregistrements remplis dans le Recordset en appelant la `GetRecordCount` fonction membre.

Si l’enregistrement en cours est supprimé, la valeur de la propriété AbsolutePosition n’est pas définie et MFC lève une exception si elle est référencée. Les nouveaux enregistrements sont ajoutés à la fin de la séquence.

> [!NOTE]
> Cette propriété n’est pas destinée à être utilisée comme numéro d’enregistrement de substitution. Les signets sont toujours la méthode recommandée pour conserver et retourner à une position donnée et constituent la seule façon de positionner l’enregistrement actuel sur tous les types d’objets Recordset qui prennent en charge les signets. En particulier, la position d’un enregistrement donné change lorsque le ou les enregistrements qui le précèdent sont supprimés. En outre, il n’est pas garanti qu’un enregistrement donné aura la même position absolue si le jeu d’enregistrements est recréé parce que l’ordre des enregistrements individuels au sein d’un jeu d’enregistrements n’est pas garanti, sauf s’il est créé avec une instruction SQL à l’aide d’une clause **orderby** .

Pour obtenir des informations connexes, consultez la rubrique « propriété AbsolutePosition » dans l’aide de DAO.

## <a name="cdaorecordsetsetbookmark"></a><a name="setbookmark"></a> CDaoRecordset :: SetBookmark

Appelez cette fonction membre pour positionner le Recordset sur l’enregistrement contenant le signet spécifié.

```cpp
void SetBookmark(COleVariant varBookmark);
```

### <a name="parameters"></a>Paramètres

*varBookmark*<br/>
Objet [COleVariant](../../mfc/reference/colevariant-class.md) contenant la valeur de signet pour un enregistrement spécifique.

### <a name="remarks"></a>Notes

Lors de la création ou de l’ouverture d’un objet Recordset, chacun de ses enregistrements a déjà un signet unique. Vous pouvez récupérer le signet de l’enregistrement en cours en appelant `GetBookmark` et en enregistrant la valeur dans un `COleVariant` objet. Vous pouvez revenir ultérieurement à cet enregistrement en appelant `SetBookmark` à l’aide de la valeur de signet enregistrée.

> [!NOTE]
> L’appel de [Requery](#requery) modifie les signets DAO.

Notez que si vous n’êtes pas en train de créer un jeu d’enregistrements UNICODE, l' `COleVariant` objet doit être déclaré explicitement en ANSI. Pour ce faire, vous pouvez utiliser la forme [COleVariant :: COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)** du constructeur *avec vtSrc* défini sur `VT_BSTRT` (ANSI) ou à l’aide de la `COleVariant` fonction [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** avec *vtSrc* défini sur `VT_BSTRT` .

Pour obtenir des informations connexes, consultez les rubriques « propriété Bookmark » et propriété Bookmarkable» dans l’aide de DAO.

## <a name="cdaorecordsetsetcachesize"></a><a name="setcachesize"></a> CDaoRecordset :: SetCacheSize

Appelez cette fonction membre pour définir le nombre d’enregistrements à mettre en cache.

```cpp
void SetCacheSize(long lSize);
```

### <a name="parameters"></a>Paramètres

*lSize*<br/>
Spécifie le nombre d’enregistrements. Une valeur typique est 100. La valeur 0 désactive la mise en cache. Le paramètre doit être compris entre 5 et 1200 enregistrements. Le cache peut utiliser une quantité considérable de mémoire.

### <a name="remarks"></a>Notes

Un cache est un espace dans la mémoire locale qui contient les données les plus récemment récupérées à partir du serveur dans le cas où les données seront de nouveau demandées pendant l’exécution de l’application. La mise en cache des données améliore les performances d’une application qui récupère des données à partir d’un serveur distant par le biais d’objets Recordset de type feuille de réponse dynamique. Lorsque des données sont demandées, le moteur de base de données Microsoft Jet vérifie d’abord le cache pour les données demandées plutôt que de les récupérer à partir du serveur, ce qui prend plus de temps. Les données qui ne proviennent pas d’une source de données ODBC ne sont pas enregistrées dans le cache.

Toute source de données ODBC, telle qu’une table attachée, peut avoir un cache local. Pour créer le cache, ouvrez un objet Recordset à partir de la source de données distante, appelez les `SetCacheSize` `SetCacheStart` fonctions membres et, puis appelez la `FillCache` fonction membre ou parcourez les enregistrements à l’aide de l’une des opérations de déplacement. Le paramètre *lSize* de la `SetCacheSize` fonction membre peut être basé sur le nombre d’enregistrements que votre application peut utiliser simultanément. Par exemple, si vous utilisez un Recordset comme source des données à afficher sur l’écran, vous pouvez passer le `SetCacheSize` paramètre *lSize* sur 20 pour afficher 20 enregistrements à la fois.

Pour obtenir des informations connexes, consultez la rubrique « CacheSize, propriétés CacheStart » dans l’aide de DAO.

## <a name="cdaorecordsetsetcachestart"></a><a name="setcachestart"></a> CDaoRecordset :: SetCacheStart

Appelez cette fonction membre pour spécifier le signet du premier enregistrement dans le jeu d’enregistrements à mettre en cache.

```cpp
void SetCacheStart(COleVariant varBookmark);
```

### <a name="parameters"></a>Paramètres

*varBookmark*<br/>
[COleVariant](../../mfc/reference/colevariant-class.md) qui spécifie le signet du premier enregistrement dans le recordset à mettre en cache.

### <a name="remarks"></a>Notes

Vous pouvez utiliser la valeur de signet de n’importe quel enregistrement pour le paramètre *varBookmark* de la `SetCacheStart` fonction membre. Créez l’enregistrement pour lequel vous souhaitez démarrer le cache avec l’enregistrement actif, établissez un signet pour cet enregistrement à l’aide de [SetBookmark](#setbookmark), puis transmettez la valeur de signet en tant que paramètre de la `SetCacheStart` fonction membre.

Le moteur de base de données Microsoft Jet demande des enregistrements à l’intérieur de la plage du cache et demande des enregistrements en dehors de la plage du cache du serveur.

Les enregistrements récupérés à partir du cache ne reflètent pas les modifications apportées simultanément aux données sources par d’autres utilisateurs.

Pour forcer une mise à jour de toutes les données mises en cache, transmettez le paramètre *lSize* de la `SetCacheSize` valeur 0, appelez `SetCacheSize` à nouveau avec la taille du cache que vous avez demandé à l’origine, puis appelez la `FillCache` fonction membre.

Notez que si vous n’êtes pas en train de créer un jeu d’enregistrements UNICODE, l' `COleVariant` objet doit être déclaré explicitement en ANSI. Pour ce faire, vous pouvez utiliser la forme [COleVariant :: COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)** du constructeur *avec vtSrc* défini sur `VT_BSTRT` (ANSI) ou à l’aide de la `COleVariant` fonction [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** avec *vtSrc* défini sur `VT_BSTRT` .

Pour obtenir des informations connexes, consultez la rubrique CacheSize, propriétés CacheStart dans l’aide de DAO.

## <a name="cdaorecordsetsetcurrentindex"></a><a name="setcurrentindex"></a> CDaoRecordset :: SetCurrentIndex

Appelez cette fonction membre pour définir un index sur un jeu d’enregistrements de type table.

```cpp
void SetCurrentIndex(LPCTSTR lpszIndex);
```

### <a name="parameters"></a>Paramètres

*lpszIndex*<br/>
Pointeur contenant le nom de l’index à définir.

### <a name="remarks"></a>Notes

Les enregistrements dans les tables de base ne sont pas stockés dans un ordre particulier. La définition d’un index modifie l’ordre des enregistrements retournés par la base de données, mais il n’affecte pas l’ordre dans lequel les enregistrements sont stockés. L’index spécifié doit déjà être défini. Si vous essayez d’utiliser un objet d’index qui n’existe pas, ou si l’index n’est pas défini lorsque vous appelez [Seek](#seek), MFC lève une exception.

Vous pouvez créer un nouvel index pour la table en appelant [CDaoTableDef :: CreateIndex](../../mfc/reference/cdaotabledef-class.md#createindex) et en ajoutant le nouvel index à la collection d’index de l’objet TableDef sous-jacent en appelant [CDaoTableDef :: Append](../../mfc/reference/cdaotabledef-class.md#append), puis en réouvrant le Recordset.

Les enregistrements retournés à partir d’un jeu d’enregistrements de type table ne peuvent être classés que par les index définis pour l’objet TableDef sous-jacent. Pour trier des enregistrements dans un autre ordre, vous pouvez ouvrir un jeu d’enregistrements de type feuille de réponse dynamique ou instantané à l’aide d’une clause SQL **orderby** stockée dans [CDaoRecordset :: m_strSort](#m_strsort).

Pour obtenir des informations connexes, consultez la rubrique « index Object » et la définition « current index » dans l’aide de DAO.

## <a name="cdaorecordsetsetfielddirty"></a><a name="setfielddirty"></a> CDaoRecordset :: SetFieldDirty

Appelez cette fonction membre pour signaler un membre de données de champ du Recordset comme étant modifié ou comme étant inchangé.

```cpp
void SetFieldDirty(
    void* pv,
    BOOL bDirty = TRUE);
```

### <a name="parameters"></a>Paramètres

*va*<br/>
Contient l’adresse d’un membre de données de champ dans le jeu d’enregistrements ou NULL. Si la valeur est NULL, tous les membres de données de champ dans le jeu d’enregistrements sont marqués d’un indicateur. (C++ NULL n’est pas identique à la valeur null dans la terminologie de base de données, ce qui signifie « aucune valeur ».)

*bDirty*<br/>
TRUE si le membre de données de champ doit être marqué comme « impropre » (modifié). Sinon, FALSe si le membre de données de champ doit être marqué comme « Clean » (inchangé).

### <a name="remarks"></a>Notes

Le fait de marquer les champs comme inchangés garantit que le champ n’est pas mis à jour.

Le Framework marque les membres de données de champ modifiés pour s’assurer qu’ils seront écrits dans l’enregistrement sur la source de données par le mécanisme d’échange de champs d’enregistrements DAO (DFX). La modification de la valeur d’un champ définit généralement le champ modifié automatiquement. vous devrez donc rarement vous appeler `SetFieldDirty` , mais vous souhaiterez peut-être parfois vous assurer que les colonnes seront mises à jour ou insérées de manière explicite, quelle que soit la valeur du membre de données de champ. Le mécanisme DFX utilise également l’utilisation de PSEUDONULL. Pour plus d’informations, consultez [CDaoFieldExchange :: m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

Si le mécanisme de double mise en mémoire tampon n’est pas utilisé, la modification de la valeur du champ ne définit pas automatiquement le champ comme étant modifié. Dans ce cas, il est nécessaire de définir explicitement le champ comme étant modifié. L’indicateur contenu dans [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) contrôle cette vérification de champ automatique.

> [!NOTE]
> Appelez cette fonction membre uniquement après avoir appelé [Edit](#edit) ou [AddNew](#addnew).

L’utilisation de NULL pour le premier argument de la fonction applique la fonction à tous les `outputColumn` champs, pas aux champs **param** dans `CDaoFieldExchange` . Par exemple, l’appel

[!code-cpp[NVC_MFCDatabase#6](../../mfc/codesnippet/cpp/cdaorecordset-class_6.cpp)]

définit uniquement les `outputColumn` champs à null ; les champs **param** ne seront pas affectés.

Pour travailler sur un **paramètre**, vous devez fournir l’adresse réelle du **paramètre** individuel sur lequel vous souhaitez travailler, par exemple :

[!code-cpp[NVC_MFCDatabase#7](../../mfc/codesnippet/cpp/cdaorecordset-class_7.cpp)]

Cela signifie que vous ne pouvez pas définir tous les champs **param** sur null, comme vous pouvez le faire avec des `outputColumn` champs.

`SetFieldDirty` est implémenté par le biais de `DoFieldExchange` .

## <a name="cdaorecordsetsetfieldnull"></a><a name="setfieldnull"></a> CDaoRecordset :: SetFieldNull

Appelez cette fonction membre pour marquer un membre de données de champ du Recordset comme null (sans valeur) ou comme non null.

```cpp
void SetFieldNull(
    void* pv,
    BOOL bNull = TRUE);
```

### <a name="parameters"></a>Paramètres

*va*<br/>
Contient l’adresse d’un membre de données de champ dans le jeu d’enregistrements ou NULL. Si la valeur est NULL, tous les membres de données de champ dans le jeu d’enregistrements sont marqués d’un indicateur. (C++ NULL n’est pas identique à la valeur null dans la terminologie de base de données, ce qui signifie « aucune valeur ».)

*bNull*<br/>
Valeur différente de zéro si le membre de données de champ doit être marqué comme n’ayant aucune valeur (null). Sinon, 0 si le membre de données de champ doit être marqué comme non null.

### <a name="remarks"></a>Notes

`SetFieldNull` est utilisé pour les champs liés dans le `DoFieldExchange` mécanisme.

Lorsque vous ajoutez un nouvel enregistrement à un Recordset, tous les membres de données de champ sont initialement définis sur une valeur null et marqués comme « modifiés » (modifiés). Lorsque vous récupérez un enregistrement d’une source de données, ses colonnes ont déjà des valeurs ou sont null. S’il n’est pas approprié de rendre un champ null, une [CDaoException](../../mfc/reference/cdaoexception-class.md) est levée.

Si vous utilisez le mécanisme de double mise en mémoire tampon, par exemple, si vous souhaitez spécifiquement désigner un champ de l’enregistrement en cours comme n’ayant pas de valeur, appelez `SetFieldNull` avec *bNull* défini sur true pour le marquer comme étant null. Si un champ a déjà été marqué comme null et que vous souhaitez maintenant lui attribuer une valeur, il vous suffit de définir sa nouvelle valeur. Vous n’avez pas besoin de supprimer l’indicateur null avec `SetFieldNull` . Pour déterminer si le champ peut être null, appelez [IsFieldNullable](#isfieldnullable).

Si vous n’utilisez pas le mécanisme de double mise en mémoire tampon, la modification de la valeur du champ ne définit pas automatiquement le champ comme étant modifié et non null. Vous devez définir spécifiquement les champs Dirty et non null. L’indicateur contenu dans [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) contrôle cette vérification de champ automatique.

Le mécanisme DFX utilise l’utilisation de PSEUDONULL. Pour plus d’informations, consultez [CDaoFieldExchange :: m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

> [!NOTE]
> Appelez cette fonction membre uniquement après avoir appelé [Edit](#edit) ou [AddNew](#addnew).

L’utilisation de NULL pour le premier argument de la fonction applique la fonction uniquement aux `outputColumn` champs, pas aux champs **param** dans `CDaoFieldExchange` . Par exemple, l’appel

[!code-cpp[NVC_MFCDatabase#8](../../mfc/codesnippet/cpp/cdaorecordset-class_8.cpp)]

définit uniquement les `outputColumn` champs à null ; les champs **param** ne seront pas affectés.

## <a name="cdaorecordsetsetfieldvalue"></a><a name="setfieldvalue"></a> CDaoRecordset :: SetFieldValue

Appelez cette fonction membre pour définir la valeur d’un champ, soit par position ordinale, soit en modifiant la valeur de la chaîne.

```cpp
virtual void SetFieldValue(
    LPCTSTR lpszName,
    const COleVariant& varValue);

virtual void SetFieldValue(
    int nIndex,
    const COleVariant& varValue);

void SetFieldValue(
    LPCTSTR lpszName,
    LPCTSTR lpszValue);

void SetFieldValue(
    int nIndex,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>Paramètres

*lpszName*<br/>
Pointeur vers une chaîne contenant le nom d’un champ.

*varValue*<br/>
Référence à un objet [COleVariant](../../mfc/reference/colevariant-class.md) contenant la valeur du contenu du champ.

*nIndex*<br/>
Entier qui représente la position ordinale du champ dans la collection de champs du recordset (de base zéro).

*lpszValue*<br/>
Pointeur vers une chaîne contenant la valeur du contenu du champ.

### <a name="remarks"></a>Notes

Utilisez `SetFieldValue` et [GetFieldValue](#getfieldvalue) pour lier dynamiquement les champs au moment de l’exécution plutôt que de lier statiquement des colonnes à l’aide du mécanisme [DoFieldExchange](#dofieldexchange) .

Notez que si vous n’êtes pas en train de créer un jeu d’enregistrements UNICODE, vous devez utiliser une forme de `SetFieldValue` qui ne contient pas de `COleVariant` paramètre, ou l' `COleVariant` objet doit être explicitement déclaré comme ANSI. Pour ce faire, vous pouvez utiliser la forme [COleVariant :: COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)** du constructeur *avec vtSrc* défini sur `VT_BSTRT` (ANSI) ou à l’aide de la `COleVariant` fonction [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** avec *vtSrc* défini sur `VT_BSTRT` .

Pour obtenir des informations connexes, consultez les rubriques « objet champ » et « propriété valeur » dans l’aide de DAO.

## <a name="cdaorecordsetsetfieldvaluenull"></a><a name="setfieldvaluenull"></a> CDaoRecordset :: SetFieldValueNull

Appelez cette fonction membre pour affecter une valeur null au champ.

```cpp
void SetFieldValueNull(int nIndex);
void SetFieldValueNull(LPCTSTR lpszName);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
Index du champ dans le Recordset, pour la recherche par index de base zéro.

*lpszName*<br/>
Nom du champ dans le Recordset, pour la recherche par nom.

### <a name="remarks"></a>Notes

C++ NULL n’est pas identique à null, ce qui, dans la terminologie de base de données, signifie « aucune valeur ».

Pour obtenir des informations connexes, consultez les rubriques « objet champ » et « propriété valeur » dans l’aide de DAO.

## <a name="cdaorecordsetsetlockingmode"></a><a name="setlockingmode"></a> CDaoRecordset :: SetLockingMode

Appelez cette fonction membre pour définir le type de verrouillage du Recordset.

```cpp
void SetLockingMode(BOOL bPessimistic);
```

### <a name="parameters"></a>Paramètres

*bPessimistic*<br/>
Indicateur qui indique le type de verrouillage.

### <a name="remarks"></a>Notes

Lorsque le verrouillage pessimiste est activé, la page 2K contenant l’enregistrement que vous modifiez est verrouillée dès que vous appelez la `Edit` fonction membre. La page est déverrouillée lorsque vous appelez la `Update` `Close` fonction membre ou ou l’une des opérations de déplacement ou de recherche.

Lorsque le verrouillage optimiste est activé, la page 2K contenant l’enregistrement est verrouillée uniquement lorsque l’enregistrement est mis à jour avec la `Update` fonction membre.

Si une page est verrouillée, aucun autre utilisateur ne peut modifier les enregistrements sur la même page. Si vous appelez `SetLockingMode` et transmettez une valeur différente de zéro et qu’un autre utilisateur a déjà verrouillé la page, une exception est levée lorsque vous appelez `Edit` . Les autres utilisateurs peuvent lire les données à partir de pages verrouillées.

Si vous appelez `SetLockingMode` avec une valeur zéro et appelez ultérieurement `Update` alors que la page est verrouillée par un autre utilisateur, une exception se produit. Pour voir les modifications apportées à votre enregistrement par un autre utilisateur (et perdre vos modifications), appelez la `SetBookmark` fonction membre avec la valeur de signet de l’enregistrement en cours.

Lorsque vous utilisez des sources de données ODBC, le mode de verrouillage est toujours optimiste.

## <a name="cdaorecordsetsetparamvalue"></a><a name="setparamvalue"></a> CDaoRecordset :: SetParamValue

Appelez cette fonction membre pour définir la valeur d’un paramètre dans le jeu d’enregistrements au moment de l’exécution.

```cpp
virtual void SetParamValue(
    int nIndex,
    const COleVariant& varValue);

virtual void SetParamValue(
    LPCTSTR lpszName,
    const COleVariant& varValue);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
Position numérique du paramètre dans la collection de paramètres de la querydef.

*var*<br/>
Valeur à définir ; consultez la section Notes.

*lpszName*<br/>
Nom du paramètre dont vous souhaitez définir la valeur.

### <a name="remarks"></a>Notes

Le paramètre doit déjà avoir été établi dans le cadre de la chaîne SQL du Recordset. Vous pouvez accéder au paramètre par son nom ou par sa position d’index dans la collection.

Spécifiez la valeur à définir en tant qu' `COleVariant` objet. Pour plus d’informations sur la définition de la valeur et du type souhaités dans votre `COleVariant` objet, consultez la classe [COleVariant](../../mfc/reference/colevariant-class.md). Notez que si vous n’êtes pas en train de créer un jeu d’enregistrements UNICODE, l' `COleVariant` objet doit être déclaré explicitement en ANSI. Pour ce faire, vous pouvez utiliser la forme [COleVariant :: COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)** du constructeur *avec vtSrc* défini sur `VT_BSTRT` (ANSI) ou à l’aide de la `COleVariant` fonction [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** avec *vtSrc* défini sur `VT_BSTRT` .

## <a name="cdaorecordsetsetparamvaluenull"></a><a name="setparamvaluenull"></a> CDaoRecordset :: SetParamValueNull

Appelez cette fonction membre pour définir le paramètre sur une valeur null.

```cpp
void SetParamValueNull(int nIndex);
void SetParamValueNull(LPCTSTR lpszName);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
Index du champ dans le Recordset, pour la recherche par index de base zéro.

*lpszName*<br/>
Nom du champ dans le Recordset, pour la recherche par nom.

### <a name="remarks"></a>Notes

C++ NULL n’est pas identique à null, ce qui, dans la terminologie de base de données, signifie « aucune valeur ».

## <a name="cdaorecordsetsetpercentposition"></a><a name="setpercentposition"></a> CDaoRecordset :: SetPercentPosition

Appelez cette fonction membre pour définir une valeur qui modifie l’emplacement approximatif de l’enregistrement actif dans l’objet Recordset en fonction d’un pourcentage des enregistrements du Recordset.

```cpp
void SetPercentPosition(float fPosition);
```

### <a name="parameters"></a>Paramètres

*fPosition*<br/>
Nombre compris entre 0 et 100.

### <a name="remarks"></a>Notes

Quand vous utilisez un jeu d’enregistrements de type feuille de réponse dynamique ou instantané, commencez par remplir le Recordset en le déplaçant vers le dernier enregistrement avant d’appeler `SetPercentPosition` . Si vous appelez `SetPercentPosition` avant de remplir complètement le jeu d’enregistrements, la quantité de mouvement est relative au nombre d’enregistrements accédés comme indiqué par la valeur de [GetRecordCount](#getrecordcount). Vous pouvez accéder au dernier enregistrement en appelant `MoveLast` .

Une fois que vous appelez `SetPercentPosition` , l’enregistrement situé à la position approximative correspondant à cette valeur devient actuel.

> [!NOTE]
> `SetPercentPosition`L’appel de pour déplacer l’enregistrement actif vers un enregistrement spécifique dans un jeu d’enregistrements n’est pas recommandé. Appelez à la place la fonction membre [SetBookmark](#setbookmark) .

Pour obtenir des informations connexes, consultez la rubrique « propriété PercentPosition » dans l’aide de DAO.

## <a name="cdaorecordsetupdate"></a><a name="update"></a> CDaoRecordset :: Update

Appelez cette fonction membre après un appel à la `AddNew` `Edit` fonction membre ou.

```cpp
virtual void Update();
```

### <a name="remarks"></a>Notes

Cet appel est requis pour terminer l' `AddNew` `Edit` opération ou.

`AddNew`Et `Edit` préparent un tampon d’édition dans lequel les données ajoutées ou modifiées sont placées pour être enregistrées dans la source de données. `Update` enregistre les données. Seuls les champs marqués ou détectés comme modifiés sont mis à jour.

Si la source de données prend en charge les transactions, vous pouvez effectuer l' `Update` appel (et sa `AddNew` partie correspondante ou `Edit` appel) d’une transaction.

> [!CAUTION]
> Si vous appelez `Update` sans appeler d’abord `AddNew` ou `Edit` , `Update` lève une exception `CDaoException` . Si vous appelez `AddNew` ou `Edit` , vous devez appeler `Update` avant d’appeler [MoveNext](#movenext) ou fermer l’ensemble d’enregistrements ou la connexion à la source de données. Dans le cas contraire, vos modifications seront perdues sans notification.

Lorsque l’objet Recordset est pessimistically verrouillé dans un environnement multi-utilisateur, l’enregistrement reste verrouillé à partir du moment où `Edit` la mise à jour est terminée. Si le Recordset est verrouillé de manière optimiste, l’enregistrement est verrouillé et comparé à l’enregistrement antérieur à la modification juste avant d’être mis à jour dans la base de données. Si l’enregistrement a changé depuis que vous avez appelé `Edit` , l' `Update` opération échoue et MFC lève une exception. Vous pouvez modifier le mode de verrouillage avec `SetLockingMode` .

> [!NOTE]
> Le verrouillage optimiste est toujours utilisé sur les formats de base de données externes, tels que ODBC et ISAM installables.

Pour obtenir des informations connexes, consultez les rubriques « méthode AddNew », « méthode CancelUpdate », « méthode Delete », « propriété LastModified », « méthode de mise à jour » et « propriété EditMode » dans l’aide de DAO.

## <a name="see-also"></a>Voir aussi

[CObject (classe)](../../mfc/reference/cobject-class.md)<br/>
[Graphique hiérarchique](../../mfc/hierarchy-chart.md)<br/>
[CDaoTableDef, classe](../../mfc/reference/cdaotabledef-class.md)<br/>
[CDaoWorkspace (classe)](../../mfc/reference/cdaoworkspace-class.md)<br/>
[Classe CDaoDatabase](../../mfc/reference/cdaodatabase-class.md)<br/>
[CDaoQueryDef (classe)](../../mfc/reference/cdaoquerydef-class.md)<br/>
