---
title: CDaoRecordset (classe)
ms.date: 08/27/2018
f1_keywords:
- CDaoRecordset
- AFXDAO/CDaoRecordset
- AFXDAO/CDaoRecordset::CDaoRecordset
- AFXDAO/CDaoRecordset::AddNew
- AFXDAO/CDaoRecordset::CanAppend
- AFXDAO/CDaoRecordset::CanBookmark
- AFXDAO/CDaoRecordset::CancelUpdate
- AFXDAO/CDaoRecordset::CanRestart
- AFXDAO/CDaoRecordset::CanScroll
- AFXDAO/CDaoRecordset::CanTransact
- AFXDAO/CDaoRecordset::CanUpdate
- AFXDAO/CDaoRecordset::Close
- AFXDAO/CDaoRecordset::Delete
- AFXDAO/CDaoRecordset::DoFieldExchange
- AFXDAO/CDaoRecordset::Edit
- AFXDAO/CDaoRecordset::FillCache
- AFXDAO/CDaoRecordset::Find
- AFXDAO/CDaoRecordset::FindFirst
- AFXDAO/CDaoRecordset::FindLast
- AFXDAO/CDaoRecordset::FindNext
- AFXDAO/CDaoRecordset::FindPrev
- AFXDAO/CDaoRecordset::GetAbsolutePosition
- AFXDAO/CDaoRecordset::GetBookmark
- AFXDAO/CDaoRecordset::GetCacheSize
- AFXDAO/CDaoRecordset::GetCacheStart
- AFXDAO/CDaoRecordset::GetCurrentIndex
- AFXDAO/CDaoRecordset::GetDateCreated
- AFXDAO/CDaoRecordset::GetDateLastUpdated
- AFXDAO/CDaoRecordset::GetDefaultDBName
- AFXDAO/CDaoRecordset::GetDefaultSQL
- AFXDAO/CDaoRecordset::GetEditMode
- AFXDAO/CDaoRecordset::GetFieldCount
- AFXDAO/CDaoRecordset::GetFieldInfo
- AFXDAO/CDaoRecordset::GetFieldValue
- AFXDAO/CDaoRecordset::GetIndexCount
- AFXDAO/CDaoRecordset::GetIndexInfo
- AFXDAO/CDaoRecordset::GetLastModifiedBookmark
- AFXDAO/CDaoRecordset::GetLockingMode
- AFXDAO/CDaoRecordset::GetName
- AFXDAO/CDaoRecordset::GetParamValue
- AFXDAO/CDaoRecordset::GetPercentPosition
- AFXDAO/CDaoRecordset::GetRecordCount
- AFXDAO/CDaoRecordset::GetSQL
- AFXDAO/CDaoRecordset::GetType
- AFXDAO/CDaoRecordset::GetValidationRule
- AFXDAO/CDaoRecordset::GetValidationText
- AFXDAO/CDaoRecordset::IsBOF
- AFXDAO/CDaoRecordset::IsDeleted
- AFXDAO/CDaoRecordset::IsEOF
- AFXDAO/CDaoRecordset::IsFieldDirty
- AFXDAO/CDaoRecordset::IsFieldNull
- AFXDAO/CDaoRecordset::IsFieldNullable
- AFXDAO/CDaoRecordset::IsOpen
- AFXDAO/CDaoRecordset::Move
- AFXDAO/CDaoRecordset::MoveFirst
- AFXDAO/CDaoRecordset::MoveLast
- AFXDAO/CDaoRecordset::MoveNext
- AFXDAO/CDaoRecordset::MovePrev
- AFXDAO/CDaoRecordset::Open
- AFXDAO/CDaoRecordset::Requery
- AFXDAO/CDaoRecordset::Seek
- AFXDAO/CDaoRecordset::SetAbsolutePosition
- AFXDAO/CDaoRecordset::SetBookmark
- AFXDAO/CDaoRecordset::SetCacheSize
- AFXDAO/CDaoRecordset::SetCacheStart
- AFXDAO/CDaoRecordset::SetCurrentIndex
- AFXDAO/CDaoRecordset::SetFieldDirty
- AFXDAO/CDaoRecordset::SetFieldNull
- AFXDAO/CDaoRecordset::SetFieldValue
- AFXDAO/CDaoRecordset::SetFieldValueNull
- AFXDAO/CDaoRecordset::SetLockingMode
- AFXDAO/CDaoRecordset::SetParamValue
- AFXDAO/CDaoRecordset::SetParamValueNull
- AFXDAO/CDaoRecordset::SetPercentPosition
- AFXDAO/CDaoRecordset::Update
- AFXDAO/CDaoRecordset::m_bCheckCacheForDirtyFields
- AFXDAO/CDaoRecordset::m_nFields
- AFXDAO/CDaoRecordset::m_nParams
- AFXDAO/CDaoRecordset::m_pDAORecordset
- AFXDAO/CDaoRecordset::m_pDatabase
- AFXDAO/CDaoRecordset::m_strFilter
- AFXDAO/CDaoRecordset::m_strSort
helpviewer_keywords:
- CDaoRecordset [MFC], CDaoRecordset
- CDaoRecordset [MFC], AddNew
- CDaoRecordset [MFC], CanAppend
- CDaoRecordset [MFC], CanBookmark
- CDaoRecordset [MFC], CancelUpdate
- CDaoRecordset [MFC], CanRestart
- CDaoRecordset [MFC], CanScroll
- CDaoRecordset [MFC], CanTransact
- CDaoRecordset [MFC], CanUpdate
- CDaoRecordset [MFC], Close
- CDaoRecordset [MFC], Delete
- CDaoRecordset [MFC], DoFieldExchange
- CDaoRecordset [MFC], Edit
- CDaoRecordset [MFC], FillCache
- CDaoRecordset [MFC], Find
- CDaoRecordset [MFC], FindFirst
- CDaoRecordset [MFC], FindLast
- CDaoRecordset [MFC], FindNext
- CDaoRecordset [MFC], FindPrev
- CDaoRecordset [MFC], GetAbsolutePosition
- CDaoRecordset [MFC], GetBookmark
- CDaoRecordset [MFC], GetCacheSize
- CDaoRecordset [MFC], GetCacheStart
- CDaoRecordset [MFC], GetCurrentIndex
- CDaoRecordset [MFC], GetDateCreated
- CDaoRecordset [MFC], GetDateLastUpdated
- CDaoRecordset [MFC], GetDefaultDBName
- CDaoRecordset [MFC], GetDefaultSQL
- CDaoRecordset [MFC], GetEditMode
- CDaoRecordset [MFC], GetFieldCount
- CDaoRecordset [MFC], GetFieldInfo
- CDaoRecordset [MFC], GetFieldValue
- CDaoRecordset [MFC], GetIndexCount
- CDaoRecordset [MFC], GetIndexInfo
- CDaoRecordset [MFC], GetLastModifiedBookmark
- CDaoRecordset [MFC], GetLockingMode
- CDaoRecordset [MFC], GetName
- CDaoRecordset [MFC], GetParamValue
- CDaoRecordset [MFC], GetPercentPosition
- CDaoRecordset [MFC], GetRecordCount
- CDaoRecordset [MFC], GetSQL
- CDaoRecordset [MFC], GetType
- CDaoRecordset [MFC], GetValidationRule
- CDaoRecordset [MFC], GetValidationText
- CDaoRecordset [MFC], IsBOF
- CDaoRecordset [MFC], IsDeleted
- CDaoRecordset [MFC], IsEOF
- CDaoRecordset [MFC], IsFieldDirty
- CDaoRecordset [MFC], IsFieldNull
- CDaoRecordset [MFC], IsFieldNullable
- CDaoRecordset [MFC], IsOpen
- CDaoRecordset [MFC], Move
- CDaoRecordset [MFC], MoveFirst
- CDaoRecordset [MFC], MoveLast
- CDaoRecordset [MFC], MoveNext
- CDaoRecordset [MFC], MovePrev
- CDaoRecordset [MFC], Open
- CDaoRecordset [MFC], Requery
- CDaoRecordset [MFC], Seek
- CDaoRecordset [MFC], SetAbsolutePosition
- CDaoRecordset [MFC], SetBookmark
- CDaoRecordset [MFC], SetCacheSize
- CDaoRecordset [MFC], SetCacheStart
- CDaoRecordset [MFC], SetCurrentIndex
- CDaoRecordset [MFC], SetFieldDirty
- CDaoRecordset [MFC], SetFieldNull
- CDaoRecordset [MFC], SetFieldValue
- CDaoRecordset [MFC], SetFieldValueNull
- CDaoRecordset [MFC], SetLockingMode
- CDaoRecordset [MFC], SetParamValue
- CDaoRecordset [MFC], SetParamValueNull
- CDaoRecordset [MFC], SetPercentPosition
- CDaoRecordset [MFC], Update
- CDaoRecordset [MFC], m_bCheckCacheForDirtyFields
- CDaoRecordset [MFC], m_nFields
- CDaoRecordset [MFC], m_nParams
- CDaoRecordset [MFC], m_pDAORecordset
- CDaoRecordset [MFC], m_pDatabase
- CDaoRecordset [MFC], m_strFilter
- CDaoRecordset [MFC], m_strSort
ms.assetid: 2322067f-1027-4662-a5d7-aa2fc7488630
ms.openlocfilehash: 6b3e3fac575d6a1308a9f61b3bf827d76785e94d
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/31/2018
ms.locfileid: "50639321"
---
# <a name="cdaorecordset-class"></a>CDaoRecordset (classe)

Représente un ensemble d'enregistrements sélectionnés à partir d'une source de données.

## <a name="syntax"></a>Syntaxe

```
class CDaoRecordset : public CObject
```

## <a name="members"></a>Membres

### <a name="public-constructors"></a>Constructeurs publics

|Nom|Description|
|----------|-----------------|
|[CDaoRecordset::CDaoRecordset](#cdaorecordset)|Construit un objet `CDaoRecordset`.|

### <a name="public-methods"></a>M&#233;thodes publiques

|Nom|Description|
|----------|-----------------|
|[CDaoRecordset::AddNew](#addnew)|Prépare pour l’ajout d’un nouvel enregistrement. Appelez [mise à jour](#update) pour terminer l’ajout.|
|[CDaoRecordset::CanAppend](#canappend)|Retourne zéro si les nouveaux enregistrements peuvent être ajoutés à l’ensemble d’enregistrements via le [AddNew](#addnew) fonction membre.|
|[CDaoRecordset::CanBookmark](#canbookmark)|Retourne une valeur différente de zéro si le jeu d’enregistrements prend en charge les signets.|
|[CDaoRecordset::CancelUpdate](#cancelupdate)|Annule les mises à jour en attente suite à une [modifier](#edit) ou [AddNew](#addnew) opération.|
|[CDaoRecordset::CanRestart](#canrestart)|Retourne la valeur différente de zéro si [Requery](#requery) peut être appelée pour réexécuter la requête du recordset.|
|[CDaoRecordset::CanScroll](#canscroll)|Retourne une valeur différente de zéro si vous pouvez faire défiler les enregistrements.|
|[CDaoRecordset::CanTransact](#cantransact)|Retourne une valeur différente de zéro si la source de données prend en charge les transactions.|
|[CDaoRecordset::CanUpdate](#canupdate)|Retourne zéro si le jeu d’enregistrements peut être mis à jour (vous pouvez ajouter, mettre à jour ou supprimer des enregistrements).|
|[CDaoRecordset::Close](#close)|Ferme le jeu d’enregistrements.|
|[CDaoRecordset::Delete](#delete)|Supprime l’enregistrement en cours de l’ensemble d’enregistrements. Après la suppression, vous devez explicitement faire défiler à un autre enregistrement.|
|[CDaoRecordset::DoFieldExchange](#dofieldexchange)|Appelé pour échanger des données (dans les deux sens) entre les membres de données de champ de l’objet recordset et l’enregistrement correspondant sur la source de données. Implémente DAO champ échange enregistrements (DFX).|
|[CDaoRecordset::Edit](#edit)|Prépare les modifications à l’enregistrement actif. Appelez `Update` pour terminer la modification.|
|[CDaoRecordset::FillCache](#fillcache)|Remplit tout ou partie d’un cache local pour un objet recordset qui contient les données d’une source de données ODBC.|
|[CDaoRecordset::Find](#find)|Localise le premier, suivant, précédent, ou le dernier emplacement d’une chaîne particulière dans un jeu d’enregistrements de type qui satisfait aux critères spécifiés et lui donne de l’enregistre actif.|
|[CDaoRecordset::FindFirst](#findfirst)|Recherche le premier enregistrement dans un jeu d’enregistrements de type instantané qui satisfait aux critères spécifiés et lui donne de l’enregistre actif ou de type.|
|[CDaoRecordset::FindLast](#findlast)|Recherche le dernier enregistrement dans un jeu d’enregistrements de type instantané qui satisfait aux critères spécifiés et lui donne de l’enregistre actif ou de type.|
|[CDaoRecordset::FindNext](#findnext)|Recherche l’enregistrement suivant dans un jeu d’enregistrements de type instantané qui satisfait aux critères spécifiés et lui donne de l’enregistre actif ou de type.|
|[CDaoRecordset::FindPrev](#findprev)|Recherche l’enregistrement précédent dans un jeu d’enregistrements de type instantané qui satisfait aux critères spécifiés et lui donne de l’enregistre actif ou de type.|
|[CDaoRecordset::GetAbsolutePosition](#getabsoluteposition)|Retourne le numéro d’enregistrement de l’enregistrement en cours d’un objet recordset.|
|[CDaoRecordset::CanBookmark](#getbookmark)|Retourne une valeur qui représente le signet sur un enregistrement.|
|[CDaoRecordset::GetCacheSize](#getcachesize)|Retourne une valeur qui spécifie le nombre d’enregistrements dans un jeu d’enregistrements de type jeu de données contenant des données à mettre en cache localement à partir d’une source de données ODBC.|
|[CDaoRecordset::GetCacheStart](#getcachestart)|Retourne une valeur qui spécifie le signet du premier enregistrement dans le jeu d’enregistrements doit être mis en cache.|
|[CDaoRecordset::GetCurrentIndex](#getcurrentindex)|Retourne un `CString` qui contient le nom de l’index plus récemment utilisés sur un type de table indexé, `CDaoRecordset`.|
|[CDaoRecordset::GetDateCreated](#getdatecreated)|Retourne la date et l’heure de la table de base sous-jacente un `CDaoRecordset` objet a été créé.|
|[CDaoRecordset::GetDateLastUpdated](#getdatelastupdated)|Retourne la date et l’heure de la dernière modification apportée à la conception d’une table de base sous-jacent un `CDaoRecordset` objet.|
|[CDaoRecordset::GetDefaultDBName](#getdefaultdbname)|Retourne le nom de la source de données par défaut.|
|[CDaoRecordset::GetDefaultSQL](#getdefaultsql)|Appelé pour obtenir la chaîne SQL par défaut à exécuter.|
|[CDaoRecordset::GetEditMode](#geteditmode)|Retourne une valeur qui indique l’état de modification de l’enregistrement actif.|
|[CDaoRecordset::GetFieldCount](#getfieldcount)|Retourne une valeur qui représente le nombre de champs dans un jeu d’enregistrements.|
|[CDaoRecordset::GetFieldInfo](#getfieldinfo)|Retourne des informations sur les champs particuliers dans le jeu d’enregistrements.|
|[CDaoRecordset::GetFieldValue](#getfieldvalue)|Retourne la valeur d’un champ dans un jeu d’enregistrements.|
|[CDaoRecordset::GetIndexCount](#getindexcount)|Récupère le nombre d’index dans une table sous-jacente d’un jeu d’enregistrements.|
|[CDaoRecordset::GetIndexInfo](#getindexinfo)|Retourne différents types d’informations relatives à un index.|
|[CDaoRecordset::GetLastModifiedBookmark](#getlastmodifiedbookmark)|Utilisé pour déterminer le plus récemment ajoutés ou mis à jour d’enregistrement.|
|[CDaoRecordset::GetLockingMode](#getlockingmode)|Retourne une valeur qui indique le type de verrouillage qui est en vigueur lors de l’édition.|
|[CDaoRecordset::GetName](#getname)|Retourne un `CString` contenant le nom de l’objet recordset.|
|[CDaoRecordset::GetParamValue](#getparamvalue)|Récupère la valeur actuelle du paramètre spécifié stocké dans l’objet DAOParameter sous-jacent.|
|[CDaoRecordset::GetPercentPosition](#getpercentposition)|Retourne la position de l’enregistrement en cours sous forme de pourcentage du nombre total d’enregistrements.|
|[CDaoRecordset::GetRecordCount](#getrecordcount)|Retourne le nombre d’enregistrements auquel accédé dans un objet recordset.|
|[CDaoRecordset::GetSQL](#getsql)|Obtient la chaîne SQL utilisée pour sélectionner des enregistrements pour le jeu d’enregistrements.|
|[CDaoRecordset::GetType](#gettype)|Appelé pour déterminer le type d’un jeu d’enregistrements : type de table, de type ou de type instantané.|
|[CDaoRecordset::GetValidationRule](#getvalidationrule)|Retourne un `CString` contenant la valeur qui valide les données lorsqu’elles sont entrées dans un champ.|
|[CDaoRecordset::GetValidationText](#getvalidationtext)|Récupère le texte qui s’affiche quand une règle de validation n’est pas satisfaite.|
|[CDaoRecordset::IsBOF](#isbof)|Retourne une valeur différente de zéro si le jeu d’enregistrements a été placé avant le premier enregistrement. Il n’existe aucun enregistrement actif.|
|[CDaoRecordset::IsDeleted](#isdeleted)|Retourne une valeur différente de zéro si le jeu d’enregistrements est positionné sur un enregistrement supprimé.|
|[CDaoRecordset::IsEOF](#iseof)|Retourne une valeur différente de zéro si le jeu d’enregistrements a été positionné après le dernier enregistrement. Il n’existe aucun enregistrement actif.|
|[CDaoRecordset::IsFieldDirty](#isfielddirty)|Retourne une valeur différente de zéro si le champ spécifié dans l’enregistrement actif a été modifié.|
|[CDaoRecordset::IsFieldNull](#isfieldnull)|Retourne une valeur différente de zéro si le champ spécifié dans l’enregistrement actif est Null (n’avoir aucune valeur).|
|[CDaoRecordset::IsFieldNullable](#isfieldnullable)|Retourne une valeur différente de zéro si le champ spécifié dans l’enregistrement actif peut être défini avec la valeur Null (n’avoir aucune valeur).|
|[CDaoRecordset::IsOpen](#isopen)|Retourne la valeur différente de zéro si [Open](#open) a été appelé précédemment.|
|[Méthode CDaoRecordset::Move](#move)|Positionne le jeu d’enregistrements à un nombre spécifié d’enregistrements à partir de l’enregistrement actif dans les deux sens.|
|[CDaoRecordset::MoveFirst](#movefirst)|Positionne l’enregistrement en cours sur le premier enregistrement dans le jeu d’enregistrements.|
|[CDaoRecordset::MoveLast](#movelast)|Positionne l’enregistrement en cours sur le dernier enregistrement dans le jeu d’enregistrements.|
|[CDaoRecordset::MoveNext](#movenext)|Positionne l’enregistrement en cours sur l’enregistrement suivant dans le jeu d’enregistrements.|
|[CDaoRecordset::MovePrev](#moveprev)|Positionne l’enregistrement en cours sur l’enregistrement précédent dans le jeu d’enregistrements.|
|[CDaoRecordset::Open](#open)|Crée un nouveau jeu d’enregistrements à partir d’une table, une feuille de réponse dynamique ou un instantané.|
|[CDaoRecordset::Requery](#requery)|Exécute la requête du recordset à nouveau pour actualiser les enregistrements sélectionnés.|
|[CDaoRecordset::Seek](#seek)|Recherche l’enregistrement dans un objet de jeu d’enregistrements de type table indexée répondant aux critères spécifiés pour l’index actuel et en fait l’enregistre actif.|
|[CDaoRecordset::SetAbsolutePosition](#setabsoluteposition)|Définit le numéro d’enregistrement de l’enregistrement en cours d’un objet recordset.|
|[CDaoRecordset::SetBookmark](#setbookmark)|Positionne le jeu d’enregistrements sur un enregistrement qui contient le signet spécifié.|
|[CDaoRecordset::SetCacheSize](#setcachesize)|Définit une valeur qui spécifie le nombre d’enregistrements dans un jeu d’enregistrements de type jeu de données contenant des données à mettre en cache localement à partir d’une source de données ODBC.|
|[CDaoRecordset::SetCacheStart](#setcachestart)|Définit une valeur qui spécifie le signet du premier enregistrement dans le jeu d’enregistrements doit être mis en cache.|
|[CDaoRecordset::SetCurrentIndex](#setcurrentindex)|Appelé pour définir un index sur un jeu d’enregistrements de type de table.|
|[CDaoRecordset::SetFieldDirty](#setfielddirty)|Marque le champ spécifié dans l’enregistrement actif comme étant modifiée.|
|[CDaoRecordset::SetFieldNull](#setfieldnull)|Définit la valeur du champ spécifié dans l’enregistrement en cours avec la valeur Null (n’avoir aucune valeur).|
|[CDaoRecordset::SetFieldValue](#setfieldvalue)|Définit la valeur d’un champ dans un jeu d’enregistrements.|
|[CDaoRecordset::SetFieldValueNull](#setfieldvaluenull)|Définit la valeur d’un champ dans un jeu d’enregistrements avec la valeur Null. (n’avoir aucune valeur).|
|[CDaoRecordset::SetLockingMode](#setlockingmode)|Définit une valeur qui indique le type de verrouillage pour mettre en vigueur lors de l’édition.|
|[CDaoRecordset::SetParamValue](#setparamvalue)|Définit la valeur actuelle du paramètre spécifié stocké dans l’objet DAOParameter sous-jacent|
|[CDaoRecordset::SetParamValueNull](#setparamvaluenull)|Définit la valeur actuelle du paramètre spécifié avec la valeur Null (n’avoir aucune valeur).|
|[CDaoRecordset::SetPercentPosition](#setpercentposition)|Définit la position de l’enregistrement en cours vers un emplacement correspondant à un pourcentage du nombre total d’enregistrements dans un jeu d’enregistrements.|
|[CDaoRecordset::Update](#update)|Termine une `AddNew` ou `Edit` opération en enregistrant les données nouvelles ou modifiées sur la source de données.|

### <a name="public-data-members"></a>Membres de données publics

|Nom|Description|
|----------|-----------------|
|[CDaoRecordset::m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields)|Contient un indicateur spécifiant si les champs sont automatiquement marquées comme étant modifiée.|
|[CDaoRecordset::m_nFields](#m_nfields)|Contient le nombre de membres de données de champ dans la classe de jeu d’enregistrements et le nombre de colonnes sélectionnées par le jeu d’enregistrements à partir de la source de données.|
|[CDaoRecordset::m_nParams](#m_nparams)|Contient le nombre de membres de données de paramètre dans la classe de jeu d’enregistrements, le nombre de paramètres transmis avec la requête du recordset|
|[CDaoRecordset::m_pDAORecordset](#m_pdaorecordset)|Pointeur vers l’interface DAO sous-jacent de l’objet recordset.|
|[CDaoRecordset::m_pDatabase](#m_pdatabase)|Base de données source pour ce jeu de résultats. Contient un pointeur vers un [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md) objet.|
|[CDaoRecordset::m_strFilter](#m_strfilter)|Contient une chaîne utilisée pour construire une instance SQL **où** instruction.|
|[CDaoRecordset::m_strSort](#m_strsort)|Contient une chaîne utilisée pour construire une instance SQL **ORDER BY** instruction.|

## <a name="remarks"></a>Notes

Appelé « jeux d’enregistrements, » `CDaoRecordset` objets sont disponibles dans trois formes suivantes :

- Jeux d’enregistrements de type de table représente une table de base que vous pouvez utiliser pour examiner, ajouter, modifier ou supprimer des enregistrements d’une table de base de données unique.

- Types d’enregistrements sont le résultat d’une requête qui peut avoir des enregistrements modifiables. Ces jeux d’enregistrements est un ensemble d’enregistrements que vous pouvez utiliser pour examiner, ajouter, modifier ou supprimer des enregistrements d’une table de base de données sous-jacente ou des tables. Types d’enregistrements peuvent contenir des champs à partir d’une ou plusieurs tables dans une base de données.

- Jeux d’enregistrements de type instantané est une copie statique d’un jeu d’enregistrements que vous pouvez utiliser pour rechercher des données ou générer des rapports. Ces jeux d’enregistrements peut contenir des champs à partir d’une ou plusieurs tables dans une base de données mais ne peut pas être mis à jour.

Chaque formulaire de jeu d’enregistrements représente un jeu d’enregistrements fixée à la fois que le jeu d’enregistrements est ouvert. Lorsque vous faites défiler vers un enregistrement dans un jeu d’enregistrements de type de table ou un jeu d’enregistrements de type jeu de données, il reflète les modifications apportées à l’enregistrement une fois que le jeu d’enregistrements est ouvert par d’autres utilisateurs ou par d’autres jeux d’enregistrements dans votre application. (Un jeu d’enregistrements de type instantané ne peut pas être mis à jour.) Vous pouvez utiliser `CDaoRecordset` directement ou dériver une classe de jeu d’enregistrements spécifiques à l’application à partir de `CDaoRecordset`. Vous pouvez ensuite :

- Faites défiler les enregistrements.

- Définir un index et rechercher rapidement des enregistrements à l’aide [recherche](#seek) (jeux d’enregistrements de type de table uniquement).

- Rechercher des enregistrements selon une comparaison de chaînes : « < «, »\<= », « = », « > = », ou « > » (de type et jeux d’enregistrements de type instantané).

- Mettre à jour les enregistrements et spécifier un mode de verrouillage (à l’exception des jeux d’enregistrements de type instantané).

- Filtrer le jeu d’enregistrements pour limiter les enregistrements qu’il sélectionne parmi celles disponibles sur la source de données.

- Trier le jeu d’enregistrements.

- Paramétrer le recordset pour personnaliser sa sélection avec des informations inconnues jusqu’au moment de l’exécution.

Classe `CDaoRecordset` fournit une interface similaire à celle de la classe `CRecordset`. La principale différence est que classe `CDaoRecordset` accède aux données via un objet DAO (Data Access) basée sur OLE. Classe `CRecordset` accède au SGBD via la connectivité ODBC (Open Database) et un pilote ODBC pour ce système SGBD.

> [!NOTE]
> Les classes de base de données DAO sont distinctes des classes de base de données MFC basées sur ODBC Open Database Connectivity (). Tous les noms de classe de base de données DAO ont le préfixe « CDao ». Vous pouvez toujours accès aux sources de données ODBC avec les classes DAO ; les classes DAO offrent généralement des fonctionnalités supérieures, car elles sont spécifiques au moteur de base de données Microsoft Jet.

Vous pouvez utiliser `CDaoRecordset` directement ou dérivez une classe de `CDaoRecordset`. Pour utiliser une classe de jeu d’enregistrements dans les deux cas, ouvrez une base de données et construire un objet recordset, en passant le constructeur un pointeur vers votre `CDaoDatabase` objet. Vous pouvez également construire un `CDaoRecordset` de l’objet et permettent de créer une table temporaire MFC `CDaoDatabase` objet pour vous. Appelez ensuite le jeu d’enregistrements [Open](#open) fonction membre, qui spécifie si l’objet est un jeu d’enregistrements de type de table, un jeu d’enregistrements de type jeu de données ou un jeu d’enregistrements de type instantané. Appel `Open` sélectionne des données à partir de la base de données et récupère le premier enregistrement.

Membres de données et des fonctions de membre de l’objet permet de parcourir les enregistrements et agissent sur eux. Les opérations disponibles varient selon si l’objet est un jeu d’enregistrements de type de table, un jeu d’enregistrements de type ou un jeu d’enregistrements de type instantané, et s’il est modifiable ou en lecture seule, cela dépend de la capacité de la base de données ou de la connectivité ODBC (Open Database) source de données. Pour actualiser les enregistrements qui ont été être modifiés ou ajoutés depuis la `Open` appeler, appelez l’objet [Requery](#requery) fonction membre. Appeler l’objet `Close` membre de fonction et détruire l’objet lorsque vous avez terminé avec lui.

`CDaoRecordset` utilise l’échange de champs d’enregistrements DAO (DFX) pour prendre en charge la lecture et la mise à jour des champs des enregistrements via membres C++ de type sécurisé de votre `CDaoRecordset` ou `CDaoRecordset`-classe dérivée. Vous pouvez également implémenter la liaison dynamique des colonnes dans une base de données sans à l’aide du mécanisme DFX [GetFieldValue](#getfieldvalue) et [SetFieldValue](#setfieldvalue).

Pour plus d’informations, consultez la rubrique « Recordset, objet » dans l’aide de DAO.

## <a name="inheritance-hierarchy"></a>Hiérarchie d'héritage

[CObject](../../mfc/reference/cobject-class.md)

`CDaoRecordset`

## <a name="requirements"></a>Configuration requise

**En-tête :** afxdao.h

##  <a name="addnew"></a>  CDaoRecordset::AddNew

Appelez cette fonction membre pour ajouter un nouvel enregistrement à un jeu d’enregistrements de type de table ou de type.

```
virtual void AddNew();
```

### <a name="remarks"></a>Notes

Champs de l’enregistrement sont initialement nulle. (Dans la terminologie de base de données, Null signifie « ne having aucune valeur » et n’est pas identique à la valeur NULL en C++.) Pour terminer l’opération, vous devez appeler la [mise à jour](#update) fonction membre. `Update` enregistre les modifications apportées à la source de données.

> [!CAUTION]
>  Si vous modifiez un enregistrement et que vous accédez à un autre enregistrement sans appeler `Update`, vos modifications sont perdues sans avertissement.

Si vous ajoutez un enregistrement à un jeu d’enregistrements de type en appelant [AddNew](#addnew), l’enregistrement est visible dans le jeu d’enregistrements et inclus dans la table sous-jacente où il devient visible pour les nouveaux `CDaoRecordset` objets.

La position du nouvel enregistrement varie selon le type de jeu d’enregistrements :

- Dans un feuille de réponse dynamique-type de jeu d’enregistrements, où le nouvel enregistrement est inséré n’est pas garanti. Ce comportement est modifié avec Microsoft Jet 3.0 pour des raisons de performances et d’accès concurrentiel. Si votre objectif est de rendre le dernier enregistrement ajouté l’enregistrement en cours, obtenez le signet du dernier enregistrement modifié et déplacer vers ce signet :

[!code-cpp[NVC_MFCDatabase#1](../../mfc/codesnippet/cpp/cdaorecordset-class_1.cpp)]

- Dans un jeu d’enregistrements de type de table pour laquelle un index a été spécifié, les enregistrements sont renvoyés à l’emplacement adéquat dans l’ordre de tri. Si aucun index n’a été spécifié, les nouveaux enregistrements sont renvoyés à la fin de l’objet recordset.

L’enregistrement qui était actif avant que vous avez utilisé `AddNew` reste en cours. Si vous souhaitez rendre le nouvel enregistrement actuel et le jeu d’enregistrements prend en charge les signets, appel [SetBookmark](#setbookmark) vers le signet identifié par le paramètre de propriété de dernière modification de l’objet de jeu d’enregistrements DAO sous-jacent. Cela est utile pour déterminer la valeur pour les champs de compteur (incrémentation automatique) dans un enregistrement ajouté. Pour plus d’informations, consultez [GetLastModifiedBookmark](#getlastmodifiedbookmark).

Si la base de données prend en charge les transactions, vous pouvez rendre votre `AddNew` des appels, partie d’une transaction. Pour plus d’informations sur les transactions, consultez la classe [CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md). Notez que vous devez appeler [CDaoWorkspace::BeginTrans](../../mfc/reference/cdaoworkspace-class.md#begintrans) avant d’appeler `AddNew`.

Il est illégal d’appeler `AddNew` pour un jeu d’enregistrements dont [Open](#open) fonction membre n’a pas été appelée. Un `CDaoException` est levée si vous appelez `AddNew` pour un jeu d’enregistrements qui ne peut pas être ajouté. Vous pouvez déterminer si le recordset est modifiable en appelant [CanAppend](#canappend).

Les marques de framework modifié des données membres de champ pour vous assurer qu’ils seront écrites à l’enregistrement sur la source de données par le mécanisme DAO record field exchange (DFX). Modification de la valeur d’un champ généralement définit le champ modifié automatiquement, donc vous serez rarement nécessaire d’appeler [SetFieldDirty](#setfielddirty) vous-même, mais vous pouvez parfois faire en sorte que les colonnes seront explicitement mis à jour ou insérés quel que soit de quelle valeur est dans le membre de données de champ. Le mécanisme DFX emploie également l’utilisation de **PSEUDO NULL**. Pour plus d’informations, consultez [section CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

Si le mécanisme de double tampon n’est pas utilisé, puis en modifiant la valeur du champ ne définit pas automatiquement le champ comme modifié. Dans ce cas, il sera nécessaire de définir explicitement le champ modifié. L’indicateur contenues dans [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) contrôle de cette vérification automatique de champ.

> [!NOTE]
> Si les enregistrements sont mis en mémoire tampon double (autrement dit, la vérification automatique de champ est activée), appel `CancelUpdate` restaurera les variables de membre pour les valeurs qu’ils avaient avant `AddNew` ou `Edit` a été appelée.

Pour plus d’informations, consultez les rubriques « Méthode AddNew », « CancelUpdate, méthode », « Propriété LastModified » et « EditMode, propriété » dans l’aide de DAO.

##  <a name="canappend"></a>  CDaoRecordset::CanAppend

Appelez cette fonction membre pour déterminer si le jeu d’enregistrements précédemment ouvert vous permet d’ajouter des enregistrements en appelant le [AddNew](#addnew) fonction membre.

```
BOOL CanAppend() const;
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le jeu d’enregistrements permet d’ajouter de nouveaux enregistrements ; sinon 0. `CanAppend` retourne 0 si vous avez ouvert le jeu d’enregistrements en lecture seule.

### <a name="remarks"></a>Notes

Pour plus d’informations, consultez la rubrique « Ajout de la méthode » dans l’aide de DAO.

##  <a name="canbookmark"></a>  CDaoRecordset::CanBookmark

Appelez cette fonction membre pour déterminer si le jeu d’enregistrements précédemment ouvert vous permet de marquer individuellement les enregistrements à l’aide de signets.

```
BOOL CanBookmark();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le jeu d’enregistrements prend en charge les signets, sinon 0.

### <a name="remarks"></a>Notes

Si vous utilisez des jeux d’enregistrements basé entièrement sur des tables de moteur de base de données Microsoft Jet, les signets peuvent être utilisés sauf sur les jeux d’enregistrements de type instantané marqués en tant que jeux d’enregistrements de défilement avant uniquement. Autres produits de base de données (sources de données ODBC externes) ne peuvent pas en charge les signets.

Pour plus d’informations, consultez la rubrique « Propriété de signet » dans l’aide de DAO.

##  <a name="cancelupdate"></a>  CDaoRecordset::CancelUpdate

Le `CancelUpdate` fonction membre annule les mises à jour en attente suite à une [modifier](#edit) ou [AddNew](#addnew) opération.

```
virtual void CancelUpdate();
```

### <a name="remarks"></a>Notes

Par exemple, si une application appelle la `Edit` ou `AddNew` fonction membre et n’a pas appelé [mise à jour](#update), `CancelUpdate` annule les modifications apportées après `Edit` ou `AddNew` a été appelée.

> [!NOTE]
>  Si les enregistrements sont mis en mémoire tampon double (autrement dit, la vérification automatique de champ est activée), appel `CancelUpdate` restaurera les variables de membre pour les valeurs qu’ils avaient avant `AddNew` ou `Edit` a été appelée.

S’il existe aucune `Edit` ou `AddNew` opération en attente, `CancelUpdate` provoque des MFC lever une exception. Appelez le [GetEditMode](#geteditmode) fonction membre pour déterminer s’il existe une opération en attente peut être annulée.

Pour plus d’informations, consultez la rubrique « CancelUpdate, méthode » dans l’aide de DAO.

##  <a name="canrestart"></a>  CDaoRecordset::CanRestart

Appelez cette fonction membre pour déterminer si le jeu d’enregistrements autorise le redémarrage de sa requête (pour actualiser ses enregistrements) en appelant le `Requery` fonction membre.

```
BOOL CanRestart();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si `Requery` peut être appelée pour exécuter la requête du recordset à nouveau, sinon 0.

### <a name="remarks"></a>Notes

Jeux d’enregistrements de type de table ne gèrent pas `Requery`.

Si `Requery` est ne pas pris en charge, appelez [fermer](#close) puis [Open](#open) pour actualiser les données. Vous pouvez appeler `Requery` pour mettre à jour d’un objet recordset sous-jacent requête paramètre une fois que les valeurs de paramètre ont été modifiés.

Pour plus d’informations, consultez la rubrique « Propriété redémarrables » dans l’aide de DAO.

##  <a name="canscroll"></a>  CDaoRecordset::CanScroll

Appelez cette fonction membre pour déterminer si le jeu d’enregistrements autorise le défilement.

```
BOOL CanScroll() const;
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si vous pouvez faire défiler les enregistrements, sinon 0.

### <a name="remarks"></a>Notes

Si vous appelez [Open](#open) avec `dbForwardOnly`, le jeu d’enregistrements peut seulement défiler vers l’avant.

Pour plus d’informations, consultez la rubrique « Positionnement du pointeur d’enregistrement actuel avec DAO » dans l’aide de DAO.

##  <a name="cantransact"></a>  CDaoRecordset::CanTransact

Appelez cette fonction membre pour déterminer si le jeu d’enregistrements permet aux transactions.

```
BOOL CanTransact();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si la source de données sous-jacente prend en charge les transactions, sinon 0.

### <a name="remarks"></a>Notes

Pour plus d’informations, consultez la rubrique « Propriété de Transactions » dans l’aide de DAO.

##  <a name="canupdate"></a>  CDaoRecordset::CanUpdate

Appelez cette fonction membre pour déterminer si le jeu d’enregistrements peut être mis à jour.

```
BOOL CanUpdate() const;
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le jeu d’enregistrements peut être mis à jour (ajouter, mettre à jour et supprimer des enregistrements), sinon, 0.

### <a name="remarks"></a>Notes

Un jeu d’enregistrements peut-être être en lecture seule si la source de données sous-jacente est en lecture seule ou si vous avez spécifié `dbReadOnly` pour *nOptions* lorsque vous avez appelé [Open](#open) pour le jeu d’enregistrements.

Pour plus d’informations, consultez les rubriques « Méthode AddNew », « Modifier la méthode », « Supprimer la méthode », « Méthode de mise à jour » et « Propriété actualisable » dans l’aide de DAO.

##  <a name="cdaorecordset"></a>  CDaoRecordset::CDaoRecordset

Construit un objet `CDaoRecordset`.

```
CDaoRecordset(CDaoDatabase* pDatabase = NULL);
```

### <a name="parameters"></a>Paramètres

*pDatabase*<br/>
Contient un pointeur vers un [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md) objet ou la valeur NULL. Si non NULL et le `CDaoDatabase` l’objet `Open` fonction membre n’a pas été appelée pour vous connecter à la source de données, le jeu d’enregistrements tente d’ouvrir pour vous lors de son propre [ouvrir](#open) appeler. Si vous passez la valeur NULL, un `CDaoDatabase` objet est construit et connecté à l’aide des informations de source de données que vous avez spécifié que si vous dérivé votre classe de jeu d’enregistrements à partir de `CDaoRecordset`.

### <a name="remarks"></a>Notes

Vous pouvez utiliser `CDaoRecordset` directement ou dériver une classe spécifique à l’application à partir de `CDaoRecordset`. Vous pouvez utiliser ClassWizard pour dériver vos classes de jeu d’enregistrements.

> [!NOTE]
>  Si vous dérivez un `CDaoRecordset` classe, votre dérivée classe doit fournir son propre constructeur. Dans le constructeur de votre classe dérivée, appelez le constructeur `CDaoRecordset::CDaoRecordset`, en passant les paramètres appropriés le long de lui.

Passez la valeur NULL au constructeur de votre recordset pour avoir un `CDaoDatabase` objet construit et connecté automatiquement à votre place. Il s’agit d’un raccourci utile ne nécessitant pas construire et connecter un `CDaoDatabase` objet avant de créer votre jeu d’enregistrements. Si le `CDaoDatabase` objet n’est pas ouvert, un [CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md) objet sera également créé pour vous qui utilise l’espace de travail par défaut. Pour plus d’informations, consultez [CDaoDatabase::CDaoDatabase](../../mfc/reference/cdaodatabase-class.md#cdaodatabase).

##  <a name="close"></a>  CDaoRecordset::Close

Fermeture d’un `CDaoRecordset` objet supprime de la collection de jeux d’enregistrements ouverts dans la base de données associée.

```
virtual void Close();
```

### <a name="remarks"></a>Notes

Étant donné que `Close` ne détruit pas les `CDaoRecordset` de l’objet, vous pouvez réutiliser l’objet en appelant `Open` sur la même source de données ou une autre source de données.

Tous les en attente [AddNew](#addnew) ou [modifier](#edit) instructions sont, et toutes les transactions en attente sont annulées. Si vous souhaitez conserver les ajouts ou modifications en attente, appelez [mise à jour](#update) avant d’appeler `Close` pour chaque jeu d’enregistrements.

Vous pouvez appeler `Open` à nouveau après l’appel `Close`. Cela vous permet de réutiliser l’objet recordset. Une meilleure alternative consiste à appeler [Requery](#requery), si possible.

Pour plus d’informations, consultez la rubrique « Méthode Close » dans l’aide de DAO.

##  <a name="delete"></a>  CDaoRecordset::Delete

Appelez cette fonction membre pour supprimer l’enregistrement actif dans un objet de jeu d’enregistrements de type de table ou de type ouvert.

```
virtual void Delete();
```

### <a name="remarks"></a>Notes

Après une suppression réussie, les membres de données de champ du jeu d’enregistrements sont définies sur une valeur Null, et vous devez appeler explicitement une des fonctions membres de navigation de jeu d’enregistrements ( [déplacer](#move), [recherche](#seek), [ SetBookmark](#setbookmark), et ainsi de suite) pour l’enregistrement supprimé. Lorsque vous supprimez des enregistrements à partir d’un jeu d’enregistrements, il doit y avoir un enregistrement en cours dans le jeu d’enregistrements avant d’appeler `Delete`; sinon, MFC lève une exception.

`Delete` Supprime l’enregistrement en cours et le rend inaccessible. Bien que vous ne pouvez pas modifier ou utiliser l’enregistrement supprimé, il reste actif. Une fois que vous déplacez vers un autre enregistrement, toutefois, vous ne pouvez pas réeffectuer l’enregistrement supprimé en cours.

> [!CAUTION]
>  Le jeu d’enregistrements doit être mis à jour et il doit y avoir un enregistrement valide dans le jeu d’enregistrements lorsque vous appelez `Delete`. Par exemple, si vous supprimez un enregistrement, mais ne fait pas défiler un nouvel enregistrement avant d’appeler `Delete` là encore, `Delete` lève un [CDaoException](../../mfc/reference/cdaoexception-class.md).

Vous pouvez restaurer un enregistrement si vous utilisez des transactions et que vous appelez le [CDaoWorkspace::Rollback](../../mfc/reference/cdaoworkspace-class.md#rollback) fonction membre. Si la table de base est la table primaire en cascade supprimer la relation, la suppression de l’enregistrement actif peut également supprimer un ou plusieurs enregistrements dans une table externe. Pour plus d’informations, consultez la définition « cascade de » supprimer dans l’aide de DAO.

Contrairement aux `AddNew` et `Edit`, un appel à `Delete` n’est pas suivi par un appel à `Update`.

Pour plus d’informations, consultez les rubriques « Méthode AddNew », « Modifier la méthode », « Supprimer la méthode », « Méthode de mise à jour » et « Propriété actualisable » dans l’aide de DAO.

##  <a name="dofieldexchange"></a>  CDaoRecordset::DoFieldExchange

L’infrastructure appelle cette fonction membre pour échanger automatiquement les données entre les membres de données de champ de votre objet de jeu d’enregistrements et les colonnes correspondantes de l’enregistrement en cours sur la source de données.

```
virtual void DoFieldExchange(CDaoFieldExchange* pFX);
```

### <a name="parameters"></a>Paramètres

*pFX*<br/>
Contient un pointeur vers un `CDaoFieldExchange` objet. Le framework est déjà avoir configuré cet objet pour spécifier un contexte pour l’opération d’échange de champ.

### <a name="remarks"></a>Notes

Il lie également vos membres de données de paramètre, cas échéant, aux espaces réservés de paramètre dans la chaîne d’instruction SQL pour la sélection du jeu d’enregistrements. L’échange de données de champ, appelées échange de champs d’enregistrements DAO (DFX), fonctionne dans les deux sens : à partir de membres de données de champ de l’objet recordset aux champs de l’enregistrement sur la source de données et à partir de l’enregistrement sur la source de données à l’objet recordset. Si vous liez dynamiquement des colonnes, vous ne devez pas implémenter `DoFieldExchange`.

La seule action que vous devez normalement suivre pour implémenter `DoFieldExchange` pour votre jeu d’enregistrements dérivée classe consiste à créer la classe avec ClassWizard et spécifier les types de données et les noms des membres de données du champ. Vous pouvez également ajouter le code à ce que ClassWizard écrit spécifier les membres de données de paramètre. Si tous les champs doivent être lié dynamiquement, cette fonction sera inactive, sauf si vous spécifiez les membres de données de paramètre.

Lorsque vous déclarez votre classe dérivée de jeu d’enregistrements avec ClassWizard, l’Assistant écrit une substitution de `DoFieldExchange` pour vous, ce qui ressemble à l’exemple suivant :

[!code-cpp[NVC_MFCDatabase#2](../../mfc/codesnippet/cpp/cdaorecordset-class_2.cpp)]

##  <a name="edit"></a>  CDaoRecordset::Edit

Appelez cette fonction membre pour autoriser les modifications à l’enregistrement actif.

```
virtual void Edit();
```

### <a name="remarks"></a>Notes

Une fois que vous appelez le `Edit` fonction membre, les modifications apportées aux champs de l’enregistrement actuel sont copiés dans le tampon de copie. Après avoir apporté les modifications souhaitées à l’enregistrement, appelez `Update` pour enregistrer vos modifications. `Edit` enregistre les valeurs du jeu d’enregistrements membres de données. Si vous appelez `Edit`, apporter des modifications, puis appelez `Edit` là encore, les valeurs de l’enregistrement sont restaurés sur leur valeur avant le premier `Edit` appeler.

> [!CAUTION]
>  Si vous modifiez un enregistrement et que vous effectuez ensuite une opération qui se déplace vers un autre enregistrement sans appeler d’abord `Update`, vos modifications sont perdues sans avertissement. En outre, si vous fermez le jeu d’enregistrements ou de la base de données parente, votre enregistrement modifié est ignoré sans avertissement.

Dans certains cas, vous souhaiterez peut-être mettre à jour une colonne en le rendant Null (ne contenant aucune donnée). Pour ce faire, appelez `SetFieldNull` avec un paramètre True permet de marquer le champ de valeur Null ; cela entraîne également la colonne à mettre à jour. Si vous voulez un champ pour être écrites dans la source de données, même si sa valeur n’a pas changé, appelez `SetFieldDirty` avec un paramètre de la valeur TRUE. Cela fonctionne même si le champ a la valeur Null.

Les marques de framework modifié des données membres de champ pour vous assurer qu’ils seront écrites à l’enregistrement sur la source de données par le mécanisme DAO record field exchange (DFX). Modification de la valeur d’un champ généralement définit le champ modifié automatiquement, donc vous serez rarement nécessaire d’appeler [SetFieldDirty](#setfielddirty) vous-même, mais vous pouvez parfois faire en sorte que les colonnes seront explicitement mis à jour ou insérés quel que soit de quelle valeur est dans le membre de données de champ. Le mécanisme DFX emploie également l’utilisation de **PSEUDO NULL**. Pour plus d’informations, consultez [section CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

Si le mécanisme de double tampon n’est pas utilisé, puis en modifiant la valeur du champ ne définit pas automatiquement le champ comme modifié. Dans ce cas, il sera nécessaire de définir explicitement le champ modifié. L’indicateur contenues dans [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) contrôle de cette vérification automatique de champ.

Lorsque l’objet recordset est verrouillage pessimiste dans un environnement multi-utilisateur, l’enregistrement reste verrouillé à partir du moment `Edit` est utilisé jusqu'à ce que la mise à jour est terminée. Si le jeu d’enregistrements est verrouillage optimiste, l’enregistrement est verrouillé et comparé à l’enregistrement avant la modification juste avant qu’il est mis à jour dans la base de données. Si l’enregistrement a changé dans la mesure où vous avez appelé `Edit`, le `Update` échoue et MFC lève une exception. Vous pouvez modifier le mode de verrouillage avec `SetLockingMode`.

> [!NOTE]
>  Le verrouillage optimiste est toujours utilisé sur les formats de base de données externe, telles que ODBC et pilote ISAM.

L’enregistrement actif reste actif après avoir appelé `Edit`. Pour appeler `Edit`, il doit y avoir un enregistrement en cours. S’il n’existe aucun enregistrement actif ou si le jeu d’enregistrements ne fait pas référence à une table-type ouvert ou d’un objet de jeu d’enregistrements de type, une exception se produit. Appel `Edit` provoque un `CDaoException` devant être levé dans les conditions suivantes :

- Il n’existe aucun enregistrement actif.

- La base de données ou d’un jeu d’enregistrements est en lecture seule.

- Aucun champ dans l’enregistrement n’est modifiables.

- La base de données ou d’un jeu d’enregistrements a été ouvert pour un usage exclusif par un autre utilisateur.

- Un autre utilisateur a verrouillé la page contenant votre enregistrement.

Si la source de données prend en charge les transactions, vous pouvez rendre le `Edit` des appels, partie d’une transaction. Notez que vous devez appeler `CDaoWorkspace::BeginTrans` avant d’appeler `Edit` et une fois que le jeu d’enregistrements a été ouvert. Notez également que l’appel `CDaoWorkspace::CommitTrans` n’est pas un substitut pour appeler `Update` pour terminer le `Edit` opération. Pour plus d’informations sur les transactions, consultez la classe `CDaoWorkspace`.

Pour plus d’informations, consultez les rubriques « Méthode AddNew », « Modifier la méthode », « Supprimer la méthode », « Méthode de mise à jour » et « Propriété actualisable » dans l’aide de DAO.

##  <a name="fillcache"></a>  CDaoRecordset::FillCache

Appelez cette fonction membre pour mettre en cache un nombre spécifié d’enregistrements du jeu d’enregistrements.

```
void FillCache(
    long* pSize = NULL,
    COleVariant* pBookmark = NULL);
```

### <a name="parameters"></a>Paramètres

*pSize*<br/>
Spécifie le nombre de lignes pour remplir le cache. Si vous omettez ce paramètre, la valeur est déterminée par le paramètre de propriété CacheSize de l’objet DAO sous-jacent.

*pBookmark*<br/>
Un [COleVariant](../../mfc/reference/colevariant-class.md) spécifiant un signet. Le cache est rempli à partir de l’enregistrement indiqué par ce signet. Si vous omettez ce paramètre, le cache est rempli à partir de l’enregistrement indiqué par la propriété CacheStart de l’objet DAO sous-jacent.

### <a name="remarks"></a>Notes

La mise en cache améliore les performances d’une application qui Récupère ou extrait des données à partir d’un serveur distant. Un cache est un espace dans la mémoire locale qui contient les données extraites le plus récemment à partir du serveur sur l’hypothèse que les données seront probablement demandées à nouveau pendant l’exécution de l’application. Lorsque les données sont demandées, le moteur de base de données Microsoft Jet vérifie tout d’abord le cache pour les données au lieu de l’extraction à partir du serveur, ce qui prend plus de temps. À l’aide de données mise en cache sur les sources de données non-ODBC n’a aucun effet car les données ne sont pas enregistrées dans le cache.

Au lieu d’attendre que le cache à remplir avec des enregistrements comme elles sont lues, vous pouvez remplir explicitement le cache à tout moment en appelant le `FillCache` fonction membre. Il s’agit d’un moyen plus rapide pour remplir le cache, car `FillCache` extrait plusieurs enregistrements à la fois au lieu d’un à la fois. Par exemple, tandis que chaque écran d’enregistrements est affiché, vous pouvez avoir votre appel de l’application `FillCache` pour extraire l’écran suivant d’enregistrements.

Toute base de données ODBC accessible avec les objets de jeu d’enregistrements peut avoir un cache local. Pour créer le cache, ouvrez un objet recordset à partir de la source de données distante, puis appelez le `SetCacheSize` et `SetCacheStart` les fonctions membres de l’objet recordset. Si *lSize* et *lBookmark* créer une plage qui est partiellement ou entièrement en dehors de la plage spécifiée par `SetCacheSize` et `SetCacheStart`, la partie de l’ensemble d’enregistrements en dehors de cette plage est ignorée et n’est pas chargé dans le cache. Si `FillCache` demande plus d’enregistrements que restent dans la source de données à distance, seuls les enregistrements restants sont extraites, et aucune exception n’est levée.

Enregistrements extraits à partir du cache ne reflètent pas les modifications apportées simultanément à la source de données par d’autres utilisateurs.

`FillCache` extrait uniquement les enregistrements pas déjà mis en cache. Pour forcer une mise à jour de toutes les données mises en cache, appelez le `SetCacheSize` fonction membre avec un *lSize* paramètre égal à 0, l’appel `SetCacheSize` à nouveau avec le *lSize* paramètre égal à la taille du cache votre demandée à l’origine, puis appelez `FillCache`.

Pour plus d’informations, consultez la rubrique « Méthode FillCache » dans l’aide de DAO.

##  <a name="find"></a>  CDaoRecordset::Find

Appelez cette fonction membre pour rechercher une chaîne particulière dans un jeu d’enregistrements de type feuille de réponse dynamique ou d’instantané à l’aide d’un opérateur de comparaison.

```
virtual BOOL Find(
    long lFindType,
    LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Paramètres

*lFindType*<br/>
Une valeur indiquant le type d’opération de recherche que vous le souhaitez. Les valeurs possibles sont :

- AFX_DAO_NEXT trouver l’emplacement suivant d’une chaîne correspondante.

- AFX_DAO_PREV trouver l’emplacement précédent d’une chaîne correspondante.

- AFX_DAO_FIRST rechercher le premier emplacement d’une chaîne correspondante.

- AFX_DAO_LAST rechercher le dernier emplacement d’une chaîne correspondante.

*lpszFilter*<br/>
Une expression de chaîne (comme le **où** clause dans une instruction SQL sans le mot **où**) permet de localiser l’enregistrement. Exemple :

[!code-cpp[NVC_MFCDatabase#3](../../mfc/codesnippet/cpp/cdaorecordset-class_3.cpp)]

### <a name="return-value"></a>Valeur de retour

Différent de zéro si les enregistrements correspondants sont trouvés, sinon 0.

### <a name="remarks"></a>Notes

Vous pouvez trouver la première, suivante, précédente, ou la dernière instance de la chaîne. `Find` étant une fonction virtuelle, vous pouvez le remplacer et ajouter votre propre implémentation. Le `FindFirst`, `FindLast`, `FindNext`, et `FindPrev` fonctions membres appellent le `Find` fonction membre, vous pouvez donc utiliser `Find` pour contrôler le comportement de toutes les opérations de recherche.

Pour obtenir un enregistrement dans un jeu d’enregistrements de type de table, appelez le [recherche](#seek) fonction membre.

> [!TIP]
>  Plus le jeu d’enregistrements vous disposez, la plus efficace `Find` sera. En général et en particulier avec les données ODBC, il est préférable de créer une requête qui récupère uniquement les enregistrements que vous souhaitez.

Pour plus d’informations, consultez la rubrique « FindFirst, FindLast, FindNext, FindPrevious méthodes » dans l’aide de DAO.

##  <a name="findfirst"></a>  CDaoRecordset::FindFirst

Appelez cette fonction membre pour rechercher le premier enregistrement qui correspond à une condition spécifiée.

```
BOOL FindFirst(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Paramètres

*lpszFilter*<br/>
Une expression de chaîne (comme le **où** clause dans une instruction SQL sans le mot **où**) permet de localiser l’enregistrement.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si les enregistrements correspondants sont trouvés, sinon 0.

### <a name="remarks"></a>Notes

Le `FindFirst` fonction membre commence sa recherche à partir du début de l’ensemble d’enregistrements et les recherches à la fin de l’objet recordset.

Si vous souhaitez inclure tous les enregistrements dans votre recherche (pas seulement ceux qui remplissent une condition spécifique) utilisent une des opérations de déplacement pour déplacer à partir d’un enregistrement à un autre. Pour obtenir un enregistrement dans un jeu d’enregistrements de type de table, appelez le `Seek` fonction membre.

Si un enregistrement correspondant aux critères n’est pas localisé, le pointeur d’enregistrement actuel est indéterminé, et `FindFirst` retourne la valeur zéro. Si le jeu d’enregistrements contient plusieurs enregistrements qui satisfait aux critères, `FindFirst` localise la première occurrence, `FindNext` recherche l’occurrence suivante et ainsi de suite.

> [!CAUTION]
>  Si vous modifiez l’enregistrement actif, veillez à enregistrer les modifications en appelant le `Update` fonction membre avant de passer à un autre enregistrement. Si vous déplacez vers un autre enregistrement sans mettre à jour, vos modifications sont perdues sans avertissement.

Le `Find` fonctions membres de recherche à partir de l’emplacement et dans la direction spécifiée dans le tableau suivant :

|Les opérations de recherche|commencer|Sens de la recherche|
|---------------------|-----------|----------------------|
|`FindFirst`|Début du jeu d’enregistrements|Fin du jeu d’enregistrements|
|`FindLast`|Fin du jeu d’enregistrements|Début du jeu d’enregistrements|
|`FindNext`|Enregistrement en cours|Fin du jeu d’enregistrements|
|`FindPrevious`|Enregistrement en cours|Début du jeu d’enregistrements|

> [!NOTE]
>  Lorsque vous appelez `FindLast`, le moteur de base de données Microsoft Jet remplit entièrement votre jeu d’enregistrements avant de commencer la recherche, si cela n’a pas déjà été fait. La première recherche peut prendre plus de temps que les recherches suivantes.

À l’aide de l’une des opérations de recherche n’est pas le même que si vous appelez `MoveFirst` ou `MoveNext`, toutefois, ce qui rend simplement l’enregistrement de la première ou prochain actuel sans spécifier une condition. Vous pouvez suivre une opération de recherche avec une opération de déplacement.

Gardez les points suivants à l’esprit lorsque vous utilisez les opérations de recherche :

- Si `Find` retourne différent de zéro, l’enregistrement en cours n’est pas défini. Dans ce cas, vous devez positionner le pointeur d’enregistrement actuel vers un enregistrement valide.

- Vous ne pouvez pas utiliser une opération de recherche avec un recordset de type instantané défilement avant uniquement.

- Vous devez utiliser le format de date des États-Unis (mois-jour-année) lorsque vous recherchez des champs contenant des dates, même si vous n’utilisez pas la version américaine du moteur de base de données Microsoft Jet ; Sinon, enregistrements correspondants peuvent être introuvable.

- Lorsque vous travaillez avec des bases de données ODBC et les dynasets volumineux, vous pouvez constater que l’utilisation des opérations de recherche est lente, en particulier lorsque vous travaillez avec des jeux d’enregistrements volumineux. Vous pouvez améliorer les performances à l’aide de requêtes SQL avec personnalisé **ORDERBY** ou **où** clauses, les requêtes avec paramètres, ou `CDaoQuerydef` objets qui extraient des enregistrements indexés spécifiques.

Pour plus d’informations, consultez la rubrique « FindFirst, FindLast, FindNext, FindPrevious méthodes » dans l’aide de DAO.

##  <a name="findlast"></a>  CDaoRecordset::FindLast

Appelez cette fonction membre pour rechercher le dernier enregistrement qui correspond à une condition spécifiée.

```
BOOL FindLast(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Paramètres

*lpszFilter*<br/>
Une expression de chaîne (comme le **où** clause dans une instruction SQL sans le mot **où**) permet de localiser l’enregistrement.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si les enregistrements correspondants sont trouvés, sinon 0.

### <a name="remarks"></a>Notes

Le `FindLast` fonction membre commence sa recherche à la fin de l’ensemble d’enregistrements et recherche vers l’arrière vers le début de l’objet recordset.

Si vous souhaitez inclure tous les enregistrements dans votre recherche (pas seulement ceux qui remplissent une condition spécifique) utilisent une des opérations de déplacement pour déplacer à partir d’un enregistrement à un autre. Pour obtenir un enregistrement dans un jeu d’enregistrements de type de table, appelez le `Seek` fonction membre.

Si un enregistrement correspondant aux critères n’est pas localisé, le pointeur d’enregistrement actuel est indéterminé, et `FindLast` retourne la valeur zéro. Si le jeu d’enregistrements contient plusieurs enregistrements qui satisfait aux critères, `FindFirst` localise la première occurrence, `FindNext` recherche l’occurrence suivante après la première occurrence et ainsi de suite.

> [!CAUTION]
>  Si vous modifiez l’enregistrement actif, veillez à ce que vous enregistrez les modifications en appelant le `Update` fonction membre avant de passer à un autre enregistrement. Si vous déplacez vers un autre enregistrement sans mettre à jour, vos modifications sont perdues sans avertissement.

À l’aide de l’une des opérations de recherche n’est pas le même que si vous appelez `MoveFirst` ou `MoveNext`, toutefois, ce qui rend simplement l’enregistrement de la première ou prochain actuel sans spécifier une condition. Vous pouvez suivre une opération de recherche avec une opération de déplacement.

Gardez les points suivants à l’esprit lorsque vous utilisez les opérations de recherche :

- Si `Find` retourne différent de zéro, l’enregistrement en cours n’est pas défini. Dans ce cas, vous devez positionner le pointeur d’enregistrement actuel vers un enregistrement valide.

- Vous ne pouvez pas utiliser une opération de recherche avec un recordset de type instantané défilement avant uniquement.

- Vous devez utiliser le format de date des États-Unis (mois-jour-année) lorsque vous recherchez des champs contenant des dates, même si vous n’utilisez pas la version américaine du moteur de base de données Microsoft Jet ; Sinon, enregistrements correspondants peuvent être introuvable.

- Lorsque vous travaillez avec des bases de données ODBC et les dynasets volumineux, vous pouvez constater que l’utilisation des opérations de recherche est lente, en particulier lorsque vous travaillez avec des jeux d’enregistrements volumineux. Vous pouvez améliorer les performances à l’aide de requêtes SQL avec personnalisé **ORDERBY** ou **où** clauses, les requêtes avec paramètres, ou `CDaoQuerydef` objets qui extraient des enregistrements indexés spécifiques.

Pour plus d’informations, consultez la rubrique « FindFirst, FindLast, FindNext, FindPrevious méthodes » dans l’aide de DAO.

##  <a name="findnext"></a>  CDaoRecordset::FindNext

Appelez cette fonction membre pour rechercher l’enregistrement suivant qui correspond à une condition spécifiée.

```
BOOL FindNext(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Paramètres

*lpszFilter*<br/>
Une expression de chaîne (comme le **où** clause dans une instruction SQL sans le mot **où**) permet de localiser l’enregistrement.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si les enregistrements correspondants sont trouvés, sinon 0.

### <a name="remarks"></a>Notes

Le `FindNext` fonction membre débute sa recherche à l’enregistrement actif et la recherche à la fin de l’objet recordset.

Si vous souhaitez inclure tous les enregistrements dans votre recherche (pas seulement ceux qui remplissent une condition spécifique) utilisent une des opérations de déplacement pour déplacer à partir d’un enregistrement à un autre. Pour obtenir un enregistrement dans un jeu d’enregistrements de type de table, appelez le `Seek` fonction membre.

Si un enregistrement correspondant aux critères n’est pas localisé, le pointeur d’enregistrement actuel est indéterminé, et `FindNext` retourne la valeur zéro. Si le jeu d’enregistrements contient plusieurs enregistrements qui satisfait aux critères, `FindFirst` localise la première occurrence, `FindNext` recherche l’occurrence suivante et ainsi de suite.

> [!CAUTION]
>  Si vous modifiez l’enregistrement actif, veillez à ce que vous enregistrez les modifications en appelant le `Update` fonction membre avant de passer à un autre enregistrement. Si vous déplacez vers un autre enregistrement sans mettre à jour, vos modifications sont perdues sans avertissement.

À l’aide de l’une des opérations de recherche n’est pas le même que si vous appelez `MoveFirst` ou `MoveNext`, toutefois, ce qui rend simplement l’enregistrement de la première ou prochain actuel sans spécifier une condition. Vous pouvez suivre une opération de recherche avec une opération de déplacement.

Gardez les points suivants à l’esprit lorsque vous utilisez les opérations de recherche :

- Si `Find` retourne différent de zéro, l’enregistrement en cours n’est pas défini. Dans ce cas, vous devez positionner le pointeur d’enregistrement actuel vers un enregistrement valide.

- Vous ne pouvez pas utiliser une opération de recherche avec un recordset de type instantané défilement avant uniquement.

- Vous devez utiliser le format de date des États-Unis (mois-jour-année) lorsque vous recherchez des champs contenant des dates, même si vous n’utilisez pas la version américaine du moteur de base de données Microsoft Jet ; Sinon, enregistrements correspondants peuvent être introuvable.

- Lorsque vous travaillez avec des bases de données ODBC et les dynasets volumineux, vous pouvez constater que l’utilisation des opérations de recherche est lente, en particulier lorsque vous travaillez avec des jeux d’enregistrements volumineux. Vous pouvez améliorer les performances à l’aide de requêtes SQL avec personnalisé **ORDERBY** ou **où** clauses, les requêtes avec paramètres, ou `CDaoQuerydef` objets qui extraient des enregistrements indexés spécifiques.

Pour plus d’informations, consultez la rubrique « FindFirst, FindLast, FindNext, FindPrevious méthodes » dans l’aide de DAO.

##  <a name="findprev"></a>  CDaoRecordset::FindPrev

Appelez cette fonction membre pour rechercher l’enregistrement précédent qui correspond à une condition spécifiée.

```
BOOL FindPrev(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Paramètres

*lpszFilter*<br/>
Une expression de chaîne (comme le **où** clause dans une instruction SQL sans le mot **où**) permet de localiser l’enregistrement.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si les enregistrements correspondants sont trouvés, sinon 0.

### <a name="remarks"></a>Notes

Le `FindPrev` fonction membre débute sa recherche à l’enregistrement actif et la recherche vers l’arrière vers le début de l’objet recordset.

Si vous souhaitez inclure tous les enregistrements dans votre recherche (pas seulement ceux qui remplissent une condition spécifique) utilisent une des opérations de déplacement pour déplacer à partir d’un enregistrement à un autre. Pour obtenir un enregistrement dans un jeu d’enregistrements de type de table, appelez le `Seek` fonction membre.

Si un enregistrement correspondant aux critères n’est pas localisé, le pointeur d’enregistrement actuel est indéterminé, et `FindPrev` retourne la valeur zéro. Si le jeu d’enregistrements contient plusieurs enregistrements qui satisfait aux critères, `FindFirst` localise la première occurrence, `FindNext` recherche l’occurrence suivante et ainsi de suite.

> [!CAUTION]
>  Si vous modifiez l’enregistrement actif, veillez à ce que vous enregistrez les modifications en appelant le `Update` fonction membre avant de passer à un autre enregistrement. Si vous déplacez vers un autre enregistrement sans mettre à jour, vos modifications sont perdues sans avertissement.

À l’aide de l’une des opérations de recherche n’est pas le même que si vous appelez `MoveFirst` ou `MoveNext`, toutefois, ce qui rend simplement l’enregistrement de la première ou prochain actuel sans spécifier une condition. Vous pouvez suivre une opération de recherche avec une opération de déplacement.

Gardez les points suivants à l’esprit lorsque vous utilisez les opérations de recherche :

- Si `Find` retourne différent de zéro, l’enregistrement en cours n’est pas défini. Dans ce cas, vous devez positionner le pointeur d’enregistrement actuel vers un enregistrement valide.

- Vous ne pouvez pas utiliser une opération de recherche avec un recordset de type instantané défilement avant uniquement.

- Vous devez utiliser le format de date des États-Unis (mois-jour-année) lorsque vous recherchez des champs contenant des dates, même si vous n’utilisez pas la version américaine du moteur de base de données Microsoft Jet ; Sinon, enregistrements correspondants peuvent être introuvable.

- Lorsque vous travaillez avec des bases de données ODBC et les dynasets volumineux, vous pouvez constater que l’utilisation des opérations de recherche est lente, en particulier lorsque vous travaillez avec des jeux d’enregistrements volumineux. Vous pouvez améliorer les performances à l’aide de requêtes SQL avec personnalisé **ORDERBY** ou **où** clauses, les requêtes avec paramètres, ou `CDaoQuerydef` objets qui extraient des enregistrements indexés spécifiques.

Pour plus d’informations, consultez la rubrique « FindFirst, FindLast, FindNext, FindPrevious méthodes » dans l’aide de DAO.

##  <a name="getabsoluteposition"></a>  CDaoRecordset::GetAbsolutePosition

Retourne le numéro d’enregistrement de l’enregistrement en cours d’un objet recordset.

```
long GetAbsolutePosition();
```

### <a name="return-value"></a>Valeur de retour

Un entier entre 0 et le nombre d’enregistrements dans le jeu d’enregistrements. Correspond à la position ordinale de l’enregistrement actif dans le jeu d’enregistrements.

### <a name="remarks"></a>Notes

La valeur de propriété AbsolutePosition de l’objet DAO sous-jacent est zéro ; la valeur 0 fait référence au premier enregistrement dans le jeu d’enregistrements. Vous pouvez déterminer le nombre d’enregistrements dans le jeu d’enregistrements en appelant [GetRecordCount](#getrecordcount). Appel `GetRecordCount` peut prendre un certain temps, car il doit accéder à tous les enregistrements pour déterminer le nombre.

S’il n’existe aucun enregistrement en cours, en tant que lorsqu’il n’existe aucun enregistrement dans le jeu d’enregistrements, - 1 est retournée. Si l’enregistrement actif est supprimé, la valeur de propriété AbsolutePosition n’est pas définie, et MFC lève une exception si elle est référencée. Pour les types d’enregistrements, les nouveaux enregistrements sont ajoutés à la fin de la séquence.

> [!NOTE]
>  Cette propriété n’est pas destinée à être utilisé comme un numéro d’enregistrement de substitution. Signets sont toujours recommandé de conserver et revenir à une position donnée et sont la seule façon de positionner l’enregistrement actif sur tous les types d’objets de jeu d’enregistrements. En particulier, la position d’un enregistrement donné change lorsque les enregistrements précèdent sont supprimés. Il n’existe également aucune assurance qu’un enregistrement donné aura la même position absolue si le jeu d’enregistrements est recréé à nouveau, car l’ordre des enregistrements individuels dans un jeu d’enregistrements n’est pas garanti, sauf si elle est créée avec une instruction SQL qui utilise un  **ORDERBY** clause.

> [!NOTE]
>  Cette fonction membre est valide uniquement pour les type jeu de données et les jeux d’enregistrements de type instantané.

Pour plus d’informations, consultez la rubrique « AbsolutePosition, propriété » dans l’aide de DAO.

##  <a name="getbookmark"></a>  CDaoRecordset::CanBookmark

Appelez cette fonction membre pour obtenir la valeur de signet dans un enregistrement particulier.

```
COleVariant GetBookmark();
```

### <a name="return-value"></a>Valeur de retour

Retourne une valeur représentant le signet sur l’enregistrement actif.

### <a name="remarks"></a>Notes

Lorsqu’un objet recordset est créé ou ouvert, chacun de ses enregistrements possède déjà un signet unique si elle prend en charge les. Appelez `CanBookmark` pour déterminer si un jeu d’enregistrements prend en charge les signets.

Vous pouvez enregistrer le signet de l’enregistrement en cours, affectez la valeur du signet à un `COleVariant` objet. Pour retourner rapidement à cet enregistrement à tout moment après avoir déplacé vers un autre enregistrement, appelez `SetBookmark` avec un paramètre correspondant à la valeur de cette `COleVariant` objet.

> [!NOTE]
>  Appel [Requery](#requery) modifie les signets DAO.

Pour plus d’informations, consultez la rubrique « Propriété de signet » dans l’aide de DAO.

##  <a name="getcachesize"></a>  CDaoRecordset::GetCacheSize

Appelez cette fonction membre pour obtenir le nombre d’enregistrements mis en cache.

```
long GetCacheSize();
```

### <a name="return-value"></a>Valeur de retour

Une valeur qui spécifie le nombre d’enregistrements dans un jeu d’enregistrements de type jeu de données contenant des données à mettre en cache localement à partir d’une source de données ODBC.

### <a name="remarks"></a>Notes

La mise en cache des données améliorent les performances d’une application qui Récupère des données à partir d’un serveur distant via des objets de jeu d’enregistrements de type instantané. Un cache est un espace dans la mémoire locale qui contient les données récemment extraites du serveur dans le cas où les données seront à nouveau demandées pendant l’exécution de l’application. Lorsque les données sont demandées, le moteur de base de données Microsoft Jet vérifie tout d’abord le cache pour les données demandées au lieu de son extraction à partir du serveur, ce qui prend plus de temps. Les données qui ne proviennent pas d’une source de données ODBC ne sont pas enregistrées dans le cache.

Toute source de données ODBC, par exemple une table jointe, peut avoir un cache local.

Pour plus d’informations, consultez la rubrique « CacheSize, CacheStart propriétés » dans l’aide de DAO.

##  <a name="getcachestart"></a>  CDaoRecordset::GetCacheStart

Appelez cette fonction membre pour obtenir la valeur de signet du premier enregistrement dans le jeu d’enregistrements doit être mis en cache.

```
COleVariant GetCacheStart();
```

### <a name="return-value"></a>Valeur de retour

Un `COleVariant` qui spécifie le signet du premier enregistrement dans le jeu d’enregistrements doit être mis en cache.

### <a name="remarks"></a>Notes

Le moteur de base de données Microsoft Jet demande des enregistrements dans la plage de cache à partir du cache, et il demande des enregistrements en dehors de la plage de cache à partir du serveur.

> [!NOTE]
>  Enregistrements récupérés à partir du cache ne reflètent pas les modifications apportées simultanément à la source de données par d’autres utilisateurs.

Pour plus d’informations, consultez la rubrique « CacheSize, CacheStart propriétés » dans l’aide de DAO.

##  <a name="getcurrentindex"></a>  CDaoRecordset::GetCurrentIndex

Appelez cette fonction membre pour déterminer l’index en cours d’utilisation dans un type de table indexée `CDaoRecordset` objet.

```
CString GetCurrentIndex();
```

### <a name="return-value"></a>Valeur de retour

Un `CString` contenant le nom de l’index en cours d’utilisation avec un jeu d’enregistrements de type de table. Retourne une chaîne vide si aucun index n’a pas été défini.

### <a name="remarks"></a>Notes

Cet index est la base pour le classement des enregistrements dans un jeu d’enregistrements de type de table et est utilisé par le [recherche](#seek) fonction membre pour localiser les enregistrements.

Un `CDaoRecordset` objet peut avoir plusieurs index mais peut utiliser un seul index à la fois (même si un [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) objet peut avoir plusieurs index définis sur ce dernier).

Pour plus d’informations, consultez la rubrique « Objet Index » et la définition de « index actuel » dans l’aide de DAO.

##  <a name="getdatecreated"></a>  CDaoRecordset::GetDateCreated

Appelez cette fonction membre pour récupérer la date et l’heure de que création d’une table de base.

```
COleDateTime GetDateCreated();
```

### <a name="return-value"></a>Valeur de retour

Un [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) objet contenant la date et l’heure de création de la table de base.

### <a name="remarks"></a>Notes

Les paramètres de date et d’heure sont dérivés de l’ordinateur sur lequel la table de base a été créée.

Pour plus d’informations, consultez la rubrique « DateCreated, LastUpdated propriétés » dans l’aide de DAO.

##  <a name="getdatelastupdated"></a>  CDaoRecordset::GetDateLastUpdated

Appelez cette fonction membre pour récupérer la date et l’heure que le schéma a été mis à jour.

```
COleDateTime GetDateLastUpdated();
```

### <a name="return-value"></a>Valeur de retour

Un [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) objet contenant la date et heure de dernière mise à jour de la structure de table de base (schéma).

### <a name="remarks"></a>Notes

Les paramètres de date et d’heure sont dérivés de l’ordinateur sur lequel la structure de table de base (schéma) a été dernière mise à jour.

Pour plus d’informations, consultez la rubrique « DateCreated, LastUpdated propriétés » dans l’aide de DAO.

##  <a name="getdefaultdbname"></a>  CDaoRecordset::GetDefaultDBName

Appelez cette fonction membre pour déterminer le nom de la base de données pour ce jeu d’enregistrements.

```
virtual CString GetDefaultDBName();
```

### <a name="return-value"></a>Valeur de retour

Un `CString` qui contient le chemin d’accès et le nom de la base de données à partir de laquelle ce jeu d’enregistrements est dérivée.

### <a name="remarks"></a>Notes

Si un jeu d’enregistrements est créé sans un pointeur vers un [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md), ce chemin d’accès est utilisé par le jeu d’enregistrements pour ouvrir la base de données par défaut. Par défaut, cette fonction retourne une chaîne vide. Lorsque ClassWizard dérive un nouveau jeu d’enregistrements à partir de `CDaoRecordset`, il va créer cette fonction pour vous.

L’exemple suivant illustre l’utilisation de la double barre oblique inverse (\\\\) dans la chaîne, comme cela est requis pour la chaîne doit être interprété correctement.

[!code-cpp[NVC_MFCDatabase#4](../../mfc/codesnippet/cpp/cdaorecordset-class_4.cpp)]

##  <a name="getdefaultsql"></a>  CDaoRecordset::GetDefaultSQL

L’infrastructure appelle cette fonction membre pour obtenir de l’instruction SQL par défaut sur lequel repose le jeu d’enregistrements.

```
virtual CString GetDefaultSQL();
```

### <a name="return-value"></a>Valeur de retour

Un `CString` qui contient l’instruction SQL par défaut.

### <a name="remarks"></a>Notes

Cela peut être un nom de table ou d’une instance SQL **sélectionnez** instruction.

Vous définissez indirectement l’instruction SQL par défaut en déclarant votre classe de jeu d’enregistrements avec ClassWizard et ClassWizard effectue cette tâche pour vous.

Si vous passez une chaîne SQL null à [Open](#open), cette fonction est appelée pour déterminer le nom de la table ou de SQL pour votre jeu d’enregistrements.

##  <a name="geteditmode"></a>  CDaoRecordset::GetEditMode

Appelez cette fonction membre pour déterminer l’état de la modification, qui est une des valeurs suivantes :

```
short GetEditMode();
```

### <a name="return-value"></a>Valeur de retour

Retourne une valeur qui indique l’état de modification de l’enregistrement actif.

### <a name="remarks"></a>Notes

|Value|Description|
|-----------|-----------------|
|`dbEditNone`|Aucune opération de modification n’est en cours.|
|`dbEditInProgress`|`Edit` a été appelée.|
|`dbEditAdd`|`AddNew` a été appelée.|

Pour plus d’informations, consultez la rubrique « EditMode, propriété » dans l’aide de DAO.

##  <a name="getfieldcount"></a>  CDaoRecordset::GetFieldCount

Appelez cette fonction membre pour récupérer le nombre de champs (colonnes) définis dans le jeu d’enregistrements.

```
short GetFieldCount();
```

### <a name="return-value"></a>Valeur de retour

Le nombre de champs dans le jeu d’enregistrements.

### <a name="remarks"></a>Notes

Pour plus d’informations, consultez la rubrique « Propriété Count » dans l’aide de DAO.

##  <a name="getfieldinfo"></a>  CDaoRecordset::GetFieldInfo

Appelez cette fonction membre pour obtenir des informations sur les champs dans un jeu d’enregistrements.

```
void GetFieldInfo(
    int nIndex,
    CDaoFieldInfo& fieldinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

void GetFieldInfo(
    LPCTSTR lpszName,
    CDaoFieldInfo& fieldinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
Index de base zéro du champ prédéfini dans la collection de champs du jeu d’enregistrements, pour la recherche par index.

*FieldInfo*<br/>
Une référence à un [CDaoFieldInfo](../../mfc/reference/cdaofieldinfo-structure.md) structure.

*dwInfoOptions*<br/>
Options qui spécifient les informations sur le jeu d’enregistrements à récupérer. Les options disponibles sont répertoriées ici, ainsi que leur cause la fonction à retourner. Pour de meilleures performances, récupérer uniquement le niveau d’informations dont vous avez besoin :

- `AFX_DAO_PRIMARY_INFO` (Valeur par défaut) Nom, Type, taille, attributs

- `AFX_DAO_SECONDARY_INFO` Informations primaire, ainsi que : Ordinal, obligatoire, permettre de Position zéro Table de Source de nom étrangère, champ Source, de longueur, ordre de classement,

- `AFX_DAO_ALL_INFO` Informations primaires et secondaires, ainsi que : texte de Validation de valeur par défaut, règle de Validation

*Caractère*<br/>
Nom du champ.

### <a name="remarks"></a>Notes

Une version de la fonction vous permet de rechercher un champ par index. L’autre version vous permet de rechercher un champ par nom.

Pour obtenir une description des informations retournées, consultez le [CDaoFieldInfo](../../mfc/reference/cdaofieldinfo-structure.md) structure. Cette structure a des membres qui correspondent aux éléments d’informations répertoriées ci-dessus dans la description de *dwInfoOptions*. Lorsque vous demandez des informations à un niveau, vous obtenez des informations sur n’importe quel préalable des niveaux.

Pour plus d’informations, consultez la rubrique « Propriété des attributs » dans l’aide de DAO.

##  <a name="getfieldvalue"></a>  CDaoRecordset::GetFieldValue

Appelez cette fonction membre pour récupérer des données dans un jeu d’enregistrements.

```
virtual void GetFieldValue(
    LPCTSTR lpszName,
    COleVariant& varValue);

virtual void GetFieldValue(
    int nIndex,
    COleVariant& varValue);

virtual COleVariant GetFieldValue(LPCTSTR lpszName);
virtual COleVariant GetFieldValue(int nIndex);
```

### <a name="parameters"></a>Paramètres

*Caractère*<br/>
Un pointeur vers une chaîne qui contient le nom d’un champ.

*varValue*<br/>
Une référence à un `COleVariant` objet qui stocke la valeur d’un champ.

*nIndex*<br/>
Index de base zéro du champ dans la collection de champs du jeu d’enregistrements, pour la recherche par index.

### <a name="return-value"></a>Valeur de retour

Les deux versions de `GetFieldValue` qui retournent une valeur de retour un [COleVariant](../../mfc/reference/colevariant-class.md) objet qui contient la valeur d’un champ.

### <a name="remarks"></a>Notes

Vous pouvez rechercher un champ par nom ou par position ordinale.

> [!NOTE]
>  Il est plus efficace pour appeler l’une des versions de cette fonction membre qui accepte un `COleVariant` référence d’objet comme un paramètre, plutôt que d’appeler une version qui retourne un `COleVariant` objet. Les versions de ce dernier de cette fonction sont conservées pour la compatibilité descendante.

Utilisez `GetFieldValue` et [SetFieldValue](#setfieldvalue) pour lier des champs de manière dynamique au moment de l’exécution plutôt que statiquement des colonnes de liaison à l’aide de la [DoFieldExchange](#dofieldexchange) mécanisme.

`GetFieldValue` et le `DoFieldExchange` mécanisme peut être combiné pour améliorer les performances. Par exemple, utilisez `GetFieldValue` pour récupérer une valeur dont vous avez besoin uniquement à la demande et affecter qu’un appel à un bouton « Informations complémentaires » dans l’interface.

Pour plus d’informations, consultez les rubriques « Objet de champ » et « Valeur de propriété » dans l’aide de DAO.

##  <a name="getindexcount"></a>  CDaoRecordset::GetIndexCount

Appelez cette fonction membre pour déterminer le nombre d’index disponibles sur le jeu d’enregistrements de type de table.

```
short GetIndexCount();
```

### <a name="return-value"></a>Valeur de retour

Le nombre d’index dans le jeu d’enregistrements de type de table.

### <a name="remarks"></a>Notes

`GetIndexCount` est utile pour une boucle dans tous les index dans le jeu d’enregistrements. Pour ce faire, utilisez `GetIndexCount` conjointement avec [GetIndexInfo](#getindexinfo). Si vous appelez cette fonction membre sur les jeux d’enregistrements de type instantané ou de type, MFC lève une exception.

Pour plus d’informations, consultez la rubrique « Propriété des attributs » dans l’aide de DAO.

##  <a name="getindexinfo"></a>  CDaoRecordset::GetIndexInfo

Appelez cette fonction membre pour obtenir les différents types d’informations sur un index défini dans la table de base sous-jacent d’un jeu d’enregistrements.

```
void GetIndexInfo(
    int nIndex,
    CDaoIndexInfo& indexinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

void GetIndexInfo(
    LPCTSTR lpszName,
    CDaoIndexInfo& indexinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
Index de base zéro dans la collection d’index de la table, pour la recherche par position numérique.

*indexinfo*<br/>
Une référence à un [CDaoIndexInfo](../../mfc/reference/cdaoindexinfo-structure.md) structure.

*dwInfoOptions*<br/>
Options qui spécifient les informations sur l’index à récupérer. Les options disponibles sont répertoriées ici, ainsi que leur cause la fonction à retourner. Pour de meilleures performances, récupérer uniquement le niveau d’informations dont vous avez besoin :

- `AFX_DAO_PRIMARY_INFO` (Valeur par défaut) Champs de noms, les informations de champ

- `AFX_DAO_SECONDARY_INFO` Informations primaire, ainsi que : principal, Unique, Clustered, Ignorer Nulls, obligatoire, étranger

- `AFX_DAO_ALL_INFO` Informations primaires et secondaires, ainsi que : comptage de valeurs

*Caractère*<br/>
Un pointeur vers le nom de l’objet index, pour la recherche par nom.

### <a name="remarks"></a>Notes

Une version de la fonction vous permet de rechercher un index par sa position dans la collection. L’autre version vous permet de rechercher un index par nom.

Pour obtenir une description des informations retournées, consultez le [CDaoIndexInfo](../../mfc/reference/cdaoindexinfo-structure.md) structure. Cette structure a des membres qui correspondent aux éléments d’informations répertoriées ci-dessus dans la description de *dwInfoOptions*. Lorsque vous demandez des informations à un niveau, vous obtenez des informations sur n’importe quel préalable des niveaux.

Pour plus d’informations, consultez la rubrique « Propriété des attributs » dans l’aide de DAO.

##  <a name="getlastmodifiedbookmark"></a>  CDaoRecordset::GetLastModifiedBookmark

Appelez cette fonction membre pour récupérer le signet de l’enregistrement plus récemment ajouté ou mis à jour.

```
COleVariant GetLastModifiedBookmark();
```

### <a name="return-value"></a>Valeur de retour

Un `COleVariant` contenant un signet qui indique le dernier enregistrement ajouté ou modifié.

### <a name="remarks"></a>Notes

Lorsqu’un objet recordset est créé ou ouvert, chacun de ses enregistrements possède déjà un signet unique si elle prend en charge les. Appelez [GetBookmark](#getbookmark) pour déterminer si le jeu d’enregistrements prend en charge les signets. Si le jeu d’enregistrements ne prend pas en charge les signets, un `CDaoException` est levée.

Lorsque vous ajoutez un enregistrement, il apparaît à la fin de l’objet recordset et n’est pas l’enregistrement en cours. Pour le nouvel enregistrement en cours, appelez `GetLastModifiedBookmark` , puis appelez `SetBookmark` pour revenir à l’enregistrement qui vient d’être ajouté.

Pour plus d’informations, consultez la rubrique « Propriété LastModified » dans l’aide de DAO.

##  <a name="getlockingmode"></a>  CDaoRecordset::GetLockingMode

Appelez cette fonction membre pour déterminer le type de verrouillage en vigueur pour le jeu d’enregistrements.

```
BOOL GetLockingMode();
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le type de verrouillage pessimiste, sinon 0 pour le verrouillage optimiste.

### <a name="remarks"></a>Notes

Lorsque le verrouillage pessimiste est en effet, la page de données contenant l’enregistrement que vous modifiez est verrouillé dès que vous appelez le [modifier](#edit) fonction membre. La page est déverrouillée lorsque vous appelez le [mise à jour](#update) ou [fermer](#close) fonction membre ou une des opérations de déplacement ou de recherche.

Lorsque le verrouillage est appliqué optimiste, la page de données contenant l’enregistrement est verrouillée uniquement pendant que l’enregistrement est mis à jour avec la `Update` fonction membre.

Lorsque vous travaillez avec des sources de données ODBC, le mode de verrouillage est toujours optimiste.

Pour plus d’informations, consultez les rubriques « Propriété LockEdits » et « Comportement verrouillage dans les Applications » dans l’aide de DAO.

##  <a name="getname"></a>  CDaoRecordset::GetName

Appelez cette fonction membre pour récupérer le nom de l’objet recordset.

```
CString GetName();
```

### <a name="return-value"></a>Valeur de retour

Un `CString` contenant le nom de l’objet recordset.

### <a name="remarks"></a>Notes

Le nom de l’objet recordset doit commencer par une lettre et peut contenir un maximum de 40 caractères. Il peut inclure des nombres et caractères de trait de soulignement mais ne peut pas inclure de signes de ponctuation ou d’espaces.

Pour plus d’informations, consultez la rubrique « Propriété de nom » dans l’aide de DAO.

##  <a name="getparamvalue"></a>  CDaoRecordset::GetParamValue

Appelez cette fonction membre pour récupérer la valeur actuelle du paramètre spécifié stocké dans l’objet DAOParameter sous-jacent.

```
virtual COleVariant GetParamValue(int nIndex);
virtual COleVariant GetParamValue(LPCTSTR lpszName);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
La position numérique du paramètre dans l’objet DAOParameter sous-jacent.

*Caractère*<br/>
Le nom du paramètre dont la valeur souhaitée.

### <a name="return-value"></a>Valeur de retour

Un objet de classe [COleVariant](../../mfc/reference/colevariant-class.md) qui contient la valeur du paramètre.

### <a name="remarks"></a>Notes

Vous pouvez accéder à la paramètre par nom ou par sa position numérique dans la collection.

Pour plus d’informations, consultez la rubrique « Objet de paramètre » dans l’aide de DAO.

##  <a name="getpercentposition"></a>  CDaoRecordset::GetPercentPosition

Lorsque vous travaillez avec un jeu de données ou jeu d’enregistrements de type instantané, si vous appelez `GetPercentPosition` avant le remplissage complet du jeu d’enregistrements, la quantité de mouvement est par rapport au nombre d’enregistrements auquel accédé comme indiqué en appelant [GetRecordCount](#getrecordcount).

```
float GetPercentPosition();
```

### <a name="return-value"></a>Valeur de retour

Un nombre compris entre 0 et 100 qui indique l’emplacement approximatif de l’enregistrement actif dans l’objet recordset basé sur un pourcentage des enregistrements dans le jeu d’enregistrements.

### <a name="remarks"></a>Notes

Vous pouvez accéder au dernier enregistrement en appelant [MoveLast](#movelast) à complète le remplissage de tous les jeux d’enregistrements, mais cela peut prendre beaucoup de temps.

Vous pouvez appeler `GetPercentPosition` sur tous les trois types d’objets de jeu d’enregistrements, y compris les tables sans index. Toutefois, vous ne pouvez pas appeler `GetPercentPosition` sur les instantanés de défilement avant uniquement, ou sur un jeu d’enregistrements ouvert à partir d’une requête directe sur une base de données externe. S’il n’existe aucun enregistrement actif, ou enregistrement actif he a été supprimé, un `CDaoException` est levée.

Pour plus d’informations, consultez la rubrique « Propriété PercentPosition » dans l’aide de DAO.

##  <a name="getrecordcount"></a>  CDaoRecordset::GetRecordCount

Appelez cette fonction membre pour savoir combien d’enregistrements dans un jeu d’enregistrements ont été consultés.

```
long GetRecordCount();
```

### <a name="return-value"></a>Valeur de retour

Retourne le nombre d’enregistrements auquel accédé dans un objet recordset.

### <a name="remarks"></a>Notes

`GetRecordCount` n’indique pas le nombre d’enregistrements contenu dans un jeu d’enregistrements de type instantané ou de type jusqu'à ce que tous les enregistrements ont été consultés. Cet appel de fonction membre peut prendre beaucoup de temps.

Après avoir accédé au dernier enregistrement, la valeur de retour indique le nombre total d’enregistrements non supprimés dans le jeu d’enregistrements. Pour forcer le dernier enregistrement accessible, appelez le `MoveLast` ou `FindLast` fonction membre pour le jeu d’enregistrements. Vous pouvez également utiliser un compte SQL pour déterminer le nombre approximatif d’enregistrements renvoyés par votre requête.

À mesure que votre application supprime des enregistrements dans un jeu d’enregistrements de type, la valeur de retour de `GetRecordCount` diminue. Toutefois, les enregistrements supprimés par d’autres utilisateurs ne sont pas reflétées par `GetRecordCount` jusqu'à ce que l’enregistrement actif est positionné sur un enregistrement supprimé. Si vous exécutez une transaction qui affecte le nombre d’enregistrements et restaurer par la suite la transaction, `GetRecordCount` ne reflète pas le nombre réel d’enregistrements restants.

La valeur de `GetRecordCount` à partir d’un jeu d’enregistrements de type instantané n’est pas affectée par les modifications dans les tables sous-jacentes.

La valeur de `GetRecordCount` à partir d’un type de table recordset reflète le nombre approximatif d’enregistrements dans la table et n’est affecté immédiatement que les enregistrements de la table sont ajoutés et supprimés.

Un jeu d’enregistrements sans enregistrements retourne une valeur égale à 0. Lorsque vous travaillez avec des tables jointes ou les bases de données ODBC, `GetRecordCount` retourne toujours - 1. Appel de la `Requery` fonction membre sur un jeu d’enregistrements réinitialise la valeur de `GetRecordCount` comme si la requête ont été réexécutée.

Pour plus d’informations, consultez la rubrique « RecordCount, propriété » dans l’aide de DAO.

##  <a name="getsql"></a>  CDaoRecordset::GetSQL

Appelez cette fonction membre pour obtenir de l’instruction SQL qui a été utilisée pour sélectionner les enregistrements du jeu d’enregistrements lorsqu’il a été ouvert.

```
CString GetSQL() const;
```

### <a name="return-value"></a>Valeur de retour

Un `CString` qui contient l’instruction SQL.

### <a name="remarks"></a>Notes

Il s’agit généralement d’une instance SQL **sélectionnez** instruction.

La chaîne retournée par `GetSQL` est généralement différent à partir de n’importe quelle chaîne que vous avez peut-être passé à l’ensemble d’enregistrements dans le *lpszSQL* paramètre à la [Open](#open) fonction membre. Il s’agit, car l’objet recordset construit une instruction SQL complète basée sur ce que vous avez passé à `Open`, ce que vous avez spécifié avec ClassWizard, et ce que vous avez spécifié dans le [m_strFilter](#m_strfilter) et [m_strSort](#m_strsort) membres de données.

> [!NOTE]
>  Appelez cette fonction membre uniquement après avoir appelé `Open`.

Pour plus d’informations, consultez la rubrique « Propriété SQL » dans l’aide de DAO.

##  <a name="gettype"></a>  CDaoRecordset::GetType

Appelez cette fonction membre après avoir ouvert le jeu d’enregistrements pour déterminer le type de l’objet recordset.

```
short GetType();
```

### <a name="return-value"></a>Valeur de retour

L’une des valeurs suivantes, qui indique le type d’un jeu d’enregistrements :

- `dbOpenTable` Jeu d’enregistrements de type de table

- `dbOpenDynaset` Récupérer des données

- `dbOpenSnapshot` Type de l’instantané

### <a name="remarks"></a>Notes

Pour plus d’informations, consultez la rubrique « Propriété de Type » dans l’aide de DAO.

##  <a name="getvalidationrule"></a>  CDaoRecordset::GetValidationRule

Appelez cette fonction membre pour déterminer la règle utilisée pour valider les données.

```
CString GetValidationRule();
```

### <a name="return-value"></a>Valeur de retour

Un `CString` objet contenant une valeur qui valide les données dans un enregistrement comme il est modifié ou ajouté à une table.

### <a name="remarks"></a>Notes

Cette règle est en mode texte et est appliquée à chaque modification de la table sous-jacente. Si les données ne sont pas autorisées, MFC lève une exception. Le message d’erreur retourné est le texte de la propriété ValidationRule de l’objet de champ sous-jacent, si spécifié, ou le texte de l’expression spécifiée par la propriété ValidationRule de l’objet de champ sous-jacent. Vous pouvez appeler [GetValidationText](#getvalidationtext) pour obtenir le texte du message d’erreur.

Par exemple, un champ dans un enregistrement qui nécessite le jour du mois peut avoir une règle de validation comme « jour entre 1 et 31. »

Pour plus d’informations, consultez la rubrique « Propriété ValidationRule » dans l’aide de DAO.

##  <a name="getvalidationtext"></a>  CDaoRecordset::GetValidationText

Appelez cette fonction membre pour récupérer le texte de la propriété ValidationRule de l’objet de champ sous-jacent.

```
CString GetValidationText();
```

### <a name="return-value"></a>Valeur de retour

Un `CString` objet contenant le texte du message qui s’affiche si la valeur d’un champ ne satisfait pas la règle de validation de l’objet de champ sous-jacent.

### <a name="remarks"></a>Notes

Pour plus d’informations, consultez la rubrique « Propriété ValidationRule » dans l’aide de DAO.

##  <a name="isbof"></a>  CDaoRecordset::IsBOF

Appelez cette fonction membre avant que vous accédez à partir de l’enregistrement à enregistrement pour savoir si vous avez bien effectué avant le premier enregistrement de l’objet recordset.

```
BOOL IsBOF() const;
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le jeu d’enregistrements ne contient aucun enregistrement ou si vous avez le défilement arrière avant le premier enregistrement ; sinon 0.

### <a name="remarks"></a>Notes

Vous pouvez également appeler `IsBOF` avec `IsEOF` pour déterminer si le jeu d’enregistrements contient tous les enregistrements ou est vide. Immédiatement après avoir appelé `Open`, si le jeu d’enregistrements ne contient aucun enregistrement, `IsBOF` retourne différente de zéro. Lorsque vous ouvrez un jeu d’enregistrements qui a au moins un enregistrement, le premier enregistrement est l’enregistrement actif et `IsBOF` retourne 0.

Si le premier enregistrement est l’enregistrement actif et que vous appelez `MovePrev`, `IsBOF` par la suite renverra différente de zéro. Si `IsBOF` retourne différente de zéro et que vous appelez `MovePrev`, une exception est levée. Si `IsBOF` retourne une valeur différente de zéro, l’enregistrement en cours n’est pas défini, et toute action qui nécessite un enregistrement actuel entraîne une exception.

Effet de méthodes spécifiques sur `IsBOF` et `IsEOF` paramètres :

- Appel `Open*` en interne fait du premier enregistrement dans le jeu d’enregistrements l’enregistrement en cours en appelant `MoveFirst`. Par conséquent, l’appel `Open` sur un ensemble de causes d’enregistrements vide `IsBOF` et `IsEOF` pour retourner la valeur différente de zéro. (Consultez le tableau suivant pour le comportement d’un échec `MoveFirst` ou `MoveLast` appeler.)

- Toutes les opérations de déplacement qui parviennent à localiser un enregistrement de provoquer `IsBOF` et `IsEOF` retourne 0.

- Un `AddNew` appel suivi par un `Update` appel qui a été insère un nouvel enregistrement entraîne `IsBOF` pour retourner 0, mais uniquement si `IsEOF` déjà est différent de zéro. L’état de `IsEOF` toujours reste inchangée. Comme défini par le moteur de base de données Microsoft Jet, le pointeur d’enregistrement actuel d’un jeu d’enregistrements vide étant à la fin d’un fichier, un nouvel enregistrement est inséré après l’enregistrement actif.

- N’importe quel `Delete` appel, même si elle supprime le dernier enregistrement dans un jeu d’enregistrements ne changera pas la valeur de `IsBOF` ou `IsEOF`.

Le tableau suivant répertorie les opérations de déplacement sont autorisées avec différentes combinaisons de `IsBOF` /  `IsEOF`.

||MoveFirst, MoveLast|MovePrev,<br /><br /> Déplacer < 0|Déplacer le 0|MoveNext,<br /><br /> Déplacer > 0|
|------|-------------------------|-----------------------------|------------|-----------------------------|
|`IsBOF`= différent de zéro,<br /><br /> `IsEOF`=0|Allowed|Exception|Exception|Allowed|
|`IsBOF`=0,<br /><br /> `IsEOF`= différente de zéro|Allowed|Allowed|Exception|Exception|
|Les deux différente de zéro|Exception|Exception|Exception|Exception|
|Les deux 0|Allowed|Allowed|Allowed|Allowed|

Ce qui permet une opération de déplacement ne signifie pas que l’opération parviendra à localiser un enregistrement. Il indique simplement que tentez d’effectuer l’opération de déplacement spécifiée est autorisée et ne génère pas d’exception. La valeur de la `IsBOF` et `IsEOF` fonctions membres peuvent changer à la suite le déplacement tenté.

L’effet des opérations de déplacement qui ne trouvez pas un enregistrement de la valeur de `IsBOF` et `IsEOF` paramètres est indiqué dans le tableau suivant.

||IsBOF|IsEOF|
|------|-----------|-----------|
|`MoveFirst`, `MoveLast`|Différent de zéro|Différent de zéro|
|`Move` 0|Aucune modification|Aucune modification|
|`MovePrev`, `Move` < 0|Différent de zéro|Aucune modification|
|`MoveNext`, `Move` > 0|Aucune modification|Différent de zéro|

Pour plus d’informations, consultez la rubrique « BOF, EOF, propriétés » dans l’aide de DAO.

##  <a name="isdeleted"></a>  CDaoRecordset::IsDeleted

Appelez cette fonction membre pour déterminer si l’enregistrement en cours a été supprimé.

```
BOOL IsDeleted() const;
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le recordset est positionné sur un enregistrement supprimé. sinon 0.

### <a name="remarks"></a>Notes

Si vous accédez à un enregistrement et `IsDeleted` renvoie la valeur TRUE (différent de zéro), puis vous devez accéder à un autre enregistrement avant de pouvoir effectuer toutes les opérations de jeu d’enregistrements.

> [!NOTE]
>  Vous n’avez pas besoin de vérifier l’état supprimé des enregistrements dans un jeu d’enregistrements de type de table ou d’instantané. Étant donné que les enregistrements ne peut pas être supprimés à partir d’un instantané, il n’est pas nécessaire d’appeler `IsDeleted`. Pour les jeux d’enregistrements de type de table, les enregistrements supprimés sont effectivement supprimés de l’ensemble d’enregistrements. Une fois qu’un enregistrement a été supprimé par un autre utilisateur, ou dans un autre jeu d’enregistrements, vous ne pouvez pas faire défiler à cet enregistrement. Par conséquent, il n’est pas nécessaire d’appeler `IsDeleted`.

Lorsque vous supprimez un enregistrement à partir d’une feuille de réponse dynamique, il est supprimé de l’ensemble d’enregistrements et vous ne pouvez pas faire défiler à cet enregistrement. Toutefois, si un enregistrement dans une feuille de réponse dynamique est supprimé par un autre utilisateur ou dans un autre jeu d’enregistrements basé sur la même table, `IsDeleted` renvoie la valeur TRUE lorsque vous faites défiler ultérieurement à cet enregistrement.

Pour plus d’informations, consultez les rubriques « Supprimer la méthode », « Propriété LastModified » et « EditMode, propriété » dans l’aide de DAO.

##  <a name="iseof"></a>  CDaoRecordset::IsEOF

Appelez cette fonction membre que vous accédez à partir de l’enregistrement à enregistrement pour savoir si vous avez dépassé le dernier enregistrement de l’objet recordset.

```
BOOL IsEOF() const;
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le jeu d’enregistrements ne contient aucun enregistrement ou si vous avez déplacé au-delà du dernier enregistrement ; sinon 0.

### <a name="remarks"></a>Notes

Vous pouvez également appeler `IsEOF` pour déterminer si le jeu d’enregistrements contient tous les enregistrements ou est vide. Immédiatement après avoir appelé `Open`, si le jeu d’enregistrements ne contient aucun enregistrement, `IsEOF` retourne différente de zéro. Lorsque vous ouvrez un jeu d’enregistrements qui a au moins un enregistrement, le premier enregistrement est l’enregistrement actif et `IsEOF` retourne 0.

Si le dernier enregistrement est l’enregistrement actif lorsque vous appelez `MoveNext`, `IsEOF` par la suite renverra différente de zéro. Si `IsEOF` retourne différente de zéro et que vous appelez `MoveNext`, une exception est levée. Si `IsEOF` retourne une valeur différente de zéro, l’enregistrement en cours n’est pas défini, et toute action qui nécessite un enregistrement actuel entraîne une exception.

Effet de méthodes spécifiques sur `IsBOF` et `IsEOF` paramètres :

- Appel `Open` en interne fait du premier enregistrement dans le jeu d’enregistrements l’enregistrement en cours en appelant `MoveFirst`. Par conséquent, l’appel `Open` sur un ensemble de causes d’enregistrements vide `IsBOF` et `IsEOF` pour retourner la valeur différente de zéro. (Consultez le tableau suivant pour le comportement d’un échec `MoveFirst` appeler.)

- Toutes les opérations de déplacement qui parviennent à localiser un enregistrement de provoquer `IsBOF` et `IsEOF` retourne 0.

- Un `AddNew` appel suivi par un `Update` appel qui a été insère un nouvel enregistrement entraîne `IsBOF` pour retourner 0, mais uniquement si `IsEOF` déjà est différent de zéro. L’état de `IsEOF` toujours reste inchangée. Comme défini par le moteur de base de données Microsoft Jet, le pointeur d’enregistrement actuel d’un jeu d’enregistrements vide étant à la fin d’un fichier, un nouvel enregistrement est inséré après l’enregistrement actif.

- N’importe quel `Delete` appel, même si elle supprime le dernier enregistrement dans un jeu d’enregistrements ne changera pas la valeur de `IsBOF` ou `IsEOF`.

Le tableau suivant répertorie les opérations de déplacement sont autorisées avec différentes combinaisons de `IsBOF` /  `IsEOF`.

||MoveFirst, MoveLast|MovePrev,<br /><br /> Déplacer < 0|Déplacer le 0|MoveNext,<br /><br /> Déplacer > 0|
|------|-------------------------|-----------------------------|------------|-----------------------------|
|`IsBOF`= différent de zéro,<br /><br /> `IsEOF`=0|Allowed|Exception|Exception|Allowed|
|`IsBOF`=0,<br /><br /> `IsEOF`= différente de zéro|Allowed|Allowed|Exception|Exception|
|Les deux différente de zéro|Exception|Exception|Exception|Exception|
|Les deux 0|Allowed|Allowed|Allowed|Allowed|

Ce qui permet une opération de déplacement ne signifie pas que l’opération parviendra à localiser un enregistrement. Il indique simplement que tentez d’effectuer l’opération de déplacement spécifiée est autorisée et ne génère pas d’exception. La valeur de la `IsBOF` et `IsEOF` fonctions membres peuvent changer à la suite le déplacement tenté.

L’effet des opérations de déplacement qui ne trouvez pas un enregistrement de la valeur de `IsBOF` et `IsEOF` paramètres est indiqué dans le tableau suivant.

||IsBOF|IsEOF|
|------|-----------|-----------|
|`MoveFirst`, `MoveLast`|Différent de zéro|Différent de zéro|
|`Move` 0|Aucune modification|Aucune modification|
|`MovePrev`, `Move` < 0|Différent de zéro|Aucune modification|
|`MoveNext`, `Move` > 0|Aucune modification|Différent de zéro|

Pour plus d’informations, consultez la rubrique « BOF, EOF, propriétés » dans l’aide de DAO.

##  <a name="isfielddirty"></a>  CDaoRecordset::IsFieldDirty

Appelez cette fonction membre pour déterminer si le membre de données de champ spécifié de la feuille de réponse dynamique a été marqué comme « modifiées » (modifié).

```
BOOL IsFieldDirty(void* pv);
```

### <a name="parameters"></a>Paramètres

*PV*<br/>
Pointeur vers le membre de données du champ dont vous souhaitez vérifier, ou NULL pour déterminer si les champs sont modifiés de l’état.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le membre de données du champ spécifié est marqué comme modifié ; sinon 0.

### <a name="remarks"></a>Notes

Les données dans tous les membres de données de champ incorrectes seront transférées à l’enregistrement sur la source de données lors de l’enregistrement actif est mis à jour par un appel à la `Update` fonction membre de `CDaoRecordset` (suit un appel à `Edit` ou `AddNew`). Sachant cela, vous pouvez suivre d’autres étapes, telles que suppression d’indicateur le membre de données de champ pour marquer la colonne, donc il n’est pas écrit pour la source de données.

`IsFieldDirty` est implémentée via `DoFieldExchange`.

##  <a name="isfieldnull"></a>  CDaoRecordset::IsFieldNull

Appelez cette fonction membre pour déterminer si le membre de données de champ spécifié d’un jeu d’enregistrements a été marqué comme Null.

```
BOOL IsFieldNull(void* pv);
```

### <a name="parameters"></a>Paramètres

*PV*<br/>
Pointeur vers le membre de données du champ dont vous souhaitez vérifier, ou NULL pour déterminer si les champs ont la valeur Null de l’état.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le membre de données du champ spécifié est marqué en tant que valeur Null. sinon 0.

### <a name="remarks"></a>Notes

(Dans la terminologie de base de données, Null signifie « ne having aucune valeur » et n’est pas identique à la valeur NULL en C++.) Si un membre de données de champ est marqué avec la valeur Null, il est interprété en tant que colonne de l’enregistrement en cours pour lequel il n’existe aucune valeur.

> [!NOTE]
>  Dans certaines situations, à l’aide de `IsFieldNull` peut être inefficace, comme l’illustre l’exemple de code suivant :

[!code-cpp[NVC_MFCDatabase#5](../../mfc/codesnippet/cpp/cdaorecordset-class_5.cpp)]

> [!NOTE]
>  Si vous utilisez une liaison d’enregistrement dynamique, sans dériver `CDaoRecordset`, veillez à utiliser VT_NULL, comme indiqué dans l’exemple.

##  <a name="isfieldnullable"></a>  CDaoRecordset::IsFieldNullable

Appelez cette fonction membre pour déterminer si le membre de données du champ spécifié est « null » (peut être définie avec une valeur Null ; C++ NULL n’est pas identique à Null, ce qui, dans la terminologie de base de données, signifie « ne having aucune valeur »).

```
BOOL IsFieldNullable(void* pv);
```

### <a name="parameters"></a>Paramètres

*PV*<br/>
Pointeur vers le membre de données du champ dont vous souhaitez vérifier, ou NULL pour déterminer si les champs ont la valeur Null de l’état.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si le membre de données du champ spécifié peut être Null ; sinon 0.

### <a name="remarks"></a>Notes

Un champ qui ne peut pas être Null doit avoir une valeur. Si vous essayez de définir ce champ avec la valeur Null lors de l’ajout ou la mise à jour un enregistrement, la source de données rejette l’ajout ou la mise à jour, et `Update` lève une exception. L’exception se produit lorsque vous appelez `Update`, pas lorsque vous appelez `SetFieldNull`.

##  <a name="isopen"></a>  CDaoRecordset::IsOpen

Appelez cette fonction membre pour déterminer si le jeu d’enregistrements est ouvert.

```
BOOL IsOpen() const;
```

### <a name="return-value"></a>Valeur de retour

Différent de zéro si l’objet recordset `Open` ou `Requery` fonction membre a été précédemment appelée et le jeu d’enregistrements n’a pas été fermée ; sinon, 0.

### <a name="remarks"></a>Notes

##  <a name="m_bcheckcachefordirtyfields"></a>  CDaoRecordset::m_bCheckCacheForDirtyFields

Contient un indicateur spécifiant si les champs mis en cache sont automatiquement marquées comme modifiées (modifiés) et Null.

### <a name="remarks"></a>Notes

L’indicateur par défaut est TRUE. Le paramètre dans ce membre de données contrôle l’ensemble du mécanisme de double tampon. Si vous définissez l’indicateur sur TRUE, vous pouvez désactiver la mise en cache sur une base de champ par champ en utilisant le mécanisme DFX. Si vous définissez l’indicateur sur FALSE, vous devez appeler `SetFieldDirty` et `SetFieldNull` vous-même.

Définissez ce membre de données avant d’appeler `Open`. Ce mécanisme est principalement pour la facilité d’utilisation. Performances peuvent être plus lent en raison de la double mise en tampon des champs, comme les modifications sont apportées.

##  <a name="m_nfields"></a>  CDaoRecordset::m_nFields

Contient le nombre de membres de données de champ dans la classe de jeu d’enregistrements et le nombre de colonnes sélectionnées par le jeu d’enregistrements à partir de la source de données.

### <a name="remarks"></a>Notes

Le constructeur de la classe de jeu d’enregistrements doit initialiser `m_nFields` avec le nombre correct de champs liés statiquement. ClassWizard écrit cette initialisation pour vous lorsque vous l’utilisez pour déclarer votre classe de jeu d’enregistrements. Vous pouvez également l’écrire manuellement.

L’infrastructure utilise ce nombre pour gérer l’interaction entre les membres de données de champ et les colonnes correspondantes de l’enregistrement en cours sur la source de données.

> [!NOTE]
>  Ce numéro doit correspondre au nombre de colonnes de sortie inscrit dans `DoFieldExchange` après un appel à `SetFieldType` avec le paramètre `CDaoFieldExchange::outputColumn`.

Vous pouvez lier des colonnes dynamiquement par l’intermédiaire de `CDaoRecordset::GetFieldValue` et `CDaoRecordset::SetFieldValue`. Si vous procédez ainsi, vous n’avez pas besoin d’incrémenter le décompte dans `m_nFields` afin de refléter le nombre de fonction DFX appelle votre `DoFieldExchange` fonction membre.

##  <a name="m_nparams"></a>  CDaoRecordset::m_nParams

Contient le nombre de membres de données de paramètre dans la classe de jeu d’enregistrements, le nombre de paramètres transmis avec la requête du recordset.

### <a name="remarks"></a>Notes

Si votre classe de jeu d’enregistrements a des membres de données de paramètre, le constructeur de la classe doit initialiser *m_nParams* avec le nombre correct. La valeur de *m_nParams* valeur par défaut est 0. Si vous ajoutez des membres de données de paramètre, ce que vous devez le faire manuellement, vous devez également ajouter manuellement une initialisation dans le constructeur de classe afin de refléter le nombre de paramètres (qui doit être au moins aussi grand que le nombre de '' espaces réservés dans votre *m_strFilter*  ou *m_strSort* chaîne).

L’infrastructure utilise ce nombre lorsqu’il paramètre la requête du recordset.

> [!NOTE]
>  Ce numéro doit correspondre au nombre de « params » inscrit dans `DoFieldExchange` après un appel à `SetFieldType` avec le paramètre `CFieldExchange::param`.

Pour plus d’informations, consultez la rubrique « Objet de paramètre » dans l’aide de DAO.

##  <a name="m_pdaorecordset"></a>  CDaoRecordset::m_pDAORecordset

Contient un pointeur vers l’interface OLE pour DAO recordset objet sous-jacent le `CDaoRecordset` objet.

### <a name="remarks"></a>Notes

Utilisez ce pointeur si vous avez besoin d’accéder à l’interface DAO directement.

Pour plus d’informations, consultez la rubrique « Recordset, objet » dans l’aide de DAO.

##  <a name="m_pdatabase"></a>  CDaoRecordset::m_pDatabase

Contient un pointeur vers le `CDaoDatabase` objet via lequel le jeu d’enregistrements est connecté à une source de données.

### <a name="remarks"></a>Notes

Cette variable est définie de deux manières. En règle générale, vous transmettez un pointeur à déjà ouverte `CDaoDatabase` objet lorsque vous construisez l’objet recordset. Si vous passez NULL au lieu de cela, `CDaoRecordset` crée un `CDaoDatabase` objet pour vous et l’ouvre. Dans les deux cas, `CDaoRecordset` stocke le pointeur dans cette variable.

Normalement vous serez directement inutile d’utiliser le pointeur stocké dans `m_pDatabase`. Si vous écrivez vos propres extensions à `CDaoRecordset`, toutefois, vous devrez peut-être utiliser le pointeur. Par exemple, vous devrez peut-être le pointeur si vous levez vos propres `CDaoException`(s).

Pour plus d’informations, consultez la rubrique « Objet de base de données » dans l’aide de DAO.

##  <a name="m_strfilter"></a>  CDaoRecordset::m_strFilter

Contient une chaîne qui est utilisée pour construire le **où** clause d’une instruction SQL.

### <a name="remarks"></a>Notes

Il n’inclut pas le mot réservé **où** pour filtrer le jeu d’enregistrements. L’utilisation de ce membre de données n’est pas applicable aux jeux d’enregistrements de type de table. L’utilisation de `m_strFilter` n’a aucun effet lors de l’ouverture d’un jeu d’enregistrements à l’aide un `CDaoQueryDef` pointeur.

Utilisez le format de date des États-Unis (mois-jour-année) lorsque vous filtrez des champs contenant des dates, même si vous n’utilisez pas la version américaine du moteur de base de données Microsoft Jet ; Sinon, les données ne peuvent pas être filtrées comme prévu.

Pour plus d’informations, consultez la rubrique « Propriété de filtre » dans l’aide de DAO.

##  <a name="m_strsort"></a>  CDaoRecordset::m_strSort

Contient une chaîne contenant le **ORDERBY** clause d’une instruction SQL sans les mots réservés **ORDERBY**.

### <a name="remarks"></a>Notes

Vous pouvez trier sur les objets recordset de type feuille de réponse dynamique et d’instantané.

Vous ne pouvez pas trier les objets de jeu d’enregistrements de type table. Pour déterminer l’ordre de tri d’un jeu d’enregistrements de type de table, appelez [SetCurrentIndex](#setcurrentindex).

L’utilisation de *m_strSort* n’a aucun effet lors de l’ouverture d’un jeu d’enregistrements à l’aide un `CDaoQueryDef` pointeur.

Pour plus d’informations, consultez la rubrique « Propriété de tri » dans l’aide de DAO.

##  <a name="move"></a>  Méthode CDaoRecordset::Move

Appelez cette fonction membre pour positionner le jeu d’enregistrements *lRows* enregistrements à partir de l’enregistrement actif.

```
virtual void Move(long lRows);
```

### <a name="parameters"></a>Paramètres

*lRows*<br/>
Le nombre d’enregistrements à avancer ou reculer. Les valeurs positives déplacent vers l’avant, vers la fin de l’objet recordset. Déplacent vers l’arrière, des valeurs négatives vers le début.

### <a name="remarks"></a>Notes

Vous pouvez déplacer vers l’avant ou vers l’arrière. `Move( 1 )` équivaut à `MoveNext`, et `Move( -1 )` équivaut à `MovePrev`.

> [!CAUTION]
>  Appel d’une le `Move` fonctions lève une exception si le jeu d’enregistrements ne comporte aucun enregistrement. En règle générale, appeler à la fois `IsBOF` et `IsEOF` avant une opération de déplacement pour déterminer si le jeu d’enregistrements a tous les enregistrements. Après avoir appelé `Open` ou `Requery`, appelez `IsBOF` ou `IsEOF`.

> [!NOTE]
>  Si vous avez atteint le début ou la fin de l’objet recordset ( `IsBOF` ou `IsEOF` retourne différente de zéro), un appel à `Move` lève un `CDaoException`.

> [!NOTE]
>  Si vous appelez une de le `Move` fonctions pendant que l’enregistrement actif est mis à jour ou ajoutée, les mises à jour sont perdues sans avertissement.

Lorsque vous appelez `Move` sur un instantané de défilement avant uniquement, le *lRows* paramètre doit être un entier positif et les signets ne sont pas autorisées, pour vous pouvez de déplacer vers l’avant uniquement.

Pour rendre le premier, dernier, suivant, ou précédente de l’enregistrement dans un jeu d’enregistrements l’enregistrement, des appels actuelle la `MoveFirst`, `MoveLast`, `MoveNext`, ou `MovePrev` fonction membre.

Pour plus d’informations, consultez les rubriques « Méthode déplacer » et « MoveFirst, MoveLast, MoveNext, MovePrevious, méthodes » dans l’aide de DAO.

##  <a name="movefirst"></a>  CDaoRecordset::MoveFirst

Appelez cette fonction membre pour rendre le premier enregistrement dans le jeu d’enregistrements (le cas échéant) l’enregistrement actif.

```
void MoveFirst();
```

### <a name="remarks"></a>Notes

Vous n’avez pas à appeler `MoveFirst` immédiatement après l’ouverture de l’ensemble d’enregistrements. À ce stade, le premier enregistrement (le cas échéant) est automatiquement l’enregistrement actif.

> [!CAUTION]
>  Appel d’une le `Move` fonctions lève une exception si le jeu d’enregistrements ne comporte aucun enregistrement. En règle générale, appeler à la fois `IsBOF` et `IsEOF` avant une opération de déplacement pour déterminer si le jeu d’enregistrements a tous les enregistrements. Après avoir appelé `Open` ou `Requery`, appelez `IsBOF` ou `IsEOF`.

> [!NOTE]
>  Si vous appelez une de le `Move` fonctions pendant que l’enregistrement actif est mis à jour ou ajoutée, les mises à jour sont perdues sans avertissement.

Utilisez le `Move` fonctions pour déplacer à partir d’un enregistrement à un autre sans appliquer une condition. Utilisez les opérations de recherche pour localiser les enregistrements dans un jeu de données ou objet de jeu d’enregistrements de type instantané qui répondent à une certaine condition. Pour obtenir un enregistrement dans un objet de jeu d’enregistrements de type de table, appelez `Seek`.

Si le jeu d’enregistrements fait référence à un jeu d’enregistrements de type de table, le déplacement suit l’index de table en cours. Vous pouvez définir l’index actuel à l’aide de la propriété de l’Index de l’objet DAO sous-jacent. Si vous ne définissez pas l’index actuel, l’ordre des enregistrements retournés est non défini.

Si vous appelez `MoveLast` sur un objet de jeu d’enregistrements basé sur une requête SQL ou une querydef, la requête est obligée de saisie semi-automatique et de l’objet recordset est entièrement remplie.

Vous ne pouvez pas appeler le `MoveFirst` ou `MovePrev` fonction membre avec un instantané de défilement avant uniquement.

Pour déplacer la position de l’actuel enregistrement d’un objet de jeu d’enregistrements spécifiques à un nombre d’enregistrements vers l’avant ou vers l’arrière, appelez `Move`.

Pour plus d’informations, consultez les rubriques « Méthode déplacer » et « MoveFirst, MoveLast, MoveNext, MovePrevious, méthodes » dans l’aide de DAO.

##  <a name="movelast"></a>  CDaoRecordset::MoveLast

Appelez cette fonction membre pour le dernier enregistrement (le cas échéant) dans le jeu d’enregistrements de l’enregistrement actif.

```
void MoveLast();
```

### <a name="remarks"></a>Notes

> [!CAUTION]
>  Appel d’une le `Move` fonctions lève une exception si le jeu d’enregistrements ne comporte aucun enregistrement. En règle générale, appeler à la fois `IsBOF` et `IsEOF` avant une opération de déplacement pour déterminer si le jeu d’enregistrements a tous les enregistrements. Après avoir appelé `Open` ou `Requery`, appelez `IsBOF` ou `IsEOF`.

> [!NOTE]
>  Si vous appelez une de le `Move` fonctions pendant que l’enregistrement actif est mis à jour ou ajoutée, les mises à jour sont perdues sans avertissement.

Utilisez le `Move` fonctions pour déplacer à partir d’un enregistrement à un autre sans appliquer une condition. Utilisez les opérations de recherche pour localiser les enregistrements dans un jeu de données ou objet de jeu d’enregistrements de type instantané qui répondent à une certaine condition. Pour obtenir un enregistrement dans un objet de jeu d’enregistrements de type de table, appelez `Seek`.

Si le jeu d’enregistrements fait référence à un jeu d’enregistrements de type de table, le déplacement suit l’index de table en cours. Vous pouvez définir l’index actuel à l’aide de la propriété de l’Index de l’objet DAO sous-jacent. Si vous ne définissez pas l’index actuel, l’ordre des enregistrements retournés est non défini.

Si vous appelez `MoveLast` sur un objet de jeu d’enregistrements basé sur une requête SQL ou une querydef, la requête est obligée de saisie semi-automatique et de l’objet recordset est entièrement remplie.

Pour déplacer la position de l’actuel enregistrement d’un objet de jeu d’enregistrements spécifiques à un nombre d’enregistrements vers l’avant ou vers l’arrière, appelez `Move`.

Pour plus d’informations, consultez les rubriques « Méthode déplacer » et « MoveFirst, MoveLast, MoveNext, MovePrevious, méthodes » dans l’aide de DAO.

##  <a name="movenext"></a>  CDaoRecordset::MoveNext

Appelez cette fonction membre pour rendre l’enregistrement suivant dans le jeu d’enregistrements de l’enregistrement actif.

```
void MoveNext();
```

### <a name="remarks"></a>Notes

Il est recommandé d’appeler `IsBOF` avant d’essayer de le déplacer vers l’enregistrement précédent. Un appel à `MovePrev` lèvera une `CDaoException` si `IsBOF` retourne différent de zéro, indiquant que vous avez atteint avant le premier enregistrement ou qu’aucun enregistrement ont été sélectionnés par le jeu d’enregistrements.

> [!CAUTION]
>  Appel d’une le `Move` fonctions lève une exception si le jeu d’enregistrements ne comporte aucun enregistrement. En règle générale, appeler à la fois `IsBOF` et `IsEOF` avant une opération de déplacement pour déterminer si le jeu d’enregistrements a tous les enregistrements. Après avoir appelé `Open` ou `Requery`, appelez `IsBOF` ou `IsEOF`.

> [!NOTE]
>  Si vous appelez une de le `Move` fonctions pendant que l’enregistrement actif est mis à jour ou ajoutée, les mises à jour sont perdues sans avertissement.

Utilisez le `Move` fonctions pour déplacer à partir d’un enregistrement à un autre sans appliquer une condition. Utilisez les opérations de recherche pour localiser les enregistrements dans un jeu de données ou objet de jeu d’enregistrements de type instantané qui répondent à une certaine condition. Pour obtenir un enregistrement dans un objet de jeu d’enregistrements de type de table, appelez `Seek`.

Si le jeu d’enregistrements fait référence à un jeu d’enregistrements de type de table, le déplacement suit l’index de table en cours. Vous pouvez définir l’index actuel à l’aide de la propriété de l’Index de l’objet DAO sous-jacent. Si vous ne définissez pas l’index actuel, l’ordre des enregistrements retournés est non défini.

Pour déplacer la position de l’actuel enregistrement d’un objet de jeu d’enregistrements spécifiques à un nombre d’enregistrements vers l’avant ou vers l’arrière, appelez `Move`.

Pour plus d’informations, consultez les rubriques « Méthode déplacer » et « MoveFirst, MoveLast, MoveNext, MovePrevious, méthodes » dans l’aide de DAO.

##  <a name="moveprev"></a>  CDaoRecordset::MovePrev

Appelez cette fonction membre pour rendre l’enregistrement précédent dans le jeu d’enregistrements de l’enregistrement actif.

```
void MovePrev();
```

### <a name="remarks"></a>Notes

Il est recommandé d’appeler `IsBOF` avant d’essayer de le déplacer vers l’enregistrement précédent. Un appel à `MovePrev` lèvera une `CDaoException` si `IsBOF` retourne différent de zéro, indiquant que vous avez atteint avant le premier enregistrement ou qu’aucun enregistrement ont été sélectionnés par le jeu d’enregistrements.

> [!CAUTION]
>  Appel d’une le `Move` fonctions lève une exception si le jeu d’enregistrements ne comporte aucun enregistrement. En règle générale, appeler à la fois `IsBOF` et `IsEOF` avant une opération de déplacement pour déterminer si le jeu d’enregistrements a tous les enregistrements. Après avoir appelé `Open` ou `Requery`, appelez `IsBOF` ou `IsEOF`.

> [!NOTE]
>  Si vous appelez une de le `Move` fonctions pendant que l’enregistrement actif est mis à jour ou ajoutée, les mises à jour sont perdues sans avertissement.

Utilisez le `Move` fonctions pour déplacer à partir d’un enregistrement à un autre sans appliquer une condition. Utilisez les opérations de recherche pour localiser les enregistrements dans un jeu de données ou objet de jeu d’enregistrements de type instantané qui répondent à une certaine condition. Pour obtenir un enregistrement dans un objet de jeu d’enregistrements de type de table, appelez `Seek`.

Si le jeu d’enregistrements fait référence à un jeu d’enregistrements de type de table, le déplacement suit l’index de table en cours. Vous pouvez définir l’index actuel à l’aide de la propriété de l’Index de l’objet DAO sous-jacent. Si vous ne définissez pas l’index actuel, l’ordre des enregistrements retournés est non défini.

Vous ne pouvez pas appeler le `MoveFirst` ou `MovePrev` fonction membre avec un instantané de défilement avant uniquement.

Pour déplacer la position de l’actuel enregistrement d’un objet de jeu d’enregistrements spécifiques à un nombre d’enregistrements vers l’avant ou vers l’arrière, appelez `Move`.

Pour plus d’informations, consultez les rubriques « Méthode déplacer » et « MoveFirst, MoveLast, MoveNext, MovePrevious, méthodes » dans l’aide de DAO.

##  <a name="open"></a>  CDaoRecordset::Open

Vous devez appeler cette fonction membre pour récupérer les enregistrements pour le jeu d’enregistrements.

```
virtual void Open(
    int nOpenType = AFX_DAO_USE_DEFAULT_TYPE,
    LPCTSTR lpszSQL = NULL,
    int nOptions = 0);

virtual void Open(
    CDaoTableDef* pTableDef,
    int nOpenType = dbOpenTable,
    int nOptions = 0);

virtual void Open(
    CDaoQueryDef* pQueryDef,
    int nOpenType = dbOpenDynaset,
    int nOptions = 0);
```

### <a name="parameters"></a>Paramètres

*nOpenType*<br/>
Une des valeurs suivantes :

- `dbOpenDynaset` Un jeu d’enregistrements de type jeu de données avec le défilement bidirectionnel. Il s'agit de la valeur par défaut.

- `dbOpenTable` Un jeu d’enregistrements de type de table avec le défilement bidirectionnel.

- `dbOpenSnapshot` Un jeu d’enregistrements de type instantané avec défilement bidirectionnel.

*lpszSQL*<br/>
Un pointeur de chaîne qui contient l’une des opérations suivantes :

- Un pointeur NULL.

- Le nom d’un ou plusieurs tabledefs et/ou querydefs (séparées par des virgules).

- SQL **sélectionnez** instruction (éventuellement avec un SQL **où** ou **ORDERBY** clause).

- Une requête directe.

*nOptions*<br/>
Un ou plusieurs des options répertoriées ci-dessous. La valeur par défaut est 0. Les valeurs possibles sont les suivantes :

- `dbAppendOnly` Vous pouvez uniquement ajouter des nouveaux enregistrements (enregistrements uniquement). Cette option signifie littéralement que les enregistrements peuvent uniquement être ajoutés. Les classes de base de données ODBC MFC ont une option d’ajout uniquement qui autorise les enregistrements à récupérer et à ajouter.

- `dbForwardOnly` Le jeu d’enregistrements est un instantané de défilement avant uniquement.

- `dbSeeChanges` Générer une exception si un autre utilisateur modifie les données que vous modifiez.

- `dbDenyWrite` Impossible de modifier ou d’ajouter des enregistrements d’autres utilisateurs.

- `dbDenyRead` Les autres utilisateurs ne peuvent pas afficher les enregistrements (jeu d’enregistrements de type de table uniquement).

- `dbReadOnly` Vous pouvez afficher uniquement les enregistrements ; les autres utilisateurs peuvent les modifier.

- `dbInconsistent` Mises à jour incohérentes sont autorisées (enregistrements uniquement).

- `dbConsistent` Uniquement les mises à jour cohérentes sont autorisées (enregistrements uniquement).

> [!NOTE]
>  Les constantes `dbConsistent` et `dbInconsistent` s’excluent mutuellement. Vous pouvez utiliser l’une ou l’autre, mais pas les deux dans une instance donnée de `Open`.

*pTableDef*<br/>
Un pointeur vers un [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) objet. Cette version est valide uniquement pour les jeux d’enregistrements de type de table. Lorsque vous utilisez cette option, le `CDaoDatabase` pointeur utilisé pour construire le `CDaoRecordset` n’est pas utilisé ; au lieu de cela, la base de données dans lequel se trouve cet objet est utilisé.

*pQueryDef*<br/>
Un pointeur vers un [CDaoQueryDef](../../mfc/reference/cdaoquerydef-class.md) objet. Cette version est valide uniquement pour la feuille de réponse dynamique et des jeux d’enregistrements de type instantané. Lorsque vous utilisez cette option, le `CDaoDatabase` pointeur utilisé pour construire le `CDaoRecordset` n’est pas utilisé ; au lieu de cela, la base de données dans laquelle réside la querydef est utilisé.

### <a name="remarks"></a>Notes

Avant d’appeler `Open`, vous devez construire l’objet recordset. Pour ce faire, plusieurs méthodes sont possibles :

- Lorsque vous construisez l’objet recordset, passez un pointeur vers un `CDaoDatabase` objet qui est déjà ouvert.

- Lorsque vous construisez l’objet recordset, passez un pointeur vers un `CDaoDatabase` objet qui n’est pas ouvert. Le jeu d’enregistrements ouvre un `CDaoDatabase` de l’objet, mais la fermera pas la fermeture de l’objet recordset.

- Lorsque vous construisez l’objet recordset, passer un pointeur NULL. Les appels d’objet recordset `GetDefaultDBName` pour obtenir le nom de Microsoft Access. Fichier MDB à ouvrir. Le jeu d’enregistrements puis ouvre un `CDaoDatabase` objet et garde celui-ci ouvre tant que le jeu d’enregistrements est ouvert. Lorsque vous appelez `Close` sur le jeu d’enregistrements, le `CDaoDatabase` objet est également fermé.

    > [!NOTE]
    >  Lorsque le jeu d’enregistrements s’ouvre le `CDaoDatabase` de l’objet, il ouvre la source de données avec un accès non exclusif.

Pour la version de `Open` qui utilise le *lpszSQL* paramètre, une fois que le jeu d’enregistrements est ouvert, vous pouvez récupérer les enregistrements de plusieurs façons. La première option consiste à avoir des fonctions DFX dans votre `DoFieldExchange`. La deuxième option consiste à utiliser la liaison dynamique en appelant le `GetFieldValue` fonction membre. Ces options peuvent être implémentées séparément ou conjointement. Si elles sont combinées, vous devrez passer dans l’instruction SQL vous-même l’appel à `Open`.

Lorsque vous utilisez la deuxième version de `Open` où vous passez un `CDaoTableDef` de l’objet, les colonnes résultantes seront disponibles pour vous permet de lier `DoFieldExchange` et le mécanisme DFX et/ou lier dynamiquement via `GetFieldValue`.

> [!NOTE]
>  Vous pouvez uniquement appeler `Open` à l’aide un `CDaoTableDef` objet pour les jeux d’enregistrements de type de table.

Lorsque vous utilisez la troisième version de `Open` où vous passez un `CDaoQueryDef` de l’objet, que la requête sera exécutée, et les colonnes résultantes seront disponibles pour vous permet de lier par le biais de `DoFieldExchange` et le mécanisme DFX et/ou lier dynamiquement via `GetFieldValue`.

> [!NOTE]
>  Vous pouvez uniquement appeler `Open` à l’aide un `CDaoQueryDef` objet de type jeu de données et les jeux d’enregistrements de type instantané.

Pour la première version de `Open` qui utilise le `lpszSQL` paramètre, les enregistrements sont affichés dans le tableau suivant en fonction de critères sélectionnés.

|Valeur du paramètre `lpszSQL`.|Enregistrements sélectionnés sont déterminés par|Exemple|
|--------------------------------------|----------------------------------------|-------------|
|NULL|La chaîne retournée par `GetDefaultSQL`.||
|Une liste séparées par des virgules d’un ou plusieurs tabledefs et/ou querydef noms.|Toutes les colonnes représentées dans le `DoFieldExchange`.|`"Customer"`|
|**Sélectionnez** -liste des colonnes **FROM** table-list|Les colonnes spécifiées du querydef(s) et/ou de tabledef(s) spécifié.|`"SELECT CustId, CustName`<br /><br /> `FROM Customer"`|

La procédure habituelle consiste à passer NULL pour `Open`; dans ce cas, `Open` appels `GetDefaultSQL`, une fonction de membre substituable ClassWizard génère lorsque vous créez un `CDaoRecordset`-classe dérivée. Cette valeur donne l’ou les noms tabledef(s) et/ou querydef que vous avez spécifié dans l’Assistant classe. Vous pouvez spécifier à la place d’autres informations dans le *lpszSQL* paramètre.

Ce que vous transmettez `Open` construit une chaîne SQL finale pour la requête (la chaîne peut avoir SQL **où** et **ORDERBY** clauses ajouté à la *lpszSQL* chaîne vous avez passé), puis exécute la requête. Vous pouvez examiner la chaîne construite en appelant `GetSQL` après avoir appelé `Open`.

Les membres de données de champ de votre classe de jeu d’enregistrements sont liés aux colonnes de données sélectionnées. Si tous les enregistrements sont retournés, le premier enregistrement devient l’enregistrement actif.

Si vous souhaitez définir des options pour le jeu d’enregistrements, tel qu’un filtre ou un tri, définissez `m_strSort` ou `m_strFilter` après avoir construit l’objet recordset, mais avant d’appeler `Open`. Si vous souhaitez actualiser les enregistrements dans le jeu d’enregistrements après le jeu d’enregistrements est déjà ouvert, appelez `Requery`.

Si vous appelez `Open` sur un jeu de données ou jeu d’enregistrements de type instantané, ou si la source de données fait référence à une instruction SQL ou un objet tabledef qui représente une table attachée, vous ne pouvez pas utiliser `dbOpenTable` pour l’argument de type ; si vous le faites, MFC lève une exception. Pour déterminer si un objet tabledef représente une table attachée, créez un [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) objet et appelez sa [GetConnect](../../mfc/reference/cdaotabledef-class.md#getconnect) fonction membre.

Utilisez le `dbSeeChanges` indicateur si vous souhaitez intercepter les modifications apportées par un autre utilisateur ou un autre programme sur votre ordinateur lorsque vous modifiez ou supprimer l’enregistrement du même. Par exemple, si deux utilisateurs commencent à modifier le même enregistrement, le premier utilisateur d’appeler le `Update` fonction membre réussit. Lorsque `Update` est appelée par le second utilisateur, un `CDaoException` est levée. De même, si le second utilisateur tente d’appeler `Delete` pour supprimer l’enregistrement et il a déjà été modifié par le premier utilisateur, un `CDaoException` se produit.

En règle générale, si l’utilisateur obtienne ce `CDaoException` lors de la mise à jour, votre code doit actualiser le contenu des champs et récupérer les valeurs qui vient d’être modifiées. Si l’exception se produit en cours de suppression, le code peut afficher les données d’enregistrement à l’utilisateur et un message indiquant que les données ont changé récemment. À ce stade, votre code peut demander une confirmation que l’utilisateur veut supprimer l’enregistrement.

> [!TIP]
>  Utilisez l’option de défilement avant uniquement (`dbForwardOnly`) pour améliorer les performances lorsque votre application effectue une seule passe dans un jeu d’enregistrements ouvert à partir d’une source de données ODBC.

Pour plus d’informations, consultez la rubrique « Méthode OpenRecordset » dans l’aide de DAO.

##  <a name="requery"></a>  CDaoRecordset::Requery

Appelez cette fonction membre pour reconstruire (actualisation) un jeu d’enregistrements.

```
virtual void Requery();
```

### <a name="remarks"></a>Notes

Si tous les enregistrements sont retournés, le premier enregistrement devient l’enregistrement actif.

Dans l’ordre du jeu d’enregistrements afin de refléter les ajouts et suppressions que vous ou autres utilisateurs effectuent dans la source de données, vous devez reconstruire le jeu d’enregistrements en appelant `Requery`. Si le recordset est une feuille de réponse dynamique, il reflète automatiquement les mises à jour que vous ou autres utilisateurs apporter à ses enregistrements existants (mais pas d’ajouts). Si le jeu d’enregistrements est un instantané, vous devez appeler `Requery` afin de refléter les modifications apportées par d’autres utilisateurs, ainsi que les ajouts et les suppressions.

Pour une feuille de réponse dynamique ou un instantané, appelez `Requery` tout moment vous souhaitez reconstruire le jeu d’enregistrements à l’aide des valeurs de paramètre. Définir le nouveau filtre ou tri en définissant [m_strFilter](#m_strfilter) et [m_strSort](#m_strsort) avant d’appeler `Requery`. Définir de nouveaux paramètres en assignant de nouvelles valeurs aux membres de données de paramètre avant d’appeler `Requery`.

En cas de la tentative de reconstruire le jeu d’enregistrements, le recordset est fermé. Avant d’appeler `Requery`, vous pouvez déterminer si le jeu d’enregistrements peut être actualisé en appelant le [CanRestart](#canrestart) fonction membre. `CanRestart` ne garantit pas que `Requery` réussira.

> [!CAUTION]
>  Appelez `Requery` uniquement après avoir appelé `Open`.

> [!NOTE]
>  Appel [Requery](#requery) modifie les signets DAO.

Vous ne pouvez pas appeler `Requery` sur un jeu d’enregistrements de type instantané si l’appel ou de type `CanRestart` retourne 0, ni utiliser sur un jeu d’enregistrements de type de table.

Si les deux `IsBOF` et `IsEOF` retour différente de zéro après avoir appelé `Requery`, la requête n’a pas retourné de tous les enregistrements et le jeu d’enregistrements ne contiendront aucune donnée.

Pour plus d’informations, consultez la rubrique « Requery, méthode » dans l’aide de DAO.

##  <a name="seek"></a>  CDaoRecordset::Seek

Appelez cette fonction membre pour rechercher l’enregistrement dans un objet de jeu d’enregistrements de type table indexée qui satisfait aux critères spécifiés pour actuel d’index et assurez-vous que l’enregistrement actif.

```
BOOL Seek(
    LPCTSTR lpszComparison,
    COleVariant* pKey1,
    COleVariant* pKey2 = NULL,
    COleVariant* pKey3 = NULL);

BOOL Seek(
    LPCTSTR lpszComparison,
    COleVariant* pKeyArray,
    WORD nKeys);
```

### <a name="parameters"></a>Paramètres

*lpszComparison*<br/>
Une des expressions de chaîne suivantes : « < «, »\<= », « = », « > = », ou « > ».

*pKey1*<br/>
Un pointeur vers un [COleVariant](../../mfc/reference/colevariant-class.md) dont la valeur correspond au premier champ dans l’index. Obligatoire.

*pKey2*<br/>
Un pointeur vers un `COleVariant` dont la valeur correspond à la deuxième champ dans l’index, le cas échéant. La valeur par défaut est NULL.

*pKey3*<br/>
Un pointeur vers un `COleVariant` dont la valeur correspond au troisième champ dans l’index, le cas échéant. La valeur par défaut est NULL.

*pKeyArray*<br/>
Pointeur vers un tableau de Variant. La taille du tableau correspond au nombre de champs dans l’index.

*nKeys*<br/>
Entier correspondant à la taille du tableau, c'est-à-dire le nombre de champs dans l’index.

> [!NOTE]
>  Ne spécifiez pas de caractères génériques dans les clés. Les caractères génériques entraîne `Seek` à ne retourner aucun enregistrement correspondant.

### <a name="return-value"></a>Valeur de retour

Différent de zéro si les enregistrements correspondants sont trouvés, sinon 0.

### <a name="remarks"></a>Notes

Utilisez la deuxième version (array) de `Seek` pour gérer un index de quatre champs ou plus.

`Seek` Active l’index hautes performances effectuant une recherche sur les jeux d’enregistrements de type de table. Vous devez définir l’index actuel en appelant `SetCurrentIndex` avant d’appeler `Seek`. Si l’index identifie un champ de clé non unique ou des champs, `Seek` recherche le premier enregistrement qui satisfait aux critères. Si vous ne définissez pas un index, une exception est levée.

Notez que si vous ne créez pas un jeu d’enregistrements UNICODE, le `COleVariant` objets doivent être déclarées explicitement ANSI. Cela est possible à l’aide de la [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)**  formulaire du constructeur avec *vtSrc* définie sur `VT_BSTRT` (ANSI) ou à l’aide de la `COleVariant` fonction [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** avec *vtSrc* défini sur `VT_BSTRT`.

Lorsque vous appelez `Seek`, vous passez un ou plusieurs des valeurs de clé et un opérateur de comparaison ( » < «, »\<= », « = », « > = », ou « > »). `Seek` effectue une recherche dans les champs de clé spécifiés et recherche le premier enregistrement qui satisfait aux critères spécifiés par *lpszComparison* et *pKey1*. Une fois trouvé, `Seek` retourne différente de zéro et rend cet enregistrement en cours. Si `Seek` ne parvient pas à trouver de correspondance, `Seek` retourne zéro, et l’enregistrement en cours n’est pas défini. Lorsque vous utilisez DAO directement, vous devez vérifier explicitement la propriété NoMatch.

Si `lpszComparison` est « = », « > = », ou « > », `Seek` commence au début de l’index. Si *lpszComparison* est « < » ou « < = », `Seek` démarre à la fin de l’index et recherche vers l’arrière sauf s’il existe des entrées d’index en double à la fin. Dans ce cas, `Seek` commence par une entrée arbitraire parmi les entrées d’index en double à la fin de l’index.

Il ne devra pas être un enregistrement actif lorsque vous utilisez `Seek`.

Pour localiser un enregistrement dans un jeu d’enregistrements de type instantané qui remplit une condition spécifique ou de type, utilisez les opérations de recherche. Pour inclure tous les enregistrements, pas seulement ceux qui satisfont à une condition spécifique, utilisez les opérations de déplacement pour déplacer à partir d’un enregistrement à un autre.

Vous ne pouvez pas appeler `Seek` sur une table attachée de n’importe quel type, car les tables jointes doivent être ouvert en tant que jeux d’enregistrements de type instantané ou de type. Toutefois, si vous appelez `CDaoDatabase::Open` pour ouvrir directement une base de données ISAM installable, vous pouvez appeler `Seek` sur les tables dans cette base de données, bien que les performances peuvent être lentes.

Pour plus d’informations, consultez la rubrique « Méthode de recherche » dans l’aide de DAO.

##  <a name="setabsoluteposition"></a>  CDaoRecordset::SetAbsolutePosition

Définit le numéro d’enregistrement relatif de l’enregistrement en cours d’un objet recordset.

```
void SetAbsolutePosition(long lPosition);
```

### <a name="parameters"></a>Paramètres

*lPosition*<br/>
Correspond à la position ordinale de l’enregistrement actif dans le jeu d’enregistrements.

### <a name="remarks"></a>Notes

Appel `SetAbsolutePosition` vous permet de positionner le pointeur d’enregistrement actuel à un enregistrement spécifique en fonction de sa position ordinale dans un jeu d’enregistrements de type instantané ou de type. Vous pouvez également déterminer le numéro d’enregistrement actuel en appelant [GetAbsolutePosition](#getabsoluteposition).

> [!NOTE]
>  Cette fonction membre est valide uniquement pour les type jeu de données et les jeux d’enregistrements de type instantané.

La valeur de propriété AbsolutePosition de l’objet DAO sous-jacent est zéro ; la valeur 0 fait référence au premier enregistrement dans le jeu d’enregistrements. Définition d’une valeur supérieure au nombre de causes d’enregistrements MFC pour lever une exception. Vous pouvez déterminer le nombre d’enregistrements dans le jeu d’enregistrements en appelant le `GetRecordCount` fonction membre.

Si l’enregistrement actif est supprimé, la valeur de propriété AbsolutePosition n’est pas définie, et MFC lève une exception si elle est référencée. Nouveaux enregistrements sont ajoutés à la fin de la séquence.

> [!NOTE]
>  Cette propriété n’est pas destinée à être utilisé comme un numéro d’enregistrement de substitution. Signets sont toujours recommandé de conserver et revenir à une position donnée et sont la seule façon de positionner l’enregistrement actif sur tous les types d’objets de jeu d’enregistrements qui prennent en charge des signets. En particulier, la position d’un enregistrement donné change lorsque les enregistrements précèdent sont supprimés. Il n’existe également aucune assurance qu’un enregistrement donné aura la même position absolue si le jeu d’enregistrements est recréé à nouveau, car l’ordre des enregistrements individuels dans un jeu d’enregistrements n’est pas garanti, sauf si elle est créée avec une instruction SQL qui utilise un  **ORDERBY** clause.

Pour plus d’informations, consultez la rubrique « AbsolutePosition, propriété » dans l’aide de DAO.

##  <a name="setbookmark"></a>  CDaoRecordset::SetBookmark

Appelez cette fonction membre pour positionner le jeu d’enregistrements sur l’enregistrement qui contient le signet spécifié.

```
void SetBookmark(COleVariant varBookmark);
```

### <a name="parameters"></a>Paramètres

*varBookmark*<br/>
Un [COleVariant](../../mfc/reference/colevariant-class.md) objet contenant la valeur de signet d’un enregistrement spécifique.

### <a name="remarks"></a>Notes

Lorsqu’un objet recordset est créé ou ouvert, chacun de ses enregistrements possède déjà un signet unique. Vous pouvez récupérer le signet de l’enregistrement en cours en appelant `GetBookmark` et l’enregistrement de la valeur à un `COleVariant` objet. Vous pouvez revenir ultérieurement à cet enregistrement en appelant `SetBookmark` à l’aide de la valeur du signet enregistré.

> [!NOTE]
>  Appel [Requery](#requery) modifie les signets DAO.

Notez que si vous ne créez pas un jeu d’enregistrements UNICODE, le `COleVariant` objet doit être déclaré explicitement ANSI. Cela est possible à l’aide de la [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)**  formulaire du constructeur avec *vtSrc* définie sur `VT_BSTRT` (ANSI) ou à l’aide de la `COleVariant` fonction [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** avec *vtSrc* défini sur `VT_BSTRT`.

Pour plus d’informations, consultez les rubriques « Propriété de signet » et de la propriété de signet » dans l’aide de DAO.

##  <a name="setcachesize"></a>  CDaoRecordset::SetCacheSize

Appelez cette fonction membre pour définir le nombre d’enregistrements doit être mis en cache.

```
void SetCacheSize(long lSize);
```

### <a name="parameters"></a>Paramètres

*lSize*<br/>
Spécifie le nombre d’enregistrements. Une valeur par défaut est 100. La valeur 0 désactive la mise en cache. Le paramètre doit comprendre entre 5 et 1200 enregistrements. Le cache peut utiliser une quantité considérable de mémoire.

### <a name="remarks"></a>Notes

Un cache est un espace dans la mémoire locale qui contient les données récemment extraites du serveur dans le cas où les données seront à nouveau demandées pendant l’exécution de l’application. La mise en cache des données améliorent les performances d’une application qui Récupère des données à partir d’un serveur distant via des objets de jeu d’enregistrements de type instantané. Lorsque les données sont demandées, le moteur de base de données Microsoft Jet vérifie tout d’abord le cache pour les données demandées au lieu de son extraction à partir du serveur, ce qui prend plus de temps. Les données qui ne proviennent pas d’une source de données ODBC ne sont pas enregistrées dans le cache.

Toute source de données ODBC, par exemple une table jointe, peut avoir un cache local. Pour créer le cache, ouvrez un objet recordset à partir de la source de données distante, appel le `SetCacheSize` et `SetCacheStart` fonctions membres et puis appelez le `FillCache` fonction membre ou parcourez les enregistrements en utilisant l’une des opérations de déplacement. Le *lSize* paramètre de la `SetCacheSize` fonction membre peut être basée sur le nombre d’enregistrements que votre application peut fonctionner avec à la fois. Par exemple, si vous utilisez un jeu d’enregistrements comme source de données à afficher sur l’écran, vous pouvez passer le `SetCacheSize` *lSize* paramètre en tant que 20 afin d’afficher 20 enregistrements à la fois.

Pour plus d’informations, consultez la rubrique « CacheSize, CacheStart propriétés » dans l’aide de DAO.

##  <a name="setcachestart"></a>  CDaoRecordset::SetCacheStart

Appelez cette fonction membre pour spécifier le signet du premier enregistrement dans le jeu d’enregistrements doit être mis en cache.

```
void SetCacheStart(COleVariant varBookmark);
```

### <a name="parameters"></a>Paramètres

*varBookmark*<br/>
Un [COleVariant](../../mfc/reference/colevariant-class.md) qui spécifie le signet du premier enregistrement dans le jeu d’enregistrements doit être mis en cache.

### <a name="remarks"></a>Notes

Vous pouvez utiliser la valeur de signet de n’importe quel enregistrement pour le *varBookmark* paramètre de la `SetCacheStart` fonction membre. L’enregistrement que vous souhaitez démarrer le cache avec l’enregistrement en cours, établir un signet pour cet enregistrement à l’aide [SetBookmark](#setbookmark)et passez la valeur de signet comme paramètre pour la `SetCacheStart` fonction membre.

Le moteur de base de données Microsoft Jet demande des enregistrements dans la plage de cache à partir du cache, et il demande des enregistrements en dehors de la plage de cache à partir du serveur.

Enregistrements récupérés à partir du cache ne reflètent pas les modifications apportées simultanément à la source de données par d’autres utilisateurs.

Pour forcer une mise à jour de toutes les données mises en cache, transmettez le *lSize* paramètre de `SetCacheSize` en tant que 0, appelez `SetCacheSize` à nouveau avec la taille du cache vous demandée à l’origine et appelez ensuite la `FillCache` fonction membre.

Notez que si vous ne créez pas un jeu d’enregistrements UNICODE, le `COleVariant` objet doit être déclaré explicitement ANSI. Cela est possible à l’aide de la [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)**  formulaire du constructeur avec *vtSrc* définie sur `VT_BSTRT` (ANSI) ou à l’aide de la `COleVariant` fonction [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** avec *vtSrc* défini sur `VT_BSTRT`.

Pour plus d’informations, consultez la rubrique CacheSize, CacheStart propriétés » dans l’aide de DAO.

##  <a name="setcurrentindex"></a>  CDaoRecordset::SetCurrentIndex

Appelez cette fonction membre pour définir un index sur un jeu d’enregistrements de type de table.

```
void SetCurrentIndex(LPCTSTR lpszIndex);
```

### <a name="parameters"></a>Paramètres

*lpszIndex*<br/>
Un pointeur qui contient le nom de l’index à définir.

### <a name="remarks"></a>Notes

Les enregistrements dans les tables de base ne sont pas stockés dans un ordre particulier. Définition d’un index modifie l’ordre des enregistrements retournés à partir de la base de données, mais elle n’affecte pas l’ordre dans lequel les enregistrements sont stockés. L’index spécifié doit déjà être défini. Si vous essayez d’utiliser un objet index qui n’existe pas, ou si l’index n’est pas définie lorsque vous appelez [recherche](#seek), MFC lève une exception.

Vous pouvez créer un nouvel index pour la table en appelant [CDaoTableDef::CreateIndex](../../mfc/reference/cdaotabledef-class.md#createindex) et en ajoutant le nouvel index à la collection d’index de l’objet sous-jacent en appelant [CDaoTableDef::Append](../../mfc/reference/cdaotabledef-class.md#append), et puis rouvrir le jeu d’enregistrements.

Enregistrements retournés à partir d’un jeu d’enregistrements de type de table peuvent être triés uniquement selon les index définis pour cet objet sous-jacent. Pour trier les enregistrements dans un autre ordre, vous pouvez ouvrir un jeu d’enregistrements de type instantané à l’aide de SQL ou de type **ORDERBY** clause stockées dans [CDaoRecordset::m_strSort](#m_strsort).

Pour plus d’informations, consultez la rubrique « Objet Index » et la définition de « index actuel » dans l’aide de DAO.

##  <a name="setfielddirty"></a>  CDaoRecordset::SetFieldDirty

Appelez cette fonction membre pour un membre de données de champ de l’objet recordset comme étant modifié ou inchangé comme un indicateur.

```
void SetFieldDirty(
    void* pv,
    BOOL bDirty = TRUE);
```

### <a name="parameters"></a>Paramètres

*PV*<br/>
Contient l’adresse d’un membre de données de champ dans le jeu d’enregistrements ou NULL. Si NULL, tous les membres de données de champ dans le jeu d’enregistrements marqués. (C++ NULL n’est pas identique à la valeur Null dans la terminologie de base de données, ce qui signifie « ne having aucune valeur. »)

*bDirty*<br/>
TRUE si le membre de données de champ doit être marqué comme « modifié » (modifié). Sinon, FALSE si le membre de données de champ doit être marqué comme « nettoyer » (inchangée).

### <a name="remarks"></a>Notes

Marquage des champs restent inchangés garantit que le champ n’est pas mis à jour.

Les marques de framework modifié des données membres de champ pour vous assurer qu’ils seront écrites à l’enregistrement sur la source de données par le mécanisme DAO record field exchange (DFX). Modification de la valeur d’un champ généralement définit le champ modifié automatiquement, donc vous serez rarement nécessaire d’appeler `SetFieldDirty` vous-même, mais vous pouvez parfois faire en sorte que les colonnes seront explicitement mis à jour ou insérés, quel que soit la valeur est dans les données de champ membre. Le mécanisme DFX utilise également l’utilisation de PSEUDONULL. Pour plus d’informations, consultez [section CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

Si le mécanisme de double tampon n’est pas utilisé, puis en modifiant la valeur du champ ne définit pas automatiquement le champ comme modifié. Dans ce cas, il sera nécessaire définir explicitement le champ comme modifié. L’indicateur contenues dans [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) contrôle de cette vérification automatique de champ.

> [!NOTE]
>  Appelez cette fonction membre uniquement après avoir appelé [modifier](#edit) ou [AddNew](#addnew).

À l’aide de la valeur NULL pour le premier argument de la fonction s’applique la fonction à tous les `outputColumn` ne champs pas **param** champs dans `CDaoFieldExchange`. Par exemple, l’appel

[!code-cpp[NVC_MFCDatabase#6](../../mfc/codesnippet/cpp/cdaorecordset-class_6.cpp)]

définira uniquement `outputColumn` champs avec la valeur NULL ; **param** champs ne seront pas affectées.

Pour travailler sur un **param**, vous devez fournir l’adresse réelle de l’individu **param** vous souhaitez travailler, telles que :

[!code-cpp[NVC_MFCDatabase#7](../../mfc/codesnippet/cpp/cdaorecordset-class_7.cpp)]

Cela signifie que vous ne pouvez pas définir tous les **param** champs avec la valeur NULL, comme vous pouvez le faire avec `outputColumn` champs.

`SetFieldDirty` est implémentée via `DoFieldExchange`.

##  <a name="setfieldnull"></a>  CDaoRecordset::SetFieldNull

Appelez cette fonction membre pour marquer un membre de données de champ de l’ensemble d’enregistrements avec la valeur Null (en particulier n’avoir aucune valeur) ou en tant que non-Null.

```
void SetFieldNull(
    void* pv,
    BOOL bNull = TRUE);
```

### <a name="parameters"></a>Paramètres

*PV*<br/>
Contient l’adresse d’un membre de données de champ dans le jeu d’enregistrements ou NULL. Si NULL, tous les membres de données de champ dans le jeu d’enregistrements marqués. (C++ NULL n’est pas identique à la valeur Null dans la terminologie de base de données, ce qui signifie « ne having aucune valeur. »)

*bNull*<br/>
Différent de zéro si le membre de données de champ doit être marquée comme en ne comportant aucun valeur (Null). Sinon, 0 si le membre de données de champ doit être marqué comme non Null.

### <a name="remarks"></a>Notes

`SetFieldNull` est utilisé pour les champs liés dans le `DoFieldExchange` mécanisme.

Lorsque vous ajoutez un nouvel enregistrement à un jeu d’enregistrements, tous les membres de données de champ sont initialement définies sur une valeur Null et marqués comme « modifié » (modifié). Lorsque vous récupérez un enregistrement à partir d’une source de données, ses colonnes soit déjà ont des valeurs ou ont la valeur Null. Si elle n’est pas approprié rendre un champ de valeur Null, un [CDaoException](../../mfc/reference/cdaoexception-class.md) est levée.

Si vous utilisez le mécanisme de double tampon, par exemple, si vous voulez désigner un champ de l’enregistrement actuel comme n’ayant ne pas une valeur, appelez `SetFieldNull` avec *bNull* définie sur TRUE pour marquer en tant que valeur Null. Si un champ marqué Null et que vous voulez lui donner une valeur, définissez simplement sa nouvelle valeur. Vous n’êtes pas obligé de supprimer l’indicateur Null avec `SetFieldNull`. Pour déterminer si le champ est autorisé à avoir la valeur Null, appelez [IsFieldNullable](#isfieldnullable).

Si vous n’utilisez pas le mécanisme de double tampon, puis en modifiant la valeur du champ ne définit pas automatiquement le champ comme erronées et non Null. Vous devez spécifiquement configurer les champs dirty et non Null. L’indicateur contenues dans [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) contrôle de cette vérification automatique de champ.

Le mécanisme DFX emploie l’utilisation de PSEUDONULL. Pour plus d’informations, consultez [section CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

> [!NOTE]
>  Appelez cette fonction membre uniquement après avoir appelé [modifier](#edit) ou [AddNew](#addnew).

À l’aide de la valeur NULL pour le premier argument de la fonction s’applique uniquement à la fonction `outputColumn` ne champs pas **param** champs dans `CDaoFieldExchange`. Par exemple, l’appel

[!code-cpp[NVC_MFCDatabase#8](../../mfc/codesnippet/cpp/cdaorecordset-class_8.cpp)]

définira uniquement `outputColumn` champs avec la valeur NULL ; **param** champs ne seront pas affectées.

##  <a name="setfieldvalue"></a>  CDaoRecordset::SetFieldValue

Appelez cette fonction membre pour définir la valeur d’un champ, position ordinale ou en modifiant la valeur de la chaîne.

```
virtual void SetFieldValue(
    LPCTSTR lpszName,
    const COleVariant& varValue);

virtual void SetFieldValue(
    int nIndex,
    const COleVariant& varValue);

void SetFieldValue(
    LPCTSTR lpszName,
    LPCTSTR lpszValue);

void SetFieldValue(
    int nIndex,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>Paramètres

*Caractère*<br/>
Un pointeur vers une chaîne contenant le nom d’un champ.

*varValue*<br/>
Une référence à un [COleVariant](../../mfc/reference/colevariant-class.md) objet contenant la valeur du contenu du champ.

*nIndex*<br/>
Entier qui représente la position ordinale du champ dans la collection de champs du jeu d’enregistrements (de base zéro).

*lpszValue*<br/>
Un pointeur vers une chaîne contenant la valeur du contenu du champ.

### <a name="remarks"></a>Notes

Utilisez `SetFieldValue` et [GetFieldValue](#getfieldvalue) pour lier des champs de manière dynamique au moment de l’exécution plutôt que statiquement des colonnes de liaison à l’aide de la [DoFieldExchange](#dofieldexchange) mécanisme.

Notez que si vous ne créez pas un jeu d’enregistrements UNICODE, vous devez utiliser une forme de `SetFieldValue` qui ne contient pas un `COleVariant` paramètre, ou le `COleVariant` objet doit être déclaré explicitement ANSI. Cela est possible à l’aide de la [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)**  formulaire du constructeur avec *vtSrc* définie sur `VT_BSTRT` (ANSI) ou à l’aide de la `COleVariant` fonction [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** avec *vtSrc* défini sur `VT_BSTRT`.

Pour plus d’informations, consultez les rubriques « Objet de champ » et « Valeur de propriété » dans l’aide de DAO.

##  <a name="setfieldvaluenull"></a>  CDaoRecordset::SetFieldValueNull

Appelez cette fonction membre pour définir le champ avec une valeur Null.

```
void SetFieldValueNull(int nIndex);
void SetFieldValueNull(LPCTSTR lpszName);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
L’index du champ dans le jeu d’enregistrements, pour la recherche par index de base zéro.

*Caractère*<br/>
Le nom du champ dans le jeu d’enregistrements, pour la recherche par nom.

### <a name="remarks"></a>Notes

C++ NULL n’est pas identique à Null, ce qui, dans la terminologie de base de données, signifie « ne having aucune valeur. »

Pour plus d’informations, consultez les rubriques « Objet de champ » et « Valeur de propriété » dans l’aide de DAO.

##  <a name="setlockingmode"></a>  CDaoRecordset::SetLockingMode

Appelez cette fonction membre pour définir le type de verrouillage pour le jeu d’enregistrements.

```
void SetLockingMode(BOOL bPessimistic);
```

### <a name="parameters"></a>Paramètres

*bPessimistic*<br/>
Un indicateur qui indique le type de verrouillage.

### <a name="remarks"></a>Notes

Lorsque le verrouillage pessimiste est en effet, la page 2K contenant l’enregistrement que vous modifiez est verrouillé dès que vous appelez le `Edit` fonction membre. La page est déverrouillée lorsque vous appelez le `Update` ou `Close` fonction membre ou une des opérations de déplacement ou de recherche.

Lorsque le verrouillage est appliqué optimiste, la page 2K contenant l’enregistrement est verrouillée uniquement pendant que l’enregistrement est mis à jour avec la `Update` fonction membre.

Si une page est verrouillée, aucun autre utilisateur ne peut modifier des enregistrements sur la même page. Si vous appelez `SetLockingMode` et passer une valeur différente de zéro et un autre utilisateur a déjà verrouillé la page, une exception est levée lorsque vous appelez `Edit`. Autres utilisateurs peuvent lire des données à partir de pages verrouillées.

Si vous appelez `SetLockingMode` avec une valeur zéro et versions ultérieures appeler `Update` pendant que la page est verrouillée par un autre utilisateur, une exception se produit. Pour voir les modifications apportées à votre enregistrement par un autre utilisateur (et perdre vos modifications), appelez le `SetBookmark` fonction membre avec la valeur du signet de l’enregistrement en cours.

Lorsque vous travaillez avec des sources de données ODBC, le mode de verrouillage est toujours optimiste.

##  <a name="setparamvalue"></a>  CDaoRecordset::SetParamValue

Appelez cette fonction membre pour définir la valeur d’un paramètre dans le jeu d’enregistrements en cours d’exécution.

```
virtual void SetParamValue(
    int nIndex,
    const COleVariant& varValue);

virtual void SetParamValue(
    LPCTSTR lpszName,
    const COleVariant& varValue);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
La position numérique du paramètre dans la collection de paramètres de la querydef.

*var*<br/>
La valeur à définir ; consultez la section Notes.

*Caractère*<br/>
Le nom du paramètre dont vous souhaitez définir la valeur.

### <a name="remarks"></a>Notes

Le paramètre doit déjà avoir été établi dans le cadre de la chaîne SQL du recordset. Vous pouvez accéder à la paramètre par nom ou par sa position d’index dans la collection.

Spécifiez la valeur à définir comme un `COleVariant` objet. Pour plus d’informations sur la définition de la valeur souhaitée et le type dans votre `COleVariant` d’objet, consultez la classe [COleVariant](../../mfc/reference/colevariant-class.md). Notez que si vous ne créez pas un jeu d’enregistrements UNICODE, le `COleVariant` objet doit être déclaré explicitement ANSI. Cela est possible à l’aide de la [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)**  formulaire du constructeur avec *vtSrc* définie sur `VT_BSTRT` (ANSI) ou à l’aide de la `COleVariant` fonction [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** avec *vtSrc* défini sur `VT_BSTRT`.

##  <a name="setparamvaluenull"></a>  CDaoRecordset::SetParamValueNull

Appelez cette fonction membre pour définir le paramètre à une valeur Null.

```
void SetParamValueNull(int nIndex);
void SetParamValueNull(LPCTSTR lpszName);
```

### <a name="parameters"></a>Paramètres

*nIndex*<br/>
L’index du champ dans le jeu d’enregistrements, pour la recherche par index de base zéro.

*Caractère*<br/>
Le nom du champ dans le jeu d’enregistrements, pour la recherche par nom.

### <a name="remarks"></a>Notes

C++ NULL n’est pas identique à Null, ce qui, dans la terminologie de base de données, signifie « ne having aucune valeur. »

##  <a name="setpercentposition"></a>  CDaoRecordset::SetPercentPosition

Appelez cette fonction membre pour définir une valeur qui change l’emplacement approximatif de l’enregistrement actif dans l’objet recordset basé sur un pourcentage des enregistrements dans le jeu d’enregistrements.

```
void SetPercentPosition(float fPosition);
```

### <a name="parameters"></a>Paramètres

*fPosition*<br/>
Nombre compris entre 0 et 100.

### <a name="remarks"></a>Notes

Lorsque vous travaillez avec un jeu d’enregistrements de type instantané ou de type, commencez par remplir le jeu d’enregistrements en accédant au dernier enregistrement avant d’appeler `SetPercentPosition`. Si vous appelez `SetPercentPosition` avant le remplissage complet du jeu d’enregistrements, la quantité de mouvement est par rapport au nombre d’enregistrements auquel accédé comme indiqué par la valeur de [GetRecordCount](#getrecordcount). Vous pouvez accéder au dernier enregistrement en appelant `MoveLast`.

Une fois que vous appelez `SetPercentPosition`, l’enregistrement à la position approximative correspondant à cette valeur devient le thread actuel.

> [!NOTE]
>  Appel `SetPercentPosition` pour déplacer l’enregistrement en cours à un enregistrement spécifique dans un jeu d’enregistrements n’est pas recommandée. Appelez le [SetBookmark](#setbookmark) membre de fonction à la place.

Pour plus d’informations, consultez la rubrique « Propriété PercentPosition » dans l’aide de DAO.

##  <a name="update"></a>  CDaoRecordset::Update

Appelez cette fonction membre après un appel à la `AddNew` ou `Edit` fonction membre.

```
virtual void Update();
```

### <a name="remarks"></a>Notes

Cet appel est requis pour terminer la `AddNew` ou `Edit` opération.

Les deux `AddNew` et `Edit` préparer un mémoire tampon d’édition dans lequel sont placées les données ajoutées ou modifiées pour l’enregistrement dans la source de données. `Update` enregistre les données. Seuls les champs marqués ou détecté comme étant modifiée sont mis à jour.

Si la source de données prend en charge les transactions, vous pouvez rendre le `Update` appeler (et de son `AddNew` ou `Edit` appeler) dans le cadre d’une transaction.

> [!CAUTION]
> Si vous appelez `Update` sans d’abord appeler `AddNew` ou `Edit`, `Update` lève un `CDaoException`. Si vous appelez `AddNew` ou `Edit`, vous devez appeler `Update` avant d’appeler [MoveNext](#movenext) fermer le jeu d’enregistrements ou de la connexion de source de données. Sinon, vos modifications sont perdues sans notification.

Lorsque l’objet recordset est verrouillage pessimiste dans un environnement multi-utilisateur, l’enregistrement reste verrouillé à partir du moment `Edit` est utilisé jusqu'à ce que la mise à jour est terminée. Si le jeu d’enregistrements est verrouillage optimiste, l’enregistrement est verrouillé et comparé à l’enregistrement avant la modification juste avant qu’il est mis à jour dans la base de données. Si l’enregistrement a changé dans la mesure où vous avez appelé `Edit`, le `Update` échoue et MFC lève une exception. Vous pouvez modifier le mode de verrouillage avec `SetLockingMode`.

> [!NOTE]
> Le verrouillage optimiste est toujours utilisé sur les formats de base de données externe, telles que ODBC et pilote ISAM.

Pour plus d’informations, consultez les rubriques « Méthode AddNew », « CancelUpdate, méthode », « Supprimer la méthode », « Propriété LastModified », « Méthode de mise à jour » et « EditMode, propriété » dans l’aide de DAO.

## <a name="see-also"></a>Voir aussi

[CObject, classe](../../mfc/reference/cobject-class.md)<br/>
[Graphique hiérarchique](../../mfc/hierarchy-chart.md)<br/>
[CDaoTableDef, classe](../../mfc/reference/cdaotabledef-class.md)<br/>
[CDaoWorkspace, classe](../../mfc/reference/cdaoworkspace-class.md)<br/>
[CDaoDatabase, classe](../../mfc/reference/cdaodatabase-class.md)<br/>
[CDaoQueryDef, classe](../../mfc/reference/cdaoquerydef-class.md)<br/>
