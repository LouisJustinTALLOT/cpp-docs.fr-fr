---
title: C6235
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6235
helpviewer_keywords:
- C6235
ms.assetid: e225955e-0bb5-43a4-a83d-83290e209df4
ms.openlocfilehash: cdd2c17533d04edbdb1587f4abb42b5d1b29eca2
ms.sourcegitcommit: a1676bf6caae05ecd698f26ed80c08828722b237
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/29/2020
ms.locfileid: "91499115"
---
# <a name="c6235"></a>C6235

> AVERTISSEMENT C6235 : ( \<non-zero constant> &#124;&#124; \<expression> ) est toujours une constante non nulle

Cet avertissement indique qu’une valeur constante non nulle, différente de 1, a été détectée sur le côté gauche d’une opération OR logique qui se produit dans un contexte de test. Le côté droit de l’opération OR logique n’est pas évalué, car l’expression résultante prend toujours la valeur true. C’est ce que l’on appelle « évaluation de court-circuit ».

Une valeur constante non nulle, autre que celle-ci, suggère que l’opérateur de bits AND ( `&` ) a peut-être été prévu. Cet avertissement n’est pas généré pour l’idiome commun lorsque la constante non nulle est 1, en raison de son utilisation pour l’activation sélective des chemins de code, mais elle est générée si la constante non nulle prend la valeur 1, par exemple 1 + 0.

## <a name="example"></a>Exemple

Le code suivant génère cet avertissement, car `INPUT_TYPE` est 2 :

```cpp
#define INPUT_TYPE 2
void f(int n)
{
   if(INPUT_TYPE || n) //warning C6235 issued
   {
      puts("Always gets here");
   }
   else
   {
      puts("Never gets here");
   }
}
```

Le code suivant utilise l’opérateur de bits AND ( `&` ) pour corriger cet avertissement :

```cpp
#define INPUT_TYPE 2
void f(int n)
{
   if((INPUT_TYPE & n) == 2)
   {
      puts("bitwise-AND comparison true");
   }
   else
   {
      puts("bitwise-AND comparison false");
   }
}
```

## <a name="see-also"></a>Voir aussi

[Opérateurs logiques C](../c-language/c-logical-operators.md)
