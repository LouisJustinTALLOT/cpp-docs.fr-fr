---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
ms.openlocfilehash: a88eab254921560a3b77869c7c4061562e320836
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/27/2020
ms.locfileid: "87202426"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

Cette vérification permet d’appliquer la *règle I. 11 : ne jamais transférer la propriété par un pointeur brut (t \* )*, qui est un sous-ensemble de la règle *R. 3 : un pointeur brut (a T \* ) est non propriétaire.* Plus précisément, il vous avertit en cas d’appel à Operator `new` qui enregistre son résultat dans une variable de type pointeur brut. Elle vous avertit également des appels aux fonctions qui retournent `gsl::owner<T>` si leurs résultats sont assignés aux pointeurs bruts. L’idée est que vous devez clairement indiquer la propriété des ressources mémoire. Pour plus d’informations, consultez la [C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

Le moyen le plus simple de résoudre ce problème consiste à utiliser la **`auto`** déclaration si la ressource est assignée immédiatement au niveau de la déclaration de la variable. Si ce n’est pas possible, nous vous suggérons d’utiliser le type `gsl::owner<T>` . Les **`auto`** déclarations initialisées avec l’opérateur **`new`** sont des « propriétaires », car nous supposons que le résultat d’une allocation est implicitement un pointeur propriétaire. Nous transférons cette hypothèse à la **`auto`** variable et la traiterons comme `owner<T>` .

Si ce contrôle signale un appel à une fonction qui retourne `owner<T>` , cela peut indiquer un bogue légitime dans le code. Fondamentalement, il pointe vers un endroit où le code perd une notion explicite de propriété (et peut-être la ressource elle-même).

## <a name="remarks"></a>Notes

Cette règle vérifie actuellement uniquement les variables locales. Si l’allocation est assignée à un paramètre formel, à une variable globale, à un membre de classe, etc., elle n’est pas signalée. Une couverture appropriée de tels scénarios fait partie du travail futur.

## <a name="example-1-simple-allocation"></a>Exemple 1 : allocation simple

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Exemple 2 : allocation simple (corrigée avec GSL :: Owner \<T> )

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
