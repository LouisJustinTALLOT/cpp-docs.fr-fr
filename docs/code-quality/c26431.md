---
title: C26431
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26431
helpviewer_keywords:
- C26431
ms.assetid: 40be6032-c8de-49ab-8e43-e8eedc0ca0ba
ms.openlocfilehash: 1be7c1c8ce26a40848c07b4e7f71e2f3da944386
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81365645"
---
# <a name="c26431-dont_test_notnull"></a>C26431 DONT_TEST_NOTNULL

"Le type d’expression est déjà gsl::not_null. Ne le testez pas pour la nullité.

**Lignes directrices de base**de CMD : F.23 : Utilisez un not_null\<T> pour indiquer que le « null » n’est pas une valeur valide

Le type de marqueur gsl::not_null de la Bibliothèque de soutien des lignes directrices est utilisé pour indiquer clairement les valeurs qui ne sont jamais des pointeurs nuls. Il provoque un échec difficile si une telle hypothèse n’est pas tenue au moment de l’exécution. Donc, évidemment, il n’est pas nécessaire de vérifier l’nullité si l’expression évalue à un résultat de type gsl::not_null.

## <a name="remarks"></a>Notes

- Depuis gsl::not_null lui-même est une classe d’emballage pointeur mince, la règle suit en fait les variables temporaires qui détiennent les résultats des appels à l’opérateur de conversion surchargé (qui retourne contenu objet pointeur). Une telle logique rend cette règle applicable aux expressions qui impliquent des variables et ont finalement le résultat du gsl::not_null type. Mais il saute actuellement les expressions qui contiennent des appels de fonction retour gsl::not_null.
  - Les contrôles heuristiques actuels pour les vérifications de nullité détectent les contextes suivants :
  - expression de symbole dans une condition de branche, par exemple « si (p) ...
  - opérations logiques non-bitwise;
  - des opérations de comparaison où un opérande est une expression constante qui évalue à zéro.

## <a name="example"></a>Exemple

les contrôles nuls inutiles révèlent une logique douteuse

```cpp
class type {
public:
    template<class T> bool is() const;
    template<class T> gsl::not_null<const T*> as() const;
    //...
};

class alias_type : public type {
public:
    gsl::not_null<const type*> get_underlying_type() const;
    gsl::not_null<const type*> get_root_type() const
    {
        const auto ut = get_underlying_type();
        if (ut)                                     // C26431
        {
            const auto uat = ut->as<alias_type>();
            if (uat)                                // C26431, also incorrect use of API!
                return uat->get_root_type();

            return ut;
        }

        return this;                                // Alias to nothing? Actually, dead code!
    }
    //...
};
```

les contrôles nuls inutiles révèlent une logique douteuse - retravaillé

```cpp
    //...
    gsl::not_null<const type*> get_root_type() const
    {
        const auto ut = get_underlying_type();
        if (ut->is<alias_type>())
            return ut->as<alias_type>()->get_root_type();

        return ut;
    }
    //...
```
