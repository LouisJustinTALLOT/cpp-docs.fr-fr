---
title: C26429
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26429
helpviewer_keywords:
- C26429
ms.assetid: 4e1c74d5-7307-436c-927b-f74ae863282c
ms.openlocfilehash: 9645ceb5b1b80365c1fcc7f59655ba4fb649a196
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81359478"
---
# <a name="c26429-use_notnull"></a>C26429 USE_NOTNULL

"Le symbole n’est jamais testé pour l’nullité, il peut être marqué comme gsl::not_null."

**Lignes directrices de base**de CMD : F.23 : Utilisez un not_null\<T> pour indiquer que le « null » n’est pas une valeur valide

Il est courant d’utiliser des affirmations pour faire valoir des hypothèses sur la validité des valeurs pointeurs. Le problème avec affirme qu’ils n’exposent pas les hypothèses à travers l’interface (par exemple en retour types ou paramètres). Les affirmations sont également plus difficiles à maintenir et à rester en phase avec d’autres modifications de code. La recommandation est d’utiliser gsl::not_null de la Bibliothèque de soutien aux lignes directrices comme un marqueur de ressources qui ne devraient jamais avoir une valeur nulle. La règle USE_NOTNULL permet d’identifier les endroits qui omettre les contrôles pour l’annulation et peut donc être mis à jour pour utiliser gsl::not_null.

## <a name="remarks"></a>Notes

- La logique de la règle exige que le code délire une variable de pointeur de sorte que la vérification de l’annulation (ou l’application de la valeur non nulle) soit justifiée. Ainsi, l’avertissement ne sera émis que si les pointeurs sont déreférés et jamais testés pour nullité.
  - La mise en œuvre actuelle ne gère que des pointeurs simples (ou leurs alias) et ne détecte pas les pointeurs intelligents, même si gsl::not_null peut être appliqué sur les pointeurs intelligents ainsi.
  - Une variable est marquée comme vérifiée pour l’annulation lorsqu’elle est utilisée dans les contextes suivants :
  - comme expression de symbole dans un état de branche, par exemple « si (p) ...
  - opérations logiques non-bitwise;
  - des opérations de comparaison où un opérande est une expression constante qui évalue à zéro.
  - La règle n’a pas de suivi complet du flux de données et peut produire des résultats incorrects dans les cas où des contrôles indirects sont utilisés (par exemple, lorsque la variable intermédiaire détient une valeur nulle et plus tard utilisée en comparaison).

## <a name="example"></a>Exemple

attente cachée

```cpp
using client_collection = gsl::span<client*>;
// ...
void keep_alive(const connection *connection)   // C26429
{
    const client_collection clients = connection->get_clients();
    for (ptrdiff_t i = 0; i < clients.size(); i++)
    {
        auto client = clients[i];               // C26429
        client->send_heartbeat();
        // ...
    }
}
```

attente cachée - clarifié par gsl::not_null

```cpp
using client_collection = gsl::span<gsl::not_null<client*>>;
// ...
void keep_alive(gsl::not_null<const connection*> connection)
{
    const client_collection clients = connection->get_clients();
    for (ptrdiff_t i = 0; i < clients.size(); i++)
    {
        auto client = clients[i];
        client->send_heartbeat();
        // ...
    }
}
```
