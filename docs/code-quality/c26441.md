---
title: C26441
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26441
helpviewer_keywords:
- C26441
ms.assetid: f923c422-ed01-4644-b40b-93f15fc5bb93
ms.openlocfilehash: 0e6d609ee8b24f40aa06250515f5e60d088a2289
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81369881"
---
# <a name="c26441-no_unnamed_guards"></a>C26441 NO_UNNAMED_GUARDS

"Les objets de garde doivent être nommés."

**Lignes directrices de base**de CMD : CP.44 : N’oubliez pas de nommer votre lock_guards et vos unique_locks

La bibliothèque standard offre quelques classes utiles qui aident à contrôler l’accès simultané aux ressources. Les objets de ces types verrouillent l’accès exclusif pour la durée de leur vie. Cela implique que chaque objet de verrouillage doit être nommé, c’est-à-dire avoir une durée de vie clairement définie qui s’étend sur la période pendant laquelle les opérations d’accès sont exécutées. Ainsi, ne pas attribuer un objet de verrouillage à une variable est une erreur qui désactive effectivement le mécanisme de verrouillage (parce que les variables temporaires sont transitoires). Cette règle tente d’attraper des cas simples de tels comportements involontaires.

## <a name="remarks"></a>Notes

- Seuls les types de serrure standard sont suivis: std::scoped_lock, std::unique_lock, et std::lock_quard.
  - Seuls les appels simples aux constructeurs sont analysés. L’expression initiale plus complexe peut conduire à des résultats inexacts, mais c’est plutôt un scénario inhabituel.
  - Les verrous passés comme arguments pour fonctionner les appels ou retournés comme résultats des appels de fonction sont ignorés.
  - Les serrures créées comme temporaires mais assignées à des références nommées pour prolonger leur durée de vie sont ignorées.

## <a name="example"></a>Exemple

variable d’envergure manquante

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex>{ diagnostic_mutex_ }; // C26441
        write_line(stream, text);
        // ...
    }
}
```

variable d’envergure manquante - corrigée

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex> lock{ diagnostic_mutex_ };
        write_line(stream, text);
        // ...
    }
}
```
