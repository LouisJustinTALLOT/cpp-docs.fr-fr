---
title: C26410
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26410
helpviewer_keywords:
- C26410
ms.assetid: d1547faf-96c6-48da-90f5-841154d0e878
ms.openlocfilehash: 1f2cbecdc1d042f8b82ec18ecbbe8e491729d6a8
ms.sourcegitcommit: f1752bf90b4f869633a859ace85439ca19e208b2
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/21/2020
ms.locfileid: "88722139"
---
# <a name="c26410--no_ref_to_const_unique_ptr"></a>C26410 NO_REF_TO_CONST_UNIQUE_PTR

En règle générale, les références au pointeur unique const ne sont pas significatives. Elles peuvent être remplacées en toute sécurité par une référence brute ou un pointeur. Cet avertissement applique [C++ Core Guidelines règle R. 32](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r32-take-a-unique_ptrwidget-parameter-to-express-that-a-function-assumes-ownership-of-a-widget).

## <a name="remarks"></a>Notes

- Les contrôles de pointeur uniques ont des critères plutôt larges pour identifier les pointeurs intelligents. [Règle de C++ Core Guidelines R. 31](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r31-if-you-have-non-std-smart-pointers-follow-the-basic-pattern-from-std): *si vous avez des pointeurs intelligents non STD, suivez le modèle de base de STD décrit le pointeur unique et les concepts du pointeur partagé*. L’heuristique est simple, mais peut entraîner des surprises : un type pointeur intelligent est n’importe quel type qui définit l’opérateur > ou opérateur \* ; un type pouvant être copié (pointeur partagé) doit avoir un constructeur de copie public ou un opérateur d’assignation surchargé qui gère un paramètre de référence non-R-value.

- Le code du modèle peut générer beaucoup de bruit. Gardez à l’esprit que les modèles peuvent être instanciés avec différents paramètres de type avec différents niveaux d’indirection, y compris des références. Certains avertissements peuvent ne pas être évidents et les correctifs peuvent nécessiter des rechargements de modèles (par exemple, la suppression explicite de l’indirection de référence). Si le code de modèle est intentionnellement générique, l’avertissement peut être supprimé.

## <a name="example-1-unnecessary-reference"></a>Exemple 1 : référence inutile

```cpp
std::vector<std::unique_ptr<Tree>> roots = GetRoots();
std::for_each(
    roots.begin(),
    roots.end(),
    [](const auto &root) { Rebalance(root.get()); });   // C26410
```
