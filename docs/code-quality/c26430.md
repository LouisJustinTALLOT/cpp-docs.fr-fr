---
title: C26430
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26430
helpviewer_keywords:
- C26430
ms.assetid: 3dca2626-8102-4eed-8ff3-73eb3d5c328c
ms.openlocfilehash: 73f69b54d7f4635be6fb67099b2864ea3882eb24
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81316905"
---
# <a name="c26430-test_on_all_paths"></a>C26430 TEST_ON_ALL_PATHS

"Le symbole n’est pas testé pour l’nullité sur tous les chemins."

**Lignes directrices de base**de CMD : F.23 : Utilisez un not_null\<T> pour indiquer que le « null » n’est pas une valeur valide

Si jamais le code vérifie l’nullité des variables de pointeur, il devrait le faire de façon cohérente et valider les pointeurs sur tous les chemins. Parfois, la vérification excessive de l’nullité est encore mieux que la possibilité d’un accident dur dans l’une des branches compliquées. Idéalement, ce code devrait être refactorisé pour être moins complexe (en se séparant en fonctions multiples) et de s’appuyer sur des marqueurs comme gsl::not_null (voir Bibliothèque de soutien aux lignes directrices) pour isoler les parties de l’algorithme qui peuvent faire une hypothèse sûre sur les valeurs de pointeur valides. La règle TEST_ON_ALL_PATHS aide à trouver des endroits où les contrôles d’annulation sont soit incohérents (d’où des hypothèses peuvent nécessiter un examen) ou des bogues réels où la valeur nulle potentielle peut contourner l’annulation vérifier dans certains des chemins de code.

## <a name="remarks"></a>Notes

- Cette règle s’attend à ce que le code déreférence une variable de pointeur de sorte que la vérification de l’nullité (ou l’application de la valeur non nulle) serait justifiée. S’il n’y a pas de déférence, la règle est suspendue.
  - La mise en œuvre actuelle ne gère que des pointeurs simples (ou leurs alias) et ne détecte pas les pointeurs intelligents, même si les contrôles d’annulation sont applicables aux pointeurs intelligents ainsi.
  - Une variable est marquée comme vérifiée pour l’annulation lorsqu’elle est utilisée dans les contextes suivants :
  - comme expression de symbole dans un état de branche, par exemple « si (p) ...
  - opérations logiques non-bitwise;
  - des opérations de comparaison où un opérande est une expression constante qui évalue à zéro.
  - La règle n’a pas de suivi complet des flux de données et peut produire des résultats incorrects dans les cas où des contrôles indirects sont utilisés (par exemple, lorsque la variable intermédiaire détient une valeur nulle et plus tard utilisée en comparaison).
  - Des vérifications implicites de nullité sont supposées lorsque la valeur du pointeur est attribuée à partir de :
  - une allocation effectuée avec l’opérateur de lancer nouveau;
  - un pointeur obtenu à partir de type marqué avec gsl::not_null.

## <a name="example"></a>Exemple

tests incohérents révèle une erreur logique

```cpp
void merge_states(const state *left, const state *right) // C26430
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (!left && !right)                            // Logic error!
            discard(left, right);
    }
}
```

tests incohérents révèle une erreur logique - corrigée

```cpp
void merge_states(gsl::not_null<const state *> left, gsl::not_null<const state *> right)
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (*left && *right)
            discard(left, right);
    }
}
```
